"""
The @beta directive is used within the type system definition language to indicate beta portions of a
GraphQL service's schema, such as beta fields, enum values, arguments or input fields.
"""
directive @beta on ARGUMENT_DEFINITION | ENUM_VALUE | FIELD_DEFINITION | INPUT_FIELD_DEFINITION | OBJECT

"""
The @ea directive is used within the type system definition language to indicate EA portions of a
GraphQL service's schema.
"""
directive @ea on FIELD_DEFINITION

"""
The @ga directive is used within the type system definition language to indicate GA portions of a
GraphQL service's schema, such as GA fields, enum values, arguments or input fields.
"""
directive @ga on FIELD_DEFINITION

"""
The @rollout directive is used within the type system definition language to indicate portions of a
GraphQL service's schema that is gradually rolling out. This APIs will be available to all accounts after a few weeks.
"""
directive @rollout on FIELD_DEFINITION

##### Queries ##########################
type Query {
  accountBySubdomain(accountID: ID!, subdomains: [String!]!): [AccountDataPayload!] @ga
  accountManagement(accountId: ID!): AccountManagementQueries
  accountMetrics(accountID: ID, id: ID @deprecated(reason: "by accountID"), timeFrame: TimeFrame!, groupInterfaces: Boolean, groupDevices: Boolean): AccountMetrics @ga
  accountRoles(accountID: ID!, accountType: AccountType): AccountRolesResult! @ga
  accountSnapshot(accountID: ID, id: ID @deprecated(reason: "by accountID")): AccountSnapshot @ga
  admin(accountId: ID!, adminID: ID!): GetAdminPayload @ga
  admins(accountID: ID!, limit: Int = 50, from: Int = 0, search: String = "", sort: [SortInput], adminIDs: [ID!]): AdminsResult @ga
  appStats(accountID: ID!, timeFrame: TimeFrame!, measures: [Measure], dimensions: [Dimension], filters: [AppStatsFilter!], sort: [AppStatsSort!]): AppStats @ga
  appStatsTimeSeries(accountID: ID!, timeFrame: TimeFrame!, measures: [Measure], dimensions: [Dimension], filters: [AppStatsFilter!]): AppStatsTimeSeries @ga
  auditFeed(accountIDs: [ID!], ids: [ID!] @deprecated(reason: "by accountIDs"), timeFrame: TimeFrame!, filters: [AuditFieldFilterInput!], marker: String): AuditFeed @ga
  catalogs(accountId: ID!): CatalogQueries
  container(accountId: ID!): ContainerQueries
  devices(accountId: ID!): DevicesQueries! @beta
  enterpriseDirectory(accountId: ID!): EnterpriseDirectoryQueries @ea
  entityLookup(accountID: ID!, type: EntityType!, limit: Int = 50, from: Int = 0, parent: EntityInput, search: String = "", entityIDs: [ID!], sort: [SortInput], filters: [LookupFilterInput], helperFields: [String!]): EntityLookupResult! @ga
  events(accountID: ID!, timeFrame: TimeFrame!, measures: [EventsMeasure], dimensions: [EventsDimension], filters: [EventsFilter!], sort: [EventsSort!]): Events @ga
  eventsFeed(accountIDs: [ID!], filters: [EventFeedFieldFilterInput!], marker: String): EventsFeedData @ga
  eventsTimeSeries(accountID: ID!, timeFrame: TimeFrame!, measures: [EventsMeasure], dimensions: [EventsDimension], filters: [EventsFilter!]): EventsTimeSeries @ga
  groups(accountId: ID!): GroupsQueries @rollout
  hardware(accountId: ID!): HardwareQueries
  hardwareManagement(accountId: ID!): HardwareManagementQueries
  licensing(accountId: ID!): LicensingQueries
  policy(accountId: ID!): PolicyQueries
  popLocations(accountId: ID!): PopLocationQueries
  privateApplication(accountId: ID!): AccessPrivateApplicationQueries
  sandbox(accountId: ID!): SandboxQueries @rollout
  servicePrincipalAdmin(accountId: ID!, adminID: ID!): GetServicePrincipalAdminPayload @ga
  site(accountId: ID!): SiteQueries!
  socketPortMetrics(accountID: ID!, timeFrame: TimeFrame!, measures: [SocketPortMetricsMeasure], dimensions: [SocketPortMetricsDimension], filters: [SocketPortMetricsFilter!], sort: [SocketPortMetricsSort!]): SocketPortMetrics @ga
  socketPortMetricsTimeSeries(accountID: ID!, timeFrame: TimeFrame!, measures: [SocketPortMetricsMeasure], dimensions: [SocketPortMetricsDimension], filters: [SocketPortMetricsFilter!]): SocketPortMetricsTimeSeries @ga
  subDomains(accountID: ID!, managedAccount: Boolean): [SubDomain!]! @ga
  xdr(accountID: ID!): XDR!
  ztnaAppConnector(accountId: ID!): ZtnaAppConnectorQueries
}

##### Mutations ##########################
type Mutation {
  accountManagement(accountId: ID!): AccountManagementMutations
  admin(accountId: ID!): AdminMutations!
  container(accountId: ID!): ContainerMutations
  enterpriseDirectory(accountId: ID!): EnterpriseDirectoryMutations @ea
  groups(accountId: ID!): GroupsMutations @rollout
  hardware(accountId: ID!): HardwareMutations
  licensing(accountId: ID!): LicensingMutations
  policy(accountId: ID!): PolicyMutations
  privateApplication(accountId: ID!): AccessPrivateApplicationMutations
  sandbox(accountId: ID!): SandboxMutations @rollout
  site(accountId: ID!): SiteMutations!
  sites(accountId: ID!): SiteMutations! @deprecated(reason: "in favor of site")
  xdr(accountId: ID!): XdrMutations!
  ztnaAppConnector(accountId: ID!): ZtnaAppConnectorMutations
}

##### Types ##########################
type AccessPrivateApplicationMutations {
  createPrivateApplication(input: CreatePrivateApplicationInput!): CreatePrivateApplicationPayload
  deletePrivateApplication(input: DeletePrivateApplicationInput!): DeletePrivateApplicationPayload
  updatePrivateApplication(input: UpdatePrivateApplicationInput!): UpdatePrivateApplicationPayload
}

type AccessPrivateApplicationQueries {
  privateApplication(input: PrivateApplicationRefInput!): PrivateApplication
  privateApplicationList: PrivateApplicationListPayload
}

type AccountAuditData {
  createdBy: String!
  createdTime: DateTime!
}

type AccountDataPayload {
  id: ID!
  name: String!
  subdomain: String!
}

type AccountInfo {
  audit: AccountAuditData!
  description: String
  id: ID!
  name: String!
  plan: AccountPlan
  status: AccountStatus!
  tenancy: AccountTenancy!
  timeZone: TimeZone!
  type: AccountProfileType!
}

type AccountManagementMutations {
  addAccount(input: AddAccountInput!): AccountInfo @ga
  disableAccount(accountId: ID!): DisableAccountPayload @beta
  removeAccount(accountId: ID!): RemoveAccountPayload @ga
  updateAccount(input: UpdateAccountInput!): AccountInfo @ga
}

type AccountManagementQueries {
  account: AccountInfo @ga
}

type AccountMetrics {
  from: DateTime
  granularity: Int
  id: ID
  sites(siteIDs: [ID!], ids: [String!] @deprecated(reason: "by siteIDs")): [SiteMetrics!]
  timeseries(labels: [TimeseriesMetricType!], buckets: Int): [Timeseries!]
  to: DateTime
  users(userIDs: [ID!]): [SiteMetrics!]
}

type AccountOperationsIncident {
  incidentTimeline: [AccountOperationsTimelineBase!]!
  metadata: [AccountOperationsMetadata!]!
  playbooks: [AiOperationsPlaybook!]!
}

type AccountOperationsMetadata {
  key: String!
  type: MetadataType!
  value: String!
}

type AccountOperationsTimelineEvent implements AccountOperationsTimelineBase {
  created: Time!
  description: String!
  eventIds: [String!]!
  id: ID!
  muted: Boolean!
  type: AccountOperationsTimelineType!
  validated: Time!
}

""" A reference identifying the Account object. ID: Unique Account Identifier, Name: The Account Name """
type AccountRef implements ObjectRef {
  id: ID!
  name: String!
}

type AccountRolesResult {
  items: [RBACRole!]!
  total: Int!
}

type AccountSnapshot {
  id: ID
  sites(siteIDs: [ID!], ids: [Int!] @deprecated(reason: "by siteIDs")): [SiteSnapshot!]
  timestamp: DateTime
  users(userIDs: [ID!], ids: [Int!] @deprecated(reason: "by userIDs")): [UserSnapshot!]
}

type AddAdminPayload {
  adminID: ID!
}

type AddBgpPeerPayload {
  bgpPeer: BgpPeer!
}

""" Payload for adding a new physical connection to a cloud interconnect site. """
type AddCloudInterconnectPhysicalConnectionPayload {
  id: ID!
}

""" Payload for adding a new cloud interconnect site. """
type AddCloudInterconnectSitePayload {
  siteId: ID!
}

type AddIpsecIkeV2SiteMultiTunnelPayload {
  fqdn: Fqdn
  tunnels: [AddIpsecIkeV2SiteTunnelPayload!]!
}

type AddIpsecIkeV2SitePayload {
  siteId: ID!
}

type AddIpsecIkeV2SiteTunnelPayload {
  localId: String
  tunnelId: IPSecV2InterfaceId
}

type AddIpsecIkeV2SiteTunnelsPayload {
  primary: AddIpsecIkeV2SiteMultiTunnelPayload
  secondary: AddIpsecIkeV2SiteMultiTunnelPayload
  siteId: ID!
}

type AddNetworkRangePayload {
  networkRangeId: ID!
}

type AddSecondaryAwsVSocketPayload {
  id: ID!
}

type AddSecondaryAzureVSocketPayload {
  id: ID!
}

type AddServicePrincipalAdminPayload {
  adminID: ID!
}

type AddSocketAddOnCardPayload {
  addOns: [SocketAddOnCard!]!
}

type AddSocketSitePayload {
  siteId: ID!
}

type AddStaticHostPayload {
  hostId: ID!
}

type AddStoryCommentPayload {
  comment: StoryComment!
}

type AddZtnaAppConnectorPayload {
  ztnaAppConnector: ZtnaAppConnector!
}

""" Payload returned after creating ZTNA App Connectors configuration. """
type AddZtnaAppConnectorsConfigurationPayload {
  ztnaAppConnectorsConfiguration: ZtnaAppConnectorsConfiguration!
}

""" A CC2 administrator """
type Admin {
  adminType: AdminType
  allowedItems: [Entity!]
  creationDate: DateTime
  email: String
  firstName: String
  id: ID!
  lastName: String
  managedRoles: [AdminRole!]
  mfaEnabled: Boolean
  modifyDate: DateTime
  nativeAccountID: ID
  passwordNeverExpires: Boolean
  presentUsageAndEvents: Boolean
  resellerRoles: [AdminRole!]
  role: UserRole
  status: OperationalStatus
  version: String!
}

type AdminMutations {
  addAdmin(input: AddAdminInput!): AddAdminPayload @ga
  addServicePrincipalAdmin(input: AddServicePrincipalAdminInput!): AddServicePrincipalAdminPayload @ga
  removeAdmin(adminID: ID!): RemoveAdminPayload @ga
  removeServicePrincipalAdmin(adminID: ID!): RemoveServicePrincipalAdminPayload @ga
  updateAdmin(adminID: ID!, input: UpdateAdminInput!): UpdateAdminPayload @ga
  updateServicePrincipalAdmin(adminID: ID!, input: UpdateServicePrincipalAdminInput!): UpdateServicePrincipalAdminPayload @ga
}

""" A reference identifying the Admin object. ID: Unique Admin Identifier, Name: The Admin Name """
type AdminRef implements ActorRef & ObjectRef {
  id: ID!
  name: String!
}

type AdminRole {
  allowedAccounts: [ID!]
  allowedEntities: [Entity!]
  role: RBACRole!
}

type AdminsResult {
  items: [Admin!]!
  total: Int!
}

type AiOperationsIncident implements MergedIncident {
  accountOperationIncident: AccountOperationsIncident
  analystFeedback: AnalystFeedback
  connectionType: ConnectionTypeEnum
  criticality: Int
  description: String
  engineType: StoryEngineTypeEnum
  eventsGraphQuery: EventsGraphQuery
  firstSignal: DateTime!
  flowLastTime: DateTime! @deprecated(reason: "use 'lastSignal' instead")
  flowStartTime: DateTime! @deprecated(reason: "use 'firstSignal' instead")
  id: ID!
  indication: String!
  ioa: String! @deprecated(reason: "'ioa' is deprecated, use 'indication' instead")
  lastSignal: DateTime!
  occurrences: Int
  predictedThreatType: String
  predictedVerdict: StoryVerdictEnum
  producer: StoryProducerEnum!
  producerName: String!
  queryName: String
  research: Boolean
  riskScore: Int! @deprecated(reason: "'riskScore' is deprecated, use 'criticality' instead")
  similarStoriesData: [SimilarStoryData!]!
  site: SiteRef
  siteName: String @deprecated(reason: "'siteName' is deprecated, use 'site.name' instead")
  source: String
  sourceIp: String
  status: StoryStatusEnum
  storyDuration: Int
  ticket: String
  type: AiOperationsIncidentTypeEnum
  user: UserRef
  vendor: VendorEnum
}

type AiOperationsPlaybook {
  description: String!
  link: String
  title: String!
}

""" A reference identifying the AllocatedIp object. ID: Unique AllocatedIp Identifier, Name: The AllocatedIp Name """
type AllocatedIpRef implements ObjectRef {
  id: ID!
  name: String!
}

type AnalystFeedback {
  additionalInfo: String
  severity: SeverityEnum
  threatClassification: String
  threatType: AnalystFeedbackThreatType
  verdict: StoryVerdictEnum
}

type AnalystFeedbackPayload {
  story: Story
}

type AnalystFeedbackThreatType {
  details: String
  name: String
  recommendedAction: String
}

type AnalystInfo {
  email: String
  name: String
}

""" The `AnomalyEvents` object represents a data structure used in GraphQL queries or mutations, containing fields related to security anomalies, such as analyst feedback, connection type, criticality, description, and various identifiers and metrics, to provide detailed information about potential security incidents. """
type AnomalyEvents implements Anomalies & MergedIncident {
  analystFeedback: AnalystFeedback
  breakdownField: String
  clientClass: [String!]!
  connectionType: ConnectionTypeEnum
  criticality: Int
  description: String
  deviceName: String
  direction: String
  drillDownFilter: [StoryDrillDownFilter!]
  engineType: StoryEngineTypeEnum
  extra: [Extra!]
  firstSignal: DateTime!
  gaussian: Gaussian
  id: ID!
  indication: String!
  lastSignal: DateTime!
  logonName: String
  macAddress: String
  metric: Metric
  metricDetails: MetricDetails
  mitres: [Mitre!]
  os: String
  predictedThreatType: String
  predictedVerdict: StoryVerdictEnum
  producer: StoryProducerEnum!
  producerName: String!
  queryName: String
  research: Boolean
  rules: [String!]
  similarStoriesData: [SimilarStoryData!]!
  site: SiteRef
  siteName: String @deprecated(reason: "'siteName' is deprecated, use 'site.name' instead")
  source: String
  sourceIp: String
  srcSiteId: String
  status: StoryStatusEnum
  storyDuration: Int
  subjectType: String
  targets: [IncidentTargetRep!]!
  ticket: String
  timeSeries: [IncidentTimeseries!]
  user: UserRef
  vendor: VendorEnum
}

""" The `AnomalyStats` object is a GraphQL type that represents statistical data related to anomalies, including fields such as analyst feedback, connection type, criticality, device information, and various metrics, along with associated metadata like timestamps, status, and predicted verdicts. """
type AnomalyStats implements Anomalies & MergedIncident {
  analystFeedback: AnalystFeedback
  breakdownField: String
  clientClass: [String!]!
  connectionType: ConnectionTypeEnum
  criticality: Int
  description: String
  deviceName: String
  direction: String
  drillDownFilter: [StoryDrillDownFilter!]
  engineType: StoryEngineTypeEnum
  extra: [Extra!]
  firstSignal: DateTime!
  gaussian: Gaussian
  id: ID!
  indication: String!
  lastSignal: DateTime!
  logonName: String
  macAddress: String
  metric: Metric
  metricDetails: MetricDetails
  mitres: [Mitre!]
  os: String
  predictedThreatType: String
  predictedVerdict: StoryVerdictEnum
  producer: StoryProducerEnum!
  producerName: String!
  queryName: String
  research: Boolean
  rules: [String!]
  similarStoriesData: [SimilarStoryData!]!
  site: SiteRef
  siteName: String @deprecated(reason: "'siteName' is deprecated, use 'site.name' instead")
  source: String
  sourceIp: String
  srcSiteId: String
  status: StoryStatusEnum
  storyDuration: Int
  subjectType: String
  targets: [IncidentTargetRep!]!
  ticket: String
  timeSeries: [IncidentTimeseries!]
  user: UserRef
  vendor: VendorEnum
}

type AntiMalwareFileHashPolicy implements IPolicy {
  audit: PolicyAudit
  enabled: Boolean!
  revision: PolicyRevision
  rules: [AntiMalwareFileHashRulePayload!]!
  sections: [PolicySectionPayload!]!
}

type AntiMalwareFileHashPolicyMutationPayload implements IPolicyMutationPayload {
  errors: [PolicyMutationError!]!
  policy: AntiMalwareFileHashPolicy
  status: PolicyMutationStatus!
}

type AntiMalwareFileHashPolicyMutations {
  addRule(input: AntiMalwareFileHashAddRuleInput!): AntiMalwareFileHashRuleMutationPayload! @beta
  addSection(input: PolicyAddSectionInput!): PolicySectionMutationPayload! @beta
  createPolicyRevision(input: PolicyCreateRevisionInput!): AntiMalwareFileHashPolicyMutationPayload! @beta
  discardPolicyRevision(input: PolicyDiscardRevisionInput): AntiMalwareFileHashPolicyMutationPayload! @beta
  moveRule(input: PolicyMoveRuleInput!): AntiMalwareFileHashRuleMutationPayload! @beta
  moveSection(input: PolicyMoveSectionInput!): PolicySectionMutationPayload! @beta
  publishPolicyRevision(input: PolicyPublishRevisionInput): AntiMalwareFileHashPolicyMutationPayload! @beta
  removeRule(input: AntiMalwareFileHashRemoveRuleInput!): AntiMalwareFileHashRuleMutationPayload! @beta
  removeSection(input: PolicyRemoveSectionInput!): PolicySectionMutationPayload! @beta
  updatePolicy(input: AntiMalwareFileHashPolicyUpdateInput!): AntiMalwareFileHashPolicyMutationPayload! @beta
  updateRule(input: AntiMalwareFileHashUpdateRuleInput!): AntiMalwareFileHashRuleMutationPayload! @beta
  updateSection(input: PolicyUpdateSectionInput!): PolicySectionMutationPayload! @beta
}

type AntiMalwareFileHashPolicyQueries {
  policy(input: AntiMalwareFileHashPolicyInput): AntiMalwareFileHashPolicy! @beta
  revisions: PolicyRevisionsPayload @beta
}

type AntiMalwareFileHashRule implements IPolicyRule {
  action: AntiMalwareFileHashAction!
  description: String!
  enabled: Boolean!
  expirationDate: DateTime!
  fileName: String!
  id: ID!
  index: Int!
  name: String!
  section: PolicySectionInfo!
  sha256: SHA_256!
}

type AntiMalwareFileHashRuleMutationPayload implements IPolicyRuleMutationPayload {
  errors: [PolicyMutationError!]!
  rule: AntiMalwareFileHashRulePayload
  status: PolicyMutationStatus!
}

type AntiMalwareFileHashRulePayload implements IPolicyRulePayload {
  audit: PolicyElementAudit!
  properties: [PolicyElementPropertiesEnum!]!
  rule: AntiMalwareFileHashRule!
}

""" A reference identifying the ApiKey object. ID: Unique ApiKey Identifier, Name: The ApiKey Name """
type ApiKeyRef implements ActorRef & ObjectRef {
  id: ID!
  name: String!
}

type AppStats {
  from: DateTime
  id: ID
  records(limit: Int, from: Int): [AppStatsRecord!]
  to: DateTime
  total: Int
  totals: Map
}

type AppStatsField {
  name: AppStatsFieldName!
  value: Value!
}

type AppStatsRecord {
  fields: [AppStatsField!]
  fieldsMap: Map
  fieldsUnitTypes: [UnitType!]
  flatFields: [[String!]]
  prevTimeFrame: Map
  trends: Map
}

type AppStatsTimeSeries {
  from: DateTime
  granularity: Int
  id: ID
  timeseries(buckets: Int!): [Timeseries!]
  to: DateTime
}

""" pair of header name and value """
type AppTenantRestrictionHeaderValue {
  name: HttpHeaderName!
  value: HttpHeaderValue!
}

type AppTenantRestrictionPolicy implements IPolicy {
  audit: PolicyAudit
  enabled: Boolean!
  revision: PolicyRevision
  rules: [AppTenantRestrictionRulePayload!]!
  sections: [PolicySectionPayload!]!
}

type AppTenantRestrictionPolicyMutationPayload implements IPolicyMutationPayload {
  errors: [PolicyMutationError!]!
  policy: AppTenantRestrictionPolicy
  status: PolicyMutationStatus!
}

type AppTenantRestrictionPolicyMutations {
  addRule(input: AppTenantRestrictionAddRuleInput!): AppTenantRestrictionRuleMutationPayload! @beta
  addSection(input: PolicyAddSectionInput!): PolicySectionMutationPayload! @beta
  createPolicyRevision(input: PolicyCreateRevisionInput!): AppTenantRestrictionPolicyMutationPayload! @beta
  discardPolicyRevision(input: PolicyDiscardRevisionInput): AppTenantRestrictionPolicyMutationPayload! @beta
  moveRule(input: PolicyMoveRuleInput!): AppTenantRestrictionRuleMutationPayload! @beta
  moveSection(input: PolicyMoveSectionInput!): PolicySectionMutationPayload! @beta
  publishPolicyRevision(input: PolicyPublishRevisionInput): AppTenantRestrictionPolicyMutationPayload! @beta
  removeRule(input: AppTenantRestrictionRemoveRuleInput!): AppTenantRestrictionRuleMutationPayload! @beta
  removeSection(input: PolicyRemoveSectionInput!): PolicySectionMutationPayload! @beta
  updatePolicy(input: AppTenantRestrictionPolicyUpdateInput!): AppTenantRestrictionPolicyMutationPayload! @beta
  updateRule(input: AppTenantRestrictionUpdateRuleInput!): AppTenantRestrictionRuleMutationPayload! @beta
  updateSection(input: PolicyUpdateSectionInput!): PolicySectionMutationPayload! @beta
}

type AppTenantRestrictionPolicyQueries {
  policy(input: AppTenantRestrictionPolicyInput): AppTenantRestrictionPolicy! @beta
  revisions: PolicyRevisionsPayload @beta
}

type AppTenantRestrictionRule implements IPolicyRule {
  action: AppTenantRestrictionActionEnum!
  application: ApplicationRef!
  description: String!
  enabled: Boolean!
  headers: [AppTenantRestrictionHeaderValue!]!
  id: ID!
  index: Int!
  name: String!
  schedule: PolicySchedule!
  section: PolicySectionInfo!
  severity: AppTenantRestrictionSeverityEnum!
  source: AppTenantRestrictionSource!
}

type AppTenantRestrictionRuleMutationPayload implements IPolicyRuleMutationPayload {
  errors: [PolicyMutationError!]!
  rule: AppTenantRestrictionRulePayload
  status: PolicyMutationStatus!
}

type AppTenantRestrictionRulePayload implements IPolicyRulePayload {
  audit: PolicyElementAudit!
  properties: [PolicyElementPropertiesEnum!]!
  rule: AppTenantRestrictionRule!
}

""" Returns the settings for Source of an App Tenant Restriction rule """
type AppTenantRestrictionSource {
  country: [CountryRef!]!
  floatingSubnet: [FloatingSubnetRef!]!
  globalIpRange: [GlobalIpRangeRef!]!
  group: [GroupRef!]!
  host: [HostRef!]!
  ip: [IPAddress!]!
  ipRange: [IpAddressRange!]!
  networkInterface: [NetworkInterfaceRef!]!
  site: [SiteRef!]!
  siteNetworkSubnet: [SiteNetworkSubnetRef!]!
  subnet: [NetworkSubnet!]!
  systemGroup: [SystemGroupRef!]!
  user: [UserRef!]!
  usersGroup: [UsersGroupRef!]!
}

""" A reference identifying the ApplicationCategory object. ID: Unique ApplicationCategory Identifier, Name: The ApplicationCategory Name """
type ApplicationCategoryRef implements ObjectRef {
  id: ID!
  name: String!
}

""" Access method matching configuration """
type ApplicationControlAccessMethod {
  accessMethod: ApplicationControlAccessMethodType!
  operator: ApplicationControlOperator!
  value: String
  valueSet: StringValueSetRef
}

""" Activity matching configuration """
type ApplicationControlActivity {
  activity: ApplicationControlActivityRef!
  field: ApplicationControlActivityFieldRef
  operator: ApplicationControlOperator
  value: String
  valueSet: StringValueSetRef
}

type ApplicationControlActivityFieldRef implements ObjectRef {
  id: ID!
  name: String!
}

type ApplicationControlActivityRef implements ObjectRef {
  id: ID!
  name: String!
}

""" Application matching configuration. Only one of the following fields should be filled - the others must remain empty. """
type ApplicationControlApplication {
  appCategory: ApplicationCategoryRef
  application: ApplicationRef
  applicationType: [ApplicationType!]!
  customApp: CustomApplicationRef
  customCategory: CustomCategoryRef
  sanctionedAppsCategory: SanctionedAppsCategoryRef
}

""" Configuration for application-based control rules """
type ApplicationControlApplicationRule {
  accessMethod: [ApplicationControlAccessMethod!]!
  action: ApplicationControlAction!
  application: ApplicationControlApplication!
  applicationActivity: [ApplicationControlActivity!]!
  applicationActivitySatisfy: ApplicationControlSatisfy!
  applicationContext: ApplicationControlContext!
  applicationCriteria: ApplicationControlCriteria!
  applicationCriteriaSatisfy: ApplicationControlSatisfy!
  device: [DeviceProfileRef!]!
  schedule: PolicySchedule!
  severity: ApplicationControlSeverity!
  source: ApplicationControlSource!
  tracking: PolicyTracking!
}

""" Application attributes, such as compliance and security, see the app catalog for details """
type ApplicationControlAttributes {
  complianceAttributes: ApplicationControlComplianceAttributes!
  securityAttributes: ApplicationControlSecurityAttributes!
}

""" Compliance attributes """
type ApplicationControlComplianceAttributes {
  hippa: ApplicationControlAttributeValue!
  isae3402: ApplicationControlAttributeValue!
  iso27001: ApplicationControlAttributeValue!
  pciDss: ApplicationControlAttributeValue!
  soc1: ApplicationControlAttributeValue!
  soc2: ApplicationControlAttributeValue!
  soc3: ApplicationControlAttributeValue!
  sox: ApplicationControlAttributeValue!
}

""" Additional attributes for application control """
type ApplicationControlConfig {
  dataControlEnabled: PolicyToggleState!
}

type ApplicationControlContentTypeGroupRef implements ObjectRef {
  id: ID!
  name: String!
}

type ApplicationControlContentTypeRef implements ObjectRef {
  id: ID!
  name: String!
}

type ApplicationControlContext {
  applicationTenant: [ApplicationControlTenant!]!
}

""" Application criteria configuration """
type ApplicationControlCriteria {
  attributes: ApplicationControlAttributes!
  originCountry: [CountryRef!]!
  risk: [ApplicationControlRiskCriteria!]!
}

""" Configuration for data-based control rules """
type ApplicationControlDataRule {
  accessMethod: [ApplicationControlAccessMethod!]!
  action: ApplicationControlAction!
  application: ApplicationControlApplication!
  applicationActivity: [ApplicationControlActivity!]!
  applicationActivitySatisfy: ApplicationControlSatisfy!
  applicationContext: ApplicationControlContext!
  device: [DeviceProfileRef!]!
  dlpProfile: ApplicationControlDlpProfile!
  fileAttribute: [ApplicationControlFileAttribute!]!
  fileAttributeSatisfy: ApplicationControlSatisfy!
  schedule: PolicySchedule!
  severity: ApplicationControlSeverity!
  source: ApplicationControlSource!
  tracking: PolicyTracking!
}

""" DLP profile configuration """
type ApplicationControlDlpProfile {
  contentProfile: [DlpContentProfileRef!]!
  edmProfile: [DlpEdmProfileRef!]!
}

""" File attribute matching configuration """
type ApplicationControlFileAttribute {
  contentTypeGroupValues: [ApplicationControlContentTypeGroupRef!]!
  contentTypeValues: [ApplicationControlContentTypeRef!]!
  fileAttribute: ApplicationControlFileAttributeType!
  operator: ApplicationControlOperator!
  value: String
}

""" Configuration for file-based control rules """
type ApplicationControlFileRule {
  accessMethod: [ApplicationControlAccessMethod!]!
  action: ApplicationControlAction!
  application: ApplicationControlApplication!
  applicationActivity: [ApplicationControlActivity!]!
  applicationActivitySatisfy: ApplicationControlSatisfy!
  device: [DeviceProfileRef!]!
  fileAttribute: [ApplicationControlFileAttribute!]!
  fileAttributeSatisfy: ApplicationControlSatisfy!
  schedule: PolicySchedule!
  severity: ApplicationControlSeverity!
  source: ApplicationControlSource!
  tracking: PolicyTracking!
}

type ApplicationControlPolicy implements IPolicy {
  additionalAttributes: ApplicationControlConfig
  audit: PolicyAudit
  enabled: Boolean!
  revision: PolicyRevision
  rules: [ApplicationControlRulePayload!]!
  sections: [PolicySectionPayload!]!
}

type ApplicationControlPolicyMutationPayload implements IPolicyMutationPayload {
  errors: [PolicyMutationError!]!
  policy: ApplicationControlPolicy
  status: PolicyMutationStatus!
}

type ApplicationControlPolicyMutations {
  addRule(input: ApplicationControlAddRuleInput!): ApplicationControlRuleMutationPayload! @beta
  addSection(input: PolicyAddSectionInput!): PolicySectionMutationPayload! @beta
  createPolicyRevision(input: PolicyCreateRevisionInput!): ApplicationControlPolicyMutationPayload! @beta
  discardPolicyRevision(input: PolicyDiscardRevisionInput): ApplicationControlPolicyMutationPayload! @beta
  moveRule(input: PolicyMoveRuleInput!): ApplicationControlRuleMutationPayload! @beta
  moveSection(input: PolicyMoveSectionInput!): PolicySectionMutationPayload! @beta
  publishPolicyRevision(input: PolicyPublishRevisionInput): ApplicationControlPolicyMutationPayload! @beta
  removeRule(input: ApplicationControlRemoveRuleInput!): ApplicationControlRuleMutationPayload! @beta
  removeSection(input: PolicyRemoveSectionInput!): PolicySectionMutationPayload! @beta
  updatePolicy(input: ApplicationControlPolicyUpdateInput!): ApplicationControlPolicyMutationPayload! @beta
  updateRule(input: ApplicationControlUpdateRuleInput!): ApplicationControlRuleMutationPayload! @beta
  updateSection(input: PolicyUpdateSectionInput!): PolicySectionMutationPayload! @beta
}

type ApplicationControlPolicyQueries {
  policy(input: ApplicationControlPolicyInput): ApplicationControlPolicy! @beta
  revisions: PolicyRevisionsPayload @beta
}

""" Application risk """
type ApplicationControlRiskCriteria {
  risk: ApplicationRisk!
  riskOperator: ApplicationControlOperator!
}

type ApplicationControlRule implements IPolicyRule {
  applicationRule: ApplicationControlApplicationRule
  dataRule: ApplicationControlDataRule
  description: String!
  enabled: Boolean!
  fileRule: ApplicationControlFileRule
  id: ID!
  index: Int!
  name: String!
  ruleType: ApplicationControlRuleType!
  section: PolicySectionInfo!
}

type ApplicationControlRuleMutationPayload implements IPolicyRuleMutationPayload {
  errors: [PolicyMutationError!]!
  rule: ApplicationControlRulePayload
  status: PolicyMutationStatus!
}

type ApplicationControlRulePayload implements IPolicyRulePayload {
  audit: PolicyElementAudit!
  properties: [PolicyElementPropertiesEnum!]!
  rule: ApplicationControlRule!
}

""" Security attributes """
type ApplicationControlSecurityAttributes {
  auditTrail: ApplicationControlAttributeValue!
  encryptionAtRest: ApplicationControlAttributeValue!
  httpSecurityHeaders: ApplicationControlAttributeValue!
  mfa: ApplicationControlAttributeValue!
  rbac: ApplicationControlAttributeValue!
  rememberPassword: ApplicationControlAttributeValue!
  sso: ApplicationControlAttributeValue!
  tlsEnforcement: ApplicationControlAttributeValue!
  trustedCertificate: ApplicationControlAttributeValue!
}

""" Source traffic matching configuration """
type ApplicationControlSource {
  country: [CountryRef!]!
  floatingSubnet: [FloatingSubnetRef!]!
  globalIpRange: [GlobalIpRangeRef!]!
  group: [GroupRef!]!
  host: [HostRef!]!
  ip: [IPAddress!]!
  ipRange: [IpAddressRange!]!
  networkInterface: [NetworkInterfaceRef!]!
  site: [SiteRef!]!
  siteNetworkSubnet: [SiteNetworkSubnetRef!]!
  subnet: [NetworkSubnet!]!
  systemGroup: [SystemGroupRef!]!
  user: [UserRef!]!
  usersGroup: [UsersGroupRef!]!
}

""" Tenant matching configuration """
type ApplicationControlTenant {
  operator: ApplicationControlOperator
  value: String
  valueSet: StringValueSetRef
}

""" A reference identifying the Application object. ID: Unique Application Identifier, Name: The Application Name """
type ApplicationRef implements ObjectRef {
  id: ID!
  name: String!
}

type AssignSiteBwLicensePayload {
  license: License!
}

type AssignSocketToZtnaAppConnectorPayload {
  ztnaAppConnector: ZtnaAppConnector!
}

""" Advanced Threat Prevention (ATP) service license details """
type AtpLicense implements License {
  description: String
  expirationDate: DateTime!
  id: String
  lastUpdated: DateTime
  plan: LicensePlan!
  sku: LicenseSku!
  startDate: DateTime
  status: LicenseStatus!
}

type AuditFeed {
  accounts: [AuditFeedAccountRecords]
  fetchedCount: Int!
  from: DateTime
  hasMore: Boolean
  marker: String
  to: DateTime
}

type AuditFeedAccountRecords {
  id: ID
  records(fieldNames: [AuditFieldName!]): [AuditRecord!]
}

type AuditField {
  name: String!
  value: Value!
}

""" Represents a single event in the audit database """
type AuditRecord {
  account: EntityInfo
  admin: Entity
  apiKey: Entity
  fields: [AuditField!]
  fieldsMap: Map
  flatFields: [[String!]]
  object: Entity
  time: DateTime
}

type AuditingMetadata {
  updatedBy: ActorRef!
  updatedTime: DateTime!
}

""" Response payload for available versions query. """
type AvailableVersionListPayload {
  items: [PlatformVersions!]!
}

type BGPConnection {
  catoAsn: Asn16
  catoIp: String
  connectionName: String
  peerAsn: Asn32
  peerIp: String
}

type BandwidthManagementRef implements ObjectRef {
  id: ID!
  name: String!
}

type BfdSettings {
  multiplier: Int!
  receiveInterval: Int!
  transmitInterval: Int!
}

type BgpCommunity {
  from: Asn16!
  to: Asn16!
}

type BgpCommunityFilterRule {
  community: [BgpCommunity!]!
  id: ID!
  predicate: BgpCommunityFilterPredicate!
}

type BgpDetailedStatus {
  bfdSession: String
  bgpSession: String!
  rejectedRoutesFromPeer: [BgpRejectedRoutesFromPeer!]!
  remoteIp: IPAddress!
  routesFromPeer: [String!]!
  routesToPeer: [String!]!
}

type BgpFilterRule {
  bgpRouteExactAndInclusiveFilterRule: BgpRouteExactAndInclusiveFilterRule
  bgpRouteExactFilterRule: BgpRouteExactFilterRule
  communityFilterRule: BgpCommunityFilterRule
}

type BgpPeer {
  advertiseAllRoutes: Boolean!
  advertiseDefaultRoute: Boolean!
  advertiseSummaryRoutes: Boolean!
  bfdEnabled: Boolean!
  bfdSettings: BfdSettings
  catoAsn: Asn16!
  catoIp: IPAddress!
  defaultAction: BgpDefaultAction!
  defaultActionExclusion: [BgpFilterRule!]!
  holdTime: Int!
  id: ID!
  keepaliveInterval: Int!
  md5AuthKey: String
  metric: Int!
  name: String!
  peerAsn: Asn32!
  peerIp: IPAddress!
  performNat: Boolean!
  site: SiteRef!
  summaryRoute: [BgpSummaryRoute!]!
  tracking: BgpTracking
}

type BgpPeerListPayload {
  bgpPeer: [BgpPeer!]!
  total: Int!
}

type BgpRejectedRoutesFromPeer {
  community: [BgpCommunity!]!
  lastPublishAttempt: DateTime
  rule: String
  subnet: NetworkSubnet
  type: String
}

type BgpRouteExactAndInclusiveFilterRule {
  ge: Int
  globalIpRange: [GlobalIpRangeRef!]!
  globalIpRangeException: [GlobalIpRangeRef!]!
  id: ID!
  le: Int
  networkSubnet: [NetworkSubnet!]!
  networkSubnetException: [NetworkSubnet!]!
}

type BgpRouteExactFilterRule {
  globalIpRange: [GlobalIpRangeRef!]!
  id: ID!
  networkSubnet: [NetworkSubnet!]!
}

type BgpSummaryRoute {
  community: [BgpCommunity!]!
  id: ID!
  route: NetworkSubnet!
}

type BgpTracking {
  alertFrequency: PolicyRuleTrackingFrequencyEnum!
  enabled: Boolean!
  id: ID!
  subscriptionId: ID
}

type BulkUpgradeSiteInfo {
  id: ID!
  name: String!
}

""" Cloud Access Security Broker (CASB) service license details """
type CasbLicense implements License {
  description: String
  expirationDate: DateTime!
  id: String
  lastUpdated: DateTime
  plan: LicensePlan!
  sku: LicenseSku!
  startDate: DateTime
  status: LicenseStatus!
}

type CatalogApplication {
  activity: [CatalogApplicationActivity!]!
  capability: [CatalogApplicationCapability!]!
  category: [ApplicationCategoryRef!]!
  city: String
  complianceAttributes: CatalogApplicationComplianceAttributes!
  description: String
  descriptionSummary: String
  id: ID!
  ipoStatus: String
  name: String!
  numOfEmployees: EmployeeRange
  originCountry: CountryRef
  recentlyAdded: Boolean!
  region: String
  risk: ApplicationRisk
  sanctioned: Boolean!
  securityAttributes: CatalogApplicationSecurityAttributes!
  standardPorts: [CustomService!]!
  type: CatalogApplicationType!
  website: Url
}

type CatalogApplicationActivity {
  fields: [CatalogApplicationActivityField!]!
  id: ID!
  name: String!
}

type CatalogApplicationActivityField {
  id: ID!
  name: String!
  possibleOperators: [CatalogApplicationActivityFieldOperator!]!
  possibleValues: [String!]!
}

type CatalogApplicationComplianceAttributes {
  hippa: CatalogApplicationAttribute!
  isae3402: CatalogApplicationAttribute!
  iso27001: CatalogApplicationAttribute!
  pciDss: CatalogApplicationAttribute!
  soc1: CatalogApplicationAttribute!
  soc2: CatalogApplicationAttribute!
  soc3: CatalogApplicationAttribute!
  sox: CatalogApplicationAttribute!
}

type CatalogApplicationContentType {
  id: ID!
  name: String!
}

type CatalogApplicationContentTypeGroup {
  contentType: [CatalogApplicationContentType!]!
  id: ID!
  name: String!
}

type CatalogApplicationContentTypeGroupListPayload {
  contentTypeGroup: [CatalogApplicationContentTypeGroup!]!
  pageInfo: PageInfo!
}

type CatalogApplicationListPayload {
  application: [CatalogApplication!]!
  pageInfo: PageInfo!
}

type CatalogApplicationSecurityAttributes {
  auditTrail: CatalogApplicationAttribute!
  encryptionAtRest: CatalogApplicationAttribute!
  httpSecurityHeaders: CatalogApplicationAttribute!
  mfa: CatalogApplicationAttribute!
  rbac: CatalogApplicationAttribute!
  rememberPassword: CatalogApplicationAttribute!
  sso: CatalogApplicationAttribute!
  tlsEnforcement: CatalogApplicationAttribute!
  trustedCertificate: CatalogApplicationAttribute!
}

type CatalogQueries {
  catalogApplication(input: ApplicationRefInput!): CatalogApplication @beta
  catalogApplicationList(input: CatalogApplicationListInput!): CatalogApplicationListPayload @beta
  contentTypeGroupList(input: CatalogApplicationContentTypeGroupListInput!): CatalogApplicationContentTypeGroupListPayload @beta
}

""" CatoActivity is an object type representing an activity in a Cato alert, containing unique identifiers for the activity itself, the preceding resource, and the involved resource. """
type CatoActivity implements Activity {
  id: ID!
  parentResourceId: ID!
  resourceId: ID!
}

""" The `CatoEndpoint` object represents a comprehensive data structure used in GraphQL queries or mutations to encapsulate details about a security incident detected by an Endpoint Protection Platform (EPP). It includes fields such as threat alerts, analyst feedback, connection type, criticality score, device details, timestamps for incident signals, and various enums and strings that describe the incident's status, source, and producer. """
type CatoEndpoint implements Endpoint & MergedIncident {
  alerts: [CatoEndpointAlert!]!
  analystFeedback: AnalystFeedback
  connectionType: ConnectionTypeEnum
  criticality: Int
  description: String
  device: CatoEndpointDeviceDetails
  engineType: StoryEngineTypeEnum
  firstSignal: DateTime!
  id: ID!
  indication: String!
  lastSignal: DateTime!
  predictedThreatType: String
  predictedVerdict: StoryVerdictEnum
  producer: StoryProducerEnum!
  producerName: String!
  queryName: String
  research: Boolean
  similarStoriesData: [SimilarStoryData!]!
  site: SiteRef
  siteName: String
  source: String
  sourceIp: String
  status: StoryStatusEnum
  storyDuration: Int
  ticket: String
  user: UserRef
  vendor: VendorEnum
}

""" The `CatoEndpointAlert` object represents an alert generated by Cato's endpoint protection system, detailing information about detected threats, including associated activities, threat description, criticality level, endpoint protection profile, and remediation status. """
type CatoEndpointAlert implements EndpointAlert {
  activities: [CatoActivity!]!
  createdDateTime: DateTime
  criticality: Int
  description: String
  endpointProtectionProfile: String
  engineType: CatoEndpointEngineType
  externalIp: String
  id: ID!
  localIp: String
  mitreSubTechnique: [Mitre!]!
  mitreTechnique: [Mitre!]!
  resources: [CatoResource!]!
  status: RemediationStatusEnum
  threatName: String
  title: String
}

""" The `CatoEndpointDeviceDetails` object represents detailed information about a device, including its name, unique ID, logged-on users, MAC address, and operating system details. """
type CatoEndpointDeviceDetails implements DeviceDetails {
  deviceName: String
  externalIp: String
  id: ID!
  localIp: String
  loggedOnUsers: [EndpointUser!]!
  macAddress: String
  osDetails: OsDetails
}

""" The `CatoEndpointUser` is a GraphQL object type representing a user, with fields for a unique identifier (`id`) and a username (`name`), both of which are required. """
type CatoEndpointUser implements EndpointUser {
  id: ID!
  name: String!
}

""" The `CatoFileResource` is a GraphQL object type that represents a file resource with fields for its creation timestamp, detection and remediation statuses, file details, and a unique identifier. """
type CatoFileResource implements CatoResource & EndpointResource & FileResource {
  createdDateTime: DateTime
  detectionStatus: DetectionStatusEnum
  fileDetails: FileDetails
  id: ID!
  remediationStatus: RemediationStatusEnum
}

""" The `CatoProcessResource` is a GraphQL object type that represents a process resource, including details such as a unique Cato ID, the timestamp of usage, associated file details, command line information, process ID, remediation status, and the related user account. """
type CatoProcessResource implements CatoResource & EndpointResource & ProcessResource {
  createdDateTime: DateTime
  id: ID!
  imageFile: FileDetails
  processCommandLine: String
  processId: Int!
  remediationStatus: RemediationStatusEnum
  userAccount: EndpointUser
}

type CellularInterface {
  apn: String
  apnSelectionMethod: ApnMethod
  disconnectionReason: CellularDisconnectionReason
  iccid: String
  imei: String
  isModemConnected: Boolean!
  isModemSuspended: Boolean!
  isRoamingAllowed: Boolean!
  isSimSlot1Detected: Boolean!
  isSimSlot2Detected: Boolean!
  modemStatus: CellularModemStatus
  networkType: CellularNetworkType
  operatorName: String
  signalStrength: String
  simNumber: String
  simSlotId: Int
}

""" Connectivity status of a cloud interconnect connection. """
type CloudInterconnectConnectionConnectivity {
  success: Boolean!
}

""" Details of a physical connection at a cloud interconnect site. """
type CloudInterconnectPhysicalConnection {
  cVlan: Vlan
  downstreamBwLimit: NetworkBandwidth!
  encapsulationMethod: TaggingMethod!
  haRole: HaRole!
  id: ID!
  popLocation: PopLocationRef!
  privateCatoIp: IPAddress!
  privateSiteIp: IPAddress!
  sVlan: Vlan
  serviceProviderName: String!
  site: SiteRef!
  subnet: NetworkSubnet!
  upstreamBwLimit: NetworkBandwidth!
  vlan: Vlan
}

""" ID of a physical connection at a cloud interconnect site. """
type CloudInterconnectPhysicalConnectionId {
  id: ID!
}

type ContactDetails {
  email: Email
  name: String
  phone: Phone
}

""" Audit metadata about the container """
type ContainerAudit {
  createdAt: DateTime!
  createdBy: String!
  lastModifiedAt: DateTime!
  lastModifiedBy: String!
}

type ContainerMutations {
  delete(input: DeleteContainerInput!): DeleteContainerPayload! @beta
  fqdn: FqdnContainerMutations!
  ipAddressRange: IpAddressRangeContainerMutations!
}

type ContainerQueries {
  fqdn: FqdnContainerQueries!
  ipAddressRange: IpAddressRangeContainerQueries!
  list(input: ContainerSearchInput!): ContainerSearchPayload! @beta
}

""" Container search result, including all containers that matched input criteria """
type ContainerSearchPayload {
  containers: [Container!]!
}

""" A reference identifying the Country object. ID: Unique Country Identifier, Name: The Country Name """
type CountryRef implements ObjectRef {
  id: ID!
  name: String!
}

""" Payload of CreateFromFile operation on FQDN typed container """
type CreateFqdnContainerFromFilePayload {
  container: FqdnContainer!
}

""" Payload of CreateFromList operation on FQDN typed container """
type CreateFqdnContainerFromListPayload {
  container: FqdnContainer!
}

""" The created group object. """
type CreateGroupPayload {
  group: Group!
}

""" Payload of CreateFromFile operation on IPAddressRange typed container """
type CreateIpAddressRangeContainerFromFilePayload {
  container: IpAddressRangeContainer!
}

""" Payload of CreateFromList operation on IPAddressRange typed container """
type CreateIpAddressRangeContainerFromListPayload {
  container: IpAddressRangeContainer!
}

""" A reference identifying the CustomApplication object. ID: Unique CustomApplication Identifier, Name: The CustomApplication Name """
type CreatePrivateApplicationPayload {
  application: PrivateApplication!
}

type CustomApplicationRef implements ObjectRef {
  id: ID!
  name: String!
}

""" A reference identifying the CustomCategory object. ID: Unique CustomCategory Identifier, Name: The CustomCategory Name """
type CustomCategoryRef implements ObjectRef {
  id: ID!
  name: String!
}

""" Returns data for Custom Service defined by a combination of L4 ports and an IP Protocol """
type CustomService {
  port: [Port!]
  portRange: PortRange
  protocol: IpProtocol!
}

type CustomServiceIp {
  ip: IPAddress
  ipRange: IpAddressRange
  name: String!
}

type DataLakeLicense implements License & QuantifiableLicense {
  description: String
  dpaVersion: DpaVersion!
  expirationDate: DateTime!
  id: String
  lastUpdated: DateTime
  plan: LicensePlan!
  retentionPeriod: Int
  sku: LicenseSku!
  startDate: DateTime
  status: LicenseStatus!
  total: Int!
}

type DateValue {
  date: DateTime
}

type DegradedDetail {
  args: DegradedStatusArgs
  reason: DegradedStatusReason!
}

type DegradedStatus {
  degradedDetails: [DegradedDetail!]!
  isDegraded: Boolean!
}

type DegradedStatusBasicDataArgs {
  deviceName: String!
  lastConnectedDate: DateTime
}

type DegradedStatusLastConnectedArgs {
  lastConnectedDate: DateTime
}

type DegradedStatusMultiTunnelArgs {
  deviceName: String!
  lastConnectedDate: DateTime
  tunnelID: ID!
  tunnelName: String!
}

type DegradedStatusSocketArgs {
  deviceName: String!
  lastConnectedDate: DateTime
  portID: ID!
  portName: String!
}

type DegradedStatusSocketVersionsArgs {
  primaryVersion: String!
  secondaryVersion: String!
}

type DeleteContainerPayload {
  container: Container!
}

""" The deleted group object """
type DeleteGroupPayload {
  group: Group!
}

type DeletePrivateApplicationPayload {
  application: ID!
}

""" Delete report response """
type DeleteReportPayload {
  fileHash: String!
}

type DeleteStoryCommentPayload {
  comment: StoryComment!
}

""" DEM service license details """
type DemLicense implements License & QuantifiableLicense {
  description: String
  expirationDate: DateTime!
  id: String
  lastUpdated: DateTime
  plan: LicensePlan!
  sku: LicenseSku!
  startDate: DateTime
  status: LicenseStatus!
  total: Int!
}

type DeviceAttributeCatalogPayload {
  items: [String!]!
  pageInfo: PageInfo!
}

type DeviceAttributes {
  category: [String!]!
  manufacturer: [String!]!
  model: [String!]!
  os: [String!]!
  osVersion: [String!]!
  type: [String!]!
}

type DeviceAttributesCatalogQueries {
  category(sort: SortOrderInput): DeviceAttributeCatalogPayload!
  manufacturer(input: DeviceAttributeCatalogInput): DeviceAttributeCatalogPayload!
  model(input: DeviceAttributeCatalogInput): DeviceAttributeCatalogPayload!
  os(input: DeviceAttributeCatalogInput): DeviceAttributeCatalogPayload!
  type(input: DeviceAttributeCatalogInput): DeviceAttributeCatalogPayload!
}

type DeviceConnectionProfile {
  destApps: [String!]!
  destDomains: [String!]!
  destHosts: [String!]!
  directions: [String!]!
}

type DeviceHw {
  manufacturer: String
  model: String
  type: String
}

type DeviceNetwork {
  networkName: String
  subnet: String
}

type DeviceNic {
  macAddress: MacAddress
  vendor: String
}

type DeviceOs {
  product: String
  vendor: String
  version: String
}

""" A reference identifying the DeviceProfile object. ID: Unique DeviceProfile Identifier, Name: The DeviceProfile Name """
type DeviceProfileRef implements ObjectRef {
  id: ID!
  name: String!
}

type DeviceSnapshot {
  connected: Boolean
  connectedSince: DateTime
  deviceUptime: Int
  haRole: String
  id: ID
  identifier: String
  interfaces: [InterfaceSnapshot!]
  interfacesLinkState: [InterfaceLinkState!]
  internalIP: String
  lastConnected: DateTime
  lastDuration: Int
  lastPopID: Int
  lastPopName: String
  mfaCreationTime: Int
  mfaExpirationTime: Int
  name: String
  osType: String
  osVersion: String
  recentConnections: [RecentConnection!]
  releaseGroup: String
  socketInfo: SocketInfo
  type: String
  version: String
  versionNumber: Int
}

type DeviceV2 {
  category: String
  complianceState: String
  confidence: DeviceConfidenceLevel
  connectionProfile: DeviceConnectionProfile
  firstSeen: DateTime
  hw: DeviceHw
  id: ID!
  ip: String @deprecated(reason: "Use ipAddress instead")
  ipAddress: IPAddress
  isManaged: Boolean!
  lastSeen: DateTime
  name: String
  network: DeviceNetwork
  networkInfo: DeviceNetworkRef
  nic: DeviceNic
  originTypes: [OriginType!]!
  os: DeviceOs
  riskScore: Int
  site: SiteRef
  user: UserRef
}

type DevicesPayload {
  device: [DeviceV2!]!
  paging: PageInfo!
}

type DevicesQueries {
  attributesCatalog: DeviceAttributesCatalogQueries! @beta
  csvExport(input: DeviceCsvExportInput): ExportJobResponse! @beta
  csvExportStatus(jobId: ID!): ExportStatusResponse! @beta
  list(input: DeviceV2Input): DevicesPayload @beta
}

type DimensionData {
  label: String!
  value: String
}

type DimensionKey {
  fieldName: String!
  value: String
}

type DisableAccountPayload {
  accountInfo: AccountInfo!
}

type DlpContentProfileRef implements ObjectRef {
  id: ID!
  name: String!
}

type DlpEdmProfileRef implements ObjectRef {
  id: ID!
  name: String!
}

""" Data Loss Prevention (DLP) Service license details """
type DlpLicense implements License {
  description: String
  expirationDate: DateTime!
  id: String
  lastUpdated: DateTime
  plan: LicensePlan!
  sku: LicenseSku!
  startDate: DateTime
  status: LicenseStatus!
}

""" Payload of download FQDN typed container file """
type DownloadFqdnContainerFilePayload {
  encodedFile: String!
  id: ID!
  name: String!
}

""" Payload of download IPAddressRange typed container file """
type DownloadIpAddressRangeContainerFilePayload {
  encodedFile: String!
  id: ID!
  name: String!
}

type DynamicIpAllocationPolicy implements IPolicy {
  audit: PolicyAudit
  enabled: Boolean!
  revision: PolicyRevision
  rules: [DynamicIpAllocationRulePayload!]!
  sections: [PolicySectionPayload!]!
}

type DynamicIpAllocationPolicyMutationPayload implements IPolicyMutationPayload {
  errors: [PolicyMutationError!]!
  policy: DynamicIpAllocationPolicy
  status: PolicyMutationStatus!
}

type DynamicIpAllocationPolicyMutations {
  addRule(input: DynamicIpAllocationAddRuleInput!): DynamicIpAllocationRuleMutationPayload! @beta
  addSection(input: PolicyAddSectionInput!): PolicySectionMutationPayload! @beta
  createPolicyRevision(input: PolicyCreateRevisionInput!): DynamicIpAllocationPolicyMutationPayload! @beta
  discardPolicyRevision(input: PolicyDiscardRevisionInput): DynamicIpAllocationPolicyMutationPayload! @beta
  moveRule(input: PolicyMoveRuleInput!): DynamicIpAllocationRuleMutationPayload! @beta
  moveSection(input: PolicyMoveSectionInput!): PolicySectionMutationPayload! @beta
  publishPolicyRevision(input: PolicyPublishRevisionInput): DynamicIpAllocationPolicyMutationPayload! @beta
  removeRule(input: DynamicIpAllocationRemoveRuleInput!): DynamicIpAllocationRuleMutationPayload! @beta
  removeSection(input: PolicyRemoveSectionInput!): PolicySectionMutationPayload! @beta
  updatePolicy(input: DynamicIpAllocationPolicyUpdateInput!): DynamicIpAllocationPolicyMutationPayload! @beta
  updateRule(input: DynamicIpAllocationUpdateRuleInput!): DynamicIpAllocationRuleMutationPayload! @beta
  updateSection(input: PolicyUpdateSectionInput!): PolicySectionMutationPayload! @beta
}

type DynamicIpAllocationPolicyQueries {
  policy(input: DynamicIpAllocationPolicyInput): DynamicIpAllocationPolicy! @beta
  revisions: PolicyRevisionsPayload @beta
}

type DynamicIpAllocationRange {
  globalIpRange: GlobalIpRangeRef!
}

type DynamicIpAllocationRule implements IPolicyRule {
  country: [CountryRef!]!
  description: String!
  enabled: Boolean!
  id: ID!
  index: Int!
  name: String!
  platform: [OperatingSystem!]!
  range: DynamicIpAllocationRange!
  section: PolicySectionInfo!
  source: DynamicIpAllocationSource!
}

type DynamicIpAllocationRuleMutationPayload implements IPolicyRuleMutationPayload {
  errors: [PolicyMutationError!]!
  rule: DynamicIpAllocationRulePayload
  status: PolicyMutationStatus!
}

type DynamicIpAllocationRulePayload implements IPolicyRulePayload {
  audit: PolicyElementAudit!
  properties: [PolicyElementPropertiesEnum!]!
  rule: DynamicIpAllocationRule!
}

type DynamicIpAllocationSource {
  user: [UserRef!]!
  usersGroup: [UsersGroupRef!]!
}

""" End Point Protection (EPP) license details """
type EndpointProtectionLicense implements License & QuantifiableLicense {
  description: String
  expirationDate: DateTime!
  id: String
  lastUpdated: DateTime
  plan: LicensePlan!
  sku: LicenseSku!
  startDate: DateTime
  status: LicenseStatus!
  total: Int!
}

type EnterpriseDirectoryArchiveLocationPayload {
  location: Location!
}

type EnterpriseDirectoryCreateLocationPayload {
  location: Location!
}

type EnterpriseDirectoryLocationListPayload {
  items: [Location!]!
  pageInfo: PageInfo
}

type EnterpriseDirectoryMutations {
  archiveLocation(locationId: ID): EnterpriseDirectoryArchiveLocationPayload @beta
  createLocation(input: EnterpriseDirectoryCreateLocationInput!): EnterpriseDirectoryCreateLocationPayload @beta
  restoreLocation(locationId: ID): EnterpriseDirectoryRestoreLocationPayload @beta
  updateLocation(input: EnterpriseDirectoryUpdateLocationInput!): EnterpriseDirectoryUpdateLocationPayload @beta
}

type EnterpriseDirectoryQueries {
  locationList(input: EnterpriseDirectoryLocationListInput): EnterpriseDirectoryLocationListPayload! @beta
}

type EnterpriseDirectoryRestoreLocationPayload {
  location: Location!
}

type EnterpriseDirectoryUpdateLocationPayload {
  location: Location!
}

type Entity {
  id: ID!
  name: String
  type: EntityType!
}

type EntityAccess {
  action: RBACAction!
}

type EntityInfo {
  description: String!
  entity: Entity!
  helperFields: Map!
}

type EntityLookupResult {
  items: [EntityInfo!]!
  total: Int
}

type Event {
  action: String
  appId: String
  appName: String
  dnsProtectionCategory: String
  eventType: String
  ruleId: String
  scanResult: ScanResult
  severity: String
  signatureId: String
  threatName: String
  threatType: String
  virusName: String
}

type EventField {
  name: EventFieldName!
  value: Value!
}

type EventRecord {
  fieldsMap: Map
  flatFields: [[String!]]
  time: DateTime
}

type Events {
  from: DateTime
  id: ID
  records(limit: Int, from: Int): [EventsRecord!]
  to: DateTime
  total: Int
  totals: Map
}

type EventsFeedAccountRecords {
  errorString: String
  id: ID
  records(fieldNames: [EventFieldName!]): [EventRecord!]
}

type EventsFeedData {
  accounts: [EventsFeedAccountRecords]
  fetchedCount: Int!
  marker: String
}

type EventsGraphQuery {
  timeSeriesEvents: TimeSeriesEvents
  type: GraphType!
}

type EventsRecord {
  fields: [EventField!]
  fieldsMap: Map
  fieldsUnitTypes: [UnitType!]
  flatFields: [[String!]]
  prevTimeFrame: Map
  trends: Map
}

type EventsTimeSeries {
  from: DateTime
  granularity: Int
  id: ID
  timeseries(buckets: Int!): [Timeseries!]
  to: DateTime
}

""" Response returned when initiating a CSV export job """
type ExportJobResponse {
  jobId: ID!
  message: String
}

""" Response containing the current status and details of an export job """
type ExportStatusResponse {
  downloadUrl: String
  expiresAt: DateTime
  jobId: ID!
  message: String
  progress: Float
  status: ExportJobStatus!
}

type Extra {
  name: String!
  type: String!
  value: String!
}

type FileDetails {
  issuer: String
  md5: String
  name: String
  path: String
  publisher: String
  sha1: String
  sha256: String
  signer: String
  size: Int
}

"""
Returns data for the Floating Subnet object. Floating Subnets (ie. Floating Ranges) are used to identify traffic exactly matched
to the route advertised by BGP. They are not associated with a specific site.
This is useful in scenarios such as active-standby high availability routed via BGP.
"""
type FloatingSubnetRef implements ObjectRef {
  id: ID!
  name: String!
}

""" A group with members of FQDN type """
type FqdnContainer implements Container {
  audit: ContainerAudit!
  description: String
  id: ID!
  name: String!
  size: Int!
}

""" Payload of AddValues operation on FQDN typed container """
type FqdnContainerAddValuesPayload {
  container: FqdnContainer!
}

type FqdnContainerMutations {
  addValues(input: FqdnContainerAddValuesInput!): FqdnContainerAddValuesPayload! @beta
  createFromFile(input: CreateFqdnContainerFromFileInput!): CreateFqdnContainerFromFilePayload! @beta
  createFromList(input: CreateFqdnContainerFromListInput!): CreateFqdnContainerFromListPayload! @beta
  removeValues(input: FqdnContainerRemoveValuesInput!): FqdnContainerRemoveValuesPayload! @beta
  updateFromFile(input: UpdateFqdnContainerFromFileInput!): UpdateFqdnContainerFromFilePayload! @beta
  updateFromList(input: UpdateFqdnContainerFromListInput!): UpdateFqdnContainerFromListPayload! @beta
}

type FqdnContainerQueries {
  downloadFile(input: DownloadFqdnContainerFileInput!): DownloadFqdnContainerFilePayload! @beta
  search(input: FqdnContainerSearchInput!): FqdnContainerSearchPayload! @beta
  searchFqdn(input: FqdnContainerSearchFqdnInput!): FqdnContainerSearchFqdnPayload! @beta
}

""" A group with members of FQDN type """
type FqdnContainerRef implements ObjectRef {
  id: ID!
  name: String!
}

""" Payload of RemoveValues operation on FQDN typed container """
type FqdnContainerRemoveValuesPayload {
  container: FqdnContainer!
}

""" Payload of FQDN search query """
type FqdnContainerSearchFqdnPayload {
  containers: [FqdnContainer!]!
}

""" Payload of FQDN container search """
type FqdnContainerSearchPayload {
  container: FqdnContainer!
}

type Gaussian {
  avg: Float
  n: Float
  ss: Float
  std: Float
  z_score: Float
}

type GetAdminPayload {
  adminType: AdminType!
  creationDate: String!
  email: String!
  firstName: String!
  id: ID!
  lastName: String!
  managedRoles: [AdminRole!]
  mfaEnabled: Boolean!
  passwordNeverExpires: Boolean!
  resellerRoles: [AdminRole!]
}

type GetServicePrincipalAdminPayload {
  adminType: AdminType!
  creationDate: String!
  email: String
  id: ID!
  managedRoles: [AdminRole!]
  name: String!
  resellerRoles: [AdminRole!]
}

""" A reference identifying the GlobalIpRange object. ID: Unique GlobalIpRange Identifier, Name: The GlobalIpRange Name """
type GlobalIpRangeRef implements ObjectRef {
  id: ID!
  name: String!
}

""" License usage and allocation across all accounts """
type GlobalLicenseAllocations {
  publicIps: PublicIpsLicenseAllocations
  ztnaUsers: ZtnaUsersLicenseAllocations
}

type GlobalRangeRef implements ObjectRef {
  id: ID!
  name: String!
}

type GraphEventsDimension {
  fieldName: String!
}

type GraphEventsFilter {
  fieldName: String!
  operator: String!
  values: [String!]!
}

type GraphEventsMeasure {
  aggType: String!
  fieldName: String!
  trend: Boolean
}

"""
A group is a collection of typed members (e.g., sites, hosts).
Groups can include members of different types.

When you update a group or use it in a policy, the system verifies that all members are allowed in the policy's scope.
If a group is used in a policy that doesnt support certain member types, you can't add those types to the group.
If a group already includes unsupported types, you can only assign it to a policy that supports those types.
A member type is valid if it's supported in the group and allowed in the policy scope.
"""
type Group {
  audit: AuditingMetadata!
  description: String
  id: ID!
  members(input: GroupMembersListInput! = {paging:{limit:100,from:0},sort:{name:{direction:ASC,priority:2},type:{direction:ASC,priority:1}}}): GroupMembersListPayload!
  membersCount: Int!
  membersCountPerType: [GroupMemberTypeCount!]!
  name: String!
}

""" A list of groups returned by the groupList query, with pagination info. """
type GroupListPayload {
  items: [Group!]!
  paging: PageInfo!
}

"""
Reference to a group member, including its ID, name, and type.
Used when listing or identifying members within a group.
"""
type GroupMemberRefTyped implements ObjectRef {
  id: ID!
  name: String!
  type: GroupMemberRefType!
}

""" Counts how many members of each type the group contains. """
type GroupMemberTypeCount {
  membersCount: Int!
  type: GroupMemberRefType!
}

""" A list of group members, pagination details, applied filters, and sorting information. """
type GroupMembersListPayload {
  items: [GroupMemberRefTyped!]!
  paging: PageInfo!
}

""" A reference identifying the Group object. ID: Unique Group Identifier, Name: The Group Name """
type GroupRef implements ObjectRef {
  id: ID!
  name: String!
}

"""
The scope (context) in which a group is used or supported.
Includes the policy type and the specific field name(s) where the group is used.
"""
type GroupScope {
  field: [String!]!
  type: String!
}

"""
Describes where the group is used across policies and scopes.

Includes a list of policy scopes where the group is applied,
and identifies any member types that are not supported in those policy scopes.
"""
type GroupWhereUsedPayload {
  invalidMemberTypes: [InvalidGroupMemberTypeInScope!]!
  usage: [GroupScope!]!
  used: Boolean!
}

""" Operations for managing groups """
type GroupsMutations {
  createGroup(input: CreateGroupInput!): CreateGroupPayload @beta
  deleteGroup(input: GroupRefInput!): DeleteGroupPayload @beta
  updateGroup(input: UpdateGroupInput!): UpdateGroupPayload @beta
}

""" Queries for reading groups-related information """
type GroupsQueries {
  group(input: GroupRefInput!): Group @beta
  groupList(input: GroupListInput = {paging:{limit:100,from:0},sort:{name:{direction:ASC,priority:1}}}): GroupListPayload @beta
  whereUsed(input: GroupRefInput!): GroupWhereUsedPayload @beta
}

""" Basic Site Ha readiness information """
type HaStatus {
  keepalive: HaSubStatus
  readiness: HaReadiness
  socketVersion: HaSubStatus
  wanConnectivity: HaSubStatus
}

type Hardware {
  account: AccountRef
  id: ID!
  lastModified: DateTime
  licenseId: ID
  licenseStartDate: Date
  locationId: ID
  macAddress: String
  model: String
  poNumber: String
  productType: String
  quoteId: String
  serialNumber: String
  shippingDetail: ShippingDetails
  shippingTracking: ShippingTracking
  siteCountryName: String
  validation: HardwareValidation
}

type HardwareManagementQueries {
  socketInventory(input: SocketInventoryInput): SocketInventoryPayload! @beta
}

type HardwareMutations {
  updateHardwareShipping(input: UpdateHardwareShippingInput!): HardwarePayload @beta
}

type HardwarePayload {
  items: [Hardware!]!
  pageInfo: PageInfo
}

type HardwareQueries {
  hardware(input: HardwareSearchInput): HardwarePayload @beta
}

type HardwareValidation {
  addressValidationStatus: AddressValidationStatus
  completed: Boolean!
  incompleteReason: String
}

""" A reference identifying the Host object. ID: Unique Host Identifier, Name: The Host Name """
type HostRef implements ObjectRef {
  id: ID!
  name: String!
}

""" A general structure to contain IP detailed information """
type IPInfo {
  city: String
  countryCode: String
  countryName: String
  ip: String
  latitude: Float
  longitude: Float
  provider: String
  state: String
}

""" Basic IPSec configuration information """
type IPSecInfo {
  catoIP: String
  ikeVersion: Int
  isPrimary: Boolean
  remoteIP: String
  tunnelConfig: [TunnelConfig!]!
}

type IlmmContact {
  email: String
  name: String
  phone: String
}

type IlmmDetails {
  contacts: [IlmmContact!]
  ispDetails: IlmmIspDetails
  linkDetails: IlmmLinkDetails
}

type IlmmIspDetails {
  countryCode: String
  description: String
  ispAccountId: String
  loaFile: IspLoaFile
  name: String
  supportEmail: String
  supportPhone: String
}

""" Intelligent Last Mile Monitoring (ILMM) License details """
type IlmmLicense implements License & QuantifiableLicense {
  description: String
  expirationDate: DateTime!
  id: String
  lastUpdated: DateTime
  plan: LicensePlan!
  sku: LicenseSku!
  startDate: DateTime
  status: LicenseStatus!
  total: Int!
}

type IlmmLinkDetails {
  activeLicense: Boolean
  comments: String
  description: String
  ispLinkId: String
  linkId: String
  onboardingStatus: IlmmOnboardingStatus
}

type IncidentFlow {
  appName: String
  clientClass: String
  createdAt: DateTime
  destinationCountry: String
  destinationGeolocation: String
  destinationIp: String
  destinationPort: Int
  direction: String
  dnsResponseIP: String
  domain: String
  fileHash: String
  httpResponseCode: Int
  ja3: String
  method: String
  referer: String
  smbFileName: String
  sourceGeolocation: String
  sourceIp: String
  sourcePort: Int
  target: String
  tunnelGeolocation: String
  url: String
  user: String
  userAgent: String
}

type IncidentTargetRep {
  analysisScore: Float
  categories: String
  catoPopularity: Int
  countryOfRegistration: String
  creationTime: DateTime
  engines: Int
  eventData: [Event!]!
  infectionSource: Boolean
  name: String
  searchHits: String
  threatFeeds: Int
  threatReference: String
  type: TargetType
}

type IncidentTimeseries {
  data(perSecond: Boolean = true): [[Float!]]
  groupBy: String
  info: [String!]
  key: TimeseriesKey
  label: String!
  sum: Float
  units: UnitType
}

""" Basic Socket Interface configuration information """
type InterfaceInfo {
  destType: String
  downstreamBandwidth: Int
  downstreamBandwidthMbpsPrecision: Float @beta
  id: ID!
  name: String
  upstreamBandwidth: Int
  upstreamBandwidthMbpsPrecision: Float @beta
  wanRole: SocketInterfaceWanRole @beta
}

type InterfaceLinkState {
  duplex: String
  hasAddress: Boolean
  hasInternet: Boolean
  hasTunnel: Boolean
  id: ID
  linkSpeed: String
  mediaIn: Boolean
  up: Boolean
}

type InterfaceMetrics {
  annotations(types: [String!]): [TimeAnnotation!]
  interfaceInfo: InterfaceInfo
  ipsecInfo: IPSecInfo
  metrics(toRate: Boolean = false): Metrics
  name: String
  periods: [TimePeriod!]
  remoteIP: String
  remoteIPInfo: IPInfo
  socketInfo: SocketInfo
  timeseries(buckets: Int, labels: [TimeseriesMetricType!]): [Timeseries!]
}

type InterfaceSnapshot {
  bgpState: BgpState
  cellularInterfaceInfo: CellularInterface
  connected: Boolean
  id: ID
  info: InterfaceInfo
  name: String
  naturalOrder: Int
  physicalPort: Int
  popName: String
  previousPopID: Int
  previousPopName: String
  tunnelConnectionReason: String
  tunnelRemoteIP: String
  tunnelRemoteIPInfo: IPInfo
  tunnelUptime: Int
  type: String @deprecated(reason: "No longer supported")
}

type InternetFirewallContainer {
  fqdnContainer: [FqdnContainerRef!]!
  ipAddressRangeContainer: [IpAddressRangeContainerRef!]!
}

""" Returns the settings for Destination of an Internet Firewall rule """
type InternetFirewallDestination {
  appCategory: [ApplicationCategoryRef!]!
  application: [ApplicationRef!]!
  containers: InternetFirewallContainer!
  country: [CountryRef!]!
  customApp: [CustomApplicationRef!]!
  customCategory: [CustomCategoryRef!]!
  domain: [Domain!]!
  fqdn: [Fqdn!]!
  globalIpRange: [GlobalIpRangeRef!]!
  ip: [IPAddress!]!
  ipRange: [IpAddressRange!]!
  remoteAsn: [Asn16!]!
  sanctionedAppsCategory: [SanctionedAppsCategoryRef!]!
  subnet: [NetworkSubnet!]!
}

type InternetFirewallPolicy implements IPolicy {
  audit: PolicyAudit
  enabled: Boolean!
  revision: PolicyRevision
  rules: [InternetFirewallRulePayload!]!
  sections: [PolicySectionPayload!]!
}

""" Internet Firewall policy information provided in the API response """
type InternetFirewallPolicyMutationPayload implements IPolicyMutationPayload {
  errors: [PolicyMutationError!]!
  policy: InternetFirewallPolicy
  status: PolicyMutationStatus!
}

""" The Internet firewall Policy information returned to the caller in the API response. """
type InternetFirewallPolicyMutations {
  addRule(input: InternetFirewallAddRuleInput!): InternetFirewallRuleMutationPayload! @beta
  addSection(input: PolicyAddSectionInput!): PolicySectionMutationPayload! @beta
  createPolicyRevision(input: PolicyCreateRevisionInput!): InternetFirewallPolicyMutationPayload! @beta
  discardPolicyRevision(input: PolicyDiscardRevisionInput): InternetFirewallPolicyMutationPayload! @beta
  moveRule(input: PolicyMoveRuleInput!): InternetFirewallRuleMutationPayload! @beta
  moveSection(input: PolicyMoveSectionInput!): PolicySectionMutationPayload! @beta
  publishPolicyRevision(input: PolicyPublishRevisionInput): InternetFirewallPolicyMutationPayload! @beta
  removeRule(input: InternetFirewallRemoveRuleInput!): InternetFirewallRuleMutationPayload! @beta
  removeSection(input: PolicyRemoveSectionInput!): PolicySectionMutationPayload! @beta
  updatePolicy(input: InternetFirewallPolicyUpdateInput!): InternetFirewallPolicyMutationPayload! @beta
  updateRule(input: InternetFirewallUpdateRuleInput!): InternetFirewallRuleMutationPayload! @beta
  updateSection(input: PolicyUpdateSectionInput!): PolicySectionMutationPayload! @beta
}

type InternetFirewallPolicyQueries {
  policy(input: InternetFirewallPolicyInput): InternetFirewallPolicy! @beta
  revisions: PolicyRevisionsPayload @beta
}

type InternetFirewallRule implements IPolicyRule {
  action: InternetFirewallActionEnum!
  activePeriod: PolicyRuleActivePeriod!
  connectionOrigin: ConnectionOriginEnum!
  country: [CountryRef!]!
  description: String!
  destination: InternetFirewallDestination!
  device: [DeviceProfileRef!]!
  deviceAttributes: DeviceAttributes!
  deviceOS: [OperatingSystem!]!
  enabled: Boolean!
  exceptions: [InternetFirewallRuleException!]!
  id: ID!
  index: Int!
  name: String!
  schedule: PolicySchedule!
  section: PolicySectionInfo!
  service: InternetFirewallServiceType!
  source: InternetFirewallSource!
  tracking: PolicyTracking!
}

""" Exceptions define when a rule is ignored, and the firewall policy evaluation continues with the lower priority rules. """
type InternetFirewallRuleException {
  connectionOrigin: ConnectionOriginEnum!
  country: [CountryRef!]!
  destination: InternetFirewallDestination!
  device: [DeviceProfileRef!]!
  deviceAttributes: DeviceAttributes!
  deviceOS: [OperatingSystem!]!
  name: String!
  service: InternetFirewallServiceType!
  source: InternetFirewallSource!
}

type InternetFirewallRuleMutationPayload implements IPolicyRuleMutationPayload {
  errors: [PolicyMutationError!]!
  rule: InternetFirewallRulePayload
  status: PolicyMutationStatus!
}

""" Internet Firewall policy information for a specific revision """
type InternetFirewallRulePayload implements IPolicyRulePayload {
  audit: PolicyElementAudit!
  properties: [PolicyElementPropertiesEnum!]!
  rule: InternetFirewallRule!
}

""" Returns the Service Type to which this Internet Firewall rule applies """
type InternetFirewallServiceType {
  custom: [CustomService!]!
  standard: [ServiceRef!]!
}

""" Returns the settings for Source of an Internet Firewall rule """
type InternetFirewallSource {
  floatingSubnet: [FloatingSubnetRef!]!
  globalIpRange: [GlobalIpRangeRef!]!
  group: [GroupRef!]!
  host: [HostRef!]!
  ip: [IPAddress!]!
  ipRange: [IpAddressRange!]!
  networkInterface: [NetworkInterfaceRef!]!
  site: [SiteRef!]!
  siteNetworkSubnet: [SiteNetworkSubnetRef!]!
  subnet: [NetworkSubnet!]!
  systemGroup: [SystemGroupRef!]!
  user: [UserRef!]!
  usersGroup: [UsersGroupRef!]!
}

"""
Represents a member type in the group that is not supported in one or more scopes.
Each scope indicates where the member type is not allowed.
"""
type InvalidGroupMemberTypeInScope {
  scope: [GroupScope!]!
  type: GroupMemberRefType!
}

""" IoT/OT Security service license details """
type IotOtLicense implements License {
  description: String
  expirationDate: DateTime!
  id: String
  lastUpdated: DateTime
  plan: LicensePlan!
  sku: LicenseSku!
  startDate: DateTime
  status: LicenseStatus!
}

""" Inclusive range of IPs """
type IpAddressRange {
  from: IPAddress!
  to: IPAddress!
}

""" A group with members of IPAddressRange type """
type IpAddressRangeContainer implements Container {
  audit: ContainerAudit!
  description: String
  id: ID!
  name: String!
  size: Int!
}

""" Payload of AddValues operation on IPAddressRange typed container """
type IpAddressRangeContainerAddValuesPayload {
  container: IpAddressRangeContainer!
}

type IpAddressRangeContainerMutations {
  addValues(input: IpAddressRangeContainerAddValuesInput!): IpAddressRangeContainerAddValuesPayload! @beta
  createFromFile(input: CreateIpAddressRangeContainerFromFileInput!): CreateIpAddressRangeContainerFromFilePayload! @beta
  createFromList(input: CreateIpAddressRangeContainerFromListInput!): CreateIpAddressRangeContainerFromListPayload! @beta
  removeValues(input: IpAddressRangeContainerRemoveValuesInput!): IpAddressRangeContainerRemoveValuesPayload! @beta
  updateFromFile(input: UpdateIpAddressRangeContainerFromFileInput!): UpdateIpAddressRangeContainerFromFilePayload! @beta
  updateFromList(input: UpdateIpAddressRangeContainerFromListInput!): UpdateIpAddressRangeContainerFromListPayload! @beta
}

type IpAddressRangeContainerQueries {
  downloadFile(input: DownloadIpAddressRangeContainerFileInput!): DownloadIpAddressRangeContainerFilePayload! @beta
  search(input: IpAddressRangeContainerSearchInput!): IpAddressRangeContainerSearchPayload! @beta
  searchIpAddressRange(input: IpAddressRangeContainerSearchIpAddressRangeInput!): IpAddressRangeContainerSearchIpAddressRangePayload! @beta
}

""" A group with members of IPAddressRange type """
type IpAddressRangeContainerRef implements ObjectRef {
  id: ID!
  name: String!
}

""" Payload of AddValues operation on IPAddressRange typed container """
type IpAddressRangeContainerRemoveValuesPayload {
  container: IpAddressRangeContainer!
}

""" Payload of IPAddressRange search query """
type IpAddressRangeContainerSearchIpAddressRangePayload {
  containers: [IpAddressRangeContainer!]!
}

""" Payload of IPAddressRange container search """
type IpAddressRangeContainerSearchPayload {
  container: IpAddressRangeContainer!
}

""" Intrusion Prevention System (IPS) service license (Legacy license, replaced by TP) """
type IpsLicense implements License {
  description: String
  expirationDate: DateTime!
  id: String
  lastUpdated: DateTime
  plan: LicensePlan!
  sku: LicenseSku!
  startDate: DateTime
  status: LicenseStatus!
}

type IspLoaFile {
  fileHash: String
  fileName: String
  uploadedAt: Time
}

""" Public license API """
type LicensingInfo {
  atp: [AtpLicense!]!
  casb: [CasbLicense!]!
  dataLake: [DataLakeLicense!]!
  dem: [DemLicense!]!
  dlp: [DlpLicense!]!
  endpointProtection: [EndpointProtectionLicense!]!
  globalLicenseAllocations: GlobalLicenseAllocations!
  ilmm: [IlmmLicense!]!
  iotOt: [IotOtLicense!]!
  ips: [IpsLicense!]!
  licenses: [License!]! @deprecated(reason: "please use individual license type fields")
  malwareProtection: [MalwareProtectionLicense!]!
  managedXdr: [ManagedXdrLicense!]!
  mdr: [MdrLicense!]!
  nextGenMalwareProtection: [NextGenMalwareProtectionLicense!]!
  nocaas: [NOCaaSLicense!]!
  pooledBandwidth: [PooledBandwidthLicense!]!
  publicIps: [PublicIpsLicense!]!
  rbi: [RbiLicense!]!
  saasSecurityApi: [SaasSecurityApiLicense!]!
  site: [SiteLicense!]!
  threatPrevention: [ThreatPreventionLicense!]!
  xOps: [XOpsLicense!]!
  xdrPro: [XdrProLicense!]!
  ztnaUsers: [ZtnaUsersLicense!]!
}

type LicensingMutations {
  updateCommercialLicense(input: UpdateCommercialLicenseInput!): UpdateCommercialLicensePayload @beta
}

type LicensingQueries {
  licensingInfo: LicensingInfo @beta
}

type LinkQualityIssue {
  current: Int
  direction: TrafficDirectionEnum
  issueType: LinkQualityIssueTypeEnum
  threshold: Int
}

type Location {
  account: AccountRef!
  archived: Boolean!
  audit: AuditingMetadata!
  businessUnit: String
  description: String
  details: LocationDetails!
  id: ID!
  name: String!
  type: LocationType!
}

type LocationDetails {
  companyName: String
  contact: ContactDetails
  postalAddress: PostalAddress!
  shippingLocation: Boolean!
  vatId: String
}

""" Anti-Malware service license details (Legacy license, replaced by TP) """
type MalwareProtectionLicense implements License {
  description: String
  expirationDate: DateTime!
  id: String
  lastUpdated: DateTime
  plan: LicensePlan!
  sku: LicenseSku!
  startDate: DateTime
  status: LicenseStatus!
}

""" Managed XDR service license details """
type ManagedXdrLicense implements License {
  description: String
  expirationDate: DateTime!
  id: String
  lastUpdated: DateTime
  plan: LicensePlan!
  sku: LicenseSku!
  startDate: DateTime
  status: LicenseStatus!
}

""" MDR service license details """
type MdrLicense implements License {
  description: String
  expirationDate: DateTime!
  id: String
  lastUpdated: DateTime
  plan: LicensePlan!
  sku: LicenseSku!
  startDate: DateTime
  status: LicenseStatus!
}

type Metric {
  name: String!
  value: Float!
}

type MetricDetails {
  name: String!
  units: String!
}

type Metrics {
  bytesDownstream: Float
  bytesTotal: Float
  bytesUpstream: Float
  duration: Int
  flowCount: Float
  granularity: Int
  hostCount: Float
  hostLimit: Float
  jitterDownstream: Float
  jitterUpstream: Float
  lostDownstream: Float
  lostDownstreamPcnt: Float
  lostUpstream: Float
  lostUpstreamPcnt: Float
  packetsDiscardedDownstream: Float
  packetsDiscardedUpstream: Float
  packetsDownstream: Float
  packetsUpstream: Float
  rtt: Int
}

""" The `MicrosoftActivity` object represents an activity within Microsoft services, containing fields such as action type, timestamps for the first and last activity, and identifiers for the activity and its associated resources. """
type MicrosoftActivity implements Activity {
  action: String
  firstActivityDateTime: DateTime
  id: ID!
  lastActivityDateTime: DateTime
  parentResourceId: ID!
  resourceId: ID!
}

""" The `MicrosoftDefenderEndpointAlert` object represents an alert generated by Microsoft Defender for Endpoint, containing details such as activities, classification, criticality, detection source, and recommended actions, among other attributes, to help in identifying and managing security threats. """
type MicrosoftDefenderEndpointAlert implements EndpointAlert {
  activities: [MicrosoftActivity!]!
  alertWebUrl: String
  category: String
  classification: AlertClassificationEnum
  comments: [String!]!
  createdDateTime: DateTime
  criticality: Int
  description: String
  destinationIp: String
  destinationUrl: String
  detectionSource: DetectionSourceEnum
  determination: AlertDeterminationEnum
  externalIp: String
  firstActivityDateTime: DateTime
  id: ID!
  lastActivityDateTime: DateTime
  lastUpdateDateTime: DateTime
  localIp: String
  mitreSubTechnique: [Mitre!]!
  mitreTechnique: [Mitre!]!
  ownerName: String
  providerAlertId: String
  recommendedActions: String
  resolvedDateTime: DateTime
  resources: [MicrosoftEndpointResource!]!
  status: MsAlertStatus
  threatFamilyName: String
  threatName: String
  threatType: String
  title: String
}

""" The `MicrosoftDeviceDetails` object represents detailed information about a Microsoft device, including its antivirus status, Azure AD device ID, device name, first seen date and time, health status, IP interfaces, logged-on users, onboarding status, operating system details, and RBAC group. """
type MicrosoftDeviceDetails implements DeviceDetails {
  avStatus: DeviceAvStatusEnum
  azureAdDeviceId: String
  deviceName: String
  externalIp: String
  firstSeenDateTime: DateTime
  healthStatus: DeviceHealthStatusEnum
  id: ID!
  ipInterfaces: [String!]!
  localIp: String
  loggedOnUsers: [EndpointUser!]!
  onboardingStatus: OnboardingStatusEnum
  osDetails: OsDetails
  rbacGroup: RbacGroup
}

""" The `MicrosoftEndpoint` object represents a comprehensive data structure used in GraphQL queries or mutations, containing fields related to security alerts, device details, threat predictions, and other metadata associated with Microsoft's security ecosystem. """
type MicrosoftEndpoint implements Endpoint & MergedIncident {
  alerts: [MicrosoftDefenderEndpointAlert!]!
  analystFeedback: AnalystFeedback
  connectionType: ConnectionTypeEnum
  criticality: Int
  description: String
  device: MicrosoftDeviceDetails
  engineType: StoryEngineTypeEnum
  firstSignal: DateTime!
  id: ID!
  indication: String!
  lastSignal: DateTime!
  predictedThreatType: String
  predictedVerdict: StoryVerdictEnum
  producer: StoryProducerEnum!
  producerName: String!
  queryName: String
  research: Boolean
  similarStoriesData: [SimilarStoryData!]!
  site: SiteRef
  siteName: String
  source: String
  sourceIp: String
  status: StoryStatusEnum
  storyDuration: Int
  ticket: String
  user: UserRef
  vendor: VendorEnum
}

""" The `MicrosoftEndpointUser` object represents a user associated with a Microsoft endpoint, containing fields such as account name, domain name, unique identifier, user name, principal name, and user security identifier. """
type MicrosoftEndpointUser implements EndpointUser {
  accountName: String
  domainName: String
  id: ID!
  name: String!
  principalName: String
  userSid: String
}

""" The `MicrosoftFileResource` object represents a file resource in a Microsoft system, containing fields such as creation date, detection and remediation status, file details, unique identifier, roles, tags, and a verdict on the file's status. """
type MicrosoftFileResource implements EndpointResource & FileResource & MicrosoftEndpointResource {
  createdDateTime: DateTime
  detectionStatus: DetectionStatusEnum
  fileDetails: FileDetails
  id: ID!
  remediationStatus: RemediationStatusEnum
  remediationStatusDetails: String
  roles: [ResourceRoleEnum!]!
  tags: [String!]!
  verdict: MsResourceVerdictEnum
}

""" The `MicrosoftNetworkResource` object represents a registry resource in a Microsoft environment, containing fields such as creation date, remediation status, roles, tags, and verdict, which are used to manage and assess the resource's status and attributes. """
type MicrosoftNetworkResource implements EndpointResource & MicrosoftEndpointResource & NetworkResource {
  action: String
  createdDateTime: DateTime
  destinationIp: String
  destinationPort: Int
  dnsRequest: String
  dnsResponse: String
  id: ID!
  method: String
  remediationStatus: RemediationStatusEnum
  remediationStatusDetails: String
  roles: [ResourceRoleEnum!]!
  sourcePort: Int
  tags: [String!]!
  url: String
  verdict: MsResourceVerdictEnum
}

""" The `MicrosoftProcessResource` object represents a process resource in a Microsoft environment, containing fields such as creation date, process ID, command line details, remediation status, roles, tags, user account information, and a verdict on the process's nature. """
type MicrosoftProcessResource implements EndpointResource & MicrosoftEndpointResource & ProcessResource {
  action: String
  createdDateTime: DateTime
  id: ID!
  imageFile: FileDetails
  processCommandLine: String
  processId: Int!
  remediationStatus: RemediationStatusEnum
  remediationStatusDetails: String
  roles: [ResourceRoleEnum!]!
  tags: [String!]!
  userAccount: EndpointUser
  verdict: MsResourceVerdictEnum
}

""" The `MicrosoftRegistryResource` object represents a registry resource in a Microsoft environment, containing fields such as creation date, hive, key, remediation status, roles, tags, and verdict, which are used to manage and assess the resource's status and attributes. """
type MicrosoftRegistryResource implements EndpointResource & MicrosoftEndpointResource & RegistryResource {
  createdDateTime: DateTime
  hive: String
  id: ID!
  key: String
  remediationStatus: RemediationStatusEnum
  remediationStatusDetails: String
  roles: [ResourceRoleEnum!]!
  tags: [String!]!
  value: String
  valueName: String
  valueType: String
  verdict: MsResourceVerdictEnum
}

type Mitre {
  id: String
  name: String
}

""" NOC as a Service (NOCaaS) service license details """
type NOCaaSLicense implements License {
  description: String
  expirationDate: DateTime!
  id: String
  lastUpdated: DateTime
  plan: LicensePlan!
  sku: LicenseSku!
  startDate: DateTime
  status: LicenseStatus!
}

""" A reference identifying the NetworkInterface object. ID: Unique NetworkInterface Identifier, Name: The NetworkInterface Name """
type NetworkInterfaceRef implements ObjectRef {
  id: ID!
  name: String!
}

type NetworkTimelineEvent {
  acknowledged: Boolean
  bgpConnection: BGPConnection
  created: DateTime!
  description: String
  deviceConfigHaRole: DeviceConfigHaRoleEnum
  deviceHaRoleState: DeviceHaRoleStateEnum
  eventIds: [String!]!
  eventType: NetworkXDREventTypeEnum
  hostIp: String
  incidentId: String
  isp: String
  linkConfigBandwidth: String
  linkConfigPrecedence: LinkConfigPrecedenceEnum
  linkId: String
  linkName: String
  linkQualityIssue: LinkQualityIssue
  linkStatus: LinkStatusEnum
  muted: Boolean
  networkEventSource: NetworkEventSourceEnum
  pop: String
  ruleName: String
  socketSerialId: String
  tunnelResetCount: Int
  validated: DateTime!
}

""" The `NetworkXDRIncident` object represents a detailed incident report within a network, containing various fields such as incident ID, description, criticality, timeline events, and associated metadata like connection type, site information, and predicted threat type, used for analyzing and managing network security incidents. """
type NetworkXDRIncident implements MergedIncident {
  acknowledged: Boolean
  analystFeedback: AnalystFeedback
  bgpConnection: BGPConnection
  connectionType: ConnectionTypeEnum
  criticality: Int
  description: String
  deviceConfigHaRole: DeviceConfigHaRoleEnum
  engineType: StoryEngineTypeEnum
  firstSignal: DateTime!
  hostIp: String
  id: ID!
  ilmmDetails: IlmmDetails
  indication: String!
  isp: String
  lastSignal: DateTime!
  licenseBandwidth: String
  licenseRegion: String
  linkConfigPrecedence: LinkConfigPrecedenceEnum
  linkId: String
  linkName: String
  muted: Boolean
  networkIncidentTimeline: [NetworkTimelineEvent!]!
  occurrences: Int
  pop: String
  predictedThreatType: String
  predictedVerdict: StoryVerdictEnum
  producer: StoryProducerEnum!
  producerName: String!
  queryName: String
  research: Boolean
  ruleName: String
  similarStoriesData: [SimilarStoryData!]!
  site: SiteRef
  siteConfigLocation: String
  siteConnectionType: String
  siteName: String!
  source: String
  sourceIp: String
  status: StoryStatusEnum
  storyDuration: Int
  storyType: String!
  ticket: String
  user: UserRef
  vendor: VendorEnum
}

""" NG Anti-Malware service license details (Legacy license, replaced by TP) """
type NextGenMalwareProtectionLicense implements License {
  description: String
  expirationDate: DateTime!
  id: String
  lastUpdated: DateTime
  plan: LicensePlan!
  sku: LicenseSku!
  startDate: DateTime
  status: LicenseStatus!
}

type OsDetails {
  osBuild: Int
  osType: String!
  osVersion: String
}

type PageInfo {
  total: Int!
}

type Paging {
  from: Int!
  limit: Int!
  total: Int!
}

type PartnerPooledBandwidthLicenseAccount {
  account: AccountRef!
  allocatedBandwidth: Int!
}

""" Represents available versions for a specific platform. """
type PlatformVersions {
  platform: String!
  versions: [String!]!
}

type PolicyAudit {
  publishedBy: String!
  publishedTime: DateTime!
}

""" Returns data for a custom recurring time range that a rule is active """
type PolicyCustomRecurring {
  days: [DayOfWeek!]!
  from: Time!
  to: Time!
}

""" Returns data for a custom one-time time range that a rule is active """
type PolicyCustomTimeframe {
  from: DateTime!
  to: DateTime!
}

type PolicyElementAudit {
  updatedBy: String!
  updatedTime: DateTime!
}

"""
The `PolicyMutationError` enum defines various error messages related to policy publishing in the policy platform service.

## Policy Errors

### `ConcurrentPolicyPublish`
- **Error Message:** "Another policy is currently publishing"

### `PolicyRevisionMismatch`
- **Error Message:** "Revision is not owned by the admin"

### `PolicyRevisionNotFound`
- **Error Message:** "Revision was not found"

### `PolicyInvalidEntity`
- **Error Message:** "Invalid entity"

### `DuplicateRuleName`
- **Error Message:** "Rule with the same name already exists"

### `DuplicateSectionName`
- **Error Message:** "Section with the same name already exists"

### `PolicyFailure`
- **Error Message:** "Cant publish policy due to an internal error. Please try again in a few minutes"


## Rule Errors

### `ruleIsLocked`
- **Error Message:** "Rule is locked by another revision"

### `ruleWasRemoved`
- **Error Message:** "Rule was already removed"

### `ruleNotExist`
- **Error Message:** "Rule does not exist"

### `ruleSectionNotExist`
- **Error Message:** "Section does not exist"

### `ruleSectionIsLocked`
- **Error Message:** "Section is locked by another revision"

### `rulePositionInvalid`
- **Error Message:** "Rule position is invalid"

### `ruleNameIsEmpty`
- **Error Message:** "Rule name can't be empty"

### `ruleNameAlreadyExists`
- **Error Message:** "Rule with the same name already exists"

### `ruleSystemModification`
- **Error Message:** "Can't modify a system rule"

### `ruleSystemMove`
- **Error Message:** "Can't add a rule above the system rules"

### `ruleHasInvalidEntity`
- **Error Message:** "Rule has an invalid entity"

### `failedValidatingRule`
- **Error Message:** "Something went wrong, couldn't validate rule"


## Section Errors

### `sectionIsLocked`
- **Error Message:** "Section is locked by another revision"

### `sectionSystemMove`
- **Error Message:** "Section with system rules cannot be moved or removed"

### `sectionNotExist`
- **Error Message:** "Section does not exist"

### `sectionPositionInvalid`
- **Error Message:** "Section position is invalid"
"""
type PolicyMutationError {
  errorCode: String
  errorMessage: String
}

type PolicyMutations {
  antiMalwareFileHash(input: AntiMalwareFileHashPolicyMutationInput): AntiMalwareFileHashPolicyMutations
  appTenantRestriction(input: AppTenantRestrictionPolicyMutationInput): AppTenantRestrictionPolicyMutations
  applicationControl(input: ApplicationControlPolicyMutationInput): ApplicationControlPolicyMutations
  dynamicIpAllocation(input: DynamicIpAllocationPolicyMutationInput): DynamicIpAllocationPolicyMutations
  internetFirewall(input: InternetFirewallPolicyMutationInput): InternetFirewallPolicyMutations
  privateAccess(input: PrivateAccessPolicyMutationInput): PrivateAccessPolicyMutations
  remotePortFwd(input: RemotePortFwdPolicyMutationInput): RemotePortFwdPolicyMutations
  socketLan(input: SocketLanPolicyMutationInput): SocketLanPolicyMutations
  terminalServer(input: TerminalServerPolicyMutationInput): TerminalServerPolicyMutations
  tlsInspect(input: TlsInspectPolicyMutationInput): TlsInspectPolicyMutations
  wanFirewall(input: WanFirewallPolicyMutationInput): WanFirewallPolicyMutations
  wanNetwork(input: WanNetworkPolicyMutationInput): WanNetworkPolicyMutations
}

""" policies which configuration can be read with query APIs. """
type PolicyQueries {
  antiMalwareFileHash: AntiMalwareFileHashPolicyQueries
  appTenantRestriction: AppTenantRestrictionPolicyQueries
  applicationControl: ApplicationControlPolicyQueries
  dynamicIpAllocation: DynamicIpAllocationPolicyQueries
  internetFirewall: InternetFirewallPolicyQueries
  privateAccess: PrivateAccessPolicyQueries
  remotePortFwd: RemotePortFwdPolicyQueries
  socketLan: SocketLanPolicyQueries
  terminalServer: TerminalServerPolicyQueries
  tlsInspect: TlsInspectPolicyQueries
  wanFirewall: WanFirewallPolicyQueries
  wanNetwork: WanNetworkPolicyQueries
}

""" Returns data about the policy revision, such as when the change was made, how many rules were changed, etc. """
type PolicyRevision {
  changes: Int!
  createdTime: DateTime!
  description: String!
  id: ID!
  name: String!
  updatedTime: DateTime!
}

""" Returns data for publishing the policy """
type PolicyRevisionsPayload {
  revision: [PolicyRevision!]!
}

""" Returns the time period during which the rule is active, outside this period, the rule is inactive """
type PolicyRuleActivePeriod {
  effectiveFrom: DateTime
  expiresAt: DateTime
  useEffectiveFrom: Boolean!
  useExpiresAt: Boolean!
}

""" Returns data for the alert settings for the rule """
type PolicyRuleTrackingAlert {
  enabled: Boolean!
  frequency: PolicyRuleTrackingFrequencyEnum!
  mailingList: [SubscriptionMailingListRef!]!
  subscriptionGroup: [SubscriptionGroupRef!]!
  webhook: [SubscriptionWebhookRef!]!
}

""" Returns data if an alert is sent for a rule """
type PolicyRuleTrackingEvent {
  enabled: Boolean!
}

type PolicySchedule {
  activeOn: PolicyActiveOnEnum!
  customRecurring: PolicyCustomRecurring
  customTimeframe: PolicyCustomTimeframe
}

""" Define settings for a policy section """
type PolicySectionInfo {
  id: ID!
  name: String!
  subPolicyId: ID
}

type PolicySectionMutationPayload {
  errors: [PolicyMutationError!]!
  section: PolicySectionPayload
  status: PolicyMutationStatus!
}

type PolicySectionPayload {
  access: EntityAccess
  audit: PolicyElementAudit!
  properties: [PolicyElementPropertiesEnum!]!
  section: PolicySectionInfo!
}

type PolicyTracking {
  alert: PolicyRuleTrackingAlert!
  event: PolicyRuleTrackingEvent!
}

type PooledBandwidthLicense implements License & QuantifiableLicense {
  accounts: [PartnerPooledBandwidthLicenseAccount!]!
  allocatedBandwidth: Int!
  description: String
  expirationDate: DateTime!
  id: String
  lastUpdated: DateTime
  plan: LicensePlan!
  siteLicenseGroup: SiteLicenseGroup!
  siteLicenseType: SiteLicenseType!
  sites: [PooledBandwidthLicenseSite!]!
  sku: LicenseSku!
  startDate: DateTime
  status: LicenseStatus!
  total: Int!
}

type PooledBandwidthLicenseSite {
  allocatedBandwidth: Int!
  site: SiteRef!
}

type PopLocation {
  cloudInterconnect: [PopLocationCloudInterconnect!]!
  country: CountryRef!
  displayName: String!
  id: ID!
  isPrivate: Boolean!
  name: String!
}

type PopLocationCloudInterconnect {
  providerName: String!
  taggingMethod: TaggingMethod!
}

type PopLocationPayload {
  items: [PopLocation!]!
}

type PopLocationQueries {
  popLocationList(input: PopLocationFilterInput): PopLocationPayload @beta
}

""" A reference identifying the PopLocation object. ID: Unique PopLocation Identifier, Name: The PopLocation Name """
type PopLocationRef implements ObjectRef {
  id: ID!
  name: String!
}

""" Inclusive network port range """
type PortRange {
  from: Port!
  to: Port!
}

type PostalAddress {
  addressValidated: AddressValidationStatus!
  cityName: String
  country: CountryRef!
  stateName: String
  street: String
  zipCode: String
}

type PrivateAccessPolicy implements IPolicy {
  audit: PolicyAudit
  enabled: Boolean!
  revision: PolicyRevision
  rules: [PrivateAccessRulePayload!]!
  sections: [PolicySectionPayload!]!
}

type PrivateAccessPolicyAction {
  action: PrivateAccessPolicyActionEnum!
}

type PrivateAccessPolicyApplication {
  application: [PrivateApplicationRef!]!
}

type PrivateAccessPolicyMutationPayload implements IPolicyMutationPayload {
  errors: [PolicyMutationError!]!
  policy: PrivateAccessPolicy
  status: PolicyMutationStatus!
}

type PrivateAccessPolicyMutations {
  addRule(input: PrivateAccessAddRuleInput!): PrivateAccessRuleMutationPayload!
  addSection(input: PolicyAddSectionInput!): PolicySectionMutationPayload!
  createPolicyRevision(input: PolicyCreateRevisionInput!): PrivateAccessPolicyMutationPayload!
  discardPolicyRevision(input: PolicyDiscardRevisionInput): PrivateAccessPolicyMutationPayload!
  moveRule(input: PolicyMoveRuleInput!): PrivateAccessRuleMutationPayload!
  moveSection(input: PolicyMoveSectionInput!): PolicySectionMutationPayload!
  publishPolicyRevision(input: PolicyPublishRevisionInput): PrivateAccessPolicyMutationPayload!
  removeRule(input: PrivateAccessRemoveRuleInput!): PrivateAccessRuleMutationPayload!
  removeSection(input: PolicyRemoveSectionInput!): PolicySectionMutationPayload!
  updatePolicy(input: PrivateAccessPolicyUpdateInput!): PrivateAccessPolicyMutationPayload!
  updateRule(input: PrivateAccessUpdateRuleInput!): PrivateAccessRuleMutationPayload!
  updateSection(input: PolicyUpdateSectionInput!): PolicySectionMutationPayload!
}

type PrivateAccessPolicyQueries {
  policy(input: PrivateAccessPolicyInput): PrivateAccessPolicy!
  revisions: PolicyRevisionsPayload
}

type PrivateAccessPolicySource {
  user: [UserRef!]!
  usersGroup: [UsersGroupRef!]!
}

type PrivateAccessRule implements IPolicyRule {
  action: PrivateAccessPolicyAction!
  activePeriod: PolicyRuleActivePeriod!
  applications: PrivateAccessPolicyApplication!
  connectionOrigin: [PrivateAccessPolicyOriginEnum!]!
  country: [CountryRef!]!
  description: String!
  device: [DeviceProfileRef!]!
  enabled: Boolean!
  id: ID!
  index: Int!
  name: String!
  platform: [OperatingSystem!]!
  schedule: PolicySchedule!
  section: PolicySectionInfo!
  source: PrivateAccessPolicySource!
  tracking: PolicyTracking!
  userAttributes: PrivateAccessUserAttributes!
}

type PrivateAccessRuleMutationPayload implements IPolicyRuleMutationPayload {
  errors: [PolicyMutationError!]!
  rule: PrivateAccessRulePayload
  status: PolicyMutationStatus!
}

type PrivateAccessRulePayload implements IPolicyRulePayload {
  audit: PolicyElementAudit!
  properties: [PolicyElementPropertiesEnum!]!
  rule: PrivateAccessRule!
}

type PrivateAccessUserAttributes implements UserAttributes {
  riskScore: RiskScoreCondition!
}

type PrivateAppProbing {
  faultThresholdDown: Int!
  id: ID!
  interval: Int!
  type: String!
}

type PrivateApplication {
  allowIcmpProtocol: Boolean!
  creationTime: DateTime!
  description: String
  id: ID!
  internalAppAddress: IPAddressOrFqdn!
  name: String!
  privateAppProbing: PrivateAppProbing
  probingEnabled: Boolean!
  protocolPorts: [CustomService!]!
  published: Boolean!
  publishedAppDomain: PublishedAppDomain
}

type PrivateApplicationListPayload {
  applications: [PrivateApplication!]!
}

"""
A reference identifying of the PrivateApplication object. ID: Unique PrivateApplication Identifier,
Name: The PrivateApplication Name
"""
type PrivateApplicationRef implements ObjectRef {
  id: ID!
  name: String!
}

""" Public IP address license """
type PublicIpsLicense implements License & QuantifiableLicense {
  description: String
  expirationDate: DateTime!
  id: String
  lastUpdated: DateTime
  plan: LicensePlan!
  sku: LicenseSku!
  startDate: DateTime
  status: LicenseStatus!
  total: Int!
}

""" IP addresses license usage and allocation across all accounts """
type PublicIpsLicenseAllocations {
  allocated: Int!
  available: Int!
  total: Int!
}

type PublishedAppDomain {
  catoIp: IPAddress
  connectorGroupName: String
  creationTime: DateTime!
  id: ID!
  publishedAppDomain: String!
}

type RBACRole {
  description: String
  id: ID!
  isPredefined: Boolean!
  name: String!
}

type RbacGroup {
  id: ID!
  name: String
}

""" Remote Browser Isolation (RBI) service license details """
type RbiLicense implements License {
  description: String
  expirationDate: DateTime!
  id: String
  lastUpdated: DateTime
  plan: LicensePlan!
  sku: LicenseSku!
  startDate: DateTime
  status: LicenseStatus!
}

type RecentConnection {
  deviceName: String
  duration: Int
  interfaceName: String
  lastConnected: DateTime
  popName: String
  remoteIP: String
  remoteIPInfo: IPInfo
}

type RemotePortFwdPolicy implements IPolicy {
  audit: PolicyAudit
  enabled: Boolean!
  revision: PolicyRevision
  rules: [RemotePortFwdRulePayload!]!
  sections: [PolicySectionPayload!]!
}

""" Remote port forwarding policy information provided in the API response """
type RemotePortFwdPolicyMutationPayload implements IPolicyMutationPayload {
  errors: [PolicyMutationError!]!
  policy: RemotePortFwdPolicy
  status: PolicyMutationStatus!
}

""" The Remote Port Forwarding Policy information returned to the caller in the API response. """
type RemotePortFwdPolicyMutations {
  addRule(input: RemotePortFwdAddRuleInput!): RemotePortFwdRuleMutationPayload! @beta
  addSection(input: PolicyAddSectionInput!): PolicySectionMutationPayload! @beta
  createPolicyRevision(input: PolicyCreateRevisionInput!): RemotePortFwdPolicyMutationPayload! @beta
  discardPolicyRevision(input: PolicyDiscardRevisionInput): RemotePortFwdPolicyMutationPayload! @beta
  moveRule(input: PolicyMoveRuleInput!): RemotePortFwdRuleMutationPayload! @beta
  moveSection(input: PolicyMoveSectionInput!): PolicySectionMutationPayload! @beta
  publishPolicyRevision(input: PolicyPublishRevisionInput): RemotePortFwdPolicyMutationPayload! @beta
  removeRule(input: RemotePortFwdRemoveRuleInput!): RemotePortFwdRuleMutationPayload! @beta
  removeSection(input: PolicyRemoveSectionInput!): PolicySectionMutationPayload! @beta
  updatePolicy(input: RemotePortFwdPolicyUpdateInput!): RemotePortFwdPolicyMutationPayload! @beta
  updateRule(input: RemotePortFwdUpdateRuleInput!): RemotePortFwdRuleMutationPayload! @beta
  updateSection(input: PolicyUpdateSectionInput!): PolicySectionMutationPayload! @beta
}

type RemotePortFwdPolicyQueries {
  policy(input: RemotePortFwdPolicyInput): RemotePortFwdPolicy! @beta
  revisions: PolicyRevisionsPayload @beta
}

type RemotePortFwdRemoteIps {
  globalIpRange: [GlobalIpRangeRef!]!
  ip: [IPAddress!]!
  ipRange: [IpAddressRange!]!
  subnet: [NetworkSubnet!]!
}

type RemotePortFwdRule implements IPolicyRule {
  description: String!
  enabled: Boolean!
  externalIp: AllocatedIpRef!
  externalPortRange: PortRange!
  forwardIcmp: Boolean!
  id: ID!
  index: Int!
  internalIp: IPAddress!
  internalPortRange: PortRange!
  name: String!
  remoteIPs: RemotePortFwdRemoteIps!
  restrictionType: RemotePortFwdRestrictionType!
  section: PolicySectionInfo!
  tracking: PolicyRuleTrackingAlert!
}

type RemotePortFwdRuleMutationPayload implements IPolicyRuleMutationPayload {
  errors: [PolicyMutationError!]!
  rule: RemotePortFwdRulePayload
  status: PolicyMutationStatus!
}

type RemotePortFwdRulePayload implements IPolicyRulePayload {
  audit: PolicyElementAudit!
  properties: [PolicyElementPropertiesEnum!]!
  rule: RemotePortFwdRule!
}

type RemoveAccountPayload {
  accountInfo: AccountInfo!
}

type RemoveAdminPayload {
  adminID: ID!
}

type RemoveBgpPeerPayload {
  bgpPeer: BgpPeer!
}

""" Payload for removing a physical connection from a cloud interconnect site. """
type RemoveCloudInterconnectPhysicalConnectionPayload {
  id: ID!
}

type RemoveIpsecIkeV2SiteMultiTunnelPayload {
  fqdn: Fqdn
  tunnels: [RemoveIpsecIkeV2SiteTunnelPayload!]!
}

type RemoveIpsecIkeV2SiteTunnelPayload {
  localId: String
  tunnelId: IPSecV2InterfaceId
}

type RemoveIpsecIkeV2SiteTunnelsPayload {
  primary: RemoveIpsecIkeV2SiteMultiTunnelPayload
  secondary: RemoveIpsecIkeV2SiteMultiTunnelPayload
  siteId: ID!
}

type RemoveNetworkRangePayload {
  networkRangeId: ID!
}

type RemoveSecondaryAwsVSocketPayload {
  secondaryAwsVSocket: SecondaryAwsVSocket!
}

type RemoveSecondaryAzureVSocketPayload {
  secondaryAzureVSocket: SecondaryAzureVSocket!
}

type RemoveServicePrincipalAdminPayload {
  adminID: ID!
}

type RemoveSiteBwLicensePayload {
  license: License!
}

type RemoveSitePayload {
  siteId: ID!
}

type RemoveSocketAddOnCardPayload {
  addOns: [SocketAddOnCard!]!
}

type RemoveStaticHostPayload {
  hostId: ID!
}

type RemoveZtnaAppConnectorPayload {
  ztnaAppConnector: ZtnaAppConnector!
}

""" Payload returned after removing ZTNA App Connectors configuration. """
type RemoveZtnaAppConnectorsConfigurationPayload {
  ztnaAppConnectorsConfiguration: ZtnaAppConnectorsConfiguration!
}

type ReplaceSiteBwLicensePayload {
  license: License!
}

type RiskScoreCondition {
  category: RiskScoreCategory!
  operator: RiskScoreOperator!
}

""" SaaS Security API service license details """
type SaasSecurityApiLicense implements License & QuantifiableLicense {
  description: String
  expirationDate: DateTime!
  id: String
  lastUpdated: DateTime
  plan: LicensePlan!
  sku: LicenseSku!
  startDate: DateTime
  status: LicenseStatus!
  total: Int!
}

""" A reference identifying the SanctionedAppsCategory object. ID: Unique SanctionedAppsCategory Identifier, Name: The SanctionedAppsCategory Name """
type SanctionedAppsCategoryRef implements ObjectRef {
  id: ID!
  name: String!
}

type SandboxMutations {
  deleteReport(input: DeleteReportInput!): DeleteReportPayload! @beta
  uploadFile(input: UploadFileInput!): UploadFilePayload! @beta
}

type SandboxQueries {
  reports(input: SandboxReportsInput!): SandboxReportsPayload! @beta
}

""" Sandbox report meta-data """
type SandboxReport {
  creationDate: DateTime!
  downloadUrl: Url
  expirationDate: DateTime
  failureReason: SandboxFailureReason
  fileHash: String!
  fileName: String
  status: SandboxStatus!
  verdict: SandboxVerdict
}

""" Output of sandbox reports query """
type SandboxReportsPayload {
  pageInfo: PageInfo!
  report: [SandboxReport!]!
}

type SecondaryAwsVSocket {
  id: ID!
  ipAddress: IPAddress!
  routeTableId: String!
  site: SiteRef!
  subnet: NetworkSubnet!
}

type SecondaryAzureVSocket {
  floatingIp: IPAddress!
  id: ID!
  interfaceIp: IPAddress!
  site: SiteRef!
}

""" A reference identifying the Service object. ID: Unique Service Identifier, Name: The Service Name """
type ServiceRef implements ObjectRef {
  id: ID!
  name: String!
}

type ShippingDetails {
  cityName: String
  comment: String
  companyName: String
  contact: ContactDetails
  countryName: String
  incoterms: String
  instruction: String
  powerCable: String
  stateName: String
  street: String
  vatId: String
  zipCode: String
}

type ShippingTracking {
  carrier: String
  shippingDate: Date
  shippingStatus: ShippingStatus
  trackingNumber: String
  trackingUrl: String
}

type SimilarStoryData {
  indication: String
  similarityPercentage: Float
  storyId: String
  threatClassification: String
  threatTypeName: String
  verdict: String
}

type SimpleService {
  name: SimpleServiceType!
}

type SiteBgpStatus {
  rawStatus: [String!]!
  status: [BgpDetailedStatus!]!
}

type SiteGeneralDetailsPayload {
  description: String
  preferredPopLocation: SitePreferredPopLocation
  site: SiteRef!
  siteLocation: SiteLocation!
  siteType: SiteType!
}

""" Basic Site configuration information """
type SiteInfo {
  address: String
  cityName: String
  connType: ProtoType
  countryCode: String
  countryName: String
  countryStateName: String
  creationTime: DateTime
  description: String
  interfaces: [InterfaceInfo!]
  ipsec: [IPSecInfo!]
  isHA: Boolean
  name: String
  region: String
  sockets: [SocketInfo!]
  type: SiteType
}

""" Site bandwidth license """
type SiteLicense implements License & QuantifiableLicense {
  description: String
  expirationDate: DateTime!
  id: String
  lastUpdated: DateTime
  plan: LicensePlan!
  regionality: Regionality
  site: SiteRef
  siteLicenseGroup: SiteLicenseGroup!
  siteLicenseType: SiteLicenseType!
  sku: LicenseSku!
  startDate: DateTime
  status: LicenseStatus!
  total: Int!
}

type SiteLocation {
  address: String
  cityName: String
  countryCode: String!
  stateCode: String
  timezone: String!
}

type SiteMetrics {
  flowCount: Timeseries
  hostCount: Timeseries
  hostLimit: Timeseries
  id: ID
  info: SiteInfo
  interfaces: [InterfaceMetrics!]
  metrics(toRate: Boolean = false): Metrics
  name: String
  samples: Int @deprecated(reason: "internal use")
}

type SiteMutations {
  addBgpPeer(input: AddBgpPeerInput!): AddBgpPeerPayload @beta
  addCloudInterconnectPhysicalConnection(input: AddCloudInterconnectPhysicalConnectionInput!): AddCloudInterconnectPhysicalConnectionPayload @beta
  addCloudInterconnectSite(input: AddCloudInterconnectSiteInput!): AddCloudInterconnectSitePayload @beta
  addIpsecIkeV2Site(input: AddIpsecIkeV2SiteInput!): AddIpsecIkeV2SitePayload @beta
  addIpsecIkeV2SiteTunnels(siteId: ID!, input: AddIpsecIkeV2SiteTunnelsInput!): AddIpsecIkeV2SiteTunnelsPayload @beta
  addNetworkRange(lanSocketInterfaceId: ID!, input: AddNetworkRangeInput!): AddNetworkRangePayload @ga
  addSecondaryAwsVSocket(input: AddSecondaryAwsVSocketInput!): AddSecondaryAwsVSocketPayload @beta
  addSecondaryAzureVSocket(input: AddSecondaryAzureVSocketInput!): AddSecondaryAzureVSocketPayload @beta
  addSocketAddOnCard(input: AddSocketAddOnCardInput!): AddSocketAddOnCardPayload @rollout @beta
  addSocketSite(input: AddSocketSiteInput!): AddSocketSitePayload @ga
  addStaticHost(siteId: ID!, input: AddStaticHostInput!): AddStaticHostPayload @ga
  assignSiteBwLicense(input: AssignSiteBwLicenseInput!): AssignSiteBwLicensePayload @beta
  removeBgpPeer(input: RemoveBgpPeerInput!): RemoveBgpPeerPayload @beta
  removeCloudInterconnectPhysicalConnection(input: RemoveCloudInterconnectPhysicalConnectionInput!): RemoveCloudInterconnectPhysicalConnectionPayload @beta
  removeIpsecIkeV2SiteTunnels(siteId: ID!, input: RemoveIpsecIkeV2SiteTunnelsInput!): RemoveIpsecIkeV2SiteTunnelsPayload @beta
  removeNetworkRange(networkRangeId: ID!): RemoveNetworkRangePayload @ga
  removeSecondaryAwsVSocket(socketId: ID!): RemoveSecondaryAwsVSocketPayload @beta
  removeSecondaryAzureVSocket(socketId: ID!): RemoveSecondaryAzureVSocketPayload @beta
  removeSite(siteId: ID!): RemoveSitePayload @ga
  removeSiteBwLicense(input: RemoveSiteBwLicenseInput!): RemoveSiteBwLicensePayload @beta
  removeSocketAddOnCard(input: RemoveSocketAddOnCardInput!): RemoveSocketAddOnCardPayload @beta
  removeStaticHost(hostId: ID!): RemoveStaticHostPayload @ga
  replaceSiteBwLicense(input: ReplaceSiteBwLicenseInput!): ReplaceSiteBwLicensePayload @beta
  startSiteUpgrade(input: StartSiteUpgradeInput!): StartSiteUpgradePayload @rollout @beta
  updateBgpPeer(input: UpdateBgpPeerInput!): UpdateBgpPeerPayload @beta
  updateCloudInterconnectPhysicalConnection(input: UpdateCloudInterconnectPhysicalConnectionInput!): UpdateCloudInterconnectPhysicalConnectionPayload @beta
  updateHa(siteId: ID!, input: UpdateHaInput!): UpdateHaPayload @ga
  updateIpsecIkeV2SiteGeneralDetails(siteId: ID!, input: UpdateIpsecIkeV2SiteGeneralDetailsInput!): UpdateIpsecIkeV2SiteGeneralDetailsPayload @beta
  updateIpsecIkeV2SiteTunnels(siteId: ID!, input: UpdateIpsecIkeV2SiteTunnelsInput!): UpdateIpsecIkeV2SiteTunnelsPayload @beta
  updateNetworkRange(networkRangeId: ID!, input: UpdateNetworkRangeInput!): UpdateNetworkRangePayload @ga
  updateSecondaryAwsVSocket(input: UpdateSecondaryAwsVSocketInput!): UpdateSecondaryAwsVSocketPayload @beta
  updateSecondaryAzureVSocket(input: UpdateSecondaryAzureVSocketInput!): UpdateSecondaryAzureVSocketPayload @beta
  updateSiteBwLicense(input: UpdateSiteBwLicenseInput!): UpdateSiteBwLicensePayload @beta
  updateSiteGeneralDetails(siteId: ID!, input: UpdateSiteGeneralDetailsInput!): UpdateSiteGeneralDetailsPayload @ga
  updateSocketInterface(siteId: ID!, socketInterfaceId: SocketInterfaceIDEnum!, input: UpdateSocketInterfaceInput!): UpdateSocketInterfacePayload @ga
  updateStaticHost(hostId: ID!, input: UpdateStaticHostInput!): UpdateStaticHostPayload @ga
}

""" A reference identifying the SiteNetworkSubnet object. ID: Unique SiteNetworkSubnet Identifier, Name: The SiteNetworkSubnet Name """
type SiteNetworkSubnetRef implements ObjectRef {
  id: ID!
  name: String!
}

type SitePreferredPopLocation {
  preferredOnly: Boolean!
  primary: PopLocationRef
  secondary: PopLocationRef
}

type SiteQueries {
  availableVersionList(input: AvailableVersionListInput!): AvailableVersionListPayload @rollout @beta
  bgpPeer(input: BgpPeerRefInput!): BgpPeer @beta
  bgpPeerList(input: BgpPeerListInput!): BgpPeerListPayload @beta
  cloudInterconnectConnectionConnectivity(input: CloudInterconnectConnectionConnectivityInput!): CloudInterconnectConnectionConnectivity @beta
  cloudInterconnectPhysicalConnection(input: CloudInterconnectPhysicalConnectionInput!): CloudInterconnectPhysicalConnection @beta
  cloudInterconnectPhysicalConnectionId(input: CloudInterconnectPhysicalConnectionIdInput!): CloudInterconnectPhysicalConnectionId @beta
  secondaryAwsVSocket(socketId: ID!): SecondaryAwsVSocket @beta
  secondaryAzureVSocket(socketId: ID!): SecondaryAzureVSocket @beta
  siteBgpStatus(input: SiteBgpStatusInput!): SiteBgpStatus @beta
  siteGeneralDetails(site: SiteRefInput!): SiteGeneralDetailsPayload @beta
}

""" A reference identifying the Site object. ID: Unique Site Identifier, Name: The Site Name """
type SiteRef implements ObjectRef {
  id: ID!
  name: String!
}

type SiteSnapshot {
  altWanStatus: String
  connectedSince: DateTime
  connectivityStatus: ConnectivityStatus
  degradedStatus: DegradedStatus
  devices: [DeviceSnapshot!]
  haStatus: HaStatus
  hostCount: Int
  id: ID
  info: SiteInfo
  lastConnected: DateTime
  operationalStatus: OperationalStatus
  popName: String
  protoId: Int
}

""" Information about a site upgrade. """
type SiteUpgradeInfo {
  scheduledAt: String!
  site: SiteRef!
  targetVersion: String!
}

""" Represents the result of an upgrade request. """
type SiteUpgradeResult {
  site: BulkUpgradeSiteInfo!
  targetVersion: String!
}

type SocketAddOnCard {
  expansionSlotNumber: SocketAddOnExpansionSlotNumber!
  type: SocketAddOnType!
}

""" Basic information about socket """
type SocketInfo {
  id: String
  isPrimary: Boolean
  platform: SocketPlatform
  serial: String
  version: String
  versionUpdateTime: DateTime
}

type SocketInventoryItem {
  account: AccountRef!
  availableUpgradeVersions: [String!]!
  deliverySiteName: String
  description: String
  hardwareVersion: String
  id: ID!
  isPrimary: Boolean!
  registrationStatus: SocketRegistrationStatus
  serialNumber: String
  shippingCompany: String
  shippingDate: DateTime
  site: SiteRef
  socketMac: MacAddress
  socketType: SocketPlatform
  socketVersion: String
  status: SocketInventoryItemStatus
  trackingNumber: String
  trackingUrl: Url
  upgradeStatus: SocketUpgradeStatus
  upgradesPaused: Boolean!
}

type SocketInventoryPayload {
  items: [SocketInventoryItem!]!
  pageInfo: PageInfo!
}

""" Returns the settings for Destination of a Wan Firewall rule. """
type SocketLanDestination {
  floatingSubnet: [FloatingSubnetRef!]!
  globalIpRange: [GlobalIpRangeRef!]!
  group: [GroupRef!]!
  host: [HostRef!]!
  ip: [IPAddress!]!
  ipRange: [IpAddressRange!]!
  networkInterface: [NetworkInterfaceRef!]!
  siteNetworkSubnet: [SiteNetworkSubnetRef!]!
  subnet: [NetworkSubnet!]!
  systemGroup: [SystemGroupRef!]!
  vlan: [Vlan!]!
}

""" Defines applications for the socket LAN firewall. """
type SocketLanFirewallApplication {
  application: [ApplicationRef!]!
  customApp: [CustomApplicationRef!]!
  domain: [Domain!]!
  fqdn: [Fqdn!]!
  globalIpRange: [GlobalIpRangeRef!]!
  ip: [IPAddress!]!
  ipRange: [IpAddressRange!]!
  subnet: [NetworkSubnet!]!
}

""" Defines destinations for the socket LAN firewall. """
type SocketLanFirewallDestination {
  floatingSubnet: [FloatingSubnetRef!]!
  globalIpRange: [GlobalIpRangeRef!]!
  group: [GroupRef!]!
  host: [HostRef!]!
  ip: [IPAddress!]!
  ipRange: [IpAddressRange!]!
  networkInterface: [NetworkInterfaceRef!]!
  site: [SiteRef!]!
  siteNetworkSubnet: [SiteNetworkSubnetRef!]!
  subnet: [NetworkSubnet!]!
  systemGroup: [SystemGroupRef!]!
  vlan: [Vlan!]!
}

type SocketLanFirewallPolicyMutations {
  addRule(input: SocketLanFirewallAddRuleInput!): SocketLanFirewallRuleMutationPayload! @beta
  moveRule(input: PolicyMoveSubRuleInput!): SocketLanFirewallRuleMutationPayload! @beta
  removeRule(input: SocketLanFirewallRemoveRuleInput!): SocketLanFirewallRuleMutationPayload! @beta
  updateRule(input: SocketLanFirewallUpdateRuleInput!): SocketLanFirewallRuleMutationPayload! @beta
}

type SocketLanFirewallRule implements IPolicyRule {
  action: SocketLanFirewallAction!
  application: SocketLanFirewallApplication!
  description: String!
  destination: SocketLanFirewallDestination!
  direction: SocketLanFirewallDirection!
  enabled: Boolean!
  id: ID!
  index: Int!
  name: String!
  section: PolicySectionInfo!
  service: SocketLanFirewallServiceType!
  source: SocketLanFirewallSource!
  tracking: PolicyTracking!
}

type SocketLanFirewallRuleMutationPayload implements IPolicyRuleMutationPayload {
  errors: [PolicyMutationError!]!
  rule: SocketLanFirewallRulePayload
  status: PolicyMutationStatus!
}

type SocketLanFirewallRulePayload implements IPolicyRulePayload {
  audit: PolicyElementAudit!
  properties: [PolicyElementPropertiesEnum!]!
  rule: SocketLanFirewallRule!
}

""" Defines services used in the socket LAN firewall. """
type SocketLanFirewallServiceType {
  custom: [CustomService!]!
  simple: [SimpleService!]!
  standard: [ServiceRef!]!
}

""" Defines sources for the socket LAN firewall. """
type SocketLanFirewallSource {
  floatingSubnet: [FloatingSubnetRef!]!
  globalIpRange: [GlobalIpRangeRef!]!
  group: [GroupRef!]!
  host: [HostRef!]!
  ip: [IPAddress!]!
  ipRange: [IpAddressRange!]!
  mac: [MacAddress!]!
  networkInterface: [NetworkInterfaceRef!]!
  site: [SiteRef!]!
  siteNetworkSubnet: [SiteNetworkSubnetRef!]!
  subnet: [NetworkSubnet!]!
  systemGroup: [SystemGroupRef!]!
  vlan: [Vlan!]!
}

""" Defines NAT settings for the socket LAN policy. """
type SocketLanNatSettings {
  enabled: Boolean!
  natType: SocketLanNatType!
}

type SocketLanPolicy implements IPolicy {
  audit: PolicyAudit
  enabled: Boolean!
  revision: PolicyRevision
  rules: [SocketLanRulePayload!]!
  sections: [PolicySectionPayload!]!
}

type SocketLanPolicyMutationPayload implements IPolicyMutationPayload {
  errors: [PolicyMutationError!]!
  policy: SocketLanPolicy
  status: PolicyMutationStatus!
}

type SocketLanPolicyMutations {
  addRule(input: SocketLanAddRuleInput!): SocketLanRuleMutationPayload! @beta
  addSection(input: PolicyAddSectionInput!): PolicySectionMutationPayload! @beta
  createPolicyRevision(input: PolicyCreateRevisionInput!): SocketLanPolicyMutationPayload! @beta
  discardPolicyRevision(input: PolicyDiscardRevisionInput): SocketLanPolicyMutationPayload! @beta
  firewall: SocketLanFirewallPolicyMutations!
  moveRule(input: PolicyMoveRuleInput!): SocketLanRuleMutationPayload! @beta
  moveSection(input: PolicyMoveSectionInput!): PolicySectionMutationPayload! @beta
  publishPolicyRevision(input: PolicyPublishRevisionInput): SocketLanPolicyMutationPayload! @beta
  removeRule(input: SocketLanRemoveRuleInput!): SocketLanRuleMutationPayload! @beta
  removeSection(input: PolicyRemoveSectionInput!): PolicySectionMutationPayload! @beta
  updatePolicy(input: SocketLanPolicyUpdateInput!): SocketLanPolicyMutationPayload! @beta
  updateRule(input: SocketLanUpdateRuleInput!): SocketLanRuleMutationPayload! @beta
  updateSection(input: PolicyUpdateSectionInput!): PolicySectionMutationPayload! @beta
}

type SocketLanPolicyQueries {
  policy(input: SocketLanPolicyInput): SocketLanPolicy! @beta
  revisions: PolicyRevisionsPayload @beta
}

type SocketLanRule implements IPolicyRule {
  description: String!
  destination: SocketLanDestination!
  direction: SocketLanDirection!
  enabled: Boolean!
  firewall: [SocketLanFirewallRulePayload!]!
  id: ID!
  index: Int!
  name: String!
  nat: SocketLanNatSettings!
  section: PolicySectionInfo!
  service: SocketLanService!
  site: SocketLanSite!
  source: SocketLanSource!
  transport: SocketLanTransportType!
}

type SocketLanRuleMutationPayload implements IPolicyRuleMutationPayload {
  errors: [PolicyMutationError!]!
  rule: SocketLanRulePayload
  status: PolicyMutationStatus!
}

type SocketLanRulePayload implements IPolicyRulePayload {
  audit: PolicyElementAudit!
  properties: [PolicyElementPropertiesEnum!]!
  rule: SocketLanRule!
}

""" Defines services used in the socket LAN policy. """
type SocketLanService {
  custom: [CustomService!]!
  simple: [SimpleService!]!
}

""" Represents the site configurations in the socket LAN policy. """
type SocketLanSite {
  group: [GroupRef!]!
  site: [SiteRef!]!
}

""" Defines sources for the socket LAN policy. """
type SocketLanSource {
  floatingSubnet: [FloatingSubnetRef!]!
  globalIpRange: [GlobalIpRangeRef!]!
  group: [GroupRef!]!
  host: [HostRef!]!
  ip: [IPAddress!]!
  ipRange: [IpAddressRange!]!
  networkInterface: [NetworkInterfaceRef!]!
  siteNetworkSubnet: [SiteNetworkSubnetRef!]!
  subnet: [NetworkSubnet!]!
  systemGroup: [SystemGroupRef!]!
  vlan: [Vlan!]!
}

type SocketPortMetrics {
  from: DateTime
  id: ID
  records(limit: Int, from: Int): [SocketPortMetricsRecord!]
  to: DateTime
  total: Int
  totals: Map
}

type SocketPortMetricsField {
  name: SocketPortMetricsFieldName!
  value: Value!
}

type SocketPortMetricsRecord {
  fields: [SocketPortMetricsField!]
  fieldsMap: Map
  fieldsUnitTypes: [UnitType!]
  prevTimeFrame: Map
  trends: Map
}

type SocketPortMetricsTimeSeries {
  from: DateTime
  granularity: Int
  id: ID
  timeseries(buckets: Int!): [Timeseries!]
  to: DateTime
}

""" Wrapper for site upgrade response. """
type StartSiteUpgradePayload {
  results: [SiteUpgradeInfo!]!
}

type StoriesData {
  items: [Story!]!
  paging: Paging!
}

type Story {
  accountId: Int!
  accountName: String
  analystEmail: String
  analystName: String
  createdAt: DateTime!
  id: ID!
  incident: MergedIncident!
  playbook: String
  summary: String
  timeline: [TimelineItem!]!
  updatedAt: DateTime!
}

type StoryComment {
  actor: ActorRef!
  createdAt: Time!
  id: ID!
  text: String!
}

type StoryDrillDownFilter {
  name: String!
  value: String! @deprecated(reason: "No longer supported")
  values: [String!]!
}

type StringValue {
  string: String
}

type StringValueSetRef implements ObjectRef {
  id: ID!
  name: String!
}

type SubDomain {
  accountId: ID!
  accountName: String!
  accountType: String!
  subDomain: String!
}

""" A reference identifying the SubscriptionGroup object. ID: Unique SubscriptionGroup Identifier, Name: The SubscriptionGroup Name """
type SubscriptionGroupRef implements ObjectRef {
  id: ID!
  name: String!
}

""" A reference identifying the SubscriptionMailingList object. ID: Unique SubscriptionMailingList Identifier, Name: The SubscriptionMailingList Name """
type SubscriptionMailingListRef implements ObjectRef {
  id: ID!
  name: String!
}

""" A reference identifying the SubscriptionWebhook object. ID: Unique SubscriptionWebhook Identifier, Name: The SubscriptionWebhook Name """
type SubscriptionWebhookRef implements ObjectRef {
  id: ID!
  name: String!
}

""" A reference identifying the SystemGroup object. ID: Unique SystemGroup Identifier, Name: The SystemGroup Name """
type SystemGroupRef implements ObjectRef {
  id: ID!
  name: String!
}

type TerminalServerPolicy implements IPolicy {
  audit: PolicyAudit
  enabled: Boolean!
  revision: PolicyRevision
  rules: [TerminalServerRulePayload!]!
  sections: [PolicySectionPayload!]!
}

type TerminalServerPolicyMutationPayload implements IPolicyMutationPayload {
  errors: [PolicyMutationError!]!
  policy: TerminalServerPolicy
  status: PolicyMutationStatus!
}

type TerminalServerPolicyMutations {
  addRule(input: TerminalServerAddRuleInput!): TerminalServerRuleMutationPayload! @beta
  addSection(input: PolicyAddSectionInput!): PolicySectionMutationPayload! @beta
  createPolicyRevision(input: PolicyCreateRevisionInput!): TerminalServerPolicyMutationPayload! @beta
  discardPolicyRevision(input: PolicyDiscardRevisionInput): TerminalServerPolicyMutationPayload! @beta
  moveRule(input: PolicyMoveRuleInput!): TerminalServerRuleMutationPayload! @beta
  moveSection(input: PolicyMoveSectionInput!): PolicySectionMutationPayload! @beta
  publishPolicyRevision(input: PolicyPublishRevisionInput): TerminalServerPolicyMutationPayload! @beta
  removeRule(input: TerminalServerRemoveRuleInput!): TerminalServerRuleMutationPayload! @beta
  removeSection(input: PolicyRemoveSectionInput!): PolicySectionMutationPayload! @beta
  updatePolicy(input: TerminalServerPolicyUpdateInput!): TerminalServerPolicyMutationPayload! @beta
  updateRule(input: TerminalServerUpdateRuleInput!): TerminalServerRuleMutationPayload! @beta
  updateSection(input: PolicyUpdateSectionInput!): PolicySectionMutationPayload! @beta
}

type TerminalServerPolicyQueries {
  policy(input: TerminalServerPolicyInput): TerminalServerPolicy! @beta
  revisions: PolicyRevisionsPayload @beta
}

type TerminalServerRule implements IPolicyRule {
  allowedHostIP: GlobalIpRangeRef!
  description: String!
  enabled: Boolean!
  excludeTraffic: [GlobalIpRangeRef!]!
  id: ID!
  index: Int!
  name: String!
  section: PolicySectionInfo!
}

type TerminalServerRuleMutationPayload implements IPolicyRuleMutationPayload {
  errors: [PolicyMutationError!]!
  rule: TerminalServerRulePayload
  status: PolicyMutationStatus!
}

type TerminalServerRulePayload implements IPolicyRulePayload {
  audit: PolicyElementAudit!
  properties: [PolicyElementPropertiesEnum!]!
  rule: TerminalServerRule!
}

""" The "Threat" object represents a comprehensive data structure used in GraphQL queries or mutations to encapsulate various attributes and metadata related to a threat incident, including details about the threat's origin, nature, risk assessment, and associated network traffic flows. """
type Threat implements MergedIncident {
  analystFeedback: AnalystFeedback
  clientClass: [String!]!
  connectionType: ConnectionTypeEnum
  criticality: Int
  description: String
  deviceName: String
  direction: String
  engineType: StoryEngineTypeEnum
  events: [Event!]
  firstSignal: DateTime!
  flows: [IncidentFlow!]
  flowsCardinality: Int
  id: ID!
  indication: String!
  lastSignal: DateTime!
  logonName: String
  macAddress: String
  mitres: [Mitre!]
  os: String
  predictedThreatType: String
  predictedVerdict: StoryVerdictEnum
  producer: StoryProducerEnum!
  producerName: String!
  queryName: String
  research: Boolean
  riskLevel: RiskLevelEnum
  similarStoriesData: [SimilarStoryData!]!
  site: SiteRef
  siteName: String @deprecated(reason: "'siteName' is deprecated, use 'site.name' instead")
  source: String
  sourceIp: String
  srcSiteId: String
  status: StoryStatusEnum
  storyDuration: Int
  targets: [IncidentTargetRep!]!
  ticket: String
  timeSeries: [IncidentTimeseries!]
  user: UserRef
  vendor: VendorEnum
}

""" The `ThreatPrevention` object is a GraphQL type that represents the details of a threat prevention incident, including fields such as analyst feedback, client class, connection type, criticality, description, device name, and various other attributes related to the incident's signals, events, and status. """
type ThreatPrevention implements MergedIncident {
  analystFeedback: AnalystFeedback
  clientClass: [String!]!
  connectionType: ConnectionTypeEnum
  criticality: Int
  description: String
  deviceName: String
  direction: String
  engineType: StoryEngineTypeEnum
  events: [Event!]
  firstSignal: DateTime!
  flowsCardinality: Int
  id: ID!
  indication: String!
  lastSignal: DateTime!
  logonName: String
  macAddress: String
  mitres: [Mitre!]
  os: String
  predictedThreatType: String
  predictedVerdict: StoryVerdictEnum
  producer: StoryProducerEnum!
  producerName: String!
  queryName: String
  research: Boolean
  riskLevel: RiskLevelEnum
  similarStoriesData: [SimilarStoryData!]!
  site: SiteRef
  siteName: String @deprecated(reason: "'siteName' is deprecated, use 'site.name' instead")
  source: String
  sourceIp: String
  srcSiteId: String
  status: StoryStatusEnum
  storyDuration: Int
  targets: [IncidentTargetRep!]!
  threatPreventionsEvents: [ThreatPreventionEvents!]
  ticket: String
  timeSeries: [IncidentTimeseries!]
  user: UserRef
  vendor: VendorEnum
}

type ThreatPreventionEvents {
  appName: String
  clientClass: String
  createdAt: DateTime
  destinationCountry: String
  destinationGeolocation: String
  destinationIp: String
  destinationPort: Int
  direction: String
  dnsResponseIP: String
  domain: String
  fileHash: String
  httpResponseCode: Int
  ja3: String
  method: String
  referrer: String
  smbFileName: String
  sourceGeolocation: String
  sourceIp: String
  sourcePort: Int
  target: String
  tunnelGeolocation: String
  url: String
  user: String
  userAgent: String
}

""" Threat Prevention (TP) license details """
type ThreatPreventionLicense implements License {
  description: String
  expirationDate: DateTime!
  id: String
  lastUpdated: DateTime
  plan: LicensePlan!
  sku: LicenseSku!
  startDate: DateTime
  status: LicenseStatus!
}

""" An object for marking specific events in time. """
type TimeAnnotation {
  label: String!
  shortLabel: String!
  time: Float!
  type: AnnotationType!
}

""" An object for marking durations! """
type TimePeriod {
  duration: [Float!]!
  title: String!
  type: PeriodType!
}

type TimeSeriesEvents {
  accountID: String!
  buckets: Int!
  dimensions: [GraphEventsDimension!]!
  filters: [GraphEventsFilter!]!
  measures: [GraphEventsMeasure!]!
  timeFrame: TimeFrame!
}

""" For XDR stories, items that happened during the lifetime of the story """
type TimelineItem {
  additionalInfo: String
  analystInfo: AnalystInfo
  category: TimelineItemCategoryEnum
  context: String!
  createdAt: DateTime!
  description: String! @deprecated(reason: "use 'descriptions' instead")
  descriptions: [String!]!
  type: TimelineTypeEnum!
}

type Timeseries {
  data(perSecond: Boolean = true, withMissingData: Boolean = false, useDefaultSizeBucket: Boolean = false): [[Float!]]
  dimensions: [DimensionData!]
  info: [String!]
  key: TimeseriesKey
  label: String!
  sum: Float
  units: UnitType
}

type TimeseriesKey {
  dimensions: [DimensionKey!]
  measureFieldName: String!
}

""" Application match criteria set """
type TlsInspectApplication {
  appCategory: [ApplicationCategoryRef!]!
  application: [ApplicationRef!]!
  country: [CountryRef!]!
  customApp: [CustomApplicationRef!]!
  customCategory: [CustomCategoryRef!]!
  customService: [CustomService!]!
  customServiceIp: [CustomServiceIp!]!
  domain: [Domain!]!
  fqdn: [Fqdn!]!
  globalIpRange: [GlobalIpRangeRef!]!
  ip: [IPAddress!]!
  ipRange: [IpAddressRange!]!
  remoteAsn: [Asn32!]!
  service: [ServiceRef!]!
  subnet: [NetworkSubnet!]!
  tlsInspectCategory: [TlsInspectSystemCategory!]!
}

""" Default rule settings for the TLS Inspection policy """
type TlsInspectConfig {
  defaultRuleAction: TlsInspectAction!
  defaultRuleUntrustedCertificateAction: TlsInspectUntrustedCertificateAction!
}

type TlsInspectPolicy implements IPolicy {
  additionalAttributes: TlsInspectConfig
  audit: PolicyAudit
  enabled: Boolean!
  revision: PolicyRevision
  rules: [TlsInspectRulePayload!]!
  sections: [PolicySectionPayload!]!
}

type TlsInspectPolicyMutationPayload implements IPolicyMutationPayload {
  errors: [PolicyMutationError!]!
  policy: TlsInspectPolicy
  status: PolicyMutationStatus!
}

type TlsInspectPolicyMutations {
  addRule(input: TlsInspectAddRuleInput!): TlsInspectRuleMutationPayload! @beta
  addSection(input: PolicyAddSectionInput!): PolicySectionMutationPayload! @beta
  createPolicyRevision(input: PolicyCreateRevisionInput!): TlsInspectPolicyMutationPayload! @beta
  discardPolicyRevision(input: PolicyDiscardRevisionInput): TlsInspectPolicyMutationPayload! @beta
  moveRule(input: PolicyMoveRuleInput!): TlsInspectRuleMutationPayload! @beta
  moveSection(input: PolicyMoveSectionInput!): PolicySectionMutationPayload! @beta
  publishPolicyRevision(input: PolicyPublishRevisionInput): TlsInspectPolicyMutationPayload! @beta
  removeRule(input: TlsInspectRemoveRuleInput!): TlsInspectRuleMutationPayload! @beta
  removeSection(input: PolicyRemoveSectionInput!): PolicySectionMutationPayload! @beta
  updatePolicy(input: TlsInspectPolicyUpdateInput!): TlsInspectPolicyMutationPayload! @beta
  updateRule(input: TlsInspectUpdateRuleInput!): TlsInspectRuleMutationPayload! @beta
  updateSection(input: PolicyUpdateSectionInput!): PolicySectionMutationPayload! @beta
}

type TlsInspectPolicyQueries {
  policy(input: TlsInspectPolicyInput): TlsInspectPolicy! @beta
  revisions: PolicyRevisionsPayload @beta
}

type TlsInspectRule implements IPolicyRule {
  action: TlsInspectAction!
  application: TlsInspectApplication!
  connectionOrigin: ConnectionOriginEnum!
  country: [CountryRef!]!
  description: String!
  devicePostureProfile: [DeviceProfileRef!]!
  enabled: Boolean!
  id: ID!
  index: Int!
  name: String!
  platform: [OperatingSystem!]!
  section: PolicySectionInfo!
  source: TlsInspectSource!
  untrustedCertificateAction: TlsInspectUntrustedCertificateAction!
}

type TlsInspectRuleMutationPayload implements IPolicyRuleMutationPayload {
  errors: [PolicyMutationError!]!
  rule: TlsInspectRulePayload
  status: PolicyMutationStatus!
}

type TlsInspectRulePayload implements IPolicyRulePayload {
  audit: PolicyElementAudit!
  properties: [PolicyElementPropertiesEnum!]!
  rule: TlsInspectRule!
}

""" Returns the settings for Source of an TLS inspection rule """
type TlsInspectSource {
  floatingSubnet: [FloatingSubnetRef!]!
  globalIpRange: [GlobalIpRangeRef!]!
  group: [GroupRef!]!
  host: [HostRef!]!
  ip: [IPAddress!]!
  ipRange: [IpAddressRange!]!
  networkInterface: [NetworkInterfaceRef!]!
  site: [SiteRef!]!
  siteNetworkSubnet: [SiteNetworkSubnetRef!]!
  subnet: [NetworkSubnet!]!
  systemGroup: [SystemGroupRef!]!
  user: [UserRef!]!
  usersGroup: [UsersGroupRef!]!
}

type TunnelConfig {
  localId: String
  tunnelId: String
  tunnelRemoteIdentifier: String
}

type UnassignSocketFromZtnaAppConnectorPayload {
  ztnaAppConnector: ZtnaAppConnector!
}

type UpdateAdminPayload {
  adminID: ID!
}

type UpdateBgpPeerPayload {
  bgpPeer: BgpPeer!
}

""" Payload for updating an existing physical connection at a cloud interconnect site. """
type UpdateCloudInterconnectPhysicalConnectionPayload {
  id: ID!
}

type UpdateCommercialLicensePayload {
  license: License!
}

""" Payload of UpdateFromFile operation on FQDN typed container """
type UpdateFqdnContainerFromFilePayload {
  container: FqdnContainer!
}

""" Payload of UpdateFromList operation on FQDN typed container """
type UpdateFqdnContainerFromListPayload {
  container: FqdnContainer!
}

""" The updated group object """
type UpdateGroupPayload {
  group: Group!
}

type UpdateHaPayload {
  siteId: ID!
}

""" Payload of UpdateFromFile operation on IPAddressRange typed container """
type UpdateIpAddressRangeContainerFromFilePayload {
  container: IpAddressRangeContainer!
}

""" Payload of UpdateFromList operation on IPAddressRange typed container """
type UpdateIpAddressRangeContainerFromListPayload {
  container: IpAddressRangeContainer!
}

type UpdateIpsecIkeV2SiteGeneralDetailsPayload {
  localId: String
  siteId: ID!
}

type UpdateIpsecIkeV2SiteMultiTunnelPayload {
  fqdn: Fqdn
  tunnels: [UpdateIpsecIkeV2SiteTunnelPayload!]!
}

type UpdateIpsecIkeV2SiteTunnelPayload {
  localId: String
  tunnelId: IPSecV2InterfaceId
}

type UpdateIpsecIkeV2SiteTunnelsPayload {
  primary: UpdateIpsecIkeV2SiteMultiTunnelPayload
  secondary: UpdateIpsecIkeV2SiteMultiTunnelPayload
  siteId: ID!
}

type UpdateNetworkRangePayload {
  networkRangeId: ID!
}

type UpdatePrivateApplicationPayload {
  application: PrivateApplication!
}

type UpdateSecondaryAwsVSocketPayload {
  secondaryAwsVSocket: SecondaryAwsVSocket!
}

type UpdateSecondaryAzureVSocketPayload {
  secondaryAzureVSocket: SecondaryAzureVSocket!
}

type UpdateServicePrincipalAdminPayload {
  adminID: ID!
}

type UpdateSiteBwLicensePayload {
  license: License!
}

type UpdateSiteGeneralDetailsPayload {
  siteId: ID!
}

type UpdateSocketInterfacePayload {
  siteId: ID!
  socketInterfaceId: SocketInterfaceIDEnum!
}

type UpdateStaticHostPayload {
  hostId: ID!
}

type UpdateZtnaAppConnectorPayload {
  ztnaAppConnector: ZtnaAppConnector!
}

""" Payload returned after updating ZTNA App Connectors configuration. """
type UpdateZtnaAppConnectorsConfigurationPayload {
  ztnaAppConnectorsConfiguration: ZtnaAppConnectorsConfiguration!
}

type UpgradeZtnaAppConnectorPayload {
  upgrades: [ZtnaAppConnectorUpgradeInfo!]!
}

""" Upload file response """
type UploadFilePayload {
  uploadUrl: Url
}

""" Basic User configuration information """
type UserInfo {
  authMethod: String
  creationTime: DateTime
  email: String
  name: String
  origin: String
  phoneNumber: String
  status: OperationalStatus
}

""" A reference identifying the User object. ID: Unique User Identifier, Name: The User Name """
type UserRef implements ObjectRef {
  id: ID!
  name: String!
}

type UserSnapshot {
  connectedInOffice: Boolean
  connectivityStatus: ConnectivityStatus
  deviceName: String
  devices: [DeviceSnapshot!]
  id: ID
  info: UserInfo
  internalIP: String
  lastConnected: DateTime
  name: String
  operationalStatus: OperationalStatus
  osType: String
  osVersion: String
  popID: Int
  popName: String
  recentConnections: [RecentConnection!]
  remoteIP: String
  remoteIPInfo: IPInfo
  uptime: Int
  version: String
  versionNumber: Int
}

""" A reference identifying the UsersGroup object. ID: Unique UsersGroup Identifier, Name: The UsersGroup Name """
type UsersGroupRef implements ObjectRef {
  id: ID!
  name: String!
}

""" Application match criteria set """
type WanFirewallApplication {
  appCategory: [ApplicationCategoryRef!]!
  application: [ApplicationRef!]!
  customApp: [CustomApplicationRef!]!
  customCategory: [CustomCategoryRef!]!
  domain: [Domain!]!
  fqdn: [Fqdn!]!
  globalIpRange: [GlobalIpRangeRef!]!
  ip: [IPAddress!]!
  ipRange: [IpAddressRange!]!
  sanctionedAppsCategory: [SanctionedAppsCategoryRef!]!
  subnet: [NetworkSubnet!]!
}

""" Returns the settings for Destination of a Wan Firewall rule """
type WanFirewallDestination {
  floatingSubnet: [FloatingSubnetRef!]!
  globalIpRange: [GlobalIpRangeRef!]!
  group: [GroupRef!]!
  host: [HostRef!]!
  ip: [IPAddress!]!
  ipRange: [IpAddressRange!]!
  networkInterface: [NetworkInterfaceRef!]!
  site: [SiteRef!]!
  siteNetworkSubnet: [SiteNetworkSubnetRef!]!
  subnet: [NetworkSubnet!]!
  systemGroup: [SystemGroupRef!]!
  user: [UserRef!]!
  usersGroup: [UsersGroupRef!]!
}

type WanFirewallPolicy implements IPolicy {
  audit: PolicyAudit
  enabled: Boolean!
  revision: PolicyRevision
  rules: [WanFirewallRulePayload!]!
  sections: [PolicySectionPayload!]!
}

""" Wan Firewall policy information provided in the API response """
type WanFirewallPolicyMutationPayload implements IPolicyMutationPayload {
  errors: [PolicyMutationError!]!
  policy: WanFirewallPolicy
  status: PolicyMutationStatus!
}

""" The Wan Firewall Policy information returned to the caller in the API response. """
type WanFirewallPolicyMutations {
  addRule(input: WanFirewallAddRuleInput!): WanFirewallRuleMutationPayload! @beta
  addSection(input: PolicyAddSectionInput!): PolicySectionMutationPayload! @beta
  createPolicyRevision(input: PolicyCreateRevisionInput!): WanFirewallPolicyMutationPayload! @beta
  discardPolicyRevision(input: PolicyDiscardRevisionInput): WanFirewallPolicyMutationPayload! @beta
  moveRule(input: PolicyMoveRuleInput!): WanFirewallRuleMutationPayload! @beta
  moveSection(input: PolicyMoveSectionInput!): PolicySectionMutationPayload! @beta
  publishPolicyRevision(input: PolicyPublishRevisionInput): WanFirewallPolicyMutationPayload! @beta
  removeRule(input: WanFirewallRemoveRuleInput!): WanFirewallRuleMutationPayload! @beta
  removeSection(input: PolicyRemoveSectionInput!): PolicySectionMutationPayload! @beta
  updatePolicy(input: WanFirewallPolicyUpdateInput!): WanFirewallPolicyMutationPayload! @beta
  updateRule(input: WanFirewallUpdateRuleInput!): WanFirewallRuleMutationPayload! @beta
  updateSection(input: PolicyUpdateSectionInput!): PolicySectionMutationPayload! @beta
}

type WanFirewallPolicyQueries {
  policy(input: WanFirewallPolicyInput): WanFirewallPolicy! @beta
  revisions: PolicyRevisionsPayload @beta
}

type WanFirewallRule implements IPolicyRule {
  action: WanFirewallActionEnum!
  activePeriod: PolicyRuleActivePeriod!
  application: WanFirewallApplication!
  connectionOrigin: ConnectionOriginEnum!
  country: [CountryRef!]!
  description: String!
  destination: WanFirewallDestination!
  device: [DeviceProfileRef!]!
  deviceAttributes: DeviceAttributes!
  deviceOS: [OperatingSystem!]!
  direction: WanFirewallDirectionEnum!
  enabled: Boolean!
  exceptions: [WanFirewallRuleException!]!
  id: ID!
  index: Int!
  name: String!
  schedule: PolicySchedule!
  section: PolicySectionInfo!
  service: WanFirewallServiceType!
  source: WanFirewallSource!
  tracking: PolicyTracking!
}

""" Exceptions define when a rule is ignored, and the firewall policy evaluation continues with the lower priority rules. """
type WanFirewallRuleException {
  application: WanFirewallApplication!
  connectionOrigin: ConnectionOriginEnum!
  country: [CountryRef!]!
  destination: WanFirewallDestination!
  device: [DeviceProfileRef!]!
  deviceAttributes: DeviceAttributes!
  deviceOS: [OperatingSystem!]!
  direction: WanFirewallDirectionEnum!
  name: String!
  service: WanFirewallServiceType!
  source: WanFirewallSource!
}

type WanFirewallRuleMutationPayload implements IPolicyRuleMutationPayload {
  errors: [PolicyMutationError!]!
  rule: WanFirewallRulePayload
  status: PolicyMutationStatus!
}

""" Wan Firewall policy information for a specific revision """
type WanFirewallRulePayload implements IPolicyRulePayload {
  audit: PolicyElementAudit!
  properties: [PolicyElementPropertiesEnum!]!
  rule: WanFirewallRule!
}

""" Returns the Service Type to which this Wan Firewall rule applies """
type WanFirewallServiceType {
  custom: [CustomService!]!
  standard: [ServiceRef!]!
}

""" Returns the settings for Source of an Wan Firewall rule """
type WanFirewallSource {
  floatingSubnet: [FloatingSubnetRef!]!
  globalIpRange: [GlobalIpRangeRef!]!
  group: [GroupRef!]!
  host: [HostRef!]!
  ip: [IPAddress!]!
  ipRange: [IpAddressRange!]!
  networkInterface: [NetworkInterfaceRef!]!
  site: [SiteRef!]!
  siteNetworkSubnet: [SiteNetworkSubnetRef!]!
  subnet: [NetworkSubnet!]!
  systemGroup: [SystemGroupRef!]!
  user: [UserRef!]!
  usersGroup: [UsersGroupRef!]!
}

type WanNetworkPolicy implements IPolicy {
  audit: PolicyAudit
  enabled: Boolean!
  revision: PolicyRevision
  rules: [WanNetworkRulePayload!]!
  sections: [PolicySectionPayload!]!
}

type WanNetworkPolicyMutationPayload implements IPolicyMutationPayload {
  errors: [PolicyMutationError!]!
  policy: WanNetworkPolicy
  status: PolicyMutationStatus!
}

type WanNetworkPolicyMutations {
  addRule(input: WanNetworkAddRuleInput!): WanNetworkRuleMutationPayload! @beta
  addSection(input: PolicyAddSectionInput!): PolicySectionMutationPayload! @beta
  createPolicyRevision(input: PolicyCreateRevisionInput!): WanNetworkPolicyMutationPayload! @beta
  discardPolicyRevision(input: PolicyDiscardRevisionInput): WanNetworkPolicyMutationPayload! @beta
  moveRule(input: PolicyMoveRuleInput!): WanNetworkRuleMutationPayload! @beta
  moveSection(input: PolicyMoveSectionInput!): PolicySectionMutationPayload! @beta
  publishPolicyRevision(input: PolicyPublishRevisionInput): WanNetworkPolicyMutationPayload! @beta
  removeRule(input: WanNetworkRemoveRuleInput!): WanNetworkRuleMutationPayload! @beta
  removeSection(input: PolicyRemoveSectionInput!): PolicySectionMutationPayload! @beta
  updatePolicy(input: WanNetworkPolicyUpdateInput!): WanNetworkPolicyMutationPayload! @beta
  updateRule(input: WanNetworkUpdateRuleInput!): WanNetworkRuleMutationPayload! @beta
  updateSection(input: PolicyUpdateSectionInput!): PolicySectionMutationPayload! @beta
}

type WanNetworkPolicyQueries {
  policy(input: WanNetworkPolicyInput): WanNetworkPolicy! @beta
  revisions: PolicyRevisionsPayload @beta
}

type WanNetworkRule implements IPolicyRule {
  application: WanNetworkRuleApplication!
  bandwidthPriority: BandwidthManagementRef!
  configuration: WanNetworkRuleConfiguration!
  description: String!
  destination: WanNetworkRuleDestination!
  enabled: Boolean!
  exceptions: [WanNetworkRuleException!]!
  id: ID!
  index: Int!
  name: String!
  routeType: WanNetworkRuleRouteType!
  ruleType: WanNetworkRuleType!
  section: PolicySectionInfo!
  source: WanNetworkRuleSource!
}

type WanNetworkRuleApplication {
  appCategory: [ApplicationCategoryRef!]!
  application: [ApplicationRef!]!
  customApp: [CustomApplicationRef!]!
  customCategory: [CustomCategoryRef!]!
  customService: [CustomService!]!
  customServiceIp: [CustomServiceIp!]!
  domain: [Domain!]!
  fqdn: [Fqdn!]!
  service: [ServiceRef!]!
}

type WanNetworkRuleConfiguration {
  activeTcpAcceleration: Boolean!
  allocationIp: [AllocatedIpRef!]!
  backhaulingSite: [SiteRef!]!
  packetLossMitigation: Boolean!
  popLocation: [PopLocationRef!]!
  preserveSourcePort: Boolean!
  primaryTransport: WanNetworkRuleTransport!
  secondaryTransport: WanNetworkRuleTransport!
}

type WanNetworkRuleDestination {
  floatingSubnet: [FloatingSubnetRef!]!
  globalIpRange: [GlobalIpRangeRef!]!
  group: [GroupRef!]!
  host: [HostRef!]!
  ip: [IPAddress!]!
  ipRange: [IpAddressRange!]!
  networkInterface: [NetworkInterfaceRef!]!
  site: [SiteRef!]!
  siteNetworkSubnet: [SiteNetworkSubnetRef!]!
  subnet: [NetworkSubnet!]!
  systemGroup: [SystemGroupRef!]!
  user: [UserRef!]!
  usersGroup: [UsersGroupRef!]!
}

type WanNetworkRuleException {
  application: WanNetworkRuleApplication!
  destination: WanNetworkRuleDestination!
  name: String!
  source: WanNetworkRuleSource!
}

type WanNetworkRuleMutationPayload implements IPolicyRuleMutationPayload {
  errors: [PolicyMutationError!]!
  rule: WanNetworkRulePayload
  status: PolicyMutationStatus!
}

type WanNetworkRulePayload implements IPolicyRulePayload {
  audit: PolicyElementAudit!
  properties: [PolicyElementPropertiesEnum!]!
  rule: WanNetworkRule!
}

type WanNetworkRuleSource {
  floatingSubnet: [FloatingSubnetRef!]!
  globalIpRange: [GlobalIpRangeRef!]!
  group: [GroupRef!]!
  host: [HostRef!]!
  ip: [IPAddress!]!
  ipRange: [IpAddressRange!]!
  networkInterface: [NetworkInterfaceRef!]!
  site: [SiteRef!]!
  siteNetworkSubnet: [SiteNetworkSubnetRef!]!
  subnet: [NetworkSubnet!]!
  systemGroup: [SystemGroupRef!]!
  user: [UserRef!]!
  usersGroup: [UsersGroupRef!]!
}

type WanNetworkRuleTransport {
  primaryInterfaceRole: WanNetworkRuleInterfaceRole!
  secondaryInterfaceRole: WanNetworkRuleInterfaceRole!
  transportType: WanNetworkRuleTransportType!
}

type XDR {
  stories(input: StoryInput!): StoriesData @beta
  story(storyId: ID, producer: StoryProducerEnum, incidentId: ID): Story @beta
}

""" XOps service license details """
type XOpsLicense implements License {
  description: String
  expirationDate: DateTime!
  id: String
  lastUpdated: DateTime
  plan: LicensePlan!
  sku: LicenseSku!
  startDate: DateTime
  status: LicenseStatus!
}

type XdrMutations {
  addStoryComment(input: AddStoryCommentInput!): AddStoryCommentPayload @beta
  analystFeedback(input: AnalystFeedbackInput!): AnalystFeedbackPayload @beta
  deleteStoryComment(input: DeleteStoryCommentInput!): DeleteStoryCommentPayload @beta
}

""" XDR Pro (extended detection and response) service license details """
type XdrProLicense implements License & QuantifiableLicense {
  description: String
  expirationDate: DateTime!
  id: String
  lastUpdated: DateTime
  plan: LicensePlan!
  sku: LicenseSku!
  startDate: DateTime
  status: LicenseStatus!
  total: Int!
}

type ZtnaAppConnector {
  description: String
  groupName: String!
  id: ID!
  location: ZtnaAppConnectorLocation!
  name: String!
  preferredPopLocation: ZtnaAppConnectorPreferredPopLocation
  privateAppRef: [PrivateApplicationRef!]!
  serialNumber: String
  socketId: ID
  socketModel: SocketModel
  type: ZtnaAppConnectorType!
}

type ZtnaAppConnectorConnectivityInfo {
  firstConnected: DateTime
  lastConnected: DateTime
  popLocation: PopLocationRef
  status: ZtnaAppConnectorConnectivityStatus!
}

type ZtnaAppConnectorDeviceConnectivityInfo {
  platform: SocketPlatform!
  serialNumber: String!
  version: String!
}

type ZtnaAppConnectorDeviceInfo {
  model: SocketModel
  serialNumber: String
  socketId: ID
  version: String
}

type ZtnaAppConnectorDeviceSnapshot {
  connectivity: ZtnaAppConnectorDeviceConnectivityInfo
  id: ID!
  info: ZtnaAppConnectorDeviceInfo!
  interface: [ZtnaAppConnectorInterfaceSnapshot!]!
}

type ZtnaAppConnectorGroupListPayload {
  items: [String!]!
  pageInfo: PageInfo!
}

type ZtnaAppConnectorGroupSnapshot {
  connectivityStatus: [ZtnaAppConnectorSnapshotConnectivityStatusSummaryItem!]!
  connectors: [ZtnaAppConnectorSnapshot!]!
  groupName: String!
  privateApps: [PrivateApplicationRef!]!
  totalConnectors: Int!
}

type ZtnaAppConnectorGroupSnapshotPayload {
  items: [ZtnaAppConnectorGroupSnapshot!]!
  pageInfo: PageInfo!
}

type ZtnaAppConnectorInfo {
  groupName: String!
  location: ZtnaAppConnectorLocationSnapshot!
  type: ZtnaAppConnectorType!
}

type ZtnaAppConnectorInterfaceConnectivityInfo {
  dnsServer: [IPAddress!]!
  lanIp: IPAddress
  status: ConnectivityStatus
}

type ZtnaAppConnectorInterfaceSnapshot {
  connectivity: ZtnaAppConnectorInterfaceConnectivityInfo
  id: ID!
  interfaceType: ZtnaAppConnectorInterfaceType!
}

type ZtnaAppConnectorListPayload {
  pageInfo: PageInfo!
  ztnaAppConnector: [ZtnaAppConnector!]!
}

type ZtnaAppConnectorLocation {
  address: String
  cityName: String!
  countryCode: String!
  stateCode: String
  timezone: TimeZone!
}

type ZtnaAppConnectorLocationSnapshot {
  cityName: String!
  countryCode: String!
}

type ZtnaAppConnectorMutations {
  addZtnaAppConnector(input: AddZtnaAppConnectorInput!): AddZtnaAppConnectorPayload!
  addZtnaAppConnectorsConfiguration(input: AddZtnaAppConnectorsConfigurationInput!): AddZtnaAppConnectorsConfigurationPayload!
  assignSocketToZtnaAppConnector(input: AssignSocketToZtnaAppConnectorInput!): AssignSocketToZtnaAppConnectorPayload!
  removeZtnaAppConnector(input: RemoveZtnaAppConnectorInput!): RemoveZtnaAppConnectorPayload!
  removeZtnaAppConnectorsConfiguration: RemoveZtnaAppConnectorsConfigurationPayload!
  unassignSocketFromZtnaAppConnector(input: UnassignSocketFromZtnaAppConnectorInput!): UnassignSocketFromZtnaAppConnectorPayload!
  updateZtnaAppConnector(input: UpdateZtnaAppConnectorInput!): UpdateZtnaAppConnectorPayload!
  updateZtnaAppConnectorsConfiguration(input: UpdateZtnaAppConnectorsConfigurationInput!): UpdateZtnaAppConnectorsConfigurationPayload!
  upgradeZtnaAppConnector(input: UpgradeZtnaAppConnectorInput!): UpgradeZtnaAppConnectorPayload!
}

type ZtnaAppConnectorPreferredPopLocation {
  automatic: Boolean!
  preferredOnly: Boolean!
  primary: PopLocationRef
  secondary: PopLocationRef
}

type ZtnaAppConnectorPrivateAppConnectivityInfo {
  probingStatus: ZtnaAppConnectorSnapshotProbingStatus!
  routingStatus: ZtnaAppConnectorSnapshotRoutingStatus!
}

type ZtnaAppConnectorPrivateAppSnapshot {
  connectivity: ZtnaAppConnectorPrivateAppConnectivityInfo
  id: ID!
  name: String!
}

type ZtnaAppConnectorQueries {
  ztnaAppConnector(input: ZtnaAppConnectorRefInput!): ZtnaAppConnector
  ztnaAppConnectorGroupList(input: ZtnaAppConnectorGroupListInput): ZtnaAppConnectorGroupListPayload
  ztnaAppConnectorList(input: ZtnaAppConnectorListInput!): ZtnaAppConnectorListPayload
  ztnaAppConnectorsConfiguration: ZtnaAppConnectorsConfiguration
}

type ZtnaAppConnectorRef implements ObjectRef {
  id: ID!
  name: String!
}

type ZtnaAppConnectorSnapshot {
  connectivity: ZtnaAppConnectorConnectivityInfo
  device: ZtnaAppConnectorDeviceSnapshot
  id: ID!
  info: ZtnaAppConnectorInfo!
  name: String!
  privateApp: [ZtnaAppConnectorPrivateAppSnapshot!]!
}

type ZtnaAppConnectorSnapshotAssignmentSummary {
  assigned: Int!
  total: Int!
}

type ZtnaAppConnectorSnapshotConnectivityStatusSummaryItem {
  connectivityStatus: ZtnaAppConnectorConnectivityStatus!
  total: Int!
}

type ZtnaAppConnectorSnapshotPayload {
  items: [ZtnaAppConnectorSnapshot!]!
  pageInfo: PageInfo!
}

type ZtnaAppConnectorSnapshotSocketModelSummaryItem {
  model: SocketModel!
  total: Int!
}

type ZtnaAppConnectorSnapshotSocketPlatformSummaryItem {
  platform: SocketPlatform!
  total: Int!
}

type ZtnaAppConnectorSnapshotSummaryPayload {
  assignment: ZtnaAppConnectorSnapshotAssignmentSummary
  connectivityStatus: [ZtnaAppConnectorSnapshotConnectivityStatusSummaryItem!]!
  socketModel: [ZtnaAppConnectorSnapshotSocketModelSummaryItem!]!
  socketPlatform: [ZtnaAppConnectorSnapshotSocketPlatformSummaryItem!]!
  total: Int!
  version: [ZtnaAppConnectorSnapshotVersionSummaryItem!]!
}

type ZtnaAppConnectorSnapshotVersionSummaryItem {
  total: Int!
  version: String!
}

type ZtnaAppConnectorUpgradeInfo {
  targetVersion: String!
  ztnaAppConnector: ZtnaAppConnectorRef!
}

""" ZTNA App Connectors configuration for an account. """
type ZtnaAppConnectorsConfiguration {
  appConnectorManagementRange: NetworkSubnet!
  privateAppsServiceRange: NetworkSubnet!
}

""" ZTNA remote users license """
type ZtnaUsersLicense implements License & QuantifiableLicense {
  description: String
  expirationDate: DateTime!
  id: String
  lastUpdated: DateTime
  plan: LicensePlan!
  sku: LicenseSku!
  startDate: DateTime
  status: LicenseStatus!
  total: Int!
  ztnaUsersLicenseGroup: ZtnaUsersLicenseGroup!
}

""" Global ZTNA license usage and allocation across all accounts """
type ZtnaUsersLicenseAllocations {
  allocated: Int!
  available: Int!
  total: Int!
}

##### Inputs ##########################
input AccountFilter {
  accountInclusion: AccountInclusion
  in: [ID!]
}

input AccountIdPredicate {
  in: [ID!]
  not_in: [ID!]
}

input ActorRefInput {
  by: ObjectRefBy! = ID
  input: String!
}

input AddAccountInput {
  description: String
  name: String!
  tenancy: AccountTenancy!
  timezone: TimeZone!
  type: AccountProfileType!
}

input AddAdminInput {
  adminType: AdminType
  email: String
  firstName: String!
  lastName: String!
  managedRoles: [UpdateAdminRoleInput!]
  mfaEnabled: Boolean @deprecated(reason: "It is recommended to always require MFA when using User Credential authentication.")
  passwordNeverExpires: Boolean!
  resellerRoles: [UpdateAdminRoleInput!]
}

input AddBgpPeerInput {
  advertiseAllRoutes: Boolean! = false
  advertiseDefaultRoute: Boolean! = true
  advertiseSummaryRoutes: Boolean! = false
  bfdEnabled: Boolean! = false
  bfdSettings: BfdSettingsInput
  catoAsn: Asn16!
  defaultAction: BgpDefaultAction!
  defaultActionExclusion: [BgpFilterRuleInput!]! = []
  holdTime: Int! = 60
  keepaliveInterval: Int! = 20
  md5AuthKey: String
  metric: Int! = 100
  name: String!
  peerAsn: Asn32!
  peerIp: IPAddress!
  performNat: Boolean! = false
  site: SiteRefInput!
  summaryRoute: [BgpSummaryRouteInput!]! = []
  tracking: BgpTrackingInput
}

""" Input for adding a new physical connection to a cloud interconnect site. """
input AddCloudInterconnectPhysicalConnectionInput {
  downstreamBwLimit: NetworkBandwidth!
  encapsulationMethod: TaggingMethod!
  haRole: HaRole!
  popLocation: PopLocationRefInput!
  privateCatoIp: IPAddress!
  privateSiteIp: IPAddress!
  serviceProviderName: String!
  site: SiteRefInput!
  subnet: NetworkSubnet!
  upstreamBwLimit: NetworkBandwidth!
}

""" Input for adding a new cloud interconnect site. """
input AddCloudInterconnectSiteInput {
  description: String
  name: String!
  siteLocation: AddSiteLocationInput!
  siteType: SiteType! = BRANCH
}

input AddIpsecIkeV2SiteInput {
  description: String
  name: String!
  nativeNetworkRange: IPSubnet!
  siteLocation: AddSiteLocationInput!
  siteType: SiteType! = BRANCH
  vlan: Vlan
}

input AddIpsecIkeV2SiteTunnelsInput {
  primary: AddIpsecIkeV2TunnelsInput
  secondary: AddIpsecIkeV2TunnelsInput
}

input AddIpsecIkeV2TunnelInput {
  lastMileBw: LastMileBwInput
  name: String
  privateCatoIp: IPAddress
  privateSiteIp: IPAddress
  psk: String!
  publicSiteIp: IPAddress
  role: IPSecV2TunnelRole
}

input AddIpsecIkeV2TunnelsInput {
  destinationType: DestinationType
  popLocationId: ID
  publicCatoIpId: ID
  tunnels: [AddIpsecIkeV2TunnelInput!]!
}

input AddNetworkRangeInput {
  azureFloatingIp: IPAddress
  dhcpSettings: NetworkDhcpSettingsInput
  gateway: IPAddress
  internetOnly: Boolean
  localIp: IPAddress
  mdnsReflector: Boolean
  name: String!
  rangeType: SubnetType!
  subnet: IPSubnet!
  translatedSubnet: IPSubnet
  vlan: Int
}

input AddSecondaryAwsVSocketInput {
  eniIpAddress: IPAddress!
  eniIpSubnet: NetworkSubnet!
  routeTableId: String!
  site: SiteRefInput!
}

input AddSecondaryAzureVSocketInput {
  floatingIp: IPAddress!
  interfaceIp: IPAddress!
  site: SiteRefInput!
}

input AddServicePrincipalAdminInput {
  email: String
  managedRoles: [UpdateAdminRoleInput!]
  name: String!
  resellerRoles: [UpdateAdminRoleInput!]
}

input AddSiteLocationInput {
  address: String
  city: String
  countryCode: String!
  stateCode: String
  timezone: String!
}

input AddSocketAddOnCardInput {
  addOns: [SocketAddOnCardInput!]!
  site: SiteRefInput!
}

input AddSocketSiteInput {
  connectionType: SiteConnectionTypeEnum! = SOCKET_X1500
  description: String
  name: String!
  nativeNetworkRange: IPSubnet!
  siteLocation: AddSiteLocationInput!
  siteType: SiteType! = BRANCH
  translatedSubnet: IPSubnet
  vlan: Vlan
}

input AddStaticHostInput {
  ip: IPAddress!
  macAddress: String
  name: String!
}

input AddStoryCommentInput {
  storyId: ID!
  text: String!
}

""" Input for creating a new ZTNA App Connector """
input AddZtnaAppConnectorInput {
  description: String
  groupName: String!
  location: ZtnaAppConnectorLocationInput!
  name: String!
  preferredPopLocation: ZtnaAppConnectorPreferredPopLocationInput! = {preferredOnly:false,automatic:true}
  type: ZtnaAppConnectorType!
}

"""
Input for creating ZTNA App Connectors configuration.
If not provided, default ranges will be used (100.64.0.0/16 for Private Apps Service, 100.65.0.0/16
for App Connector Service).
"""
input AddZtnaAppConnectorsConfigurationInput {
  appConnectorManagementRange: NetworkSubnet!
  privateAppsServiceRange: NetworkSubnet!
}

input AddressInput {
  cityName: String!
  companyName: String!
  countryName: String!
  stateName: String
  street: String!
  zipCode: String!
}

input AdvancedStringFilterInput {
  eq: String
  in: [String!]
  neq: String
  nin: [String!]
  regex: String
}

input AllocatedIpRefInput {
  by: ObjectRefBy! = ID
  input: String!
}

input AnalystFeedbackInput {
  additionalInfo: String
  severity: SeverityEnum
  status: StoryStatusEnum
  storyId: ID!
  threatClassification: String
  threatType: StoryThreatType
  verdict: StoryVerdictEnum
}

input AntiMalwareFileHashAddRuleDataInput {
  action: AntiMalwareFileHashAction! = BLOCK
  description: String! = ""
  enabled: Boolean!
  expirationDate: DateTime!
  fileName: String!
  name: String!
  sha256: SHA_256!
}

input AntiMalwareFileHashAddRuleInput {
  at: PolicyRulePositionInput
  rule: AntiMalwareFileHashAddRuleDataInput!
}

input AntiMalwareFileHashPolicyInput {
  revision: PolicyRevisionInput
}

input AntiMalwareFileHashPolicyMutationInput {
  revision: PolicyMutationRevisionInput
}

input AntiMalwareFileHashPolicyUpdateInput {
  state: PolicyToggleState
}

input AntiMalwareFileHashRemoveRuleInput {
  id: ID!
}

input AntiMalwareFileHashUpdateRuleDataInput {
  action: AntiMalwareFileHashAction
  description: String
  enabled: Boolean
  expirationDate: DateTime
  fileName: String
  name: String
  sha256: SHA_256
}

input AntiMalwareFileHashUpdateRuleInput {
  id: ID!
  rule: AntiMalwareFileHashUpdateRuleDataInput!
}

input AppStatsFilter {
  fieldName: AppStatsFieldName!
  operator: FilterOperator!
  values: [String!]!
}

input AppStatsSort {
  fieldName: AppStatsFieldName!
  order: DirectionEnum!
}

input AppTenantRestrictionAddRuleDataInput {
  action: AppTenantRestrictionActionEnum! = INJECT_HEADERS
  application: ApplicationRefInput!
  description: String! = ""
  enabled: Boolean!
  headers: [AppTenantRestrictionHeaderValueInput!]! = []
  name: String!
  schedule: PolicyScheduleInput! = {activeOn:ALWAYS}
  severity: AppTenantRestrictionSeverityEnum! = HIGH
  source: AppTenantRestrictionSourceInput! = {ip:[],host:[],site:[],subnet:[],ipRange:[],globalIpRange:[],networkInterface:[],siteNetworkSubnet:[],floatingSubnet:[],user:[],usersGroup:[],group:[],systemGroup:[],country:[]}
}

input AppTenantRestrictionAddRuleInput {
  at: PolicyRulePositionInput
  rule: AppTenantRestrictionAddRuleDataInput!
}

""" pair of header name and value """
input AppTenantRestrictionHeaderValueInput {
  name: HttpHeaderName!
  value: HttpHeaderValue!
}

input AppTenantRestrictionPolicyInput {
  revision: PolicyRevisionInput
}

input AppTenantRestrictionPolicyMutationInput {
  revision: PolicyMutationRevisionInput
}

input AppTenantRestrictionPolicyUpdateInput {
  state: PolicyToggleState
}

input AppTenantRestrictionRemoveRuleInput {
  id: ID!
}

""" Input of the settings for Source of an App Tenant Restriction rule """
input AppTenantRestrictionSourceInput {
  country: [CountryRefInput!]! = []
  floatingSubnet: [FloatingSubnetRefInput!]! = []
  globalIpRange: [GlobalIpRangeRefInput!]! = []
  group: [GroupRefInput!]! = []
  host: [HostRefInput!]! = []
  ip: [IPAddress!]! = []
  ipRange: [IpAddressRangeInput!]! = []
  networkInterface: [NetworkInterfaceRefInput!]! = []
  site: [SiteRefInput!]! = []
  siteNetworkSubnet: [SiteNetworkSubnetRefInput!]! = []
  subnet: [NetworkSubnet!]! = []
  systemGroup: [SystemGroupRefInput!]! = []
  user: [UserRefInput!]! = []
  usersGroup: [UsersGroupRefInput!]! = []
}

""" Input of the settings for Source of an App Tenant Restriction rule """
input AppTenantRestrictionSourceUpdateInput {
  country: [CountryRefInput!]
  floatingSubnet: [FloatingSubnetRefInput!]
  globalIpRange: [GlobalIpRangeRefInput!]
  group: [GroupRefInput!]
  host: [HostRefInput!]
  ip: [IPAddress!]
  ipRange: [IpAddressRangeInput!]
  networkInterface: [NetworkInterfaceRefInput!]
  site: [SiteRefInput!]
  siteNetworkSubnet: [SiteNetworkSubnetRefInput!]
  subnet: [NetworkSubnet!]
  systemGroup: [SystemGroupRefInput!]
  user: [UserRefInput!]
  usersGroup: [UsersGroupRefInput!]
}

input AppTenantRestrictionUpdateRuleDataInput {
  action: AppTenantRestrictionActionEnum
  application: ApplicationRefInput
  description: String
  enabled: Boolean
  headers: [AppTenantRestrictionHeaderValueInput!]
  name: String
  schedule: PolicyScheduleUpdateInput
  severity: AppTenantRestrictionSeverityEnum
  source: AppTenantRestrictionSourceUpdateInput
}

input AppTenantRestrictionUpdateRuleInput {
  id: ID!
  rule: AppTenantRestrictionUpdateRuleDataInput!
}

input ApplicationCategoryRefInput {
  by: ObjectRefBy! = ID
  input: String!
}

""" Access method matching configuration """
input ApplicationControlAccessMethodInput {
  accessMethod: ApplicationControlAccessMethodType! = USER_AGENT
  operator: ApplicationControlOperator! = IS
  value: String
  valueSet: StringValueSetRefInput
}

input ApplicationControlActivityFieldRefInput {
  by: ObjectRefBy! = ID
  input: String!
}

""" Activity matching configuration """
input ApplicationControlActivityInput {
  activity: ApplicationControlActivityRefInput!
  field: ApplicationControlActivityFieldRefInput
  operator: ApplicationControlOperator = IS
  value: String
  valueSet: StringValueSetRefInput
}

input ApplicationControlActivityRefInput {
  by: ObjectRefBy! = ID
  input: String!
}

input ApplicationControlAddRuleDataInput {
  applicationRule: ApplicationControlApplicationRuleInput = {application:{applicationType:[]},applicationActivitySatisfy:ANY,applicationActivity:[],applicationContext:{applicationTenant:[]},accessMethod:[],source:{country:[],host:[],site:[],subnet:[],ip:[],ipRange:[],globalIpRange:[],networkInterface:[],siteNetworkSubnet:[],floatingSubnet:[],user:[],usersGroup:[],group:[],systemGroup:[]},device:[],action:BLOCK,tracking:{event:{enabled:false},alert:{enabled:false,frequency:HOURLY,subscriptionGroup:[],webhook:[],mailingList:[]}},schedule:{activeOn:ALWAYS},severity:HIGH,applicationCriteriaSatisfy:ANY,applicationCriteria:{attributes:{complianceAttributes:{iso27001:ANY,sox:ANY,hippa:ANY,soc1:ANY,soc2:ANY,soc3:ANY,isae3402:ANY,pciDss:ANY},securityAttributes:{mfa:ANY,encryptionAtRest:ANY,auditTrail:ANY,rbac:ANY,rememberPassword:ANY,sso:ANY,trustedCertificate:ANY,tlsEnforcement:ANY,httpSecurityHeaders:ANY}},originCountry:[],risk:[]}}
  dataRule: ApplicationControlDataRuleInput = {application:{applicationType:[]},applicationContext:{applicationTenant:[]},applicationActivitySatisfy:ANY,applicationActivity:[],accessMethod:[],source:{country:[],host:[],site:[],subnet:[],ip:[],ipRange:[],globalIpRange:[],networkInterface:[],siteNetworkSubnet:[],floatingSubnet:[],user:[],usersGroup:[],group:[],systemGroup:[]},device:[],action:BLOCK,tracking:{event:{enabled:false},alert:{enabled:false,frequency:HOURLY,subscriptionGroup:[],webhook:[],mailingList:[]}},schedule:{activeOn:ALWAYS},severity:HIGH,fileAttributeSatisfy:ANY,fileAttribute:[],dlpProfile:{contentProfile:[],edmProfile:[]}}
  description: String! = ""
  enabled: Boolean!
  fileRule: ApplicationControlFileRuleInput = {application:{applicationType:[]},applicationActivitySatisfy:ANY,applicationActivity:[],accessMethod:[],source:{country:[],host:[],site:[],subnet:[],ip:[],ipRange:[],globalIpRange:[],networkInterface:[],siteNetworkSubnet:[],floatingSubnet:[],user:[],usersGroup:[],group:[],systemGroup:[]},device:[],action:BLOCK,tracking:{event:{enabled:false},alert:{enabled:false,frequency:HOURLY,subscriptionGroup:[],webhook:[],mailingList:[]}},schedule:{activeOn:ALWAYS},severity:HIGH,fileAttributeSatisfy:ANY,fileAttribute:[]}
  name: String!
  ruleType: ApplicationControlRuleType! = APPLICATION
}

input ApplicationControlAddRuleInput {
  at: PolicyRulePositionInput
  rule: ApplicationControlAddRuleDataInput!
}

""" Application matching configuration. Only one of the following fields should be filled - the others must remain empty. """
input ApplicationControlApplicationInput {
  appCategory: ApplicationCategoryRefInput
  application: ApplicationRefInput
  applicationType: [ApplicationType!]! = []
  customApp: CustomApplicationRefInput
  customCategory: CustomCategoryRefInput
  sanctionedAppsCategory: SanctionedAppsCategoryRefInput
}

""" Configuration for application-based control rules """
input ApplicationControlApplicationRuleInput {
  accessMethod: [ApplicationControlAccessMethodInput!]! = []
  action: ApplicationControlAction! = BLOCK
  application: ApplicationControlApplicationInput! = {applicationType:[]}
  applicationActivity: [ApplicationControlActivityInput!]! = []
  applicationActivitySatisfy: ApplicationControlSatisfy! = ANY
  applicationContext: ApplicationControlContextInput! = {applicationTenant:[]}
  applicationCriteria: ApplicationControlCriteriaInput! = {attributes:{complianceAttributes:{iso27001:ANY,sox:ANY,hippa:ANY,soc1:ANY,soc2:ANY,soc3:ANY,isae3402:ANY,pciDss:ANY},securityAttributes:{mfa:ANY,encryptionAtRest:ANY,auditTrail:ANY,rbac:ANY,rememberPassword:ANY,sso:ANY,trustedCertificate:ANY,tlsEnforcement:ANY,httpSecurityHeaders:ANY}},originCountry:[],risk:[]}
  applicationCriteriaSatisfy: ApplicationControlSatisfy! = ANY
  device: [DeviceProfileRefInput!]! = []
  schedule: PolicyScheduleInput! = {activeOn:ALWAYS}
  severity: ApplicationControlSeverity! = HIGH
  source: ApplicationControlSourceInput! = {country:[],host:[],site:[],subnet:[],ip:[],ipRange:[],globalIpRange:[],networkInterface:[],siteNetworkSubnet:[],floatingSubnet:[],user:[],usersGroup:[],group:[],systemGroup:[]}
  tracking: PolicyTrackingInput! = {event:{enabled:false},alert:{enabled:false,frequency:HOURLY,subscriptionGroup:[],webhook:[],mailingList:[]}}
}

""" Configuration for application-based control rules """
input ApplicationControlApplicationRuleUpdateInput {
  accessMethod: [ApplicationControlAccessMethodInput!]
  action: ApplicationControlAction
  application: ApplicationControlApplicationUpdateInput
  applicationActivity: [ApplicationControlActivityInput!]
  applicationActivitySatisfy: ApplicationControlSatisfy
  applicationContext: ApplicationControlContextUpdateInput
  applicationCriteria: ApplicationControlCriteriaUpdateInput
  applicationCriteriaSatisfy: ApplicationControlSatisfy
  device: [DeviceProfileRefInput!]
  schedule: PolicyScheduleUpdateInput
  severity: ApplicationControlSeverity
  source: ApplicationControlSourceUpdateInput
  tracking: PolicyTrackingUpdateInput
}

""" Application matching configuration. Only one of the following fields should be filled - the others must remain empty. """
input ApplicationControlApplicationUpdateInput {
  appCategory: ApplicationCategoryRefInput
  application: ApplicationRefInput
  applicationType: [ApplicationType!]
  customApp: CustomApplicationRefInput
  customCategory: CustomCategoryRefInput
  sanctionedAppsCategory: SanctionedAppsCategoryRefInput
}

""" Application attributes, such as compliance and security, see the app catalog for details """
input ApplicationControlAttributesInput {
  complianceAttributes: ApplicationControlComplianceAttributesInput! = {iso27001:ANY,sox:ANY,hippa:ANY,soc1:ANY,soc2:ANY,soc3:ANY,isae3402:ANY,pciDss:ANY}
  securityAttributes: ApplicationControlSecurityAttributesInput! = {mfa:ANY,encryptionAtRest:ANY,auditTrail:ANY,rbac:ANY,rememberPassword:ANY,sso:ANY,trustedCertificate:ANY,tlsEnforcement:ANY,httpSecurityHeaders:ANY}
}

""" Application attributes, such as compliance and security, see the app catalog for details """
input ApplicationControlAttributesUpdateInput {
  complianceAttributes: ApplicationControlComplianceAttributesUpdateInput
  securityAttributes: ApplicationControlSecurityAttributesUpdateInput
}

""" Compliance attributes """
input ApplicationControlComplianceAttributesInput {
  hippa: ApplicationControlAttributeValue! = ANY
  isae3402: ApplicationControlAttributeValue! = ANY
  iso27001: ApplicationControlAttributeValue! = ANY
  pciDss: ApplicationControlAttributeValue! = ANY
  soc1: ApplicationControlAttributeValue! = ANY
  soc2: ApplicationControlAttributeValue! = ANY
  soc3: ApplicationControlAttributeValue! = ANY
  sox: ApplicationControlAttributeValue! = ANY
}

""" Compliance attributes """
input ApplicationControlComplianceAttributesUpdateInput {
  hippa: ApplicationControlAttributeValue
  isae3402: ApplicationControlAttributeValue
  iso27001: ApplicationControlAttributeValue
  pciDss: ApplicationControlAttributeValue
  soc1: ApplicationControlAttributeValue
  soc2: ApplicationControlAttributeValue
  soc3: ApplicationControlAttributeValue
  sox: ApplicationControlAttributeValue
}

input ApplicationControlConfigInput {
  dataControlEnabled: PolicyToggleState! = ENABLED
}

input ApplicationControlContentTypeGroupRefInput {
  by: ObjectRefBy! = ID
  input: String!
}

input ApplicationControlContentTypeRefInput {
  by: ObjectRefBy! = ID
  input: String!
}

input ApplicationControlContextInput {
  applicationTenant: [ApplicationControlTenantInput!]! = []
}

input ApplicationControlContextUpdateInput {
  applicationTenant: [ApplicationControlTenantInput!]
}

""" Application criteria configuration """
input ApplicationControlCriteriaInput {
  attributes: ApplicationControlAttributesInput! = {complianceAttributes:{iso27001:ANY,sox:ANY,hippa:ANY,soc1:ANY,soc2:ANY,soc3:ANY,isae3402:ANY,pciDss:ANY},securityAttributes:{mfa:ANY,encryptionAtRest:ANY,auditTrail:ANY,rbac:ANY,rememberPassword:ANY,sso:ANY,trustedCertificate:ANY,tlsEnforcement:ANY,httpSecurityHeaders:ANY}}
  originCountry: [CountryRefInput!]! = []
  risk: [ApplicationControlRiskCriteriaInput!]! = []
}

""" Application criteria configuration """
input ApplicationControlCriteriaUpdateInput {
  attributes: ApplicationControlAttributesUpdateInput
  originCountry: [CountryRefInput!]
  risk: [ApplicationControlRiskCriteriaInput!]
}

""" Configuration for data-based control rules """
input ApplicationControlDataRuleInput {
  accessMethod: [ApplicationControlAccessMethodInput!]! = []
  action: ApplicationControlAction! = BLOCK
  application: ApplicationControlApplicationInput! = {applicationType:[]}
  applicationActivity: [ApplicationControlActivityInput!]! = []
  applicationActivitySatisfy: ApplicationControlSatisfy! = ANY
  applicationContext: ApplicationControlContextInput! = {applicationTenant:[]}
  device: [DeviceProfileRefInput!]! = []
  dlpProfile: ApplicationControlDlpProfileInput! = {contentProfile:[],edmProfile:[]}
  fileAttribute: [ApplicationControlFileAttributeInput!]! = []
  fileAttributeSatisfy: ApplicationControlSatisfy! = ANY
  schedule: PolicyScheduleInput! = {activeOn:ALWAYS}
  severity: ApplicationControlSeverity! = HIGH
  source: ApplicationControlSourceInput! = {country:[],host:[],site:[],subnet:[],ip:[],ipRange:[],globalIpRange:[],networkInterface:[],siteNetworkSubnet:[],floatingSubnet:[],user:[],usersGroup:[],group:[],systemGroup:[]}
  tracking: PolicyTrackingInput! = {event:{enabled:false},alert:{enabled:false,frequency:HOURLY,subscriptionGroup:[],webhook:[],mailingList:[]}}
}

""" Configuration for data-based control rules """
input ApplicationControlDataRuleUpdateInput {
  accessMethod: [ApplicationControlAccessMethodInput!]
  action: ApplicationControlAction
  application: ApplicationControlApplicationUpdateInput
  applicationActivity: [ApplicationControlActivityInput!]
  applicationActivitySatisfy: ApplicationControlSatisfy
  applicationContext: ApplicationControlContextUpdateInput
  device: [DeviceProfileRefInput!]
  dlpProfile: ApplicationControlDlpProfileUpdateInput
  fileAttribute: [ApplicationControlFileAttributeInput!]
  fileAttributeSatisfy: ApplicationControlSatisfy
  schedule: PolicyScheduleUpdateInput
  severity: ApplicationControlSeverity
  source: ApplicationControlSourceUpdateInput
  tracking: PolicyTrackingUpdateInput
}

""" DLP profile configuration """
input ApplicationControlDlpProfileInput {
  contentProfile: [DlpContentProfileRefInput!]! = []
  edmProfile: [DlpEdmProfileRefInput!]! = []
}

""" DLP profile configuration """
input ApplicationControlDlpProfileUpdateInput {
  contentProfile: [DlpContentProfileRefInput!]
  edmProfile: [DlpEdmProfileRefInput!]
}

""" File attribute matching configuration """
input ApplicationControlFileAttributeInput {
  contentTypeGroupValues: [ApplicationControlContentTypeGroupRefInput!]! = []
  contentTypeValues: [ApplicationControlContentTypeRefInput!]! = []
  fileAttribute: ApplicationControlFileAttributeType! = CONTENT_TYPE
  operator: ApplicationControlOperator! = IS
  value: String
}

""" Configuration for file-based control rules """
input ApplicationControlFileRuleInput {
  accessMethod: [ApplicationControlAccessMethodInput!]! = []
  action: ApplicationControlAction! = BLOCK
  application: ApplicationControlApplicationInput! = {applicationType:[]}
  applicationActivity: [ApplicationControlActivityInput!]! = []
  applicationActivitySatisfy: ApplicationControlSatisfy! = ANY
  device: [DeviceProfileRefInput!]! = []
  fileAttribute: [ApplicationControlFileAttributeInput!]! = []
  fileAttributeSatisfy: ApplicationControlSatisfy! = ANY
  schedule: PolicyScheduleInput! = {activeOn:ALWAYS}
  severity: ApplicationControlSeverity! = HIGH
  source: ApplicationControlSourceInput! = {country:[],host:[],site:[],subnet:[],ip:[],ipRange:[],globalIpRange:[],networkInterface:[],siteNetworkSubnet:[],floatingSubnet:[],user:[],usersGroup:[],group:[],systemGroup:[]}
  tracking: PolicyTrackingInput! = {event:{enabled:false},alert:{enabled:false,frequency:HOURLY,subscriptionGroup:[],webhook:[],mailingList:[]}}
}

""" Configuration for file-based control rules """
input ApplicationControlFileRuleUpdateInput {
  accessMethod: [ApplicationControlAccessMethodInput!]
  action: ApplicationControlAction
  application: ApplicationControlApplicationUpdateInput
  applicationActivity: [ApplicationControlActivityInput!]
  applicationActivitySatisfy: ApplicationControlSatisfy
  device: [DeviceProfileRefInput!]
  fileAttribute: [ApplicationControlFileAttributeInput!]
  fileAttributeSatisfy: ApplicationControlSatisfy
  schedule: PolicyScheduleUpdateInput
  severity: ApplicationControlSeverity
  source: ApplicationControlSourceUpdateInput
  tracking: PolicyTrackingUpdateInput
}

input ApplicationControlPolicyInput {
  revision: PolicyRevisionInput
}

input ApplicationControlPolicyMutationInput {
  revision: PolicyMutationRevisionInput
}

input ApplicationControlPolicyUpdateInput {
  additionalAttributes: ApplicationControlConfigInput
  state: PolicyToggleState
}

input ApplicationControlRemoveRuleInput {
  id: ID!
}

""" Application risk """
input ApplicationControlRiskCriteriaInput {
  risk: ApplicationRisk!
  riskOperator: ApplicationControlOperator! = IS
}

""" Security attributes """
input ApplicationControlSecurityAttributesInput {
  auditTrail: ApplicationControlAttributeValue! = ANY
  encryptionAtRest: ApplicationControlAttributeValue! = ANY
  httpSecurityHeaders: ApplicationControlAttributeValue! = ANY
  mfa: ApplicationControlAttributeValue! = ANY
  rbac: ApplicationControlAttributeValue! = ANY
  rememberPassword: ApplicationControlAttributeValue! = ANY
  sso: ApplicationControlAttributeValue! = ANY
  tlsEnforcement: ApplicationControlAttributeValue! = ANY
  trustedCertificate: ApplicationControlAttributeValue! = ANY
}

""" Security attributes """
input ApplicationControlSecurityAttributesUpdateInput {
  auditTrail: ApplicationControlAttributeValue
  encryptionAtRest: ApplicationControlAttributeValue
  httpSecurityHeaders: ApplicationControlAttributeValue
  mfa: ApplicationControlAttributeValue
  rbac: ApplicationControlAttributeValue
  rememberPassword: ApplicationControlAttributeValue
  sso: ApplicationControlAttributeValue
  tlsEnforcement: ApplicationControlAttributeValue
  trustedCertificate: ApplicationControlAttributeValue
}

""" Source traffic matching configuration """
input ApplicationControlSourceInput {
  country: [CountryRefInput!]! = []
  floatingSubnet: [FloatingSubnetRefInput!]! = []
  globalIpRange: [GlobalIpRangeRefInput!]! = []
  group: [GroupRefInput!]! = []
  host: [HostRefInput!]! = []
  ip: [IPAddress!]! = []
  ipRange: [IpAddressRangeInput!]! = []
  networkInterface: [NetworkInterfaceRefInput!]! = []
  site: [SiteRefInput!]! = []
  siteNetworkSubnet: [SiteNetworkSubnetRefInput!]! = []
  subnet: [NetworkSubnet!]! = []
  systemGroup: [SystemGroupRefInput!]! = []
  user: [UserRefInput!]! = []
  usersGroup: [UsersGroupRefInput!]! = []
}

""" Source traffic matching configuration """
input ApplicationControlSourceUpdateInput {
  country: [CountryRefInput!]
  floatingSubnet: [FloatingSubnetRefInput!]
  globalIpRange: [GlobalIpRangeRefInput!]
  group: [GroupRefInput!]
  host: [HostRefInput!]
  ip: [IPAddress!]
  ipRange: [IpAddressRangeInput!]
  networkInterface: [NetworkInterfaceRefInput!]
  site: [SiteRefInput!]
  siteNetworkSubnet: [SiteNetworkSubnetRefInput!]
  subnet: [NetworkSubnet!]
  systemGroup: [SystemGroupRefInput!]
  user: [UserRefInput!]
  usersGroup: [UsersGroupRefInput!]
}

""" Tenant matching configuration """
input ApplicationControlTenantInput {
  operator: ApplicationControlOperator = IS
  value: String
  valueSet: StringValueSetRefInput
}

input ApplicationControlUpdateRuleDataInput {
  applicationRule: ApplicationControlApplicationRuleUpdateInput
  dataRule: ApplicationControlDataRuleUpdateInput
  description: String
  enabled: Boolean
  fileRule: ApplicationControlFileRuleUpdateInput
  name: String
  ruleType: ApplicationControlRuleType
}

input ApplicationControlUpdateRuleInput {
  id: ID!
  rule: ApplicationControlUpdateRuleDataInput!
}

input ApplicationRefInput {
  by: ObjectRefBy! = ID
  input: String!
}

input AssignSiteBwLicenseInput {
  bw: Int
  licenseId: ID!
  site: SiteRefInput!
}

input AssignSocketToZtnaAppConnectorInput {
  description: String! = ""
  socketSerial: String!
  ztnaAppConnector: ZtnaAppConnectorRefInput!
}

input AuditFieldFilterInput {
  fieldName: FieldNameInput!
  operator: ElasticOperator!
  values: [String!]
}

input AuditingMetadataFilterInput {
  updatedBy: ActorRefInput
  updatedTime: DateTimeFilterInput
}

input AuditingMetadataSortInput {
  updatedBy: SortOrderInput
  updatedTime: SortOrderInput
}

""" Input parameters for querying available versions. """
input AvailableVersionListInput {
  platforms: [String!]!
}

input BandwidthManagementRefInput {
  by: ObjectRefBy! = ID
  input: String!
}

input BfdSettingsInput {
  multiplier: Int! = 5
  receiveInterval: Int! = 1000
  transmitInterval: Int! = 1000
}

input BgpCommunityFilterRuleInput {
  community: [BgpCommunityInput!]! = []
  predicate: BgpCommunityFilterPredicate
}

input BgpCommunityInput {
  from: Asn16!
  to: Asn16!
}

input BgpFilterRuleInput {
  bgpRouteExactAndInclusiveFilterRule: BgpRouteExactAndInclusiveFilterRuleInput
  bgpRouteExactFilterRule: BgpRouteExactFilterRuleInput
  communityFilterRule: BgpCommunityFilterRuleInput
}

input BgpPeerListInput {
  site: SiteRefInput!
}

input BgpPeerRefInput {
  by: ObjectRefBy! = ID
  input: String!
}

input BgpRouteExactAndInclusiveFilterRuleInput {
  ge: Int
  globalIpRange: [GlobalIpRangeRefInput!]! = []
  globalIpRangeException: [GlobalIpRangeRefInput!]! = []
  le: Int
  networkSubnet: [NetworkSubnet!]! = []
  networkSubnetException: [NetworkSubnet!]! = []
}

input BgpRouteExactFilterRuleInput {
  globalIpRange: [GlobalIpRangeRefInput!]! = []
  networkSubnet: [NetworkSubnet!]! = []
}

input BgpSummaryRouteInput {
  community: [BgpCommunityInput!]! = []
  route: NetworkSubnet!
}

input BgpTrackingInput {
  alertFrequency: PolicyRuleTrackingFrequencyEnum! = HOURLY
  enabled: Boolean! = false
  subscriptionId: ID!
}

input BooleanFilterInput {
  eq: Boolean
  neq: Boolean
}

input BooleanPredicate {
  is: String!
}

input CatalogApplicationActivityFilterInput {
  hasAny: [CatalogApplicationActivityRefInput!]
}

input CatalogApplicationActivityRefInput {
  by: ObjectRefBy! = ID
  input: String!
}

input CatalogApplicationCapabilityFilterInput {
  hasAny: [CatalogApplicationCapability!]
}

input CatalogApplicationCategoryFilterInput {
  hasAny: [ApplicationCategoryRefInput!]
}

input CatalogApplicationCategorySortInput {
  name: SortOrderInput
}

input CatalogApplicationContentTypeFilterInput {
  id: [IdFilterInput!]
  name: [StringFilterInput!]
}

input CatalogApplicationContentTypeGroupFilterInput {
  contentType: [CatalogApplicationContentTypeFilterInput!]
  id: [IdFilterInput!]
  name: [StringFilterInput!]
}

input CatalogApplicationContentTypeGroupListInput {
  filter: [CatalogApplicationContentTypeGroupFilterInput!]
  paging: PagingInput = {limit:100,from:0}
  sort: CatalogApplicationContentTypeGroupSortInput
}

input CatalogApplicationContentTypeGroupSortInput {
  name: SortOrderInput
}

input CatalogApplicationFilterInput {
  activity: [CatalogApplicationActivityFilterInput!]
  capability: [CatalogApplicationCapabilityFilterInput!]
  category: [CatalogApplicationCategoryFilterInput!]
  id: [IdFilterInput!]
  name: [StringFilterInput!]
  recentlyAdded: [BooleanFilterInput!]
  risk: [IntFilterInput!]
  type: [CatalogApplicationTypeFilterInput!]
}

input CatalogApplicationListInput {
  filter: [CatalogApplicationFilterInput!]
  paging: PagingInput = {limit:100,from:0}
  sort: CatalogApplicationSortInput
}

input CatalogApplicationSortInput {
  category: CatalogApplicationCategorySortInput
  description: SortOrderInput
  name: SortOrderInput
  risk: SortOrderInput
  type: SortOrderInput
}

input CatalogApplicationTypeFilterInput {
  eq: CatalogApplicationType
  in: [CatalogApplicationType!]
  neq: CatalogApplicationType
  nin: [CatalogApplicationType!]
}

""" Input for checking the connectivity status of a cloud interconnect connection. """
input CloudInterconnectConnectionConnectivityInput {
  id: ID!
}

""" Input for getting the ID of a physical connection at a cloud interconnect site. """
input CloudInterconnectPhysicalConnectionIdInput {
  haRole: HaRole!
  site: SiteRefInput!
}

""" Input for getting details of a physical connection at a cloud interconnect site. """
input CloudInterconnectPhysicalConnectionInput {
  id: ID!
}

input ContactDetailsInput {
  email: Email
  name: String
  phone: Phone
}

""" Add a container by ID or name """
input ContainerRefInput {
  by: ObjectRefBy! = ID
  input: String!
}

""" Filtering input to container search """
input ContainerSearchInput {
  refs: [ContainerRefInput!]! = []
  types: [ContainerType!]! = []
}

input CountryRefFilterInput {
  eq: CountryRefInput
  in: [CountryRefInput!]
  neq: CountryRefInput
  nin: [CountryRefInput!]
}

input CountryRefInput {
  by: ObjectRefBy! = ID
  input: String!
}

""" Input for creating FQDN typed container from file """
input CreateFqdnContainerFromFileInput {
  description: String!
  fileType: ContainerFileType! = CSV
  name: String!
  uploadFile: Upload
}

input CreateFqdnContainerFromListInput {
  description: String!
  name: String!
  values: [Fqdn!]! = []
}

""" Create a new group """
input CreateGroupInput {
  description: String
  members: [GroupMemberRefTypedInput!]
  name: String!
}

""" Input for creating IPAddressRange typed container from file """
input CreateIpAddressRangeContainerFromFileInput {
  description: String!
  fileType: ContainerFileType! = CSV
  name: String!
  uploadFile: Upload
}

input CreateIpAddressRangeContainerFromListInput {
  description: String!
  name: String!
  values: [IpAddressRangeInput!]! = []
}

input CreateLocationDetailsInput {
  companyName: String
  contact: ContactDetailsInput
  postalAddress: PostalAddressInput!
  vatId: String
}

input CreatePrivateApplicationInput {
  allowIcmpProtocol: Boolean! = true
  description: String
  internalAppAddress: IPAddressOrFqdn!
  name: String!
  privateAppProbing: PrivateAppProbingInput
  probingEnabled: Boolean! = true
  protocolPorts: [CustomServiceInput!]
  published: Boolean! = false
  publishedAppDomain: PublishedAppDomainInput
}

input CustomApplicationRefInput {
  by: ObjectRefBy! = ID
  input: String!
}

input CustomCategoryRefInput {
  by: ObjectRefBy! = ID
  input: String!
}

""" Add a Custom Service defined by a combination of L4 ports and an IP Protocol """
input CustomServiceInput {
  port: [Port!]
  portRange: PortRangeInput
  protocol: IpProtocol!
}

input CustomServiceIpInput {
  ip: IPAddress
  ipRange: IpAddressRangeInput
  name: String!
}

input DateTimeFilterInput {
  between: [DateTime!]
  eq: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  neq: DateTime
  nin: [DateTime!]
}

""" Identification of container for delete operation """
input DeleteContainerInput {
  ref: ContainerRefInput!
}

input DeletePrivateApplicationInput {
  privateApplication: PrivateApplicationRefInput!
}

""" Delete report input """
input DeleteReportInput {
  fileHash: String!
}

input DeleteStoryCommentInput {
  commentId: ID!
  storyId: ID!
}

input DeviceAttributeCatalogInput {
  filter: StringFilterInput
  paging: PagingInput
  sort: SortOrderInput
}

input DeviceAttributesInput {
  category: [String!]! = []
  manufacturer: [String!]! = []
  model: [String!]! = []
  os: [String!]! = []
  osVersion: [String!]! = []
  type: [String!]! = []
}

input DeviceAttributesUpdateInput {
  category: [String!]
  manufacturer: [String!]
  model: [String!]
  os: [String!]
  osVersion: [String!]
  type: [String!]
}

""" Filter input for device confidence level with equality and inclusion operators """
input DeviceCategoryFilterInput {
  eq: DeviceCategory
  in: [DeviceCategory!]
  neq: DeviceCategory
  nin: [DeviceCategory!]
}

input DeviceConfidenceLevelFilterInput {
  eq: DeviceConfidenceLevel
  in: [DeviceConfidenceLevel!]
  neq: DeviceConfidenceLevel
  nin: [DeviceConfidenceLevel!]
}

""" Input for CSV export with optional filtering """
input DeviceCsvExportInput {
  filter: [DeviceV2FilterInput!]
}

input DeviceHwFilterInput {
  manufacturer: [StringFilterInput!]
  model: [StringFilterInput!]
  type: [StringFilterInput!]
}

input DeviceHwSortOrderInput {
  manufacturer: SortOrderInput
  model: SortOrderInput
  type: SortOrderInput
}

input DeviceNetworkFilterInput {
  networkName: [StringFilterInput!]
  subnet: [StringFilterInput!]
}

input DeviceNetworkSortOrderInput {
  networkName: SortOrderInput
  subnet: SortOrderInput
}

input DeviceNicFilterInput {
  macAddress: [MacAddressFilterInput!]
  vendor: [StringFilterInput!]
}

input DeviceNicSortOrderInput {
  macAddress: SortOrderInput
  vendor: SortOrderInput
}

input DeviceOsFilterInput {
  product: [StringFilterInput!]
  vendor: [StringFilterInput!]
  version: [StringFilterInput!]
}

input DeviceOsSortOrderInput {
  product: SortOrderInput
  vendor: SortOrderInput
  version: SortOrderInput
}

input DeviceProfileRefInput {
  by: ObjectRefBy! = ID
  input: String!
}

input DeviceSiteSortOrderInput {
  id: SortOrderInput
  name: SortOrderInput
}

""" Input for sorting devices by various fields """
input DeviceSortInput {
  category: SortOrderInput
  confidence: SortOrderInput
  firstSeen: SortOrderInput
  hw: DeviceHwSortOrderInput
  id: SortOrderInput
  ip: SortOrderInput
  lastSeen: SortOrderInput
  name: SortOrderInput
  network: DeviceNetworkSortOrderInput
  nic: DeviceNicSortOrderInput
  os: DeviceOsSortOrderInput
  riskScore: SortOrderInput
  site: DeviceSiteSortOrderInput
  user: DeviceUserSortOrderInput
}

input DeviceUserSortOrderInput {
  id: SortOrderInput
  name: SortOrderInput
}

""" Input for filtering devices by various criteria """
input DeviceV2FilterInput {
  category: [StringFilterInput!]
  complianceState: [StringFilterInput!]
  confidence: [DeviceConfidenceLevelFilterInput!]
  firstSeen: [DateTimeFilterInput!]
  hw: DeviceHwFilterInput
  id: [IdFilterInput!]
  ip: [StringFilterInput!] @deprecated(reason: "Use ipAddress instead")
  ipAddress: [IPAddressFilterInput!]
  isManaged: [BooleanFilterInput!]
  lastSeen: [DateTimeFilterInput!]
  name: [StringFilterInput!]
  network: DeviceNetworkFilterInput
  nic: DeviceNicFilterInput
  originTypes: [OriginTypeFilterInput!]
  os: DeviceOsFilterInput
  riskScore: [IntFilterInput!]
  site: [SiteRefFilterInput!]
  user: [UserRefFilterInput!]
}

input DeviceV2Input {
  filter: [DeviceV2FilterInput!]
  paging: PagingInput! = {limit:100,from:0}
  sort: DeviceSortInput! = {id:{direction:DESC,priority:1}}
}

input Dimension {
  fieldName: AppStatsFieldName!
}

input DlpContentProfileRefInput {
  by: ObjectRefBy! = ID
  input: String!
}

input DlpEdmProfileRefInput {
  by: ObjectRefBy! = ID
  input: String!
}

""" Input for searching FQDN typed container to download its content """
input DownloadFqdnContainerFileInput {
  by: ObjectRefBy!
  input: String!
}

""" Input for searching IPAddressRange typed container to download its content """
input DownloadIpAddressRangeContainerFileInput {
  by: ObjectRefBy!
  input: String!
}

input DynamicIpAllocationAddRuleDataInput {
  country: [CountryRefInput!]! = []
  description: String! = ""
  enabled: Boolean!
  name: String!
  platform: [OperatingSystem!]! = []
  range: DynamicIpAllocationRangeInput!
  source: DynamicIpAllocationSourceInput! = {user:[],usersGroup:[]}
}

input DynamicIpAllocationAddRuleInput {
  at: PolicyRulePositionInput
  rule: DynamicIpAllocationAddRuleDataInput!
}

input DynamicIpAllocationPolicyInput {
  revision: PolicyRevisionInput
}

input DynamicIpAllocationPolicyMutationInput {
  revision: PolicyMutationRevisionInput
}

input DynamicIpAllocationPolicyUpdateInput {
  state: PolicyToggleState
}

input DynamicIpAllocationRangeInput {
  globalIpRange: GlobalIpRangeRefInput!
}

input DynamicIpAllocationRangeUpdateInput {
  globalIpRange: GlobalIpRangeRefInput
}

input DynamicIpAllocationRemoveRuleInput {
  id: ID!
}

input DynamicIpAllocationSourceInput {
  user: [UserRefInput!]! = []
  usersGroup: [UsersGroupRefInput!]! = []
}

input DynamicIpAllocationSourceUpdateInput {
  user: [UserRefInput!]
  usersGroup: [UsersGroupRefInput!]
}

input DynamicIpAllocationUpdateRuleDataInput {
  country: [CountryRefInput!]
  description: String
  enabled: Boolean
  name: String
  platform: [OperatingSystem!]
  range: DynamicIpAllocationRangeUpdateInput
  source: DynamicIpAllocationSourceUpdateInput
}

input DynamicIpAllocationUpdateRuleInput {
  id: ID!
  rule: DynamicIpAllocationUpdateRuleDataInput!
}

input EngineTypePredicate {
  in: [StoryEngineTypeEnum!]
  not_in: [StoryEngineTypeEnum!]
}

input EnterpriseDirectoryCreateLocationInput {
  businessUnit: String
  description: String
  details: CreateLocationDetailsInput!
  name: String!
  type: LocationType!
}

input EnterpriseDirectoryLocationListInput {
  filter: LocationFilterInput
  paging: PagingInput = {limit:100,from:0}
  sort: LocationSortInput = {name:{direction:ASC,priority:1}}
}

input EnterpriseDirectoryUpdateLocationInput {
  businessUnit: String
  description: String
  details: UpdateLocationDetailsInput
  id: ID!
  name: String
  type: LocationType
}

input EntityInput {
  id: ID!
  name: String
  type: EntityType!
}

input EventFeedFieldFilterInput {
  fieldName: EventFeedFilterFieldName!
  operator: EventFeedFilterOperator!
  values: [String!]
}

input EventsDimension {
  fieldName: EventFieldName!
}

input EventsFilter {
  fieldName: EventFieldName!
  operator: FilterOperator!
  values: [String!]!
}

input EventsMeasure {
  aggType: AggregationType!
  fieldName: EventFieldName!
  trend: Boolean
}

input EventsSort {
  fieldName: EventFieldName!
  order: DirectionEnum!
}

"""
FieldName for the different types of FieldName inputs
Use the EventFieldName for events, and AuditFieldName for audit
"""
input FieldNameInput {
  AuditFieldName: AuditFieldName
  EventFieldName: EventFieldName
}

"""
Defines the Floating Subnet object. Floating Subnets (ie. Floating Ranges) are used to identify traffic exactly matched
to the route advertised by BGP. They are not associated with a specific site.
This is useful in scenarios such as active-standby high availability routed via BGP.
"""
input FloatingSubnetRefInput {
  by: ObjectRefBy! = ID
  input: String!
}

""" Input for adding values to existing FQDN typed container """
input FqdnContainerAddValuesInput {
  ref: ContainerRefInput!
  values: [Fqdn!]! = []
}

input FqdnContainerRefInput {
  by: ObjectRefBy! = ID
  input: String!
}

""" Input for removing values from existing FQDN typed container """
input FqdnContainerRemoveValuesInput {
  ref: ContainerRefInput!
  values: [Fqdn!]! = []
}

""" Input for searching FQDN typed containers that contain a specific FQDN """
input FqdnContainerSearchFqdnInput {
  fqdn: Fqdn!
}

""" Input for searching FQDN typed container """
input FqdnContainerSearchInput {
  ref: ContainerRefInput!
}

input FreeTextFilterInput {
  search: String!
}

input GlobalIpRangeRefInput {
  by: ObjectRefBy! = ID
  input: String!
}

""" Apply filters when fetching the list of groups. """
input GroupListFilterInput {
  audit: [AuditingMetadataFilterInput!]
  freeText: FreeTextFilterInput
  id: [IdFilterInput!]
  member: [GroupMemberFilterInput!]
  name: [AdvancedStringFilterInput!]
}

""" List groups with optional filters, sorting, and pagination. """
input GroupListInput {
  filter: [GroupListFilterInput!]
  paging: PagingInput! = {limit:100,from:0}
  sort: GroupListSortInput! = {name:{direction:ASC,priority:1}}
}

""" Sort groups by name or audit metadata """
input GroupListSortInput {
  audit: AuditingMetadataSortInput
  name: SortOrderInput
}

""" Filter groups by member reference. """
input GroupMemberFilterInput {
  ref: GroupMemberRefTypedInput!
}

""" Filter member types using the supported operators """
input GroupMemberRefTypeFilterInput {
  eq: GroupMemberRefType
  in: [GroupMemberRefType!]
  neq: GroupMemberRefType
  nin: [GroupMemberRefType!]
}

""" A reference to a group member, used when adding or filtering members. """
input GroupMemberRefTypedInput {
  by: ObjectRefBy! = ID
  input: String!
  type: GroupMemberRefType!
}

""" Filters to narrow down group members that are fetched. """
input GroupMembersListFilterInput {
  name: [AdvancedStringFilterInput!]
  type: [GroupMemberRefTypeFilterInput!]
}

""" Filter, sort, and pagination applied when fetching the the list of group members. """
input GroupMembersListInput {
  filter: [GroupMembersListFilterInput!]
  paging: PagingInput! = {limit:100,from:0}
  sort: GroupMembersListSortInput! = {name:{direction:ASC,priority:2},type:{direction:ASC,priority:1}}
}

"""
Sort group members by one or more fields.
If multiple fields are specified, the system uses their priority to determine order. For example, type with priority 1 will be used first, then name with priority 2.
"""
input GroupMembersListSortInput {
  name: SortOrderInput
  type: SortOrderInput
}

input GroupRefInput {
  by: ObjectRefBy! = ID
  input: String!
}

input HardwareFilterInput {
  account: [AccountFilter!]
  countryCode: StringFilterInput
  countryName: [StringFilterInput!]
  freeText: FreeTextFilterInput
  id: [IdFilterInput!]
  licenseStartDate: [DateTimeFilterInput!]
  product: [StringFilterInput!]
  serialNumber: [StringFilterInput!]
  shippingStatus: [ShippingStatusFilterInput!]
  validAddress: BooleanFilterInput
}

input HardwareSearchInput {
  filter: HardwareFilterInput
  paging: PagingInput = {limit:100,from:0}
  sort: HardwareSortInput
}

input HardwareShippingDetailsInput {
  details: ShippingDetailsInput!
  powerCable: String
}

input HardwareSortInput {
  accountName: SortOrderInput
  country: SortOrderInput
  incoterms: SortOrderInput
  licenseId: SortOrderInput
  licenseStartDate: SortOrderInput
  productType: SortOrderInput
  quoteId: SortOrderInput
  shippingDate: SortOrderInput
  shippingStatus: SortOrderInput
  siteName: SortOrderInput
}

input HostRefInput {
  by: ObjectRefBy! = ID
  input: String!
}

input IPAddressFilterInput {
  between: [IPAddress!]
  eq: IPAddress
  in: [IPAddress!]
  neq: IPAddress
  nin: [IPAddress!]
  nwithin: NetworkSubnet
  within: NetworkSubnet
}

input IdFilterInput {
  eq: ID
  in: [ID!]
  neq: ID
  nin: [ID!]
}

input IntFilterInput {
  between: [Int!]
  eq: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  neq: Int
  nin: [Int!]
}

input IntPredicate {
  eq: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not_in: [Int!]
}

input InternetFirewallAddRuleDataInput {
  action: InternetFirewallActionEnum! = BLOCK
  activePeriod: PolicyRuleActivePeriodInput! = {useEffectiveFrom:false,useExpiresAt:false}
  connectionOrigin: ConnectionOriginEnum! = ANY
  country: [CountryRefInput!]! = []
  description: String! = ""
  destination: InternetFirewallDestinationInput! = {application:[],customApp:[],appCategory:[],customCategory:[],sanctionedAppsCategory:[],country:[],domain:[],fqdn:[],ip:[],subnet:[],ipRange:[],globalIpRange:[],remoteAsn:[]}
  device: [DeviceProfileRefInput!]! = []
  deviceAttributes: DeviceAttributesInput! = {category:[],type:[],model:[],manufacturer:[],os:[],osVersion:[]}
  deviceOS: [OperatingSystem!]! = []
  enabled: Boolean!
  exceptions: [InternetFirewallRuleExceptionInput!]! = []
  name: String!
  schedule: PolicyScheduleInput! = {activeOn:ALWAYS}
  service: InternetFirewallServiceTypeInput = {standard:[],custom:[]}
  source: InternetFirewallSourceInput! = {ip:[],host:[],site:[],subnet:[],ipRange:[],globalIpRange:[],networkInterface:[],siteNetworkSubnet:[],floatingSubnet:[],user:[],usersGroup:[],group:[],systemGroup:[]}
  tracking: PolicyTrackingInput! = {event:{enabled:false},alert:{enabled:false,frequency:HOURLY,subscriptionGroup:[],webhook:[],mailingList:[]}}
}

""" Rule parameters and relevant position """
input InternetFirewallAddRuleInput {
  at: PolicyRulePositionInput
  rule: InternetFirewallAddRuleDataInput!
}

input InternetFirewallContainerInput {
  fqdnContainer: [FqdnContainerRefInput!]! = []
  ipAddressRangeContainer: [IpAddressRangeContainerRefInput!]! = []
}

input InternetFirewallContainerUpdateInput {
  fqdnContainer: [FqdnContainerRefInput!]
  ipAddressRangeContainer: [IpAddressRangeContainerRefInput!]
}

""" Input of the settings for Destination of an Internet Firewall rule. To specify 'ANY' destination, an empty list must be provided for each match criteria field (e.g. application: [], country: [], etc...) """
input InternetFirewallDestinationInput {
  appCategory: [ApplicationCategoryRefInput!]! = []
  application: [ApplicationRefInput!]! = []
  # containers: InternetFirewallContainerInput! = {fqdnContainer: [], ipAddressRangeContainer: []}
  country: [CountryRefInput!]! = []
  customApp: [CustomApplicationRefInput!]! = []
  customCategory: [CustomCategoryRefInput!]! = []
  domain: [Domain!]! = []
  fqdn: [Fqdn!]! = []
  globalIpRange: [GlobalIpRangeRefInput!]! = []
  ip: [IPAddress!]! = []
  ipRange: [IpAddressRangeInput!]! = []
  remoteAsn: [Asn16!]! = []
  sanctionedAppsCategory: [SanctionedAppsCategoryRefInput!]! = []
  subnet: [NetworkSubnet!]! = []
}

""" Input of the settings for Destination of an Internet Firewall rule. To specify 'ANY' destination, an empty list must be provided for each match criteria field (e.g. application: [], country: [], etc...) """
input InternetFirewallDestinationUpdateInput {
  appCategory: [ApplicationCategoryRefInput!]
  application: [ApplicationRefInput!]
  # containers: InternetFirewallContainerUpdateInput
  country: [CountryRefInput!]
  customApp: [CustomApplicationRefInput!]
  customCategory: [CustomCategoryRefInput!]
  domain: [Domain!]
  fqdn: [Fqdn!]
  globalIpRange: [GlobalIpRangeRefInput!]
  ip: [IPAddress!]
  ipRange: [IpAddressRangeInput!]
  remoteAsn: [Asn16!]
  sanctionedAppsCategory: [SanctionedAppsCategoryRefInput!]
  subnet: [NetworkSubnet!]
}

input InternetFirewallPolicyInput {
  revision: PolicyRevisionInput
}

input InternetFirewallPolicyMutationInput {
  revision: PolicyMutationRevisionInput
}

input InternetFirewallPolicyUpdateInput {
  state: PolicyToggleState
}

input InternetFirewallRemoveRuleInput {
  id: ID!
}

""" Exceptions define when a rule is ignored, and the firewall policy evaluation continues with the lower priority rules. """
input InternetFirewallRuleExceptionInput {
  connectionOrigin: ConnectionOriginEnum! = ANY
  country: [CountryRefInput!]! = []
  destination: InternetFirewallDestinationInput! = {application:[],customApp:[],appCategory:[],customCategory:[],sanctionedAppsCategory:[],country:[],domain:[],fqdn:[],ip:[],subnet:[],ipRange:[],globalIpRange:[],remoteAsn:[]}
  device: [DeviceProfileRefInput!]! = []
  deviceAttributes: DeviceAttributesInput! = {category:[],type:[],model:[],manufacturer:[],os:[],osVersion:[]}
  deviceOS: [OperatingSystem!]! = []
  name: String!
  service: InternetFirewallServiceTypeInput! = {standard:[],custom:[]}
  source: InternetFirewallSourceInput! = {ip:[],host:[],site:[],subnet:[],ipRange:[],globalIpRange:[],networkInterface:[],siteNetworkSubnet:[],floatingSubnet:[],user:[],usersGroup:[],group:[],systemGroup:[]}
}

""" Input of the Service Type to which this Internet Firewall rule applies. To specify 'ANY' source, an empty list must be provided for each match criteria field (e.g. standard: [], custom: [], etc...) """
input InternetFirewallServiceTypeInput {
  custom: [CustomServiceInput!]! = []
  standard: [ServiceRefInput!]! = []
}

""" Input of the Service Type to which this Internet Firewall rule applies. To specify 'ANY' source, an empty list must be provided for each match criteria field (e.g. standard: [], custom: [], etc...) """
input InternetFirewallServiceTypeUpdateInput {
  custom: [CustomServiceInput!]
  standard: [ServiceRefInput!]
}

""" Input of the settings for Source of an Internet Firewall rule. To specify 'ANY' source, an empty list must be provided for each match criteria field (e.g. ip: [], group: [], etc...) """
input InternetFirewallSourceInput {
  floatingSubnet: [FloatingSubnetRefInput!]! = []
  globalIpRange: [GlobalIpRangeRefInput!]! = []
  group: [GroupRefInput!]! = []
  host: [HostRefInput!]! = []
  ip: [IPAddress!]! = []
  ipRange: [IpAddressRangeInput!]! = []
  networkInterface: [NetworkInterfaceRefInput!]! = []
  site: [SiteRefInput!]! = []
  siteNetworkSubnet: [SiteNetworkSubnetRefInput!]! = []
  subnet: [NetworkSubnet!]! = []
  systemGroup: [SystemGroupRefInput!]! = []
  user: [UserRefInput!]! = []
  usersGroup: [UsersGroupRefInput!]! = []
}

""" Input of the settings for Source of an Internet Firewall rule. To specify 'ANY' source, an empty list must be provided for each match criteria field (e.g. ip: [], group: [], etc...) """
input InternetFirewallSourceUpdateInput {
  floatingSubnet: [FloatingSubnetRefInput!]
  globalIpRange: [GlobalIpRangeRefInput!]
  group: [GroupRefInput!]
  host: [HostRefInput!]
  ip: [IPAddress!]
  ipRange: [IpAddressRangeInput!]
  networkInterface: [NetworkInterfaceRefInput!]
  site: [SiteRefInput!]
  siteNetworkSubnet: [SiteNetworkSubnetRefInput!]
  subnet: [NetworkSubnet!]
  systemGroup: [SystemGroupRefInput!]
  user: [UserRefInput!]
  usersGroup: [UsersGroupRefInput!]
}

input InternetFirewallUpdateRuleDataInput {
  action: InternetFirewallActionEnum
  activePeriod: PolicyRuleActivePeriodUpdateInput
  connectionOrigin: ConnectionOriginEnum
  country: [CountryRefInput!]
  description: String
  destination: InternetFirewallDestinationUpdateInput
  device: [DeviceProfileRefInput!]
  deviceAttributes: DeviceAttributesUpdateInput
  deviceOS: [OperatingSystem!]
  enabled: Boolean
  exceptions: [InternetFirewallRuleExceptionInput!]
  name: String
  schedule: PolicyScheduleUpdateInput
  service: InternetFirewallServiceTypeUpdateInput
  source: InternetFirewallSourceUpdateInput
  tracking: PolicyTrackingUpdateInput
}

input InternetFirewallUpdateRuleInput {
  id: ID!
  rule: InternetFirewallUpdateRuleDataInput!
}

""" Input for adding values to existing IPAddressRange typed container """
input IpAddressRangeContainerAddValuesInput {
  ref: ContainerRefInput!
  values: [IpAddressRangeInput!]! = []
}

input IpAddressRangeContainerRefInput {
  by: ObjectRefBy! = ID
  input: String!
}

""" Input for removing values from existing IPAddressRange typed container """
input IpAddressRangeContainerRemoveValuesInput {
  ref: ContainerRefInput!
  values: [IpAddressRangeInput!]! = []
}

""" Filtering input to IPAddressRange container search """
input IpAddressRangeContainerSearchInput {
  ref: ContainerRefInput!
}

""" Input for searching IPAddressRange typed containers that contain a specific IPAddressRange """
input IpAddressRangeContainerSearchIpAddressRangeInput {
  ipAddressRange: IpAddressRangeInput!
}

""" Inclusive range of IPs """
input IpAddressRangeInput {
  from: IPAddress!
  to: IPAddress!
}

input IpsecIkeV2MessageInput {
  cipher: IpSecCipher
  dhGroup: IpSecDHGroup
  integrity: IpSecHash
  prf: IpSecHash
}

input LastMileBwInput {
  downstream: Int
  downstreamMbpsPrecision: Float
  upstream: Int
  upstreamMbpsPrecision: Float
}

input LocationFilterInput {
  account: [AccountFilter!]
  countryCode: [StringFilterInput!]
  freeText: FreeTextFilterInput
  id: [IdFilterInput!]
  includeArchived: Boolean = false
  isShippingLocation: Boolean
  name: [StringFilterInput!]
  type: [LocationTypeFilterInput!]
}

input LocationSortInput {
  country: SortOrderInput
  name: SortOrderInput
  type: SortOrderInput
}

input LocationTypeFilterInput {
  eq: LocationType
  in: [LocationType!]
  neq: LocationType
  nin: [LocationType!]
}

input LookupFilterInput {
  filter: LookupFilterType
  value: String
}

input MacAddressFilterInput {
  eq: MacAddress
  in: [MacAddress!]
  neq: MacAddress
  nin: [MacAddress!]
}

input Measure {
  aggType: AggregationType!
  fieldName: AppStatsFieldName!
  trend: Boolean
}

input NetworkDhcpSettingsInput {
  dhcpMicrosegmentation: Boolean
  dhcpType: DhcpType!
  ipRange: IPRange
  relayGroupId: ID
}

input NetworkInterfaceRefInput {
  by: ObjectRefBy! = ID
  input: String!
}

input OriginTypeFilterInput {
  hasAll: [OriginType!]
  in: [OriginType!]
  nin: [OriginType!]
}

input PagingInput {
  from: Int! = 0
  limit: Int! = 100
}

""" Input for adding section info to a policy """
input PolicyAddSectionInfoInput {
  name: String!
}

""" Input for adding a section to a policy """
input PolicyAddSectionInput {
  at: PolicySectionPositionInput!
  section: PolicyAddSectionInfoInput!
}

input PolicyCreateRevisionInput {
  description: String! = ""
  name: String!
}

""" Input of data for a custom recurring time range that a rule is active """
input PolicyCustomRecurringInput {
  days: [DayOfWeek!]! = []
  from: Time!
  to: Time!
}

""" Input of data for a custom recurring time range that a rule is active """
input PolicyCustomRecurringUpdateInput {
  days: [DayOfWeek!]
  from: Time
  to: Time
}

""" Input of data for a custom one-time time range that a rule is active """
input PolicyCustomTimeframeInput {
  from: DateTime!
  to: DateTime!
}

""" Input of data for a custom one-time time range that a rule is active """
input PolicyCustomTimeframeUpdateInput {
  from: DateTime
  to: DateTime
}

""" Discards unpublished revision for the policy and reverts to the settings for the published policy. """
input PolicyDiscardRevisionInput {
  id: ID
}

""" Move the rule to a different position in the policy """
input PolicyMoveRuleInput {
  id: ID!
  to: PolicyRulePositionInput
}

""" Input for moving a section within a policy """
input PolicyMoveSectionInput {
  id: ID!
  to: PolicySectionPositionInput
}

""" Move the sub rule to a different position in the policy """
input PolicyMoveSubRuleInput {
  id: ID!
  to: PolicySubRulePositionInput!
}

input PolicyMutationRevisionInput {
  id: ID
}

"""
Published revision is the active policy
applied on the traffic.
In addition, when a policy is published, revision changes become visible
to other admins, and rules locked by the revision become unlocked
"""
input PolicyPublishRevisionInput {
  description: String
  name: String
}

""" Input for removing a section from a policy """
input PolicyRemoveSectionInput {
  id: ID!
}

""" Input for specifying a policy revision """
input PolicyRevisionInput {
  id: ID
  type: PolicyRevisionType = PRIVATE
}

""" Input of the time period during which the rule is active, outside this period, the rule is inactive """
input PolicyRuleActivePeriodInput {
  effectiveFrom: DateTime
  expiresAt: DateTime
  useEffectiveFrom: Boolean! = false
  useExpiresAt: Boolean! = false
}

""" Input of the time period during which the rule is active, outside this period, the rule is inactive """
input PolicyRuleActivePeriodUpdateInput {
  effectiveFrom: DateTime
  expiresAt: DateTime
  useEffectiveFrom: Boolean
  useExpiresAt: Boolean
}

""" Parameters required to define the rule position """
input PolicyRulePositionInput {
  position: PolicyRulePositionEnum
  ref: ID
}

""" Input of data for the alert settings for the rule """
input PolicyRuleTrackingAlertInput {
  enabled: Boolean! = false
  frequency: PolicyRuleTrackingFrequencyEnum! = HOURLY
  mailingList: [SubscriptionMailingListRefInput!]! = []
  subscriptionGroup: [SubscriptionGroupRefInput!]! = []
  webhook: [SubscriptionWebhookRefInput!]! = []
}

""" Input of data for the alert settings for the rule """
input PolicyRuleTrackingAlertUpdateInput {
  enabled: Boolean
  frequency: PolicyRuleTrackingFrequencyEnum
  mailingList: [SubscriptionMailingListRefInput!]
  subscriptionGroup: [SubscriptionGroupRefInput!]
  webhook: [SubscriptionWebhookRefInput!]
}

""" Input of data if an alert is sent for a rule """
input PolicyRuleTrackingEventInput {
  enabled: Boolean! = false
}

""" Input of data if an alert is sent for a rule """
input PolicyRuleTrackingEventUpdateInput {
  enabled: Boolean
}

input PolicyScheduleInput {
  activeOn: PolicyActiveOnEnum! = ALWAYS
  customRecurring: PolicyCustomRecurringInput
  customTimeframe: PolicyCustomTimeframeInput
}

input PolicyScheduleUpdateInput {
  activeOn: PolicyActiveOnEnum
  customRecurring: PolicyCustomRecurringUpdateInput
  customTimeframe: PolicyCustomTimeframeUpdateInput
}

input PolicySectionPositionInput {
  position: PolicySectionPositionEnum!
  ref: ID
}

""" Parameters required to define the rule position """
input PolicySubRulePositionInput {
  position: PolicySubRulePositionEnum!
  ref: ID!
}

input PolicyTrackingInput {
  alert: PolicyRuleTrackingAlertInput! = {enabled:false,frequency:HOURLY,subscriptionGroup:[],webhook:[],mailingList:[]}
  event: PolicyRuleTrackingEventInput! = {enabled:false}
}

input PolicyTrackingUpdateInput {
  alert: PolicyRuleTrackingAlertUpdateInput
  event: PolicyRuleTrackingEventUpdateInput
}

input PolicyUpdateSectionInfoInput {
  name: String
}

input PolicyUpdateSectionInput {
  id: ID!
  section: PolicyUpdateSectionInfoInput!
}

input PopLocationCloudInterconnectFilterInput {
  taggingMethod: TaggingMethodFilterInput
}

input PopLocationFilterInput {
  country: CountryRefFilterInput
  id: IdFilterInput
  interconnectTagging: PopLocationCloudInterconnectFilterInput
  isPrivate: BooleanFilterInput
  name: StringFilterInput
  primary: BooleanFilterInput
  siteLicenseRegion: StringFilterInput
}

input PopLocationRefInput {
  by: ObjectRefBy! = ID
  input: String!
}

""" Inclusive network port range """
input PortRangeInput {
  from: Port!
  to: Port!
}

input PortRangeUpdateInput {
  from: Port
  to: Port
}

input PostalAddressInput {
  cityName: String
  country: CountryRefInput!
  stateName: String
  street: String
  zipCode: String
}

input PrivateAccessAddRuleDataInput {
  action: PrivateAccessPolicyActionInput! = {action:ALLOW}
  activePeriod: PolicyRuleActivePeriodInput! = {useEffectiveFrom:false,useExpiresAt:false}
  applications: PrivateAccessPolicyApplicationInput!
  connectionOrigin: [PrivateAccessPolicyOriginEnum!]! = []
  country: [CountryRefInput!]! = []
  description: String! = ""
  device: [DeviceProfileRefInput!]! = []
  enabled: Boolean!
  name: String!
  platform: [OperatingSystem!]! = []
  schedule: PolicyScheduleInput! = {activeOn:ALWAYS}
  source: PrivateAccessPolicySourceInput! = {user:[],usersGroup:[]}
  tracking: PolicyTrackingInput! = {event:{enabled:false},alert:{enabled:false,frequency:HOURLY,subscriptionGroup:[],webhook:[],mailingList:[]}}
  userAttributes: PrivateAccessUserAttributesInput! = {riskScore:{category:ANY,operator:GTE}}
}

input PrivateAccessAddRuleInput {
  at: PolicyRulePositionInput
  rule: PrivateAccessAddRuleDataInput!
}

input PrivateAccessPolicyActionInput {
  action: PrivateAccessPolicyActionEnum! = ALLOW
}

input PrivateAccessPolicyActionUpdateInput {
  action: PrivateAccessPolicyActionEnum
}

input PrivateAccessPolicyApplicationInput {
  application: [PrivateApplicationRefInput!]! = []
}

input PrivateAccessPolicyApplicationUpdateInput {
  application: [PrivateApplicationRefInput!]
}

input PrivateAccessPolicyInput {
  revision: PolicyRevisionInput
}

input PrivateAccessPolicyMutationInput {
  revision: PolicyMutationRevisionInput
}

input PrivateAccessPolicySourceInput {
  user: [UserRefInput!]! = []
  usersGroup: [UsersGroupRefInput!]! = []
}

input PrivateAccessPolicySourceUpdateInput {
  user: [UserRefInput!]
  usersGroup: [UsersGroupRefInput!]
}

input PrivateAccessPolicyUpdateInput {
  state: PolicyToggleState
}

input PrivateAccessRemoveRuleInput {
  id: ID!
}

input PrivateAccessUpdateRuleDataInput {
  action: PrivateAccessPolicyActionUpdateInput
  activePeriod: PolicyRuleActivePeriodUpdateInput
  applications: PrivateAccessPolicyApplicationUpdateInput
  connectionOrigin: [PrivateAccessPolicyOriginEnum!]
  country: [CountryRefInput!]
  description: String
  device: [DeviceProfileRefInput!]
  enabled: Boolean
  name: String
  platform: [OperatingSystem!]
  schedule: PolicyScheduleUpdateInput
  source: PrivateAccessPolicySourceUpdateInput
  tracking: PolicyTrackingUpdateInput
  userAttributes: PrivateAccessUserAttributesUpdateInput
}

input PrivateAccessUpdateRuleInput {
  id: ID!
  rule: PrivateAccessUpdateRuleDataInput!
}

input PrivateAccessUserAttributesInput {
  riskScore: RiskScoreConditionInput! = {category:ANY,operator:GTE}
}

input PrivateAccessUserAttributesUpdateInput {
  riskScore: RiskScoreConditionUpdateInput
}

input PrivateAppProbingInput {
  faultThresholdDown: Int
  id: ID
  interval: Int
  type: String
}

input PrivateApplicationRefInput {
  by: ObjectRefBy! = ID
  input: String!
}

input PublishedAppDomainInput {
  catoIp: IPAddress
  connectorGroupName: String
  creationTime: DateTime
  id: ID
  publishedAppDomain: String
}

input RemotePortFwdAddRuleDataInput {
  description: String! = ""
  enabled: Boolean!
  externalIp: AllocatedIpRefInput!
  externalPortRange: PortRangeInput!
  forwardIcmp: Boolean! = false
  internalIp: IPAddress!
  internalPortRange: PortRangeInput!
  name: String!
  remoteIPs: RemotePortFwdRemoteIpsInput! = {ip:[],ipRange:[],subnet:[],globalIpRange:[]}
  restrictionType: RemotePortFwdRestrictionType! = ALLOW_LIST
  tracking: PolicyRuleTrackingAlertInput! = {enabled:false,frequency:HOURLY,subscriptionGroup:[],webhook:[],mailingList:[]}
}

""" Rule parameters and relevant position """
input RemotePortFwdAddRuleInput {
  at: PolicyRulePositionInput
  rule: RemotePortFwdAddRuleDataInput!
}

input RemotePortFwdPolicyInput {
  revision: PolicyRevisionInput
}

input RemotePortFwdPolicyMutationInput {
  revision: PolicyMutationRevisionInput
}

input RemotePortFwdPolicyUpdateInput {
  state: PolicyToggleState
}

input RemotePortFwdRemoteIpsInput {
  globalIpRange: [GlobalIpRangeRefInput!]! = []
  ip: [IPAddress!]! = []
  ipRange: [IpAddressRangeInput!]! = []
  subnet: [NetworkSubnet!]! = []
}

input RemotePortFwdRemoteIpsUpdateInput {
  globalIpRange: [GlobalIpRangeRefInput!]
  ip: [IPAddress!]
  ipRange: [IpAddressRangeInput!]
  subnet: [NetworkSubnet!]
}

input RemotePortFwdRemoveRuleInput {
  id: ID!
}

input RemotePortFwdUpdateRuleDataInput {
  description: String
  enabled: Boolean
  externalIp: AllocatedIpRefInput
  externalPortRange: PortRangeUpdateInput
  forwardIcmp: Boolean
  internalIp: IPAddress
  internalPortRange: PortRangeUpdateInput
  name: String
  remoteIPs: RemotePortFwdRemoteIpsUpdateInput
  restrictionType: RemotePortFwdRestrictionType
  tracking: PolicyRuleTrackingAlertUpdateInput
}

input RemotePortFwdUpdateRuleInput {
  id: ID!
  rule: RemotePortFwdUpdateRuleDataInput!
}

input RemoveBgpPeerInput {
  id: ID!
}

""" Input for removing a physical connection from a cloud interconnect site. """
input RemoveCloudInterconnectPhysicalConnectionInput {
  id: ID!
}

input RemoveIpsecIkeV2SiteTunnelsInput {
  tunnelId: [IPSecV2InterfaceId!]!
}

input RemoveSiteBwLicenseInput {
  licenseId: ID!
  site: SiteRefInput!
}

input RemoveSocketAddOnCardInput {
  expansionSlotNumbers: [SocketAddOnExpansionSlotNumber!]!
  site: SiteRefInput!
}

input RemoveZtnaAppConnectorInput {
  ztnaAppConnector: ZtnaAppConnectorRefInput!
}

input ReplaceSiteBwLicenseInput {
  bw: Int
  licenseIdToAdd: ID!
  licenseIdToRemove: ID!
  site: SiteRefInput!
}

input RiskScoreConditionInput {
  category: RiskScoreCategory! = ANY
  operator: RiskScoreOperator! = GTE
}

input RiskScoreConditionUpdateInput {
  category: RiskScoreCategory
  operator: RiskScoreOperator
}

input SanctionedAppsCategoryRefInput {
  by: ObjectRefBy! = ID
  input: String!
}

""" Sandbox reports query filter """
input SandboxReportsFilterInput {
  fileHash: [StringFilterInput!]
  fileName: [StringFilterInput!]
  reportCreateDate: [DateTimeFilterInput!]
}

""" Sandbox reports query input """
input SandboxReportsInput {
  filter: SandboxReportsFilterInput
  paging: PagingInput! = {limit:25,from:0}
  sort: SandboxReportsSortInput! = {reportCreateDate:{direction:DESC,priority:1}}
}

""" Sandbox reports query sorting """
input SandboxReportsSortInput {
  fileName: SortOrderInput
  reportCreateDate: SortOrderInput
}

input ServiceRefInput {
  by: ObjectRefBy! = ID
  input: String!
}

input ShippingDetailsInput {
  address: AddressInput
  comment: String
  contact: ContactDetailsInput
  incoterms: String
  instruction: String
  vatId: String
}

input ShippingStatusFilterInput {
  eq: ShippingStatus
  in: [ShippingStatus!]
  neq: ShippingStatus
  nin: [ShippingStatus!]
}

input SimpleServiceInput {
  name: SimpleServiceType!
}

input SiteBgpStatusInput {
  site: SiteRefInput!
}

input SiteNetworkSubnetRefInput {
  by: ObjectRefBy! = ID
  input: String!
}

input SiteRefFilterInput {
  eq: SiteRefInput
  in: [SiteRefInput!]
  neq: SiteRefInput
  nin: [SiteRefInput!]
}

input SiteRefInput {
  by: ObjectRefBy! = ID
  input: String!
}

""" Represents a single site upgrade request. """
input SiteUpgradeRequest {
  site: SiteRefInput!
  targetVersion: String!
}

input SocketAddOnCardInput {
  expansionSlotNumber: SocketAddOnExpansionSlotNumber!
  type: SocketAddOnType!
}

input SocketInterfaceAltWanInput {
  privateGatewayIp: IPAddress!
  privateInterfaceIp: IPAddress!
  privateNetwork: IPSubnet!
  privateVlanTag: Int
  publicGatewayIp: IPAddress
  publicInterfaceIp: IPAddress
  publicNetwork: IPSubnet
  publicVlanTag: Int
}

input SocketInterfaceBandwidthInput {
  downstreamBandwidth: Int
  downstreamBandwidthMbpsPrecision: Float @beta
  upstreamBandwidth: Int
  upstreamBandwidthMbpsPrecision: Float @beta
}

input SocketInterfaceLagInput {
  minLinks: Int!
}

input SocketInterfaceLanInput {
  localIp: IPAddress!
  subnet: IPSubnet!
  translatedSubnet: IPSubnet
}

input SocketInterfaceOffCloudInput {
  enabled: Boolean!
  publicIp: IPAddress
  publicStaticPort: Int
}

input SocketInterfaceVrrpInput {
  vrrpType: VrrpType
}

input SocketInterfaceWanInput {
  precedence: SocketInterfacePrecedenceEnum!
  role: SocketInterfaceRole!
}

input SocketInventoryFilterInput {
  freeText: FreeTextFilterInput
}

input SocketInventoryInput {
  filter: SocketInventoryFilterInput
  paging: PagingInput
  sort: SocketInventoryOrderInput
}

input SocketInventoryOrderInput {
  accountName: SortOrderInput
  deliverySiteName: SortOrderInput
  description: SortOrderInput
  hardwareVersion: SortOrderInput
  installedSite: SortOrderInput
  serialNumber: SortOrderInput
  shippingCompany: SortOrderInput
  shippingDate: SortOrderInput
  socketType: SortOrderInput
  status: SortOrderInput
}

input SocketLanAddRuleDataInput {
  description: String! = ""
  destination: SocketLanDestinationInput! = {vlan:[],ipRange:[],subnet:[],networkInterface:[],systemGroup:[],host:[],ip:[],globalIpRange:[],group:[],floatingSubnet:[],siteNetworkSubnet:[]}
  direction: SocketLanDirection! = TO
  enabled: Boolean!
  name: String!
  nat: SocketLanNatSettingsInput! = {enabled:false,natType:DYNAMIC_PAT}
  service: SocketLanServiceInput! = {simple:[],custom:[]}
  site: SocketLanSiteInput! = {site:[],group:[]}
  source: SocketLanSourceInput! = {vlan:[],ipRange:[],group:[],subnet:[],networkInterface:[],systemGroup:[],host:[],ip:[],globalIpRange:[],floatingSubnet:[],siteNetworkSubnet:[]}
  transport: SocketLanTransportType! = WAN
}

input SocketLanAddRuleInput {
  at: PolicyRulePositionInput
  rule: SocketLanAddRuleDataInput!
}

""" Input of the settings for Destination of a Wan Firewall rule. """
input SocketLanDestinationInput {
  floatingSubnet: [FloatingSubnetRefInput!]! = []
  globalIpRange: [GlobalIpRangeRefInput!]! = []
  group: [GroupRefInput!]! = []
  host: [HostRefInput!]! = []
  ip: [IPAddress!]! = []
  ipRange: [IpAddressRangeInput!]! = []
  networkInterface: [NetworkInterfaceRefInput!]! = []
  siteNetworkSubnet: [SiteNetworkSubnetRefInput!]! = []
  subnet: [NetworkSubnet!]! = []
  systemGroup: [SystemGroupRefInput!]! = []
  vlan: [Vlan!]! = []
}

""" Input of the settings for Destination of a Wan Firewall rule. """
input SocketLanDestinationUpdateInput {
  floatingSubnet: [FloatingSubnetRefInput!]
  globalIpRange: [GlobalIpRangeRefInput!]
  group: [GroupRefInput!]
  host: [HostRefInput!]
  ip: [IPAddress!]
  ipRange: [IpAddressRangeInput!]
  networkInterface: [NetworkInterfaceRefInput!]
  siteNetworkSubnet: [SiteNetworkSubnetRefInput!]
  subnet: [NetworkSubnet!]
  systemGroup: [SystemGroupRefInput!]
  vlan: [Vlan!]
}

input SocketLanFirewallAddRuleDataInput {
  action: SocketLanFirewallAction! = ALLOW
  application: SocketLanFirewallApplicationInput! = {application:[],customApp:[],domain:[],fqdn:[],ip:[],subnet:[],ipRange:[],globalIpRange:[]}
  description: String! = ""
  destination: SocketLanFirewallDestinationInput! = {vlan:[],ipRange:[],subnet:[],site:[],networkInterface:[],systemGroup:[],host:[],ip:[],globalIpRange:[],group:[],floatingSubnet:[],siteNetworkSubnet:[]}
  direction: SocketLanFirewallDirection! = TO
  enabled: Boolean!
  name: String!
  service: SocketLanFirewallServiceTypeInput! = {simple:[],standard:[],custom:[]}
  source: SocketLanFirewallSourceInput! = {vlan:[],mac:[],ipRange:[],group:[],subnet:[],site:[],networkInterface:[],systemGroup:[],host:[],ip:[],globalIpRange:[],floatingSubnet:[],siteNetworkSubnet:[]}
  tracking: PolicyTrackingInput! = {event:{enabled:false},alert:{enabled:false,frequency:HOURLY,subscriptionGroup:[],webhook:[],mailingList:[]}}
}

input SocketLanFirewallAddRuleInput {
  at: PolicySubRulePositionInput
  rule: SocketLanFirewallAddRuleDataInput!
}

""" Defines applications for the socket LAN firewall. """
input SocketLanFirewallApplicationInput {
  application: [ApplicationRefInput!]! = []
  customApp: [CustomApplicationRefInput!]! = []
  domain: [Domain!]! = []
  fqdn: [Fqdn!]! = []
  globalIpRange: [GlobalIpRangeRefInput!]! = []
  ip: [IPAddress!]! = []
  ipRange: [IpAddressRangeInput!]! = []
  subnet: [NetworkSubnet!]! = []
}

""" Defines applications for the socket LAN firewall. """
input SocketLanFirewallApplicationUpdateInput {
  application: [ApplicationRefInput!]
  customApp: [CustomApplicationRefInput!]
  domain: [Domain!]
  fqdn: [Fqdn!]
  globalIpRange: [GlobalIpRangeRefInput!]
  ip: [IPAddress!]
  ipRange: [IpAddressRangeInput!]
  subnet: [NetworkSubnet!]
}

""" Defines destinations for the socket LAN firewall. """
input SocketLanFirewallDestinationInput {
  floatingSubnet: [FloatingSubnetRefInput!]! = []
  globalIpRange: [GlobalIpRangeRefInput!]! = []
  group: [GroupRefInput!]! = []
  host: [HostRefInput!]! = []
  ip: [IPAddress!]! = []
  ipRange: [IpAddressRangeInput!]! = []
  networkInterface: [NetworkInterfaceRefInput!]! = []
  site: [SiteRefInput!]! = []
  siteNetworkSubnet: [SiteNetworkSubnetRefInput!]! = []
  subnet: [NetworkSubnet!]! = []
  systemGroup: [SystemGroupRefInput!]! = []
  vlan: [Vlan!]! = []
}

""" Defines destinations for the socket LAN firewall. """
input SocketLanFirewallDestinationUpdateInput {
  floatingSubnet: [FloatingSubnetRefInput!]
  globalIpRange: [GlobalIpRangeRefInput!]
  group: [GroupRefInput!]
  host: [HostRefInput!]
  ip: [IPAddress!]
  ipRange: [IpAddressRangeInput!]
  networkInterface: [NetworkInterfaceRefInput!]
  site: [SiteRefInput!]
  siteNetworkSubnet: [SiteNetworkSubnetRefInput!]
  subnet: [NetworkSubnet!]
  systemGroup: [SystemGroupRefInput!]
  vlan: [Vlan!]
}

input SocketLanFirewallRemoveRuleInput {
  id: ID!
}

""" Defines services used in the socket LAN firewall. """
input SocketLanFirewallServiceTypeInput {
  custom: [CustomServiceInput!]! = []
  simple: [SimpleServiceInput!]! = []
  standard: [ServiceRefInput!]! = []
}

""" Defines services used in the socket LAN firewall. """
input SocketLanFirewallServiceTypeUpdateInput {
  custom: [CustomServiceInput!]
  simple: [SimpleServiceInput!]
  standard: [ServiceRefInput!]
}

""" Defines sources for the socket LAN firewall. """
input SocketLanFirewallSourceInput {
  floatingSubnet: [FloatingSubnetRefInput!]! = []
  globalIpRange: [GlobalIpRangeRefInput!]! = []
  group: [GroupRefInput!]! = []
  host: [HostRefInput!]! = []
  ip: [IPAddress!]! = []
  ipRange: [IpAddressRangeInput!]! = []
  mac: [MacAddress!]! = []
  networkInterface: [NetworkInterfaceRefInput!]! = []
  site: [SiteRefInput!]! = []
  siteNetworkSubnet: [SiteNetworkSubnetRefInput!]! = []
  subnet: [NetworkSubnet!]! = []
  systemGroup: [SystemGroupRefInput!]! = []
  vlan: [Vlan!]! = []
}

""" Defines sources for the socket LAN firewall. """
input SocketLanFirewallSourceUpdateInput {
  floatingSubnet: [FloatingSubnetRefInput!]
  globalIpRange: [GlobalIpRangeRefInput!]
  group: [GroupRefInput!]
  host: [HostRefInput!]
  ip: [IPAddress!]
  ipRange: [IpAddressRangeInput!]
  mac: [MacAddress!]
  networkInterface: [NetworkInterfaceRefInput!]
  site: [SiteRefInput!]
  siteNetworkSubnet: [SiteNetworkSubnetRefInput!]
  subnet: [NetworkSubnet!]
  systemGroup: [SystemGroupRefInput!]
  vlan: [Vlan!]
}

input SocketLanFirewallUpdateRuleDataInput {
  action: SocketLanFirewallAction
  application: SocketLanFirewallApplicationUpdateInput
  description: String
  destination: SocketLanFirewallDestinationUpdateInput
  direction: SocketLanFirewallDirection
  enabled: Boolean
  name: String
  service: SocketLanFirewallServiceTypeUpdateInput
  source: SocketLanFirewallSourceUpdateInput
  tracking: PolicyTrackingUpdateInput
}

input SocketLanFirewallUpdateRuleInput {
  id: ID!
  rule: SocketLanFirewallUpdateRuleDataInput!
}

""" Defines NAT settings for the socket LAN policy. """
input SocketLanNatSettingsInput {
  enabled: Boolean! = false
  natType: SocketLanNatType! = DYNAMIC_PAT
}

""" Defines NAT settings for the socket LAN policy. """
input SocketLanNatSettingsUpdateInput {
  enabled: Boolean
  natType: SocketLanNatType
}

input SocketLanPolicyInput {
  revision: PolicyRevisionInput
}

input SocketLanPolicyMutationInput {
  revision: PolicyMutationRevisionInput
}

input SocketLanPolicyUpdateInput {
  state: PolicyToggleState
}

input SocketLanRemoveRuleInput {
  id: ID!
}

""" Defines services used in the socket LAN policy. """
input SocketLanServiceInput {
  custom: [CustomServiceInput!]! = []
  simple: [SimpleServiceInput!]! = []
}

""" Defines services used in the socket LAN policy. """
input SocketLanServiceUpdateInput {
  custom: [CustomServiceInput!]
  simple: [SimpleServiceInput!]
}

""" Represents the site configurations in the socket LAN policy. """
input SocketLanSiteInput {
  group: [GroupRefInput!]! = []
  site: [SiteRefInput!]! = []
}

""" Represents the site configurations in the socket LAN policy. """
input SocketLanSiteUpdateInput {
  group: [GroupRefInput!]
  site: [SiteRefInput!]
}

""" Defines sources for the socket LAN policy. """
input SocketLanSourceInput {
  floatingSubnet: [FloatingSubnetRefInput!]! = []
  globalIpRange: [GlobalIpRangeRefInput!]! = []
  group: [GroupRefInput!]! = []
  host: [HostRefInput!]! = []
  ip: [IPAddress!]! = []
  ipRange: [IpAddressRangeInput!]! = []
  networkInterface: [NetworkInterfaceRefInput!]! = []
  siteNetworkSubnet: [SiteNetworkSubnetRefInput!]! = []
  subnet: [NetworkSubnet!]! = []
  systemGroup: [SystemGroupRefInput!]! = []
  vlan: [Vlan!]! = []
}

""" Defines sources for the socket LAN policy. """
input SocketLanSourceUpdateInput {
  floatingSubnet: [FloatingSubnetRefInput!]
  globalIpRange: [GlobalIpRangeRefInput!]
  group: [GroupRefInput!]
  host: [HostRefInput!]
  ip: [IPAddress!]
  ipRange: [IpAddressRangeInput!]
  networkInterface: [NetworkInterfaceRefInput!]
  siteNetworkSubnet: [SiteNetworkSubnetRefInput!]
  subnet: [NetworkSubnet!]
  systemGroup: [SystemGroupRefInput!]
  vlan: [Vlan!]
}

input SocketLanUpdateRuleDataInput {
  description: String
  destination: SocketLanDestinationUpdateInput
  direction: SocketLanDirection
  enabled: Boolean
  name: String
  nat: SocketLanNatSettingsUpdateInput
  service: SocketLanServiceUpdateInput
  site: SocketLanSiteUpdateInput
  source: SocketLanSourceUpdateInput
  transport: SocketLanTransportType
}

input SocketLanUpdateRuleInput {
  id: ID!
  rule: SocketLanUpdateRuleDataInput!
}

input SocketPortMetricsDimension {
  fieldName: SocketPortMetricsFieldName!
}

input SocketPortMetricsFilter {
  fieldName: SocketPortMetricsFieldName!
  operator: FilterOperator!
  values: [String!]!
}

input SocketPortMetricsMeasure {
  aggType: AggregationType!
  fieldName: SocketPortMetricsFieldName!
  trend: Boolean
}

input SocketPortMetricsSort {
  fieldName: SocketPortMetricsFieldName!
  order: DirectionEnum!
}

input SortInput {
  field: String
  order: DirectionInput
}

input SortOrderInput {
  direction: SortOrder! = ASC
  priority: Int! = 1
}

""" Input for bulk site upgrade requests. """
input StartSiteUpgradeInput {
  upgrades: [SiteUpgradeRequest!]!
}

input StoryFilterInput {
  accountId: AccountIdPredicate
  criticality: IntPredicate
  engineType: EngineTypePredicate
  incidentId: StringPredicate
  ioa: StringPredicate
  muted: BooleanPredicate
  producer: StoryProducerPredicate
  queryName: StringPredicate
  severity: StorySeverityPredicate
  source: StringPredicate
  sourceIp: StringPredicate
  status: StoryStatusPredicate
  storyId: StoryIdPredicate
  timeFrame: TimeFramePredicate!
  vendor: VendorPredicate
  verdict: StoryVerdictPredicate
}

input StoryIdPredicate {
  in: [ID!]
  not_in: [ID!]
}

input StoryInput {
  filter: [StoryFilterInput!]!
  paging: PagingInput!
  sort: [StorySortInput!]
}

input StoryProducerPredicate {
  in: [StoryProducerEnum!]
  not_in: [StoryProducerEnum!]
}

input StorySeverityPredicate {
  in: [SeverityEnum!]
  not_in: [SeverityEnum!]
}

input StorySortInput {
  fieldName: StorySortFieldName!
  order: SortDirectionEnum
}

input StoryStatusPredicate {
  in: [StoryStatusEnum!]
  not_in: [StoryStatusEnum!]
}

input StoryThreatType {
  details: String
  name: String!
  recommendedAction: String
}

input StoryVerdictPredicate {
  in: [StoryVerdictEnum!]
  not_in: [StoryVerdictEnum!]
}

input StringFilterInput {
  eq: String
  in: [String!]
  neq: String
  nin: [String!]
}

input StringPredicate {
  contains: String
  in: [String]
  not_in: [String]
}

input StringValueSetRefInput {
  by: ObjectRefBy! = ID
  input: String!
}

input SubscriptionGroupRefInput {
  by: ObjectRefBy! = ID
  input: String!
}

input SubscriptionMailingListRefInput {
  by: ObjectRefBy! = ID
  input: String!
}

input SubscriptionWebhookRefInput {
  by: ObjectRefBy! = ID
  input: String!
}

input SystemGroupRefInput {
  by: ObjectRefBy! = ID
  input: String!
}

input TaggingMethodFilterInput {
  eq: TaggingMethod
  in: [TaggingMethod!]
  neq: TaggingMethod
  nin: [TaggingMethod!]
}

input TerminalServerAddRuleDataInput {
  allowedHostIP: GlobalIpRangeRefInput!
  description: String! = ""
  enabled: Boolean!
  excludeTraffic: [GlobalIpRangeRefInput!]! = []
  name: String!
}

input TerminalServerAddRuleInput {
  at: PolicyRulePositionInput
  rule: TerminalServerAddRuleDataInput!
}

input TerminalServerPolicyInput {
  revision: PolicyRevisionInput
}

input TerminalServerPolicyMutationInput {
  revision: PolicyMutationRevisionInput
}

input TerminalServerPolicyUpdateInput {
  state: PolicyToggleState
}

input TerminalServerRemoveRuleInput {
  id: ID!
}

input TerminalServerUpdateRuleDataInput {
  allowedHostIP: GlobalIpRangeRefInput
  description: String
  enabled: Boolean
  excludeTraffic: [GlobalIpRangeRefInput!]
  name: String
}

input TerminalServerUpdateRuleInput {
  id: ID!
  rule: TerminalServerUpdateRuleDataInput!
}

input TimeFramePredicate {
  time: TimeFrame!
  timeFrameModifier: TimeFrameModifier
}

input TlsInspectAddRuleDataInput {
  action: TlsInspectAction! = INSPECT
  application: TlsInspectApplicationInput! = {application:[],appCategory:[],country:[],customApp:[],customCategory:[],customServiceIp:[],domain:[],fqdn:[],subnet:[],ip:[],ipRange:[],globalIpRange:[],customService:[],remoteAsn:[],service:[],tlsInspectCategory:[]}
  connectionOrigin: ConnectionOriginEnum! = ANY
  country: [CountryRefInput!]! = []
  description: String! = ""
  devicePostureProfile: [DeviceProfileRefInput!]! = []
  enabled: Boolean!
  name: String!
  platform: [OperatingSystem!]! = []
  source: TlsInspectSourceInput! = {user:[],floatingSubnet:[],globalIpRange:[],group:[],host:[],subnet:[],ipRange:[],networkInterface:[],site:[],systemGroup:[],usersGroup:[],ip:[],siteNetworkSubnet:[]}
  untrustedCertificateAction: TlsInspectUntrustedCertificateAction! = ALLOW
}

input TlsInspectAddRuleInput {
  at: PolicyRulePositionInput
  rule: TlsInspectAddRuleDataInput!
}

""" Application match criteria set """
input TlsInspectApplicationInput {
  appCategory: [ApplicationCategoryRefInput!]! = []
  application: [ApplicationRefInput!]! = []
  country: [CountryRefInput!]! = []
  customApp: [CustomApplicationRefInput!]! = []
  customCategory: [CustomCategoryRefInput!]! = []
  customService: [CustomServiceInput!]! = []
  customServiceIp: [CustomServiceIpInput!]! = []
  domain: [Domain!]! = []
  fqdn: [Fqdn!]! = []
  globalIpRange: [GlobalIpRangeRefInput!]! = []
  ip: [IPAddress!]! = []
  ipRange: [IpAddressRangeInput!]! = []
  remoteAsn: [Asn32!]! = []
  service: [ServiceRefInput!]! = []
  subnet: [NetworkSubnet!]! = []
  tlsInspectCategory: [TlsInspectSystemCategory!]! = []
}

""" Application match criteria set """
input TlsInspectApplicationUpdateInput {
  appCategory: [ApplicationCategoryRefInput!]
  application: [ApplicationRefInput!]
  country: [CountryRefInput!]
  customApp: [CustomApplicationRefInput!]
  customCategory: [CustomCategoryRefInput!]
  customService: [CustomServiceInput!]
  customServiceIp: [CustomServiceIpInput!]
  domain: [Domain!]
  fqdn: [Fqdn!]
  globalIpRange: [GlobalIpRangeRefInput!]
  ip: [IPAddress!]
  ipRange: [IpAddressRangeInput!]
  remoteAsn: [Asn32!]
  service: [ServiceRefInput!]
  subnet: [NetworkSubnet!]
  tlsInspectCategory: [TlsInspectSystemCategory!]
}

input TlsInspectConfigInput {
  defaultRuleAction: TlsInspectAction! = INSPECT
  defaultRuleUntrustedCertificateAction: TlsInspectUntrustedCertificateAction! = ALLOW
}

input TlsInspectPolicyInput {
  revision: PolicyRevisionInput
}

input TlsInspectPolicyMutationInput {
  revision: PolicyMutationRevisionInput
}

input TlsInspectPolicyUpdateInput {
  additionalAttributes: TlsInspectConfigInput
  state: PolicyToggleState
}

input TlsInspectRemoveRuleInput {
  id: ID!
}

""" Input of the settings for Source of an TLS inspection rule """
input TlsInspectSourceInput {
  floatingSubnet: [FloatingSubnetRefInput!]! = []
  globalIpRange: [GlobalIpRangeRefInput!]! = []
  group: [GroupRefInput!]! = []
  host: [HostRefInput!]! = []
  ip: [IPAddress!]! = []
  ipRange: [IpAddressRangeInput!]! = []
  networkInterface: [NetworkInterfaceRefInput!]! = []
  site: [SiteRefInput!]! = []
  siteNetworkSubnet: [SiteNetworkSubnetRefInput!]! = []
  subnet: [NetworkSubnet!]! = []
  systemGroup: [SystemGroupRefInput!]! = []
  user: [UserRefInput!]! = []
  usersGroup: [UsersGroupRefInput!]! = []
}

""" Input of the settings for Source of an TLS inspection rule """
input TlsInspectSourceUpdateInput {
  floatingSubnet: [FloatingSubnetRefInput!]
  globalIpRange: [GlobalIpRangeRefInput!]
  group: [GroupRefInput!]
  host: [HostRefInput!]
  ip: [IPAddress!]
  ipRange: [IpAddressRangeInput!]
  networkInterface: [NetworkInterfaceRefInput!]
  site: [SiteRefInput!]
  siteNetworkSubnet: [SiteNetworkSubnetRefInput!]
  subnet: [NetworkSubnet!]
  systemGroup: [SystemGroupRefInput!]
  user: [UserRefInput!]
  usersGroup: [UsersGroupRefInput!]
}

input TlsInspectUpdateRuleDataInput {
  action: TlsInspectAction
  application: TlsInspectApplicationUpdateInput
  connectionOrigin: ConnectionOriginEnum
  country: [CountryRefInput!]
  description: String
  devicePostureProfile: [DeviceProfileRefInput!]
  enabled: Boolean
  name: String
  platform: [OperatingSystem!]
  source: TlsInspectSourceUpdateInput
  untrustedCertificateAction: TlsInspectUntrustedCertificateAction
}

input TlsInspectUpdateRuleInput {
  id: ID!
  rule: TlsInspectUpdateRuleDataInput!
}

input UnassignSocketFromZtnaAppConnectorInput {
  ztnaAppConnector: ZtnaAppConnectorRefInput!
}

input UpdateAccountInput {
  description: String
}

input UpdateAccountRoleInput {
  id: ID!
  name: String
}

input UpdateAdminInput {
  firstName: String
  lastName: String
  managedRoles: [UpdateAdminRoleInput!]
  mfaEnabled: Boolean @deprecated(reason: "It is recommended to always require MFA when using User Credential authentication.")
  passwordNeverExpires: Boolean
  resellerRoles: [UpdateAdminRoleInput!]
}

input UpdateAdminRoleInput {
  allowedAccounts: [ID!]
  allowedEntities: [EntityInput!]
  role: UpdateAccountRoleInput!
}

input UpdateBgpPeerInput {
  advertiseAllRoutes: Boolean
  advertiseDefaultRoute: Boolean
  advertiseSummaryRoutes: Boolean
  bfdEnabled: Boolean
  bfdSettings: BfdSettingsInput
  catoAsn: Asn16
  defaultAction: BgpDefaultAction
  defaultActionExclusion: [BgpFilterRuleInput!]
  holdTime: Int
  id: ID!
  keepaliveInterval: Int
  md5AuthKey: String
  metric: Int
  name: String
  peerAsn: Asn32
  peerIp: IPAddress
  performNat: Boolean
  summaryRoute: [BgpSummaryRouteInput!]
  tracking: BgpTrackingInput
}

""" Input for updating an existing physical connection at a cloud interconnect site. """
input UpdateCloudInterconnectPhysicalConnectionInput {
  downstreamBwLimit: NetworkBandwidth
  encapsulationMethod: TaggingMethod
  id: ID!
  popLocation: PopLocationRefInput
  privateCatoIp: IPAddress
  privateSiteIp: IPAddress
  serviceProviderName: String
  subnet: NetworkSubnet
  upstreamBwLimit: NetworkBandwidth
}

input UpdateCommercialLicenseInput {
  licenseId: ID!
  startDate: DateTime
}

""" Input for updating FQDN typed container from file """
input UpdateFqdnContainerFromFileInput {
  description: String
  fileType: ContainerFileType! = CSV
  ref: ContainerRefInput!
  uploadFile: Upload
}

input UpdateFqdnContainerFromListInput {
  description: String!
  ref: ContainerRefInput!
  values: [Fqdn!]
}

"""
Update attributes for a group. Only the provided fields are updated - the other fields are not changed
Note: You can only update a total of 500 group members at one time, this means 'membersToAdd + membersToRemove' or 'members' must be less than 500
"""
input UpdateGroupInput {
  description: String
  group: GroupRefInput!
  members: [GroupMemberRefTypedInput!]
  membersToAdd: [GroupMemberRefTypedInput!]
  membersToRemove: [GroupMemberRefTypedInput!]
  name: String
}

input UpdateHaInput {
  primaryManagementIp: IPAddress
  secondaryManagementIp: IPAddress
  vrid: Int
}

input UpdateHardwareShippingInput {
  details: HardwareShippingDetailsInput!
  ids: [ID!]!
}

""" Input for updating existing IPAddressRange typed container from file """
input UpdateIpAddressRangeContainerFromFileInput {
  description: String
  fileType: ContainerFileType! = CSV
  ref: ContainerRefInput!
  uploadFile: Upload
}

input UpdateIpAddressRangeContainerFromListInput {
  description: String!
  ref: ContainerRefInput!
  values: [IpAddressRangeInput!]
}

input UpdateIpsecIkeV2SiteGeneralDetailsInput {
  authMessage: IpsecIkeV2MessageInput
  connectionMode: ConnectionMode
  identificationType: IdentificationType
  initMessage: IpsecIkeV2MessageInput
  networkRanges: [IPSubnet]
}

input UpdateIpsecIkeV2SiteTunnelsInput {
  primary: UpdateIpsecIkeV2TunnelsInput
  secondary: UpdateIpsecIkeV2TunnelsInput
}

input UpdateIpsecIkeV2TunnelInput {
  lastMileBw: LastMileBwInput
  name: String
  privateCatoIp: IPAddress
  privateSiteIp: IPAddress
  psk: String
  publicSiteIp: IPAddress
  role: IPSecV2TunnelRole
  tunnelId: IPSecV2InterfaceId!
}

input UpdateIpsecIkeV2TunnelsInput {
  destinationType: DestinationType
  popLocationId: ID
  publicCatoIpId: ID
  tunnels: [UpdateIpsecIkeV2TunnelInput!]!
}

input UpdateLocationDetailsInput {
  companyName: String
  contact: ContactDetailsInput
  postalAddress: PostalAddressInput
  vatId: String
}

input UpdateNetworkRangeInput {
  azureFloatingIp: IPAddress
  dhcpSettings: NetworkDhcpSettingsInput
  gateway: IPAddress
  internetOnly: Boolean
  localIp: IPAddress
  mdnsReflector: Boolean
  name: String
  rangeType: SubnetType
  subnet: IPSubnet
  translatedSubnet: IPSubnet
  vlan: Int
}

input UpdatePrivateApplicationInput {
  allowIcmpProtocol: Boolean
  description: String
  id: ID!
  internalAppAddress: IPAddressOrFqdn
  name: String
  privateAppProbing: PrivateAppProbingInput
  probingEnabled: Boolean
  protocolPorts: [CustomServiceInput!]
  published: Boolean
  publishedAppDomain: PublishedAppDomainInput
}

input UpdateSecondaryAwsVSocketInput {
  id: ID!
  ipAddress: IPAddress
  routeTableId: String
  subnet: NetworkSubnet
}

input UpdateSecondaryAzureVSocketInput {
  floatingIp: IPAddress
  id: ID!
  interfaceIp: IPAddress
}

input UpdateServicePrincipalAdminInput {
  managedRoles: [UpdateAdminRoleInput!]
  name: String
  resellerRoles: [UpdateAdminRoleInput!]
}

input UpdateSiteBwLicenseInput {
  bw: Int!
  licenseId: ID!
  site: SiteRefInput!
}

input UpdateSiteGeneralDetailsInput {
  description: String
  name: String
  preferredPopLocation: UpdateSitePreferredPopLocationInput
  siteLocation: UpdateSiteLocationInput
  siteType: SiteType
}

input UpdateSiteLocationInput {
  address: String
  cityName: String
  countryCode: String
  stateCode: String
  timezone: String
}

input UpdateSitePreferredPopLocationInput {
  preferredOnly: Boolean!
  primary: PopLocationRefInput
  secondary: PopLocationRefInput
}

input UpdateSocketInterfaceInput {
  altWan: SocketInterfaceAltWanInput
  bandwidth: SocketInterfaceBandwidthInput
  destType: SocketInterfaceDestType!
  lag: SocketInterfaceLagInput
  lan: SocketInterfaceLanInput
  name: String
  offCloud: SocketInterfaceOffCloudInput
  vrrp: SocketInterfaceVrrpInput
  wan: SocketInterfaceWanInput
}

input UpdateStaticHostInput {
  ip: IPAddress
  macAddress: String
  name: String
}

input UpdateZtnaAppConnectorInput {
  description: String
  groupName: String
  id: ID!
  location: ZtnaAppConnectorLocationInput
  name: String
  preferredPopLocation: ZtnaAppConnectorPreferredPopLocationInput
}

"""
Input for updating ZTNA App Connectors configuration.
At least one field must be provided.
"""
input UpdateZtnaAppConnectorsConfigurationInput {
  appConnectorManagementRange: NetworkSubnet
  privateAppsServiceRange: NetworkSubnet
}

input UpgradeZtnaAppConnectorInput {
  upgrades: [ZtnaAppConnectorUpgradeRequest!]!
}

""" Upload file input """
input UploadFileInput {
  fileName: String!
}

input UserRefFilterInput {
  eq: UserRefInput
  in: [UserRefInput!]
  neq: UserRefInput
  nin: [UserRefInput!]
}

input UserRefInput {
  by: ObjectRefBy! = ID
  input: String!
}

input UsersGroupRefInput {
  by: ObjectRefBy! = ID
  input: String!
}

input VendorPredicate {
  in: [VendorEnum!]
  not_in: [VendorEnum!]
}

input WanFirewallAddRuleDataInput {
  action: WanFirewallActionEnum! = BLOCK
  activePeriod: PolicyRuleActivePeriodInput! = {useEffectiveFrom:false,useExpiresAt:false}
  application: WanFirewallApplicationInput! = {application:[],appCategory:[],customApp:[],customCategory:[],sanctionedAppsCategory:[],domain:[],fqdn:[],ip:[],subnet:[],ipRange:[],globalIpRange:[]}
  connectionOrigin: ConnectionOriginEnum! = ANY
  country: [CountryRefInput!]! = []
  description: String! = ""
  destination: WanFirewallDestinationInput! = {host:[],site:[],subnet:[],ip:[],ipRange:[],globalIpRange:[],networkInterface:[],siteNetworkSubnet:[],floatingSubnet:[],user:[],usersGroup:[],group:[],systemGroup:[]}
  device: [DeviceProfileRefInput!]! = []
  deviceAttributes: DeviceAttributesInput! = {category:[],type:[],model:[],manufacturer:[],os:[],osVersion:[]}
  deviceOS: [OperatingSystem!]! = []
  direction: WanFirewallDirectionEnum! = TO
  enabled: Boolean!
  exceptions: [WanFirewallRuleExceptionInput!]! = []
  name: String!
  schedule: PolicyScheduleInput! = {activeOn:ALWAYS}
  service: WanFirewallServiceTypeInput! = {standard:[],custom:[]}
  source: WanFirewallSourceInput! = {host:[],site:[],subnet:[],ip:[],ipRange:[],globalIpRange:[],networkInterface:[],siteNetworkSubnet:[],floatingSubnet:[],user:[],usersGroup:[],group:[],systemGroup:[]}
  tracking: PolicyTrackingInput! = {event:{enabled:false},alert:{enabled:false,frequency:HOURLY,subscriptionGroup:[],webhook:[],mailingList:[]}}
}

""" Rule parameters and relevant position """
input WanFirewallAddRuleInput {
  at: PolicyRulePositionInput
  rule: WanFirewallAddRuleDataInput!
}

""" Application match criteria set """
input WanFirewallApplicationInput {
  appCategory: [ApplicationCategoryRefInput!]! = []
  application: [ApplicationRefInput!]! = []
  customApp: [CustomApplicationRefInput!]! = []
  customCategory: [CustomCategoryRefInput!]! = []
  domain: [Domain!]! = []
  fqdn: [Fqdn!]! = []
  globalIpRange: [GlobalIpRangeRefInput!]! = []
  ip: [IPAddress!]! = []
  ipRange: [IpAddressRangeInput!]! = []
  sanctionedAppsCategory: [SanctionedAppsCategoryRefInput!]! = []
  subnet: [NetworkSubnet!]! = []
}

""" Application match criteria set """
input WanFirewallApplicationUpdateInput {
  appCategory: [ApplicationCategoryRefInput!]
  application: [ApplicationRefInput!]
  customApp: [CustomApplicationRefInput!]
  customCategory: [CustomCategoryRefInput!]
  domain: [Domain!]
  fqdn: [Fqdn!]
  globalIpRange: [GlobalIpRangeRefInput!]
  ip: [IPAddress!]
  ipRange: [IpAddressRangeInput!]
  sanctionedAppsCategory: [SanctionedAppsCategoryRefInput!]
  subnet: [NetworkSubnet!]
}

""" Input of the settings for Destination of a Wan Firewall rule. To specify 'ANY' destination, an empty list must be provided for each match criteria field (e.g. ip: [], group: [], etc...) """
input WanFirewallDestinationInput {
  floatingSubnet: [FloatingSubnetRefInput!]! = []
  globalIpRange: [GlobalIpRangeRefInput!]! = []
  group: [GroupRefInput!]! = []
  host: [HostRefInput!]! = []
  ip: [IPAddress!]! = []
  ipRange: [IpAddressRangeInput!]! = []
  networkInterface: [NetworkInterfaceRefInput!]! = []
  site: [SiteRefInput!]! = []
  siteNetworkSubnet: [SiteNetworkSubnetRefInput!]! = []
  subnet: [NetworkSubnet!]! = []
  systemGroup: [SystemGroupRefInput!]! = []
  user: [UserRefInput!]! = []
  usersGroup: [UsersGroupRefInput!]! = []
}

""" Input of the settings for Destination of a Wan Firewall rule. To specify 'ANY' destination, an empty list must be provided for each match criteria field (e.g. ip: [], group: [], etc...) """
input WanFirewallDestinationUpdateInput {
  floatingSubnet: [FloatingSubnetRefInput!]
  globalIpRange: [GlobalIpRangeRefInput!]
  group: [GroupRefInput!]
  host: [HostRefInput!]
  ip: [IPAddress!]
  ipRange: [IpAddressRangeInput!]
  networkInterface: [NetworkInterfaceRefInput!]
  site: [SiteRefInput!]
  siteNetworkSubnet: [SiteNetworkSubnetRefInput!]
  subnet: [NetworkSubnet!]
  systemGroup: [SystemGroupRefInput!]
  user: [UserRefInput!]
  usersGroup: [UsersGroupRefInput!]
}

input WanFirewallPolicyInput {
  revision: PolicyRevisionInput
}

input WanFirewallPolicyMutationInput {
  revision: PolicyMutationRevisionInput
}

input WanFirewallPolicyUpdateInput {
  state: PolicyToggleState
}

input WanFirewallRemoveRuleInput {
  id: ID!
}

""" Exceptions define when a rule is ignored, and the firewall policy evaluation continues with the lower priority rules. """
input WanFirewallRuleExceptionInput {
  application: WanFirewallApplicationInput! = {application:[],appCategory:[],customApp:[],customCategory:[],sanctionedAppsCategory:[],domain:[],fqdn:[],ip:[],subnet:[],ipRange:[],globalIpRange:[]}
  connectionOrigin: ConnectionOriginEnum! = ANY
  country: [CountryRefInput!]! = []
  destination: WanFirewallDestinationInput! = {host:[],site:[],subnet:[],ip:[],ipRange:[],globalIpRange:[],networkInterface:[],siteNetworkSubnet:[],floatingSubnet:[],user:[],usersGroup:[],group:[],systemGroup:[]}
  device: [DeviceProfileRefInput!]! = []
  deviceAttributes: DeviceAttributesInput! = {category:[],type:[],model:[],manufacturer:[],os:[],osVersion:[]}
  deviceOS: [OperatingSystem!]! = []
  direction: WanFirewallDirectionEnum! = TO
  name: String!
  service: WanFirewallServiceTypeInput! = {standard:[],custom:[]}
  source: WanFirewallSourceInput! = {host:[],site:[],subnet:[],ip:[],ipRange:[],globalIpRange:[],networkInterface:[],siteNetworkSubnet:[],floatingSubnet:[],user:[],usersGroup:[],group:[],systemGroup:[]}
}

""" Input of the Service Type to which this Wan Firewall rule applies. To specify 'ANY' source, an empty list must be provided for each match criteria field (e.g. standard: [], custom: [], etc...) """
input WanFirewallServiceTypeInput {
  custom: [CustomServiceInput!]! = []
  standard: [ServiceRefInput!]! = []
}

""" Input of the Service Type to which this Wan Firewall rule applies. To specify 'ANY' source, an empty list must be provided for each match criteria field (e.g. standard: [], custom: [], etc...) """
input WanFirewallServiceTypeUpdateInput {
  custom: [CustomServiceInput!]
  standard: [ServiceRefInput!]
}

""" Input of the settings for Source of an Wan Firewall rule. To specify 'ANY' source, an empty list must be provided for each match criteria field (e.g. ip: [], group: [], etc...) """
input WanFirewallSourceInput {
  floatingSubnet: [FloatingSubnetRefInput!]! = []
  globalIpRange: [GlobalIpRangeRefInput!]! = []
  group: [GroupRefInput!]! = []
  host: [HostRefInput!]! = []
  ip: [IPAddress!]! = []
  ipRange: [IpAddressRangeInput!]! = []
  networkInterface: [NetworkInterfaceRefInput!]! = []
  site: [SiteRefInput!]! = []
  siteNetworkSubnet: [SiteNetworkSubnetRefInput!]! = []
  subnet: [NetworkSubnet!]! = []
  systemGroup: [SystemGroupRefInput!]! = []
  user: [UserRefInput!]! = []
  usersGroup: [UsersGroupRefInput!]! = []
}

""" Input of the settings for Source of an Wan Firewall rule. To specify 'ANY' source, an empty list must be provided for each match criteria field (e.g. ip: [], group: [], etc...) """
input WanFirewallSourceUpdateInput {
  floatingSubnet: [FloatingSubnetRefInput!]
  globalIpRange: [GlobalIpRangeRefInput!]
  group: [GroupRefInput!]
  host: [HostRefInput!]
  ip: [IPAddress!]
  ipRange: [IpAddressRangeInput!]
  networkInterface: [NetworkInterfaceRefInput!]
  site: [SiteRefInput!]
  siteNetworkSubnet: [SiteNetworkSubnetRefInput!]
  subnet: [NetworkSubnet!]
  systemGroup: [SystemGroupRefInput!]
  user: [UserRefInput!]
  usersGroup: [UsersGroupRefInput!]
}

input WanFirewallUpdateRuleDataInput {
  action: WanFirewallActionEnum
  activePeriod: PolicyRuleActivePeriodUpdateInput
  application: WanFirewallApplicationUpdateInput
  connectionOrigin: ConnectionOriginEnum
  country: [CountryRefInput!]
  description: String
  destination: WanFirewallDestinationUpdateInput
  device: [DeviceProfileRefInput!]
  deviceAttributes: DeviceAttributesUpdateInput
  deviceOS: [OperatingSystem!]
  direction: WanFirewallDirectionEnum
  enabled: Boolean
  exceptions: [WanFirewallRuleExceptionInput!]
  name: String
  schedule: PolicyScheduleUpdateInput
  service: WanFirewallServiceTypeUpdateInput
  source: WanFirewallSourceUpdateInput
  tracking: PolicyTrackingUpdateInput
}

input WanFirewallUpdateRuleInput {
  id: ID!
  rule: WanFirewallUpdateRuleDataInput!
}

input WanNetworkAddRuleDataInput {
  application: WanNetworkRuleApplicationInput! = {application:[],appCategory:[],customApp:[],customCategory:[],customServiceIp:[],customService:[],domain:[],fqdn:[],service:[]}
  bandwidthPriority: BandwidthManagementRefInput!
  configuration: WanNetworkRuleConfigurationInput! = {activeTcpAcceleration:false,packetLossMitigation:false,preserveSourcePort:false,primaryTransport:{transportType:AUTOMATIC,primaryInterfaceRole:AUTOMATIC,secondaryInterfaceRole:AUTOMATIC},secondaryTransport:{transportType:AUTOMATIC,primaryInterfaceRole:AUTOMATIC,secondaryInterfaceRole:AUTOMATIC},allocationIp:[],popLocation:[],backhaulingSite:[]}
  description: String! = ""
  destination: WanNetworkRuleDestinationInput! = {user:[],floatingSubnet:[],globalIpRange:[],group:[],host:[],ip:[],ipRange:[],networkInterface:[],subnet:[],site:[],siteNetworkSubnet:[],systemGroup:[],usersGroup:[]}
  enabled: Boolean!
  exceptions: [WanNetworkRuleExceptionInput!]! = []
  name: String!
  routeType: WanNetworkRuleRouteType! = NONE
  ruleType: WanNetworkRuleType! = WAN
  source: WanNetworkRuleSourceInput! = {user:[],floatingSubnet:[],globalIpRange:[],group:[],host:[],ip:[],ipRange:[],networkInterface:[],subnet:[],site:[],siteNetworkSubnet:[],systemGroup:[],usersGroup:[]}
}

input WanNetworkAddRuleInput {
  at: PolicyRulePositionInput
  rule: WanNetworkAddRuleDataInput!
}

input WanNetworkPolicyInput {
  revision: PolicyRevisionInput
}

input WanNetworkPolicyMutationInput {
  revision: PolicyMutationRevisionInput
}

input WanNetworkPolicyUpdateInput {
  state: PolicyToggleState
}

input WanNetworkRemoveRuleInput {
  id: ID!
}

input WanNetworkRuleApplicationInput {
  appCategory: [ApplicationCategoryRefInput!]! = []
  application: [ApplicationRefInput!]! = []
  customApp: [CustomApplicationRefInput!]! = []
  customCategory: [CustomCategoryRefInput!]! = []
  customService: [CustomServiceInput!]! = []
  customServiceIp: [CustomServiceIpInput!]! = []
  domain: [Domain!]! = []
  fqdn: [Fqdn!]! = []
  service: [ServiceRefInput!]! = []
}

input WanNetworkRuleApplicationUpdateInput {
  appCategory: [ApplicationCategoryRefInput!]
  application: [ApplicationRefInput!]
  customApp: [CustomApplicationRefInput!]
  customCategory: [CustomCategoryRefInput!]
  customService: [CustomServiceInput!]
  customServiceIp: [CustomServiceIpInput!]
  domain: [Domain!]
  fqdn: [Fqdn!]
  service: [ServiceRefInput!]
}

input WanNetworkRuleConfigurationInput {
  activeTcpAcceleration: Boolean! = false
  allocationIp: [AllocatedIpRefInput!]! = []
  backhaulingSite: [SiteRefInput!]! = []
  packetLossMitigation: Boolean! = false
  popLocation: [PopLocationRefInput!]! = []
  preserveSourcePort: Boolean! = false
  primaryTransport: WanNetworkRuleTransportInput! = {transportType:AUTOMATIC,primaryInterfaceRole:AUTOMATIC,secondaryInterfaceRole:AUTOMATIC}
  secondaryTransport: WanNetworkRuleTransportInput! = {transportType:AUTOMATIC,primaryInterfaceRole:AUTOMATIC,secondaryInterfaceRole:AUTOMATIC}
}

input WanNetworkRuleConfigurationUpdateInput {
  activeTcpAcceleration: Boolean
  allocationIp: [AllocatedIpRefInput!]
  backhaulingSite: [SiteRefInput!]
  packetLossMitigation: Boolean
  popLocation: [PopLocationRefInput!]
  preserveSourcePort: Boolean
  primaryTransport: WanNetworkRuleTransportUpdateInput
  secondaryTransport: WanNetworkRuleTransportUpdateInput
}

input WanNetworkRuleDestinationInput {
  floatingSubnet: [FloatingSubnetRefInput!]! = []
  globalIpRange: [GlobalIpRangeRefInput!]! = []
  group: [GroupRefInput!]! = []
  host: [HostRefInput!]! = []
  ip: [IPAddress!]! = []
  ipRange: [IpAddressRangeInput!]! = []
  networkInterface: [NetworkInterfaceRefInput!]! = []
  site: [SiteRefInput!]! = []
  siteNetworkSubnet: [SiteNetworkSubnetRefInput!]! = []
  subnet: [NetworkSubnet!]! = []
  systemGroup: [SystemGroupRefInput!]! = []
  user: [UserRefInput!]! = []
  usersGroup: [UsersGroupRefInput!]! = []
}

input WanNetworkRuleDestinationUpdateInput {
  floatingSubnet: [FloatingSubnetRefInput!]
  globalIpRange: [GlobalIpRangeRefInput!]
  group: [GroupRefInput!]
  host: [HostRefInput!]
  ip: [IPAddress!]
  ipRange: [IpAddressRangeInput!]
  networkInterface: [NetworkInterfaceRefInput!]
  site: [SiteRefInput!]
  siteNetworkSubnet: [SiteNetworkSubnetRefInput!]
  subnet: [NetworkSubnet!]
  systemGroup: [SystemGroupRefInput!]
  user: [UserRefInput!]
  usersGroup: [UsersGroupRefInput!]
}

input WanNetworkRuleExceptionInput {
  application: WanNetworkRuleApplicationInput! = {application:[],appCategory:[],customApp:[],customCategory:[],customServiceIp:[],customService:[],domain:[],fqdn:[],service:[]}
  destination: WanNetworkRuleDestinationInput! = {user:[],floatingSubnet:[],globalIpRange:[],group:[],host:[],ip:[],ipRange:[],networkInterface:[],subnet:[],site:[],siteNetworkSubnet:[],systemGroup:[],usersGroup:[]}
  name: String!
  source: WanNetworkRuleSourceInput! = {user:[],floatingSubnet:[],globalIpRange:[],group:[],host:[],ip:[],ipRange:[],networkInterface:[],subnet:[],site:[],siteNetworkSubnet:[],systemGroup:[],usersGroup:[]}
}

input WanNetworkRuleSourceInput {
  floatingSubnet: [FloatingSubnetRefInput!]! = []
  globalIpRange: [GlobalIpRangeRefInput!]! = []
  group: [GroupRefInput!]! = []
  host: [HostRefInput!]! = []
  ip: [IPAddress!]! = []
  ipRange: [IpAddressRangeInput!]! = []
  networkInterface: [NetworkInterfaceRefInput!]! = []
  site: [SiteRefInput!]! = []
  siteNetworkSubnet: [SiteNetworkSubnetRefInput!]! = []
  subnet: [NetworkSubnet!]! = []
  systemGroup: [SystemGroupRefInput!]! = []
  user: [UserRefInput!]! = []
  usersGroup: [UsersGroupRefInput!]! = []
}

input WanNetworkRuleSourceUpdateInput {
  floatingSubnet: [FloatingSubnetRefInput!]
  globalIpRange: [GlobalIpRangeRefInput!]
  group: [GroupRefInput!]
  host: [HostRefInput!]
  ip: [IPAddress!]
  ipRange: [IpAddressRangeInput!]
  networkInterface: [NetworkInterfaceRefInput!]
  site: [SiteRefInput!]
  siteNetworkSubnet: [SiteNetworkSubnetRefInput!]
  subnet: [NetworkSubnet!]
  systemGroup: [SystemGroupRefInput!]
  user: [UserRefInput!]
  usersGroup: [UsersGroupRefInput!]
}

input WanNetworkRuleTransportInput {
  primaryInterfaceRole: WanNetworkRuleInterfaceRole! = AUTOMATIC
  secondaryInterfaceRole: WanNetworkRuleInterfaceRole! = AUTOMATIC
  transportType: WanNetworkRuleTransportType! = AUTOMATIC
}

input WanNetworkRuleTransportUpdateInput {
  primaryInterfaceRole: WanNetworkRuleInterfaceRole
  secondaryInterfaceRole: WanNetworkRuleInterfaceRole
  transportType: WanNetworkRuleTransportType
}

input WanNetworkUpdateRuleDataInput {
  application: WanNetworkRuleApplicationUpdateInput
  bandwidthPriority: BandwidthManagementRefInput
  configuration: WanNetworkRuleConfigurationUpdateInput
  description: String
  destination: WanNetworkRuleDestinationUpdateInput
  enabled: Boolean
  exceptions: [WanNetworkRuleExceptionInput!]
  name: String
  routeType: WanNetworkRuleRouteType
  ruleType: WanNetworkRuleType
  source: WanNetworkRuleSourceUpdateInput
}

input WanNetworkUpdateRuleInput {
  id: ID!
  rule: WanNetworkUpdateRuleDataInput!
}

input ZtnaAppConnectorConnectivityStatusFilterInput {
  eq: ZtnaAppConnectorConnectivityStatus
  in: [ZtnaAppConnectorConnectivityStatus!]
  neq: ZtnaAppConnectorConnectivityStatus
  nin: [ZtnaAppConnectorConnectivityStatus!]
}

""" Filter object for connector group listing """
input ZtnaAppConnectorGroupListFilterInput {
  search: FreeTextFilterInput
}

input ZtnaAppConnectorGroupListInput {
  filter: ZtnaAppConnectorGroupListFilterInput
  paging: PagingInput = {limit:100,from:0}
}

input ZtnaAppConnectorGroupSnapshotFilterInput {
  connectedPop: [StringFilterInput!]
  connectivityStatus: [ZtnaAppConnectorConnectivityStatusFilterInput!]
  connectorName: [StringFilterInput!]
  country: [StringFilterInput!]
  deviceVersion: [StringFilterInput!]
  dnsServer: [StringFilterInput!]
  freeText: [FreeTextFilterInput!]
  groupName: [StringFilterInput!]
  id: [IdFilterInput!]
  lanIp: [StringFilterInput!]
  model: [ZtnaAppConnectorModelFilterInput!]
  privateApp: [StringFilterInput!]
  serialNumber: [StringFilterInput!]
}

input ZtnaAppConnectorGroupSnapshotInput {
  filter: ZtnaAppConnectorGroupSnapshotFilterInput
  paging: PagingInput = {limit:100,from:0}
}

input ZtnaAppConnectorListFilterInput {
  groupName: [StringFilterInput!]
  isAssigned: BooleanFilterInput
  name: [StringFilterInput!]
  searchGroupName: FreeTextFilterInput
  searchName: FreeTextFilterInput
  type: ZtnaAppConnectorTypeFilterInput
}

input ZtnaAppConnectorListInput {
  filter: ZtnaAppConnectorListFilterInput
  paging: PagingInput = {limit:100,from:0}
}

input ZtnaAppConnectorLocationInput {
  address: String
  city: String!
  countryCode: String!
  stateCode: String
  timezone: TimeZone!
}

input ZtnaAppConnectorModelFilterInput {
  eq: SocketModel
  in: [SocketModel!]
  neq: SocketModel
  nin: [SocketModel!]
}

input ZtnaAppConnectorPreferredPopLocationInput {
  automatic: Boolean!
  preferredOnly: Boolean!
  primary: PopLocationRefInput
  secondary: PopLocationRefInput
}

input ZtnaAppConnectorRefInput {
  by: ObjectRefBy! = ID
  input: String!
}

input ZtnaAppConnectorSnapshotFilterInput {
  connectedPop: [StringFilterInput!]
  connectivityStatus: [ZtnaAppConnectorConnectivityStatusFilterInput!]
  connectorName: [StringFilterInput!]
  country: [StringFilterInput!]
  deviceVersion: [StringFilterInput!]
  dnsServer: [StringFilterInput!]
  freeText: [FreeTextFilterInput!]
  groupName: [StringFilterInput!]
  id: [IdFilterInput!]
  lanIp: [StringFilterInput!]
  model: [ZtnaAppConnectorModelFilterInput!]
  privateApp: [StringFilterInput!]
  serialNumber: [StringFilterInput!]
}

input ZtnaAppConnectorSnapshotInput {
  filter: ZtnaAppConnectorSnapshotFilterInput
  paging: PagingInput = {limit:100,from:0}
  sort: ZtnaAppConnectorSnapshotSortInput
}

input ZtnaAppConnectorSnapshotSortInput {
  connectivity: SortOrderInput
  name: SortOrderInput
}

input ZtnaAppConnectorSnapshotSummaryFilterInput {
  connectivityStatus: [ZtnaAppConnectorConnectivityStatusFilterInput!]
}

input ZtnaAppConnectorSnapshotSummaryInput {
  filter: ZtnaAppConnectorSnapshotSummaryFilterInput
}

""" Filter input for ZTNA App Connector type """
input ZtnaAppConnectorTypeFilterInput {
  eq: ZtnaAppConnectorType
  in: [ZtnaAppConnectorType!]
  neq: ZtnaAppConnectorType
  nin: [ZtnaAppConnectorType!]
}

input ZtnaAppConnectorUpgradeRequest {
  targetVersion: String!
  ztnaAppConnector: ZtnaAppConnectorRefInput!
}

##### Scalars ##########################
""" Application Risk """
scalar ApplicationRisk

""" 16 bit autonomous system number [0-65535] """
scalar Asn16

""" 32 bit autonomous system number [0-4294967295] """
scalar Asn32

""" 2006-01-02 """
scalar Date

""" 2006-01-02T15:04:05Z07:00 (RFC3339) """
scalar DateTime

"""
Top level domain is actually second level domain (e.g. example.com)
It is recommended to use as a broad way of distinguishing domains, because they **frequently use multiple hosts**.
"""
scalar Domain

""" Email address. E.g.: user@company.org """
scalar Email

""" Fully Qualified Domain Name: An exact host name (e.g. www.example.com) """
scalar Fqdn

""" Http header name """
scalar HttpHeaderName

""" Http header value """
scalar HttpHeaderValue

""" An IPv4 IP address """
scalar IPAddress

""" An IPv4 IP address or Fqdn type """
scalar IPAddressOrFqdn

""" A from-to range (used for DHCP range, for example) """
scalar IPRange

scalar IPSubnet

""" FF:FF:FF:FF OR FF-FF-FF-FF """
scalar MacAddress

"""
A generic key-value map.

Represents an arbitrary JSON object, e.g.:
{ "key1": "value1", "key2": "value2" }

Keys must be strings, and values can be of any valid JSON type (string, number, boolean, array, or object).
"""
scalar Map

scalar NetworkBandwidth

""" Subnet in CIDR notation E.g.: 10.0.0.0/24 """
scalar NetworkSubnet

""" Phone number. E.g.: +1 505 333 4070 """
scalar Phone

""" Network port number. Must be in range [0-65535] E.g.: 433, 8080, 80, etc.. """
scalar Port

""" A 64-character hex string representing a SHA-256 hash. Typically used for secure validation and cryptographic integrity checks """
scalar SHA_256

""" Wall time. E.g.: 12:34:56 or 12:34 """
scalar Time

"""
Enter the time frame for the data that the query returns.
The argument is in the format <span style="padding: 0.25em;background-color: #DCDDDE;border-radius: 10px;">\<type\>.\<time value\></span> This argument is mandatory.

These are the supported options to define the time frame:

last.\<time duration\> - The <time duration> value for the <span style="padding: 0.25em;background-color: #DCDDDE;border-radius: 10px;">last</span> type is according to ISO-8601 and returns data
						for the previous specific times. For example:
<ul>
	<li>timeFrame = <span style="padding: 0.25em;background-color: #DCDDDE;border-radius: 10px;">last.PT5M</span> shows the previous 5 minutes</li>
	<li> timeFrame = <span style="padding: 0.25em;background-color: #DCDDDE;border-radius: 10px;">last.PT2H</span> shows the previous 2 hours</li>
	<li> timeFrame = <span style="padding: 0.25em;background-color: #DCDDDE;border-radius: 10px;">last.P1D</span> shows the previous 1 day</li>
	<li> timeFrame = <span style="padding: 0.25em;background-color: #DCDDDE;border-radius: 10px;">last.P3M</span> shows the previous 3 months</li>
	<li> timeFrame = <span style="padding: 0.25em;background-color: #DCDDDE;border-radius: 10px;">last.P1Y</span> shows the previous 1 year</li>
</ul>

utc.\<short-time-frame-spec\>  - The time frame combines a start and end date in the format  YY-MM-DD/hh:mm:ss </br>
according to the specified time zone. </br> You must enter all the date and time values for the argument. For example:

<ul>
	<li> timeFrame = <span style="padding: 0.25em;background-color: #DCDDDE;border-radius: 10px;">utc.2020-02-{11/04:50:00--21/04:50:00}</span> shows 10 days of analytics data from February 11, 2020 4:50:00 am to February 21, 2020 4:50:00 am</li>
    <li> timeFrame = <span style="padding: 0.25em;background-color: #DCDDDE;border-radius: 10px;">utc.2020-02-11/{04:50:15--16:50:15}</span> shows 12 hours of analytics data on February 11, 2020, from 4:50:15 am to 16:50:15 pm</li>
	<li> timeFrame = <span style="padding: 0.25em;background-color: #DCDDDE;border-radius: 10px;">utc.2020-{02-11/04:50:00--04-11/04:50:00}</span> shows 2 months of analytics data from February 11, 2020 4:50:00 am to April 11 4:50:00 am</li>
	<li> timeFrame = <span style="padding: 0.25em;background-color: #DCDDDE;border-radius: 10px;">utc.{2019-10-01/04:50:00--2020/02-01/04:50:00}</span> shows 4 months of analytics data from October 1, 2019 4:50:00 am to February 11 4:50:00 am</li>
</ul>

This format lets you configure a time frame the includes more than one calendar year
"""
scalar TimeFrame

""" Time zone identifier E.g.: America/New_York """
scalar TimeZone

""" File upload - https://gqlgen.com/reference/file-upload/ """
scalar Upload

""" A Uniform Resource Locator, colloquially known as an address on the Web. E.g.: http://www.example.com/page/ """
scalar Url

""" VLAN Identifier. A number in the range 1-4094 used to uniquely identify a Virtual Local Area Network (VLAN) in networking environments """
scalar Vlan

##### Enums ##########################
enum AccountInclusion {
  ALL_ACCOUNTS
  MANAGED_ACCOUNTS_ONLY
}

enum AccountOperationsTimelineType {
  Action
  Event
}

""" enum that shows account license status """
enum AccountPlan {
  COMMERCIAL
  TRIAL
}

""" enum for account type """
enum AccountProfileType {
  """ A customer account """
  CUSTOMER
  """ A partner account """
  PARTNER
}

""" enum that shows account license status """
enum AccountStatus {
  ACTIVE
  DISABLED
  LOCKED
}

""" enum for account tenancy """
enum AccountTenancy {
  """ Multi tenant account - default for partner accounts """
  MULTI_TENANT
  """ Single tenant account - default for customer accounts """
  SINGLE_TENANT
}

enum AccountType {
  ALL
  REGULAR
  RESELLER
  SYSTEM
}

enum AddressValidationStatus {
  INVALID
  NA
  VALID
}

enum AdminType {
  LOGIN
  SERVICE_PRINCIPLE
}

enum AggregationType {
  any
  avg
  changes
  count
  count_distinct
  distinct
  max
  min
  sum
  uniq_set
}

enum AiOperationsIncidentTypeEnum {
  Account
}

enum AlertClassificationEnum {
  FALSE_POSITIVE
  INFORMATIONAL_EXPECTED_ACTIVITY
  TRUE_POSITIVE
}

enum AlertDeterminationEnum {
  APT
  COMPROMISED_ACCOUNT
  CONFIRMED_ACTIVITY
  LINE_OF_BUSINESS_APPLICATION
  MALICIOUS_USER_ACTIVITY
  MALWARE
  MULTI_STAGED_ATTACK
  NOT_ENOUGH_DATA_TO_VALIDATE
  NOT_MALICIOUS
  OTHER
  PHISHING
  SECURITY_PERSONNEL
  SECURITY_TESTING
  UNWANTED_SOFTWARE
}

enum AnnotationType {
  """ Other events that are included in annotations """
  generic
  """ The site connects to a different PoP """
  popChange
  """ The ISP IP address (remote IP) changed """
  remoteIPChange
  """ Change for HA status role """
  roleChange
}

enum AntiMalwareFileHashAction {
  """ Block file download by filehash action """
  BLOCK
  """ Bypass file download by filehash action """
  BYPASS
}

enum ApnMethod {
  METHOD_AUTO
  METHOD_MANUAL
  METHOD_UNKNOWN
}

enum AppStatsFieldName {
  """ The ISP related to this event (when the IP address isn't provided by the ISP, then the event message is IP Addresses are assigned statically) """
  ISP_name
  """ Active Directory name """
  ad_name
  """ The application identifier """
  app @deprecated(reason: "use application_id instead")
  """ The application name """
  application @deprecated(reason: "use application_name instead")
  """ Application description """
  application_description
  """ The application identifier """
  application_id
  """ The application name """
  application_name
  application_risk_level
  """ The application risk score assigned by Cato """
  application_risk_score
  """ Cato system categories of the application """
  categories
  """ Cato system category of the application """
  category @deprecated(reason: "use categories instead")
  """ For hosts configured with a static IP in the Cato Management Application, the host name """
  configured_host_name
  """ Application description """
  description @deprecated(reason: "use application_description instead")
  """ IP for destination host or Cato Client """
  dest_ip
  """ Destination is site or remote user """
  dest_is_site_or_vpn
  """ Destination site or remote user identifier """
  dest_site
  """ Destination Site or remote user identifier """
  dest_site_id
  """ Destination Site or remote user name """
  dest_site_name
  """ Name for device related to the traffic """
  device_name
  discovered_app
  domain @deprecated(reason: "user tld instead")
  """ data downloaded from cloud applications """
  downstream
  flows_created
  """ the country in which the registered application headquarteres is located """
  hq_location
  ip
  """ indicates whether the application is considered cloud app/SaaS app """
  is_cloud_app
  """ Is the application defined as sanctioned? """
  is_sanctioned_app
  """ new cloud application identifier """
  new_app
  risk_level @deprecated(reason: "use application_risk_level instead")
  """ the application risk score assigned by Cato """
  risk_score @deprecated(reason: "use application_risk_score instead")
  """ Is the application defined as sanctioned? """
  sanctioned @deprecated(reason: "use is_sanctioned_app instead")
  """ Country in which the source host is located """
  site_country
  """ State in which the source host is located """
  site_state
  """ Name for Socket interface """
  socket_interface
  """ Country in which the source host is located (detected via public IP address) """
  src_country
  """ Country Code of country in which the source host is located (detected via public IP address) """
  src_country_code
  """ IP for source host or Cato Client """
  src_ip
  """ Source is site or remote user """
  src_is_site_or_vpn
  """ IP address provided by ISP to site or Client """
  src_isp_ip
  """ Site country code alpha2 """
  src_site_country_code
  """ Source site or remote user identifier """
  src_site_id
  """ Source site or remote user name """
  src_site_name
  """ Site state code """
  src_site_state
  """ Name of subnet as defined in Cato Management Application """
  subnet @deprecated(reason: "use subnet_name instead")
  """ Name of subnet as defined in Cato Management Application """
  subnet_name
  """ Top level domain """
  tld
  """ the total sum of upstream and downstream data in bytes """
  traffic @deprecated(reason: "use traffic_direction instead")
  """ Traffic direction """
  traffic_direction
  """ data uploaded to cloud applications """
  upstream
  """ User identifier """
  user_id
  """ User name """
  user_name
  vpn_user_id @deprecated(reason: "use user_id instead")
}

""" Allowed actions """
enum AppTenantRestrictionActionEnum {
  """ Do not inject any Headers nor Values for outgoing traffic """
  BYPASS
  """ Inject Headers and Values for outgoing traffic """
  INJECT_HEADERS
}

""" Severity options """
enum AppTenantRestrictionSeverityEnum {
  """ High severity """
  HIGH
  """ Low severity """
  LOW
  """ Medium severity """
  MEDIUM
}

""" Application Control Access Method Type """
enum ApplicationControlAccessMethodType {
  """ User agent identification method """
  USER_AGENT
}

""" Application Control Action """
enum ApplicationControlAction {
  """ Permit the action """
  ALLOW
  """ Prevent the action """
  BLOCK
  """ Log the action without enforcement """
  MONITOR
}

""" Attribute Value """
enum ApplicationControlAttributeValue {
  """ Any Value """
  ANY
  """ Not Supported """
  NOT_SUPPORTED
  """ Supported """
  SUPPORTED
}

""" Application Control File Attribute Type """
enum ApplicationControlFileAttributeType {
  """ File encryption status """
  CONTENT_IS_ENCRYPTED
  """ File Size """
  CONTENT_SIZE
  """ File type classification """
  CONTENT_TYPE
}

""" Application Control Operator """
enum ApplicationControlOperator {
  """ Substring match comparison """
  CONTAINS
  """ Numerical greater than comparison """
  GREATER_THAN
  """ Set membership comparison """
  IN
  """ Exact match comparison """
  IS
  """ Numerical less than or equal comparison """
  LESS_THAN_OR_EQUAL
}

""" Application Control Rule Type """
enum ApplicationControlRuleType {
  """ Specifies an application control rule """
  APPLICATION
  """ Specifies an data control rule """
  DATA
  """ Specifies an file control rule """
  FILE
}

""" Application Control Satisfy """
enum ApplicationControlSatisfy {
  """ Match only if all criteria are met """
  ALL
  """ Match if any criteria are met """
  ANY
}

""" Severity level """
enum ApplicationControlSeverity {
  """ Indicates a high severity level """
  HIGH
  """ Indicates a low severity level """
  LOW
  """ Indicates a medium severity level """
  MEDIUM
}

""" Application Type """
enum ApplicationType {
  """ Application """
  APPLICATION
  """ Cloud Application type """
  CLOUD_APPLICATION
  """ Service """
  SERVICE
}

enum AuditFieldName {
  """ The name of the account on which the record was created """
  account
  """ The id of the account on which the record was created """
  account_id
  """ The admin whose action generated the record """
  admin
  """ The ID of the admin whose action generated the record """
  admin_id
  """ The api key whose action generated the record """
  apiKey
  audit_creation_type
  """ the nature of the change: `CREATED, DELETED, MODIFIED, ENABLED, DISABLED, SKIPPED` """
  change_type
  """ Time the record was created """
  creation_date
  """ Time the record was committed to storage """
  insertion_date
  """ The name of the object that was affected, e.g. 'My Site' """
  model_name
  """ The type of object that was affected. e.g. Site, Socket, SocketInterface """
  model_type
  """ Less granular than model_name, a general marker of the modified area: administration, configuration, security """
  module
}

enum BgpCommunityFilterPredicate {
  """ Matches exactly the specified community value. """
  EQUAL
  """ Matches any community value except the specified one. """
  NOT_EQUAL
}

enum BgpDefaultAction {
  """ Default action to accept all unmatched routes. """
  ACCEPT
  """ Default action to drop all unmatched routes. """
  DROP
}

enum BgpState {
  Active
  Connect
  Established
  Idle
  OpenConfirm
  OpenSent
  StateMAX
}

enum CatalogApplicationActivityFieldOperator {
  CONTAINS
  GREATER_THAN
  IN
  IS
  LESS_EQUALS
}

enum CatalogApplicationAttribute {
  SUPPORTED
  UNKNOWN
  UNSUPPORTED
}

enum CatalogApplicationCapability {
  ANTI_MALWARE_INLINE
  APP_CONTROL_API
  APP_CONTROL_INLINE
  DATA_PROTECTION_API
  DATA_PROTECTION_INLINE
  FILE_CONTROL_INLINE
  FIREWALL_INTLINE
  LAN_FIREWALL
}

enum CatalogApplicationType {
  APPLICATION
  CLOUD_APPLICATION
  SERVICE
}

enum CatoEndpointEngineType {
  AntiMalware
  Behavioral
}

enum CellularDisconnectionReason {
  REASON_NONE
  REASON_TIMEOUT
}

enum CellularModemStatus {
  STATUS_ERROR
  STATUS_OK
  STATUS_UNKNOWN
}

enum CellularNetworkType {
  TYPE_2G
  TYPE_3G
  TYPE_4G
  TYPE_UNKNOWN
}

enum ConnectionMode {
  BIDIRECTIONAL
  RESPONDER_ONLY
}

enum ConnectionOriginEnum {
  ANY
  REMOTE
  SITE
}

enum ConnectionTypeEnum {
  Host
  Site
  User
}

enum ConnectivityStatus {
  """ Connected to the Cato Cloud """
  connected
  """ Disconnected from the Cato Cloud """
  disconnected
}

enum ContainerFileType {
  CSV
  STIX
}

enum ContainerType {
  FQDN
  IP_RANGE
}

enum DayOfWeek {
  FRIDAY
  MONDAY
  SATURDAY
  SUNDAY
  THURSDAY
  TUESDAY
  WEDNESDAY
}

enum DegradedStatusReason {
  ALT_WAN_DISCONNECTED
  CROSS_CONNECT_CIRCUIT_DISCONNECTED
  HA_NOT_READY_INCOMPATIBLE_MAJOR_SOCKET_VERSIONS
  HA_NOT_READY_NO_KEEPALIVE
  HA_NOT_READY_SOCKET_DISCONNECTED
  IPSEC_MULTI_TUNNEL_TUNNEL_DISCONNECTED
  IPSEC_TUNNEL_DISCONNECTED
  LAN_DISCONNECTED
  LAN_LAG_DISCONNECTED
  LAN_LAG_MEMBER_DISCONNECTED
  WAN_DISCONNECTED
  WAN_TUNNEL_DISCONNECTED
}

enum DestinationType {
  FQDN
  IPv4
}

enum DetectionSourceEnum {
  ANTIVIRUS
  APP_GOVERNANCE_DETECTION
  APP_GOVERNANCE_POLICY
  AUTOMATED_INVESTIGATION
  AZURE_AD_IDENTITY_PROTECTION
  CLOUD_APP_SECURITY
  CUSTOM_DETECTION
  CUSTOM_TI
  MANUAL
  MICROSOFT365_DEFENDER
  MICROSOFT_DATA_LOSS_PREVENTION
  MICROSOFT_DEFENDER_FOR_ENDPOINT
  MICROSOFT_DEFENDER_FOR_IDENTITY
  MICROSOFT_DEFENDER_FOR_OFFICE365
  MICROSOFT_THREAT_EXPERTS
  SMART_SCREEN
}

enum DetectionStatusEnum {
  BLOCKED
  DETECTED
  PREVENTED
}

enum DeviceAvStatusEnum {
  DISABLED
  NOT_REPORTING
  NOT_UPDATED
  UPDATED
}

enum DeviceCategory {
  IoT
  Mobile
  Networking
  OT
  PC
  Server
}

enum DeviceConfidenceLevel {
  """ Device classification is strongly validated by multiple signals """
  HIGH
  """ Device classification has minimal supporting evidence """
  LOW
  """ Device classification has moderate supporting signals """
  MEDIUM
}

enum DeviceConfigHaRoleEnum {
  PRIMARY
  SECONDARY
}

enum DeviceHaRoleStateEnum {
  BACKUP
  MASTER
}

enum DeviceHealthStatusEnum {
  ACTIVE
  IMPAIRED_COMMUNICATION
  INACTIVE
  NO_SENSOR_DATA
  NO_SENSOR_DATA_IMPAIRED_COMMUNICATION
}

enum DeviceV2Category {
  IOT
  MOBILE
  NETWORKING
  OT
  PC
  SERVER
}

enum DhcpType {
  ACCOUNT_DEFAULT
  DHCP_DISABLED
  DHCP_RANGE
  DHCP_RELAY
}

enum DirectionEnum {
  asc
  desc
}

enum DirectionInput {
  asc
  desc
}

""" The DPA agreement, based on your contract with Cato """
enum DpaVersion {
  DPA_2019_01
  DPA_2021_01
  DPA_2023_01
}

"""
Search operators on ElasticSearch. Between operators are applicable only to numeric fields
Note that not operators are slower
"""
enum ElasticOperator {
  between
  exists
  in
  is
  is_not
  not_between
  not_exists
  not_in
}

enum EmployeeRange {
  """ 1-10 employees """
  BETWEEN_00001_00010
  """ 11-50 employees """
  BETWEEN_00011_00050
  """ 51-100 employees """
  BETWEEN_00051_00100
  """ 101-250 employees """
  BETWEEN_00101_00250
  """ 251-500 employees """
  BETWEEN_00251_00500
  """ 501-1,000 employees """
  BETWEEN_00501_01000
  """ 1,001-5,000 employees """
  BETWEEN_01001_05000
  """ 5,001-10,000 employees """
  BETWEEN_05001_10000
  """ 10,000+ employees """
  BETWEEN_10001_MAX
}

enum EntityType {
  """ A reference to a configured Account under reseller """
  account
  """ An account administrator (user in Cato Console) """
  admin
  """ An external IP address in a specific PoP reserved for the account """
  allocatedIP
  """ Any entity (matches everything) """
  any
  """ Pooled licenses available for use """
  apiKey
  """ added by joe """
  availablePooledUsage
  """ Site licenses available for use """
  availableSiteUsage
  """ added by joe """
  casbRule
  """ A settlement with over 1K population """
  city
  """ Geographical and political entity recognized internationally """
  country
  """ Represents a state or territory within a country. It is a sub-division of the country """
  countryState
  """ A reference to DHCP Relay Group within account """
  dhcpRelayGroup
  """ added by joe """
  group
  groupSubscription
  """ A reference to the configured Host within Site """
  host
  """ added by joe """
  interfaceSubnet
  """ added by joe """
  ip
  """ A reference to LAN Firewall Rule within Site """
  lanFirewall
  """ A reference to Local Routing Rule within Site """
  localRouting
  location
  mailingListSubscription
  """ A reference to the configured Network Interface within Site """
  networkInterface
  """ added by joe """
  networkRule
  """ Combination of protocol (TCP, UDP, TCP/UDP, ICMP) and port number """
  portProtocol
  """ l4 services for LAN firewall rules """
  simpleService
  """ A reference to a configured Site within Account """
  site
  """ union of the globalRange and a Subnet """
  siteRange
  """ added by joe """
  socketInterface
  """ added by joe """
  subnet
  """ Time zone, which is a geographical region where clocks are set to the same time """
  timezone
  """ added by joe """
  usersGroup
  """ A reference to the configured VPN User within Account """
  vpnUser
  webhookSubscription
}

enum EventFeedFilterFieldName {
  """ Sub-type for Routing, Security, Connectivity, System or Sockets Management event """
  event_sub_type
  """ Routing, Security, Connectivity, System or Sockets Management event """
  event_type
}

""" Search operators on Event Feed """
enum EventFeedFilterOperator {
  in
  is
  is_not
  not_in
}

enum EventFieldName {
  """ The ISP related to this event (when the IP address isn't provided by the ISP, then the event message is IP Addresses are assigned statically) """
  ISP_name
  """ Identifies system access software or device """
  access_method
  """ Account ID """
  account_id
  """ Firewall, QoS or LAG action """
  action
  """ A list of actions taken, if more than one action was taken as defined by a policy """
  actions_taken
  """ The activity resource ID being referenced with resource type. """
  activity_resource_id
  """ Defines the type of entity performing the action, helping to distinguish between different categories of users. """
  actor_type
  """ Active Directory name """
  ad_name
  """ A unique identifier of the alert notification """
  alert_id
  """ Always-on Configuration """
  always_on_configuration
  """ Analyst Verdict """
  analyst_verdict
  """ The name of the API, e.g. eventsFeed """
  api_name
  """ Specifies whether the API is a query (read) or a mutation (create/update/delete) """
  api_type
  """ Name of application activity """
  app_activity
  """ SaaS user activities into categories. """
  app_activity_category
  """ Activity type """
  app_activity_type
  """ Related Apps """
  app_stack
  """ Application ID of the flow """
  application_id
  """ The name of the application associated with the flow """
  application_name
  """ Application risk score """
  application_risk
  """ Connectivity authentication method: unauthenticated, OATH2, LDAP or VPN """
  auth_method
  """ Examples: MFA or password """
  authentication_type
  """ BGP ASN for Cato peer """
  bgp_cato_asn
  """ BGP IP for Cato peer """
  bgp_cato_ip
  """ BGP disconnect error code """
  bgp_error_code
  """ BGP ASN for remote peer """
  bgp_peer_asn
  """ BGP IP for remote peer """
  bgp_peer_ip
  """ CIDR for BGP route """
  bgp_route_cidr
  """ BGP disconnect error message """
  bgp_suberror_code
  """ Always-On Bypass Duration In Seconds """
  bypass_duration_sec
  """ Always-On Bypass Method """
  bypass_method
  """ Always-On Bypass Reason """
  bypass_reason
  """ Cato system category """
  categories
  """ Cato application name """
  cato_app
  """ Activity classification, e.g. FALSE_POSITIVE """
  classification
  """ Expiration date for Client certificate """
  client_cert_expires
  """ Name of Client certificate """
  client_cert_name
  """ Type of process generating this traffic """
  client_class
  """
  Admins can configure the Client connection mode to control which types of traffic are routed and protected by Cato. The available options are:
  All Ports and Protocols  Secures all application traffic across any port or protocol.
  Web-only (HTTPS)  Secures only browser-based traffic over HTTPS.
  """
  client_connection_mode
  """ Socket or SDP Client version """
  client_version
  """ Shows the display name of the target user involved in an activity """
  collaborator_name
  """ For SaaS Security API, email addresses of the users that received the file """
  collaborators
  """ Confidence Level """
  confidence_level
  """ For hosts configured with a static IP in the Cato Management Application, the host name """
  configured_host_name
  """ The algorithm that is used (CUBIC /NewReno / BBR) """
  congestion_algorithm
  """ Connect on boot Enabled/Disabled """
  connect_on_boot
  """ Connection Origin """
  connection_origin
  """ For SaaS Security API, name of the connector """
  connector_name
  """ For SaaS Security API, status of the connector """
  connector_status
  """ For SaaS Security API, SaaS app for the connector """
  connector_type
  """ IoC Container Name """
  container_name
  """ An external system identifier used for correlation between related Cato entities. Example: external ticket id that correlates Cato XDR stories. """
  correlation_id
  """ Criticality """
  criticality
  """ Custom category ID """
  custom_category_id
  """ Custom category name """
  custom_category_name
  """ For Internet traffic, country where the destination host is located """
  dest_country
  """ For Internet traffic, the two letter country code where the destination host is located (based on ISO 3166-1 alpha-2) """
  dest_country_code
  """ The unique identifier by the SaaS vendor for the target group in an activity. """
  dest_group_id
  """ Identifies the target group involved in an activity """
  dest_group_name
  """ Destination IP address """
  dest_ip
  """ For WAN traffic, destination is site or SDP user """
  dest_is_site_or_vpn
  """ The destination process ID """
  dest_pid
  """ Destination port """
  dest_port
  """ Destination process command line """
  dest_process_cmdline
  """ Destination process parent file path """
  dest_process_parent_path
  """ Destination process parent process ID """
  dest_process_parent_pid
  """ Destination process file path """
  dest_process_path
  """ Unique internal Cato ID for the destination site or remote user """
  dest_site_id
  """ The name of the destination site """
  dest_site_name
  """ Short description of the detection """
  detection_name
  """
  Triggered when malware has been detected EPP Behavioral engines and has been dealt with:
   on_detection: the event is triggered upon malware detection;
   on_end_disinfect: the event is triggered upon detection and followed disinfection;
   on_inject: the event is triggered upon code injection.
  """
  detection_stage
  """ Device Categories """
  device_categories
  """ Device Certificate Validated/Not Validated """
  device_certificate
  """ Unique Cato ID for devices """
  device_id
  """ Device Manufacturer """
  device_manufacturer
  """ Device Model """
  device_model
  """ Name for device related to the event """
  device_name
  """ Device OS Type """
  device_os_type
  """ Device posture profiles """
  device_posture_profile
  """ Device Type """
  device_type
  """ Host name of Domain Controller that created LDAP event """
  directory_host_name
  """ IP address of Domain Controller that created LDAP event """
  directory_ip
  """ Result of LDAP Domain Controller sync event """
  directory_sync_result
  """ Type of LDAP Domain Controller sync event """
  directory_sync_type
  """ If policy is set to disinfect, return the result of this action """
  disinfect_result
  """ Describes the behavior when the DLP system encounters a failure """
  dlp_fail_mode
  """ DLP profiles related to the event """
  dlp_profiles
  """ Defines the scanning methods used by the DLP system """
  dlp_scan_types
  """ Catos DNS Protection type that matched the DNS request """
  dns_protection_category
  """ Domain queried in the DNS request """
  dns_query
  """ Domain name based on the SSL SNI, HTTP host name, or DNS name """
  domain_name
  """ Egress PoP Name """
  egress_pop_name
  """ Egress Site Name for backhauling traffic """
  egress_site_name
  """ Email Subject """
  email_subject
  """ The ID for the endpoint """
  endpoint_id
  """ The engine type associated with the event """
  engine_type
  """ The Endpoint Protection Engine that detected the malware """
  epp_engine_type
  """ The profile assigned to the endpoint upon detection of the malware """
  epp_profile
  """ Count for events that are repeated multiple times during one minute """
  event_count
  """ Event Id """
  event_id
  """ Cato's description of the event """
  event_message
  """ Sub-type for Routing, Security, Connectivity, System or Sockets Management event """
  event_sub_type
  """ Routing, Security, Connectivity, System or Sockets Management event """
  event_type
  """ Provides details about why a specific action or process failed """
  failure_reason
  """ File hash """
  file_hash
  """ File name """
  file_name
  """ The file operation when this event occurred """
  file_operation
  """ File size """
  file_size
  """ File type """
  file_type
  """ The final status for this object after performing actions as defined by the policy """
  final_object_status
  """ Amount of flows for a given incident """
  flows_cardinality
  """ Full path URL application activity """
  full_path_url
  """ An identifier for a guest user using Cato through a Captive Portal """
  guest_user
  """ IP address of host related to event """
  host_ip
  """ MAC address of host related to event """
  host_mac
  """ HTTP request method (ie. Get, Post) """
  http_request_method
  """ For MDR service, a true/false value that indicates if this event is: A summary that aggregates many events (true) Raw network flows for a single event (false) """
  incident_aggregation
  """ Unique Cato ID that identifies this security incident """
  incident_id
  """ Indication """
  indication
  """ Indicator """
  indicator
  """ The initial status of the object, before any policy was applied """
  initial_object_status
  """ Cato Internal-use only """
  internalId @deprecated(reason: "use event_id instead. Planned end-of-life (EoL) date: May 1, 2025.")
  """ Network protocol for this event """
  ip_protocol
  """ Classifies users based on their permissions. """
  is_admin
  """ Indicates whether an activity requires administrative permissions. """
  is_admin_activity
  """ Is Compliant """
  is_compliant
  """ Is Managed """
  is_managed
  """ Is the app for this event defined as a sanctioned app? (True/False) """
  is_sanctioned_app
  """ If the events was part of the sinkhole flow """
  is_sinkhole
  """ Name defined for the public API Key in the Cato Management Application """
  key_name
  """ A list of labels providing additional context for the event """
  labels
  """ Data that measures the congestion for a specific link """
  link_health_is_congested
  """ Data that measures the jitter for a specific link """
  link_health_jitter
  """ Round Trip Delay in Milliseconds that it takes a packet to travel between the source and the PoP """
  link_health_latency
  """ Data that measures the packet loss for a specific link """
  link_health_pkt_loss
  """ Link type  Cato, Alt. WAN or LAG """
  link_type
  """ The user logged into this endpoint during this event """
  logged_in_user
  """ Login action, values are: User portal (myvpn.catonetworks.com) or VPN client (Client or site traffic) """
  login_type
  """ Matched DLP data types related to the event """
  matched_data_types
  """ Mitre attack subtechniques """
  mitre_attack_subtechniques
  """ Mitre attack tactics """
  mitre_attack_tactics
  """ Mitre attack techniques """
  mitre_attack_techniques
  """ Network Access """
  network_access
  """ Matched network rule """
  network_rule
  """ For SaaS Security API, API Error of Apps Security Notification """
  notification_api_error
  """ For SaaS Security API, description of Apps Security Notification """
  notification_description
  """ Unique identifier by the 3rd party App of the object being referenced """
  object_id
  """ The name of the object for this event (for example: file name) """
  object_name
  """ Specifies the type of object being acted upon (e.g., file, folder) """
  object_type
  """ Office mode Enabled/Disabled """
  office_mode
  """ Host OS or tunnel device """
  os_type
  """ OS version for the device (such as 14.3.0) """
  os_version
  """ Indicate if the Access to the 3rd Party SaaS App occurs without passing through Cato Cloud (direct access to saas App) """
  out_of_band_access
  """ For SaaS Security API, email address of the file owner """
  owner
  """ Pac File Enabled/Disabled """
  pac_file
  """ For SaaS Security API, parent Microsoft 365 connector """
  parent_connector_name
  """ Name of PoP location """
  pop_name
  """ Precedence """
  precedence
  """ Indicate how many processes are part of this event """
  processes_count
  """ Producer """
  producer
  """ Related project name(s) """
  projects
  """ Prompt Page Selected Action """
  prompt_action
  """ The name of the provider, for example cloud provider - AWS """
  provider_name
  """ Public source IP """
  public_ip
  """ QoS Priority value """
  qos_priority
  """ For QoS, the time that this QoS event started. The event is generated when the QoS event finishes """
  qos_reported_time
  """ Specifies the path to a quarantine folder for isolated files """
  quarantine_folder_path
  """ A Unique ID for the quarantined file """
  quarantine_uuid
  """ Raw Data """
  raw_data
  """ Textual recommendation of the steps to take """
  recommended_actions
  """ The URL that links directly to the object involved in the activity """
  reference_url
  """ Referer URL from the HTTP request header indicating the source of the request. """
  referer_url
  """ The region of the object """
  region_name
  """ Registration code used the first time that a SDP user authenticates (the code is partially obfuscated) """
  registration_code
  """ The ID of the resource in the cloud provider """
  resource_id
  """ The specific name or identifier of the resource. """
  resource_name
  """ The type of resource being referenced. """
  resource_type
  """ (IPS or SAM event) Indicates the overall impact of a threat for the host or network: Low  ie. adware Medium  ie. network scans High  ie. spyware or worms """
  risk_level
  """ Unique Cato ID for the security rule related to the event """
  rule_id
  """ Rule name """
  rule_name
  """ Indicates the internal vendor service or module that produced the data reported in this event """
  service_name
  """ Severity defined for the rule """
  severity
  """ Sharing Options for the file (such as SharePoint) """
  sharing_scope
  """ Sign In Types """
  sign_in_event_types
  """ For IPS and SAM, ID of the IPS signature """
  signature_id
  """ Name for Socket interface """
  socket_interface
  """ Socket interface ID """
  socket_interface_id
  """ For Socket upgrades, new version number """
  socket_new_version
  """ For Socket upgrade, previous version number """
  socket_old_version
  """ Type of Socket reset (Hardware/Software) """
  socket_reset
  """ For Socket HA events, indicates if the Socket is primary or secondary """
  socket_role
  """ Socket serial number """
  socket_serial
  """ Socket version number """
  socket_version
  """ Split Tunnel Configuration """
  split_tunnel_configuration
  """ Country in which the source host is located (detected via public IP address) """
  src_country
  """ Country Code of country in which the source host is located (detected via public IP address) """
  src_country_code
  """ IP for host or Cato Client """
  src_ip
  """ Source type: site or remote user """
  src_is_site_or_vpn
  """ IP address provided by ISP to site or Client """
  src_isp_ip
  """ Source process ID """
  src_pid
  """ Internal port number """
  src_port
  """ Source process command line """
  src_process_cmdline
  """ Source process parent file path """
  src_process_parent_path
  """ Source process parent process ID """
  src_process_parent_pid
  """ Source process file path """
  src_process_path
  """ Unique internal Cato ID for the site or remote user """
  src_site_id
  """ Source site or remote user """
  src_site_name
  """ Static host """
  static_host
  """
  The story status.
  Possible values: Open, Pending Analysis, Pending more info, Closed, Reopened, Monitoring
  """
  status
  """ Story Id """
  story_id
  """ Name of subnet as defined in Cato Management Application """
  subnet_name
  """ The name of the subscription """
  subscription_name
  """ Number of targets (servers) associated with this event """
  targets_cardinality
  """ Shows if traffic was TCP accelerated or not """
  tcp_acceleration
  """ Unique identifier for the tenant within a multi-tenant environment """
  tenant_id
  """ Tenant Name """
  tenant_name
  """ Tenant Restriction Rule Name """
  tenant_restriction_rule_name
  """
  Contains the detection risk level. Could be one of the following:
   Info - this is information-only event, the activity is not malicious;
   Suspicious - the event is suspicious. It may be malicious, but there is not enough information
   Malware - the event is malicious activity
  """
  threat_confidence
  """ For anti-malware events, malware name For IPS events, explains the reason why the traffic was blocked """
  threat_name
  """ Link to external malware reference """
  threat_reference
  """ The higher the score, the more dangerous the event. In range between 1 - 100 inclusive """
  threat_score
  """ Type of malware event """
  threat_type
  """ Result of malware event (clean indicates a safe file) """
  threat_verdict
  """ Time stamp of the event (Linux epoch format) """
  time
  """ Time stamp of the event (Human-readable format) """
  time_str
  """ A short summary of the activity """
  title
  """ TLS Certificate Error """
  tls_certificate_error
  """ TLS Error Description """
  tls_error_description
  """ TLS Error Type """
  tls_error_type
  """ Shows if traffic was TLS inspected or not """
  tls_inspection
  """ TLS Inspection rule name """
  tls_rule_name
  """ TLS Version """
  tls_version
  """ Direction of network traffic for this event, values are inbound or outbound """
  traffic_direction
  """ Translated Client IP """
  translated_client_ip
  """ Translated Server IP """
  translated_server_ip
  """ Trigger """
  trigger
  """ Trust Type """
  trust_type
  """ Trusted networks Enabled/Disabled """
  trusted_networks
  """ Tunnel Protocol TCP/UDP """
  tunnel_ip_protocol
  """ Protocol for the tunnel """
  tunnel_protocol
  """ Socket upgrade end time (Linux epoch format): """
  upgrade_end_time
  """ Indicates if the Socket upgrade occurred during the maintenance window or initiated by Support (Cato Admin) """
  upgrade_initiated_by
  """ Socket upgrade start time (Linux epoch format) """
  upgrade_start_time
  """ URL associated with the event """
  url
  """ User Agent """
  user_agent
  """ Method used to get identity with User Awareness (such as Identity Agent) """
  user_awareness_method
  """ User ID """
  user_id
  """ User that generated the event """
  user_name
  """ Identifies the origin of the users connection. """
  user_origin
  """ For Block/Prompt page, reference ID to report incorrect category """
  user_reference_id
  """ User risk level category """
  user_risk_level
  """ The vendor that identified the incident, such as Cato or Microsoft """
  vendor
  """ Shows the id of the target user involved in an activity """
  vendor_collaborator_id
  """ Vendor Device Id """
  vendor_device_id
  """ Vendor Device Name """
  vendor_device_name
  """ Vendor Event Id """
  vendor_event_id
  """ Third party vendor policy description """
  vendor_policy_description
  """ Third party vendor policy ID """
  vendor_policy_id
  """ Third party vendor policy name """
  vendor_policy_name
  """ Identifies the user in the vendors system """
  vendor_user_id
  """ Unique Cato Visible ID for devices """
  visible_device_id @deprecated(reason: "use device_id instead. Planned end-of-life (EoL) date: April 1, 2026.")
  """ Lan access Allowed / Blocked """
  vpn_lan_access
  """ Users email address """
  vpn_user_email
  """ For LDAP sync events, name of the AD domain """
  windows_domain_name
  """ XFF HTTP header indicates the original IP address for the connections """
  xff
}

""" Status values for export job lifecycle """
enum ExportJobStatus {
  """ Export job finished successfully and file is ready for download """
  COMPLETED
  """ Export job encountered an error and could not complete """
  FAILED
  """ Export job is currently being processed """
  IN_PROGRESS
  """ Export job has been queued but not yet started """
  PENDING
}

enum FilterOperator {
  between
  exists
  gt
  gte
  in
  is
  is_not
  lt
  lte
  not_between
  not_exists
  not_in
}

enum GraphType {
  ANALYTICS
}

""" Member types that can be referenced in a group. """
enum GroupMemberRefType {
  FLOATING_SUBNET
  GLOBAL_IP_RANGE
  HOST
  NETWORK_INTERFACE
  SITE
  SITE_NETWORK_SUBNET
}

enum HaReadiness {
  not_ready
  ready
}

enum HaRole {
  PRIMARY
  SECONDARY
}

enum HaSubStatus {
  fail
  ok
}

enum IPSecV2InterfaceId {
  PRIMARY1
  PRIMARY2
  PRIMARY3
  SECONDARY1
  SECONDARY2
  SECONDARY3
}

enum IPSecV2TunnelRole {
  WAN1
  WAN2
  WAN3
}

enum IdentificationType {
  EMAIL
  FQDN
  IPV4
  KEY_ID
}

enum IlmmOnboardingStatus {
  COMPLETE
  FAILED
  MISSING
  PENDING
}

""" The action applied by the Internet Firewall if the rule is matched """
enum InternetFirewallActionEnum {
  """ Allow the network traffic to pass through the firewall. """
  ALLOW
  """ Deny the network traffic from passing through the firewall. """
  BLOCK
  """ Requests user confirmation to allow or block network traffic. """
  PROMPT
  """ Apply Remote Browser Isolation (RBI) to the network traffic """
  RBI
}

enum IpProtocol {
  ANY
  ICMP
  TCP
  """ TCP or UDP """
  TCP_UDP
  UDP
}

enum IpSecCipher {
  AES_CBC_128
  AES_CBC_256
  AES_GCM_128
  AES_GCM_256
  AUTOMATIC
  DES3_CBC
  NONE
}

enum IpSecDHGroup {
  AUTOMATIC
  DH_14_MODP2048
  DH_15_MODP3072
  DH_16_MODP4096
  DH_19_ECP256
  DH_20_ECP384
  DH_21_ECP521
  DH_2_MODP1024
  DH_5_MODP1536
  NONE
}

enum IpSecHash {
  AUTOMATIC
  MD5
  NONE
  SHA1
  SHA256
  SHA384
  SHA512
}

""" enum for license plan type (site license, service license, etc...) """
enum LicensePlan {
  COMMERCIAL
  TRIAL
}

enum LicenseSku {
  """ Cato Anti Malware (legacy) service SKU """
  CATO_ANTI_MALWARE
  """ Cato Anti Malware Next Generation (legacy) service SKU """
  CATO_ANTI_MALWARE_NG
  """ Cato CASB service SKU """
  CATO_CASB
  """ Cato datalake Group SKU """
  CATO_DATALAKE
  """ 12 months data retention SKU """
  CATO_DATALAKE_12M
  """ 3 months data retention SKU """
  CATO_DATALAKE_3M
  """ 6 months data retention SKU """
  CATO_DATALAKE_6M
  """ Cato DEM service SKU """
  CATO_DEM
  """ Cato DLP service SKU """
  CATO_DLP
  """ Cato EPP service SKU """
  CATO_EPP
  """ Cato ILMM service SKU """
  CATO_ILMM
  """ Cato IoT/OT Security service SKU """
  CATO_IOT_OT
  """ Cato IPS (legacy) service SKU """
  CATO_IPS
  """ Public IPs SKU """
  CATO_IP_ADD
  """ Cato Managed XDR service SKU """
  CATO_MANAGED_XDR
  """ Cato MDR service SKU """
  CATO_MDR
  """ Cato NOCaaS service SKU """
  CATO_NOCAAS_HF
  """ Site pooled bandwidth SASE SKU """
  CATO_PB
  """ Site pooled bandwidth SSE SKU """
  CATO_PB_SSE
  """ Cato Remote Browser Isolation (RBI) service SKU """
  CATO_RBI
  """ Cato SAAS Group SKU """
  CATO_SAAS
  CATO_SAAS_SECURITY_API
  """ Cato SAAS Security API with more than two Applications integration (legacy) service SKU """
  CATO_SAAS_SECURITY_API_ALL_APPS
  """ Cato SAAS Security API with one application integration (legacy) service SKU """
  CATO_SAAS_SECURITY_API_ONE_APP
  """ Cato SAAS Security API with two applications integration (legacy) service SKU """
  CATO_SAAS_SECURITY_API_TWO_APPS
  """ Site bandwidth SASE SKU """
  CATO_SITE
  """ Site bandwidth SSE SKU """
  CATO_SSE_SITE
  """ Cato Threat Prevention (legacy) service SKU """
  CATO_THREAT_PREVENTION
  """ Cato Advanced Threat Prevention service SKU """
  CATO_THREAT_PREVENTION_ADV
  """ Cato XDR service SKU """
  CATO_XDR_PRO
  """ Cato XOps service SKU """
  CATO_XOPS
  """ ZTNA remote users SKU """
  CATO_ZTNA_USERS
  """ ZTNA remote users SKU """
  MOBILE_USERS @deprecated(reason: "replaced with CATO_ZTNA_USERS")
}

""" enum for account plan status  the current license status within the license lifecycle """
enum LicenseStatus {
  """ A license that is currently active """
  ACTIVE
  """ An expired license is no longer active """
  DISABLED
  """ A license in a grace period """
  LOCKED
  """ The license is pending customer activation by setting a start date """
  PENDING
  """ An existing license with a future start date that is not currently active """
  SCHEDULED
  """ A license that is active before its start date, for partners and customers to verify the relevant configurations """
  STAGING
}

enum LinkConfigPrecedenceEnum {
  ACTIVE
  LAST_RESORT
  PASSIVE
}

enum LinkQualityIssueTypeEnum {
  CONGESTION
  DISTANCE
  JITTER
  PACKET_LOSS
}

enum LinkStatusEnum {
  ACTIVE
  PASSIVE
}

enum LocationType {
  BRANCH
  CLOUD_DATA_CENTER
  DATA_CENTER
  HEADQUARTERS
  OTHER
  WAREHOUSE
}

enum LookupFilterType {
  """ Custom filter for country, used by city and state entityLookup """
  country
  """
  Custom filter to be used with Site entityLookup, to get only sites with Alt WAN, possible values:
  "true",
  "false",
  """
  filterByAltWan
  """
  Custom filter to be used with Site entityLookup, to get only sites that are configured as backhauling gateways, possible values:
  "true",
  "false",
  """
  filterByBackhaulingGW
  """
  Custom filter to be used with Site entityLookup, to get only sites with one connection type, possible values (there are more values that can supported):
  "SOCKET_X1500",
  "SOCKET_X1600",
  "SOCKET_X1700",
  "VSOCKET_VGX_ESX",
  "VSOCKET_VGX_AWS"
  "VSOCKET_VGX_AZURE"
  "SOCKET_X1600_LTE",
  """
  filterByConnectionType
  """
  Custom filter to be used with Site entityLookup, to get only sites with one connection type, possible values:
  "SOCKET",
  "IPSEC",
  "vSOCKET",
  "PHYSICAL_SOCKET"
  """
  filterByConnectionTypeFamily
  """
  Custom filter to be used with Site entityLookup, to get only sites that are configured as OffCloudTransportEnabled, possible values:
  "true",
  "false",
  """
  filterByOffCloudTransportEnabled
  """ Custom filter for state used by city entityLookup """
  state
}

enum MetadataType {
  TXT
}

enum MsAlertStatus {
  IN_PROGRESS
  NEW
  RESOLVED
}

enum MsResourceVerdictEnum {
  Benign
  Informational
  Malicious
  Suspicious
}

enum NetworkEventSourceEnum {
  BGP_SESSION
  DEVICE
  HOST
  ISP
  LINK
  POP
  SITE
}

enum NetworkXDREventTypeEnum {
  DEGRADED
  INSIGHT
  RESOLVED
}

enum ObjectRefBy {
  ID
  NAME
}

enum OnboardingStatusEnum {
  CAN_BE_ONBOARDED
  INSUFFICIENT_INFO
  ONBOARDED
}

enum OperatingSystem {
  ANDROID
  EMBEDDED
  IOS
  LINUX
  MACOS
  WINDOWS
}

enum OperationalStatus {
  """ Passing traffic """
  active
  """ Disabled in the Cato Management Application """
  disabled
  """ License has expired for this site and you can't configure it """
  locked
  """ After you create the site before it is connected to the Cato Cloud """
  new
  """ For VPN users only """
  pending_code_generation
  """ For VPN users only """
  pending_mfa_configuration
  """ For VPN users only """
  pending_user_configuration
}

""" The origins (e.g., integrations, data feeds) that detected the device """
enum OriginType {
  """ Device details reported by the Armis security platform """
  Armis
  """ Device information provided by the Cato Networks platform """
  CatoNetworks
  """ Device data gathered from Claroty's security platform """
  Claroty
  """ Device details provided by CrowdStrike endpoint security """
  Crowdstrike
  """ Device data collected from Microsoft Intune MDM """
  MicrosoftIntune
  """ Device information from SentinelOne endpoint platform """
  SentinelOne
  """ Origin of the device data could not be determined """
  Unknown
  """ Device information identified through Zoom integration """
  Zoom
}

enum PeriodType {
  """ traffic was seen """
  active
  """ some packets were discarded after queue timeout """
  congested
  """ unspecified period type """
  generic
  """ multiple last mile destinations measured large latency (greater than 500ms) """
  lastmileLatency
  """ multiple last mile destinations measured packet loss """
  lastmilePacketLoss
  """ missing data """
  missingData
  """ some packets were queued """
  overlowed
  """ packet loss connectivity issue """
  packetLoss
  """ interface in standby mode """
  passiveLink
  """ period connected to specific pop instance """
  pop
}

""" Enum for the type of time range a rule is active """
enum PolicyActiveOnEnum {
  ALWAYS
  CUSTOM_RECURRING
  CUSTOM_TIMEFRAME
  WORKING_HOURS
}

""" Attributes describing the rule state or type """
enum PolicyElementPropertiesEnum {
  """ New (added) rule """
  ADDED
  """
  An object can not be moved, or referenced when moving other objects.
  However its properties and content can be modified.
  """
  ANCHORED
  """ A rule locked for changes by other admins """
  LOCKED
  """ A rule moved to a different position """
  MOVED
  """ Removed (deleted) rule """
  REMOVED
  """ A pre-defined (system) rule that cannot be modified or removed """
  SYSTEM
  """ Updated (modified) existing rule """
  UPDATED
}

""" Enum for the status of a policy mutation """
enum PolicyMutationStatus {
  FAILURE
  SUCCESS
}

""" Enum for the type of a policy revision """
enum PolicyRevisionType {
  PRIVATE
  PUBLIC
}

""" Enum for the position of a rule within a policy """
enum PolicyRulePositionEnum {
  """ The rule position is after the pre-existing specified rule """
  AFTER_RULE
  """ The rule position is before the pre-existing specified rule """
  BEFORE_RULE
  """ The rule position is immediately after the system rules (first non-system rule) """
  FIRST_IN_POLICY
  """ The rule position is first in the specified section """
  FIRST_IN_SECTION
  """ The rule position is last in the policy """
  LAST_IN_POLICY
  """ The rule position is last in the specified section """
  LAST_IN_SECTION
}

""" Enum for the frequency of an alert event for a rule """
enum PolicyRuleTrackingFrequencyEnum {
  DAILY
  HOURLY
  IMMEDIATE
  WEEKLY
}

enum PolicySectionPositionEnum {
  AFTER_SECTION
  BEFORE_SECTION
  LAST_IN_POLICY
}

""" Enum for the position of a rule within a policy """
enum PolicySubRulePositionEnum {
  """ The rule position is after the pre-existing specified rule """
  AFTER_SUB_RULE
  """ The rule position is before the pre-existing specified rule """
  BEFORE_SUB_RULE
  """ The rule position is first in the specified rule """
  FIRST_IN_RULE
  """ The rule position is last in the specified rule """
  LAST_IN_RULE
}

""" Enum for the state of a policy """
enum PolicyToggleState {
  DISABLED
  ENABLED
}

enum PrivateAccessPolicyActionEnum {
  ALLOW
  BLOCK
}

""" Defines Origin of the connection """
enum PrivateAccessPolicyOriginEnum {
  ANY
  """ Any Remote option """
  REMOTE
  """ User is connecting from the Enterprise Browser """
  REMOTE_BROWSER
  """ User is connecting from the SDP client """
  REMOTE_CLIENT
  """ User is connecting from the Browser Extension """
  REMOTE_EXTENSION
  """ User is connecting from the Application Portal """
  REMOTE_PORTAL
  """ User is connecting from Site """
  SITE
}

enum ProtoType {
  CROSS_CONNECT
  CROSS_CONNECT_L2
  CROSS_CONNECT_VRF
  GRE_TUNNEL
  IPSEC_CLIENT
  IPSEC_HOST
  IPSEC_V2
  NOT_DEFINED
  PORTAL_LISTENER
  SOCKET_AWS1500
  SOCKET_AZ1500
  SOCKET_ESX1500
  SOCKET_GCP1500
  SOCKET_RPI64
  SOCKET_X1
  SOCKET_X1500
  SOCKET_X1600
  SOCKET_X1600_LTE
  SOCKET_X1700
  VSOCKET_VGS
  VSOCKET_VGX
  VSOCKET_VGX_AWS
  VSOCKET_VGX_AZURE
  VSOCKET_VGX_ESX
  VSOCKET_VSH
}

enum RBACAction {
  EDIT
  NONE
  VIEW
}

""" REGIONAL and GLOBAL licenses for MOROCCO, CHINA, and VIETNAM group values """
enum Regionality {
  """ Global traffic going outside of the region """
  GLOBAL
  """ Site traffic within the region """
  REGIONAL
}

enum RemediationStatusEnum {
  BLOCKED
  CLEAN
  DELETED
  DELETED_REBOOT
  DISABLED
  DISINFECTED
  DISINFECT_FAILED
  INFECTED
  MOVED
  MOVED_REBOOT
  NOT_FOUND
  NOT_STARTED
  PASSWORD_PROTECTED
  PREVENTED
  REBOOT_REQUIRED
  REMEDIATED
  SCAN_FAILED
  SUCCESS
  SUSPICIOUS
  UNKNOWN
}

enum RemotePortFwdRestrictionType {
  ALLOW_LIST
  BLOCK_LIST
}

enum ResourceRoleEnum {
  ADDED
  ATTACKED
  ATTACKER
  COMMAND_AND_CONTROL
  COMPROMISED
  CONTEXTUAL
  CREATED
  DESTINATION
  EDITED
  LOADED
  POLICY_VIOLATOR
  SCANNED
  SOURCE
  SUSPICIOUS
}

enum RiskLevelEnum {
  Benign
  High
  Inconclusive
  Low
  Malicious
  Medium
  nan
}

enum RiskScoreCategory {
  ANY
  CRITICAL
  HIGH
  LOW
  MEDIUM
}

enum RiskScoreOperator {
  GTE
  LTE
}

""" Sandbox analysis failure reason """
enum SandboxFailureReason {
  """ Failed to fetch report from sandbox service after 10 minutes """
  ANALYSIS_TIMEOUT
  """ Reached configured queued limit for account """
  EXCEED_RATE_LIMIT
  """ Internal server error """
  INTERNAL_ERROR
  """ Invalid file size (0 or too large) """
  INVALID_FILE_SIZE
  """ Failed to submit file for sandbox analysis """
  SUBMISSION_ERROR
  """ Unsupported file type """
  UNSUPPORTED_FILE_TYPE
}

""" Sandbox analysis status """
enum SandboxStatus {
  """ Report has expired """
  EXPIRED
  """ Analysis has failed """
  FAILED
  """ File is being analyzed """
  IN_PROGRESS
  """ File is pending analysis """
  PENDING
  """ File is queued for retry after throttling """
  QUEUED
  """ Analysis is complete - report is ready """
  READY
}

""" Sandbox analysis verdict """
enum SandboxVerdict {
  """ File is clean """
  BENIGN
  """ File is malicious """
  MALICIOUS
  """ File is suspicious """
  SUSPICIOUS
}

enum ScanResult {
  BYPASS_BY_CONTENT_RULE
  BYPASS_BY_OTHER
  BYPASS_BY_TYPE
  CANCELLED
  CLEAN
  ENCRYPTED
  VIRUS_FOUND
}

enum SeverityEnum {
  High
  Low
  Medium
}

enum ShippingStatus {
  CONFIRM_SHIPPING
  DELIVERED
  IN_TRANSIT
  PENDING_INFO
}

enum SimpleServiceType {
  DNS_TCP
  DNS_UDP
  FTP
  HTTP
  HTTPS
  MYSQL
  RDP
  SMTP
  SSH
}

enum SiteConnectionTypeEnum {
  SOCKET_AWS1500
  SOCKET_AZ1500
  SOCKET_ESX1500
  SOCKET_GCP1500
  SOCKET_X1500
  SOCKET_X1600
  SOCKET_X1600_LTE
  SOCKET_X1700
}

enum SiteLicenseGroup {
  """ legacy license group """
  AFRICA
  """ legacy license group """
  ANZ
  """ legacy license group """
  APJ
  """ Country with stand-alone licenses (not part of a group) """
  CHINA
  """ legacy license group """
  DUBAI
  """ legacy license group """
  EUROPE
  GROUP_1
  GROUP_2
  """ legacy license group """
  LATAM
  """ legacy license group """
  MIDDLE_EAST
  """ Country with stand-alone licenses (not part of a group) """
  MOROCCO
  """ legacy license group """
  NAM
  """ Country with stand-alone licenses (not part of a group) """
  VIETNAM
}

enum SiteLicenseType {
  SASE
  SSE
}

enum SiteType {
  BRANCH
  CLOUD_DC
  DATACENTER
  HEADQUARTERS
}

enum SocketAddOnExpansionSlotNumber {
  SLOT_1
  SLOT_2
}

enum SocketAddOnType {
  FOUR_10G_FIBER
  FOUR_1G_COPPER
  TWO_10G_FIBER
  TWO_1G_FIBER
}

enum SocketInterfaceDestType {
  ALTERNATIVE
  CATO
  INTERFACE_DISABLED
  LAN
  LAN_AND_HA
  LAN_LAG_MASTER
  LAN_LAG_MASTER_AND_VRRP
  LAN_LAG_MEMBER
  LAYER_2_WAN
  VRRP
  VRRP_AND_LAN
}

""" SocketInterface available ids, INT_# stands for 1,2,3...12 supported ids """
enum SocketInterfaceIDEnum {
  INT_1
  INT_10
  INT_11
  INT_12
  INT_2
  INT_3
  INT_4
  INT_5
  INT_6
  INT_7
  INT_8
  INT_9
  LAN1
  LAN2
  LTE
  USB1
  USB2
  WAN1
  WAN2
  WLAN
}

enum SocketInterfacePrecedenceEnum {
  ACTIVE
  LAST_RESORT
  PASSIVE
}

enum SocketInterfaceRole {
  wan_1
  wan_2
  wan_3
  wan_4
}

enum SocketInterfaceWanRole {
  NONE
  WAN_1
  WAN_2
  WAN_3
  WAN_4
  none
  wan_1
  wan_2
  wan_3
  wan_4
}

enum SocketInventoryItemStatus {
  CONNECTED
  DELIVERED
  INSTALLED
  ORDERED
  SHIPPED
}

enum SocketLanDirection {
  """ Specifies two-way direction. """
  BOTH
  """ Specifies one-way direction. """
  TO
}

enum SocketLanFirewallAction {
  ALLOW
  BLOCK
}

enum SocketLanFirewallDirection {
  """ Specifies two-way direction. """
  BOTH
  """ Specifies one-way direction. """
  TO
}

enum SocketLanNatType {
  DYNAMIC_PAT
}

enum SocketLanTransportType {
  """ Specifies LAN transport type, routed locally for  inspection of LAN Firewall. """
  LAN
  """ Specifies WAN transport type, send to the PoP for inspection of WAN Firewall. """
  WAN
}

enum SocketModel {
  AWS
  AZURE
  ESX
  GCP
  X1500
  X1600
  X1600_LTE
  X1700
}

enum SocketPlatform {
  AWS1500
  AZ1500
  ESX1500
  GCP1500
  X1500
  X1500B_BR2
  X1500_BR2
  X1600
  X1600_5G
  X1600_LTE
  X1700
  X1700B
}

enum SocketPortMetricsFieldName {
  """ Unique identifier of the account that owns the site. """
  account_id
  """ Total bytes received downstream (from the network to the device). """
  bytes_downstream
  """ Combined total of upstream and downstream bytes. """
  bytes_total
  """ Total bytes sent upstream (from the device to the network). """
  bytes_upstream
  """ Reference Signal Received Power  measures LTE/5G signal strength (dBm). """
  cellular_rsrp
  """ Reference Signal Received Quality  a key LTE/5G metric for link quality (dB). """
  cellular_rsrq
  """ Received Signal Strength Indicator  legacy strength metric (dBm). """
  cellular_rssi
  """ Generic signal strength indicator (often maps to bars or percentage). """
  cellular_signal_strength
  """ Signal to Interference + Noise Ratio  LTE/5G metric for signal clarity (dB). """
  cellular_sinr
  """ Unique identifier of the Socket (Cato edge device). """
  device_id
  """ Indicates the high-availability (HA) role of the device (e.g., active, standby). """
  ha_role
  """ Type of physical interface (e.g., ethernet, cellular). """
  physical_interface_type
  """ SIM card number (for cellular interfaces). """
  sim_num
  """ Unique identifier of the site where the socket is deployed. """
  site_id
  """ Human-readable name of the site. """
  site_name
  """ The name or ID of the physical or logical interface on the Socket device (e.g., eth0, cell1). """
  socket_interface
  """ Describes the interface role such as primary, backup, cellular, or none. """
  socket_interface_role
  """ Current download throughput in Mbps. """
  throughput_downstream
  """ Current upload throughput in Mbps. """
  throughput_upstream
  """ Type of transport used by the interface (e.g., wired, lte, 5g, wifi). """
  transport_type
}

enum SocketRegistrationStatus {
  ASSIGNED_SITE
  ASSIGNED_SITE_PENDING_REGISTER
  NEW
  PENDING
  REGISTERED
  REJECTED
  UNASSIGNING
}

enum SocketUpgradeStatus {
  CANCEL
  FAIL
  FATAL
  PENDING
  PENDING_REBOOT
  RETRY
  SKIP
  STARTED
  STARTING
  SUCCESS
}

enum SortDirectionEnum {
  asc
  desc
}

enum SortOrder {
  ASC
  DESC
}

enum StoryEngineTypeEnum {
  ANOMALY
  ENDPOINT
  IDENTITY
  NETWORK
  THREAT
}

enum StoryProducerEnum {
  AnomalyEvents
  AnomalyExperience
  AnomalyStats
  CatoEndpointAlert
  EntraIdAlert
  MicrosoftEndpointDefender
  NetworkMonitor @deprecated(reason: "No longer supported")
  """ The producer of the Site Operations stories """
  NetworkXDR
  ThreatHunt
  ThreatPrevention
}

enum StorySortFieldName {
  accountName
  createdAt
  criticality
  engineType
  firstSignal
  producer
  queryName
  riskScore
  severity
  source
  sourceIp
  status
  updatedAt
}

enum StoryStatusEnum {
  Closed
  Monitoring
  Open
  PendingAnalysis
  PendingMoreInfo
  Reopened
}

enum StoryVerdictEnum {
  Benign
  Informational
  Malicious
  Suspicious
}

enum SubnetType {
  Direct
  Native
  Routed
  SecondaryNative
  VLAN
}

enum TaggingMethod {
  DOT1Q
  QINQ
}

enum TargetType {
  domain
  fqdn
  ip
  url
}

enum TimeFrameModifier {
  AnalystUpdate
  StoryCreate
  StoryUpdate
}

enum TimelineItemCategoryEnum {
  Error
  Information
  Warning
}

enum TimelineTypeEnum {
  Action
  Comment
  Diff
}

enum TimeseriesMetricType {
  """ Total avg downstream traffic (from the Cato Cloud to the site) """
  bytesDownstream
  """ Total max downstream traffic (from the site to the Cato Cloud) """
  bytesDownstreamMax
  """ Total number of bytes of upstream and downstream traffic """
  bytesTotal
  """ Total avg upstream traffic (from the site to the Cato Cloud) """
  bytesUpstream
  """ Total max upstream traffic (from the site to the Cato Cloud) """
  bytesUpstreamMax
  """ Health analytics for the site """
  health @deprecated(reason: "No longer supported")
  """ Jitter for downstream traffic (difference in time delay in milliseconds (ms) between data packets) """
  jitterDownstream
  """ Jitter for upstream traffic (difference in time delay in milliseconds (ms) between data packets) """
  jitterUpstream
  """
  Latency from socket directly to a well known global service, not through Cato. This is used to measure last
  mile provider's performance, independent of the service.
  """
  lastMileLatency
  """
  Packet loss from socket directly to a well known global services, not through Cato This is used to measure last
  mile provider's performance, independent of the service.
  """
  lastMilePacketLoss
  """ Number of packets lost for downstream traffic """
  lostDownstream
  """ Percent of packet loss for downstream traffic """
  lostDownstreamPcnt
  """ Number of packets lost for upstream traffic """
  lostUpstream
  """ Percent of packet loss for upstream traffic """
  lostUpstreamPcnt
  """ Total packets discarded for downstream traffic """
  packetsDiscardedDownstream
  """ Percent packets discarded for downstream traffic """
  packetsDiscardedDownstreamPcnt
  """ Total packets discarded for upstream traffic """
  packetsDiscardedUpstream
  """ Percent packets discarded for upstream traffic """
  packetsDiscardedUpstreamPcnt
  """ Total downstream packets """
  packetsDownstream
  """ Total upstream packets """
  packetsUpstream
  """ Round-trip time from the Socket to the Cato Cloud """
  rtt
  """ The age of the physical tunnel in milliseconds (It is zeroed even on transparent reconnect) """
  tunnelAge
}

enum TlsInspectAction {
  BYPASS
  INSPECT
}

""" System categories for TLS inspection policy """
enum TlsInspectSystemCategory {
  """ High-popularity cloud apps that were analyzed by Cato's security team and confirmed to be safe for inspection. """
  POPULAR_CLOUD_APPS
  """ Top domains found to be broadly TLS-inspected across the Cato cloud. TLS-inspecting these domains is likely to be safe. """
  SAFE_TO_INSPECT_DOMAINS
}

enum TlsInspectUntrustedCertificateAction {
  ALLOW
  BLOCK
  PROMPT
}

enum TrafficDirectionEnum {
  DOWNSTREAM
  UPSTREAM
}

enum UnitType {
  bits
  """ Bits per second """
  bps
  bytes
  """ Bytes per second """
  bytesPerSec
  """ The number of occurrences for this unit """
  count
  ms
  none
  packets
  percent
  """ health analytics for the site """
  score
  """ For metrics that are measured in seconds, such as tunnelAge, the number of seconds """
  seconds
}

enum UserRole {
  EDITOR
  OWNER
  PUBLIC_EDITOR
  PUBLIC_VIEWER
  SITES_VIEWER
  SUPER_USER
  VIEWER
}

enum VendorEnum {
  CATO
  MICROSOFT
}

enum VrrpType {
  DIRECT_LINK
  VIA_SWITCH
}

enum WanFirewallActionEnum {
  """ Allow the network traffic to pass through the firewall. """
  ALLOW
  """ Deny the network traffic from passing through the firewall. """
  BLOCK
  """ Requests user confirmation to allow or block network traffic. """
  PROMPT
}

enum WanFirewallDirectionEnum {
  BOTH
  TO
}

enum WanNetworkRuleInterfaceRole {
  """ Automatic interface role. """
  AUTOMATIC
  """ No interface role. """
  NONE
  """ WAN1 interface role. """
  WAN1
  """ WAN2 interface role. """
  WAN2
  """ WAN3 interface role. """
  WAN3
  """ WAN4 interface role. """
  WAN4
  """ WAN5 interface role. """
  WAN5
  """ WAN6 interface role. """
  WAN6
}

enum WanNetworkRuleRouteType {
  """ Backhaul routing. """
  BACKHAUL
  """ Backhaul hairpinning routing. """
  BACKHAUL_HAIRPINNING
  """ NAT routing. """
  NAT
  """ No routing. """
  NONE
  """ Optimized routing. Smart Egress using closest destination """
  OPTIMIZED
  """ Route via a specific path. """
  VIA
}

enum WanNetworkRuleTransportType {
  """ Alternative WAN transport type. """
  ALTERNATIVE_WAN
  """ Automatic transport type. """
  AUTOMATIC
  """ No transport type. """
  NONE
  """ Off-cloud transport type. """
  OFF_CLOUD
  """ WAN transport type. """
  WAN
}

enum WanNetworkRuleType {
  """ Inbound Internet transport type. """
  INBOUND_INTERNET
  """ Internet transport type. """
  INTERNET
  """ WAN transport type. """
  WAN
}

""" The action applied by the Always on policy if the rule is matched """
enum ZtnaAlwaysOnRuleActionEnum {
  """ Enforce always on policy. """
  ENFORCE
  """ On demand always on policy. """
  IGNORE
}

""" Return the time unit of the duration time """
enum ZtnaAlwaysOnTimeUnit {
  """ Time in hours """
  HOURS
  """ Time in minutes """
  MINUTES
}

enum ZtnaAppConnectorConnectivityStatus {
  CONNECTED
  DISCONNECTED
}

enum ZtnaAppConnectorInterfaceType {
  CATO
  LAN
}

enum ZtnaAppConnectorSnapshotProbingStatus {
  DISABLED
  DOWN
  UP
}

enum ZtnaAppConnectorSnapshotRoutingStatus {
  DOWN
  UP
}

enum ZtnaAppConnectorType {
  """ physical socket """
  PHYSICAL
  """ virtualized socket """
  VIRTUAL
}

""" Geographical regions that can be associated with a remote user license """
enum ZtnaUsersLicenseGroup {
  """ Country with stand-alone licenses (not part of a group) """
  CHINA
  """ Legacy group """
  DUBAI
  GENERAL
  """ Legacy group """
  LATAM
  """ Country with stand-alone licenses (not part of a group) """
  MOROCCO
  """ Country with stand-alone licenses (not part of a group) """
  VIETNAM
}

##### Interfaces ##########################
interface AccountOperationsTimelineBase {
  created: Time!
  description: String!
  id: ID!
  type: AccountOperationsTimelineType!
  validated: Time!
}

interface Activity {
  id: ID!
  parentResourceId: ID!
  resourceId: ID!
}

interface ActorRef implements ObjectRef {
  id: ID!
  name: String!
}

interface Anomalies implements MergedIncident {
  analystFeedback: AnalystFeedback
  connectionType: ConnectionTypeEnum
  criticality: Int
  description: String
  direction: String
  engineType: StoryEngineTypeEnum
  firstSignal: DateTime!
  id: ID!
  indication: String!
  lastSignal: DateTime!
  predictedThreatType: String
  predictedVerdict: StoryVerdictEnum
  producer: StoryProducerEnum!
  producerName: String!
  queryName: String
  research: Boolean
  similarStoriesData: [SimilarStoryData!]!
  site: SiteRef
  siteName: String @deprecated(reason: "'siteName' is deprecated, use 'site.name' instead")
  source: String
  sourceIp: String
  status: StoryStatusEnum
  storyDuration: Int
  ticket: String
  user: UserRef
  vendor: VendorEnum
}

interface CatoResource implements EndpointResource {
  createdDateTime: DateTime
  id: ID!
  remediationStatus: RemediationStatusEnum
}

""" A group with members of a single type of entity (for example: IPAddress, FQDN) """
interface Container {
  audit: ContainerAudit!
  description: String
  id: ID!
  name: String!
  size: Int!
}

interface DeviceDetails {
  deviceName: String
  externalIp: String
  id: ID!
  localIp: String
  loggedOnUsers: [EndpointUser!]!
  osDetails: OsDetails
}

interface Endpoint implements MergedIncident {
  alerts: [EndpointAlert!]!
  analystFeedback: AnalystFeedback
  connectionType: ConnectionTypeEnum
  criticality: Int
  description: String
  device: DeviceDetails
  engineType: StoryEngineTypeEnum
  firstSignal: DateTime!
  id: ID!
  indication: String!
  lastSignal: DateTime!
  predictedThreatType: String
  predictedVerdict: StoryVerdictEnum
  producer: StoryProducerEnum!
  producerName: String!
  queryName: String
  research: Boolean
  similarStoriesData: [SimilarStoryData!]!
  site: SiteRef
  siteName: String
  source: String
  sourceIp: String
  status: StoryStatusEnum
  storyDuration: Int
  ticket: String
  user: UserRef
  vendor: VendorEnum
}

interface EndpointAlert {
  activities: [Activity!]!
  createdDateTime: DateTime
  criticality: Int
  description: String
  externalIp: String
  id: ID!
  localIp: String
  mitreSubTechnique: [Mitre!]!
  mitreTechnique: [Mitre!]!
  resources: [EndpointResource!]!
  threatName: String
  title: String
}

interface EndpointResource {
  createdDateTime: DateTime
  id: ID!
  remediationStatus: RemediationStatusEnum
}

interface EndpointUser {
  id: ID!
  name: String!
}

interface FileResource implements EndpointResource {
  createdDateTime: DateTime
  detectionStatus: DetectionStatusEnum
  fileDetails: FileDetails
  id: ID!
  remediationStatus: RemediationStatusEnum
}

interface IContainerRef implements ObjectRef {
  id: ID!
  name: String!
}

""" Shared interface for any policy """
interface IPolicy {
  audit: PolicyAudit
  enabled: Boolean!
  revision: PolicyRevision
  rules: [IPolicyRulePayload!]!
  sections: [PolicySectionPayload!]!
}

""" Results of policy change """
interface IPolicyMutationPayload {
  errors: [PolicyMutationError!]!
  policy: IPolicy
  status: PolicyMutationStatus!
}

interface IPolicyRule {
  description: String
  enabled: Boolean!
  id: ID!
  index: Int!
  name: String!
  section: PolicySectionInfo
}

""" Results of rule change """
interface IPolicyRuleMutationPayload {
  errors: [PolicyMutationError!]!
  rule: IPolicyRulePayload
  status: PolicyMutationStatus!
}

""" Results of changes to the rule """
interface IPolicyRulePayload {
  audit: PolicyElementAudit!
  properties: [PolicyElementPropertiesEnum!]!
  rule: IPolicyRule!
}

""" An interface containing properties that are common to all license types """
interface License {
  description: String
  expirationDate: DateTime!
  id: String
  lastUpdated: DateTime
  plan: LicensePlan!
  sku: LicenseSku!
  startDate: DateTime
  status: LicenseStatus!
}

interface MergedIncident {
  analystFeedback: AnalystFeedback
  connectionType: ConnectionTypeEnum
  criticality: Int
  description: String
  engineType: StoryEngineTypeEnum
  firstSignal: DateTime!
  id: ID!
  indication: String!
  lastSignal: DateTime!
  predictedThreatType: String
  predictedVerdict: StoryVerdictEnum
  producer: StoryProducerEnum!
  producerName: String!
  queryName: String
  research: Boolean
  site: SiteRef
  siteName: String @deprecated(reason: "'siteName' is deprecated, use 'site.name' instead")
  source: String
  sourceIp: String
  status: StoryStatusEnum
  storyDuration: Int
  ticket: String
  user: UserRef
  vendor: VendorEnum
}

interface MicrosoftEndpointResource implements EndpointResource {
  createdDateTime: DateTime
  id: ID!
  remediationStatus: RemediationStatusEnum
  remediationStatusDetails: String
  roles: [ResourceRoleEnum!]!
  tags: [String!]!
  verdict: MsResourceVerdictEnum
}

interface NetworkResource implements EndpointResource {
  createdDateTime: DateTime
  destinationIp: String
  destinationPort: Int
  dnsRequest: String
  dnsResponse: String
  id: ID!
  method: String
  remediationStatus: RemediationStatusEnum
  sourcePort: Int
  url: String
}

interface ObjectRef {
  id: ID!
  name: String!
}

interface ProcessResource implements EndpointResource {
  createdDateTime: DateTime
  id: ID!
  imageFile: FileDetails
  processCommandLine: String
  processId: Int!
  remediationStatus: RemediationStatusEnum
  userAccount: EndpointUser
}

interface QuantifiableLicense implements License {
  description: String
  expirationDate: DateTime!
  id: String
  lastUpdated: DateTime
  plan: LicensePlan!
  sku: LicenseSku!
  startDate: DateTime
  status: LicenseStatus!
  total: Int!
}

interface RegistryResource implements EndpointResource {
  createdDateTime: DateTime
  hive: String
  id: ID!
  key: String
  remediationStatus: RemediationStatusEnum
  value: String
  valueName: String
  valueType: String
}

interface UserAttributes {
  riskScore: RiskScoreCondition!
}

##### Unions ##########################
union DegradedStatusArgs = DegradedStatusBasicDataArgs | DegradedStatusLastConnectedArgs | DegradedStatusMultiTunnelArgs | DegradedStatusSocketArgs | DegradedStatusSocketVersionsArgs

union DeviceNetworkRef = GlobalRangeRef | SiteNetworkSubnetRef

union Value = DateValue | Entity | StringValue

