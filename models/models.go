// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package cato_models

import (
	"fmt"
	"io"
	"strconv"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/catonetworks/cato-go-sdk/scalars"
)

type AccountOperationsTimelineBase interface {
	IsAccountOperationsTimelineBase()
	GetCreated() scalars.Time
	GetDescription() string
	GetID() string
	GetType() AccountOperationsTimelineType
	GetValidated() scalars.Time
}

type Activity interface {
	IsActivity()
	GetID() string
	GetParentResourceID() string
	GetResourceID() string
}

type ActorRef interface {
	IsObjectRef()
	IsActorRef()
	GetID() string
	GetName() string
}

type Anomalies interface {
	IsMergedIncident()
	IsAnomalies()
	GetAnalystFeedback() *AnalystFeedback
	GetConnectionType() *ConnectionTypeEnum
	GetCriticality() *int64
	GetDescription() *string
	GetDirection() *string
	GetEngineType() *StoryEngineTypeEnum
	GetFirstSignal() string
	GetID() string
	GetIndication() string
	GetLastSignal() string
	GetPredictedThreatType() *string
	GetPredictedVerdict() *StoryVerdictEnum
	GetProducer() StoryProducerEnum
	GetProducerName() string
	GetQueryName() *string
	GetResearch() *bool
	GetSimilarStoriesData() []*SimilarStoryData
	GetSite() *SiteRef
	GetSiteName() *string
	GetSource() *string
	GetSourceIP() *string
	GetStatus() *StoryStatusEnum
	GetStoryDuration() *int64
	GetTicket() *string
	GetUser() *UserRef
	GetVendor() *VendorEnum
}

type CatoResource interface {
	IsEndpointResource()
	IsCatoResource()
	GetCreatedDateTime() *string
	GetID() string
	GetRemediationStatus() *RemediationStatusEnum
}

// A group with members of a single type of entity (for example: IPAddress, FQDN)
type Container interface {
	IsContainer()
	GetAudit() *ContainerAudit
	GetDescription() *string
	GetID() string
	GetName() string
	GetSize() int64
}

type DegradedStatusArgs interface {
	IsDegradedStatusArgs()
}

type DeviceDetails interface {
	IsDeviceDetails()
	GetDeviceName() *string
	GetExternalIP() *string
	GetID() string
	GetLocalIP() *string
	GetLoggedOnUsers() []EndpointUser
	GetOsDetails() *OsDetails
}

type DeviceNetworkRef interface {
	IsDeviceNetworkRef()
}

type Endpoint interface {
	IsMergedIncident()
	IsEndpoint()
	GetAlerts() []EndpointAlert
	GetAnalystFeedback() *AnalystFeedback
	GetConnectionType() *ConnectionTypeEnum
	GetCriticality() *int64
	GetDescription() *string
	GetDevice() DeviceDetails
	GetEngineType() *StoryEngineTypeEnum
	GetFirstSignal() string
	GetID() string
	GetIndication() string
	GetLastSignal() string
	GetPredictedThreatType() *string
	GetPredictedVerdict() *StoryVerdictEnum
	GetProducer() StoryProducerEnum
	GetProducerName() string
	GetQueryName() *string
	GetResearch() *bool
	GetSimilarStoriesData() []*SimilarStoryData
	GetSite() *SiteRef
	GetSiteName() *string
	GetSource() *string
	GetSourceIP() *string
	GetStatus() *StoryStatusEnum
	GetStoryDuration() *int64
	GetTicket() *string
	GetUser() *UserRef
	GetVendor() *VendorEnum
}

type EndpointAlert interface {
	IsEndpointAlert()
	GetActivities() []Activity
	GetCreatedDateTime() *string
	GetCriticality() *int64
	GetDescription() *string
	GetExternalIP() *string
	GetID() string
	GetLocalIP() *string
	GetMitreSubTechnique() []*Mitre
	GetMitreTechnique() []*Mitre
	GetResources() []EndpointResource
	GetThreatName() *string
	GetTitle() *string
}

type EndpointResource interface {
	IsEndpointResource()
	GetCreatedDateTime() *string
	GetID() string
	GetRemediationStatus() *RemediationStatusEnum
}

type EndpointUser interface {
	IsEndpointUser()
	GetID() string
	GetName() string
}

type FileResource interface {
	IsEndpointResource()
	IsFileResource()
	GetCreatedDateTime() *string
	GetDetectionStatus() *DetectionStatusEnum
	GetFileDetails() *FileDetails
	GetID() string
	GetRemediationStatus() *RemediationStatusEnum
}

type IContainerRef interface {
	IsObjectRef()
	IsIContainerRef()
	GetID() string
	GetName() string
}

// Shared interface for any policy
type IPolicy interface {
	IsIPolicy()
	GetAudit() *PolicyAudit
	GetEnabled() bool
	GetRevision() *PolicyRevision
	GetRules() []IPolicyRulePayload
	GetSections() []*PolicySectionPayload
}

// Results of policy change
type IPolicyMutationPayload interface {
	IsIPolicyMutationPayload()
	GetErrors() []*PolicyMutationError
	GetPolicy() IPolicy
	GetStatus() PolicyMutationStatus
}

type IPolicyRule interface {
	IsIPolicyRule()
	GetDescription() *string
	GetEnabled() bool
	GetID() string
	GetIndex() int64
	GetName() string
	GetSection() *PolicySectionInfo
}

// Results of rule change
type IPolicyRuleMutationPayload interface {
	IsIPolicyRuleMutationPayload()
	GetErrors() []*PolicyMutationError
	GetRule() IPolicyRulePayload
	GetStatus() PolicyMutationStatus
}

// Results of changes to the rule
type IPolicyRulePayload interface {
	IsIPolicyRulePayload()
	GetAudit() *PolicyElementAudit
	GetProperties() []PolicyElementPropertiesEnum
	GetRule() IPolicyRule
}

// An interface containing properties that are common to all license types
type License interface {
	IsLicense()
	GetDescription() *string
	GetExpirationDate() string
	GetID() *string
	GetLastUpdated() *string
	GetPlan() LicensePlan
	GetSku() LicenseSku
	GetStartDate() *string
	GetStatus() LicenseStatus
}

type MergedIncident interface {
	IsMergedIncident()
	GetAnalystFeedback() *AnalystFeedback
	GetConnectionType() *ConnectionTypeEnum
	GetCriticality() *int64
	GetDescription() *string
	GetEngineType() *StoryEngineTypeEnum
	GetFirstSignal() string
	GetID() string
	GetIndication() string
	GetLastSignal() string
	GetPredictedThreatType() *string
	GetPredictedVerdict() *StoryVerdictEnum
	GetProducer() StoryProducerEnum
	GetProducerName() string
	GetQueryName() *string
	GetResearch() *bool
	GetSite() *SiteRef
	GetSiteName() *string
	GetSource() *string
	GetSourceIP() *string
	GetStatus() *StoryStatusEnum
	GetStoryDuration() *int64
	GetTicket() *string
	GetUser() *UserRef
	GetVendor() *VendorEnum
}

type MicrosoftEndpointResource interface {
	IsEndpointResource()
	IsMicrosoftEndpointResource()
	GetCreatedDateTime() *string
	GetID() string
	GetRemediationStatus() *RemediationStatusEnum
	GetRemediationStatusDetails() *string
	GetRoles() []ResourceRoleEnum
	GetTags() []string
	GetVerdict() *MsResourceVerdictEnum
}

type NetworkResource interface {
	IsEndpointResource()
	IsNetworkResource()
	GetCreatedDateTime() *string
	GetDestinationIP() *string
	GetDestinationPort() *int64
	GetDNSRequest() *string
	GetDNSResponse() *string
	GetID() string
	GetMethod() *string
	GetRemediationStatus() *RemediationStatusEnum
	GetSourcePort() *int64
	GetURL() *string
}

type ObjectRef interface {
	IsObjectRef()
	GetID() string
	GetName() string
}

type ProcessResource interface {
	IsEndpointResource()
	IsProcessResource()
	GetCreatedDateTime() *string
	GetID() string
	GetImageFile() *FileDetails
	GetProcessCommandLine() *string
	GetProcessID() int64
	GetRemediationStatus() *RemediationStatusEnum
	GetUserAccount() EndpointUser
}

type QuantifiableLicense interface {
	IsLicense()
	IsQuantifiableLicense()
	GetDescription() *string
	GetExpirationDate() string
	GetID() *string
	GetLastUpdated() *string
	GetPlan() LicensePlan
	GetSku() LicenseSku
	GetStartDate() *string
	GetStatus() LicenseStatus
	GetTotal() int64
}

type RegistryResource interface {
	IsEndpointResource()
	IsRegistryResource()
	GetCreatedDateTime() *string
	GetHive() *string
	GetID() string
	GetKey() *string
	GetRemediationStatus() *RemediationStatusEnum
	GetValue() *string
	GetValueName() *string
	GetValueType() *string
}

type UserAttributes interface {
	IsUserAttributes()
	GetRiskScore() *RiskScoreCondition
}

type Value interface {
	IsValue()
}

type AccessPrivateApplicationMutations struct {
	CreatePrivateApplication *CreatePrivateApplicationPayload `json:"createPrivateApplication,omitempty"`
	DeletePrivateApplication *DeletePrivateApplicationPayload `json:"deletePrivateApplication,omitempty"`
	UpdatePrivateApplication *UpdatePrivateApplicationPayload `json:"updatePrivateApplication,omitempty"`
}

type AccessPrivateApplicationQueries struct {
	PrivateApplication     *PrivateApplication            `json:"privateApplication,omitempty"`
	PrivateApplicationList *PrivateApplicationListPayload `json:"privateApplicationList,omitempty"`
}

type AccountAuditData struct {
	CreatedBy   string `json:"createdBy"`
	CreatedTime string `json:"createdTime"`
}

type AccountDataPayload struct {
	ID        string `json:"id"`
	Name      string `json:"name"`
	Subdomain string `json:"subdomain"`
}

type AccountFilter struct {
	AccountInclusion *AccountInclusion `json:"accountInclusion,omitempty"`
	In               []string          `json:"in,omitempty"`
}

type AccountIDPredicate struct {
	In    []string `json:"in,omitempty"`
	NotIn []string `json:"not_in,omitempty"`
}

type AccountInfo struct {
	Audit       *AccountAuditData  `json:"audit"`
	Description *string            `json:"description,omitempty"`
	ID          string             `json:"id"`
	Name        string             `json:"name"`
	Plan        *AccountPlan       `json:"plan,omitempty"`
	Status      AccountStatus      `json:"status"`
	Tenancy     AccountTenancy     `json:"tenancy"`
	TimeZone    string             `json:"timeZone"`
	Type        AccountProfileType `json:"type"`
}

type AccountManagementMutations struct {
	AddAccount     *AccountInfo           `json:"addAccount,omitempty"`
	DisableAccount *DisableAccountPayload `json:"disableAccount,omitempty"`
	RemoveAccount  *RemoveAccountPayload  `json:"removeAccount,omitempty"`
	UpdateAccount  *AccountInfo           `json:"updateAccount,omitempty"`
}

type AccountManagementQueries struct {
	Account *AccountInfo `json:"account,omitempty"`
}

type AccountMetrics struct {
	From        *string        `json:"from,omitempty"`
	Granularity *int64         `json:"granularity,omitempty"`
	ID          *string        `json:"id,omitempty"`
	Sites       []*SiteMetrics `json:"sites,omitempty"`
	Timeseries  []*Timeseries  `json:"timeseries,omitempty"`
	To          *string        `json:"to,omitempty"`
	Users       []*SiteMetrics `json:"users,omitempty"`
}

type AccountOperationsIncident struct {
	IncidentTimeline []AccountOperationsTimelineBase `json:"incidentTimeline"`
	Metadata         []*AccountOperationsMetadata    `json:"metadata"`
	Playbooks        []*AiOperationsPlaybook         `json:"playbooks"`
}

type AccountOperationsMetadata struct {
	Key   string       `json:"key"`
	Type  MetadataType `json:"type"`
	Value string       `json:"value"`
}

type AccountOperationsTimelineEvent struct {
	Created     scalars.Time                  `json:"created"`
	Description string                        `json:"description"`
	EventIds    []string                      `json:"eventIds"`
	ID          string                        `json:"id"`
	Muted       bool                          `json:"muted"`
	Type        AccountOperationsTimelineType `json:"type"`
	Validated   scalars.Time                  `json:"validated"`
}

func (AccountOperationsTimelineEvent) IsAccountOperationsTimelineBase()            {}
func (this AccountOperationsTimelineEvent) GetCreated() scalars.Time               { return this.Created }
func (this AccountOperationsTimelineEvent) GetDescription() string                 { return this.Description }
func (this AccountOperationsTimelineEvent) GetID() string                          { return this.ID }
func (this AccountOperationsTimelineEvent) GetType() AccountOperationsTimelineType { return this.Type }
func (this AccountOperationsTimelineEvent) GetValidated() scalars.Time             { return this.Validated }

// A reference identifying the Account object. ID: Unique Account Identifier, Name: The Account Name
type AccountRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (AccountRef) IsObjectRef()         {}
func (this AccountRef) GetID() string   { return this.ID }
func (this AccountRef) GetName() string { return this.Name }

type AccountRolesResult struct {
	Items []*RBACRole `json:"items"`
	Total int64       `json:"total"`
}

type AccountSnapshot struct {
	ID        *string         `json:"id,omitempty"`
	Sites     []*SiteSnapshot `json:"sites,omitempty"`
	Timestamp *string         `json:"timestamp,omitempty"`
	Users     []*UserSnapshot `json:"users,omitempty"`
}

type ActorRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

type AddAccountInput struct {
	Description *string            `json:"description,omitempty"`
	Name        string             `json:"name"`
	Tenancy     AccountTenancy     `json:"tenancy"`
	Timezone    string             `json:"timezone"`
	Type        AccountProfileType `json:"type"`
}

type AddAdminInput struct {
	AdminType            *AdminType              `json:"adminType,omitempty"`
	Email                *string                 `json:"email,omitempty"`
	FirstName            string                  `json:"firstName"`
	LastName             string                  `json:"lastName"`
	ManagedRoles         []*UpdateAdminRoleInput `json:"managedRoles,omitempty"`
	MfaEnabled           *bool                   `json:"mfaEnabled,omitempty"`
	PasswordNeverExpires bool                    `json:"passwordNeverExpires"`
	ResellerRoles        []*UpdateAdminRoleInput `json:"resellerRoles,omitempty"`
}

type AddAdminPayload struct {
	AdminID string `json:"adminID"`
}

type AddBgpPeerInput struct {
	AdvertiseAllRoutes     bool                    `json:"advertiseAllRoutes"`
	AdvertiseDefaultRoute  bool                    `json:"advertiseDefaultRoute"`
	AdvertiseSummaryRoutes bool                    `json:"advertiseSummaryRoutes"`
	BfdEnabled             bool                    `json:"bfdEnabled"`
	BfdSettings            *BfdSettingsInput       `json:"bfdSettings,omitempty"`
	CatoAsn                scalars.Asn16           `json:"catoAsn"`
	DefaultAction          BgpDefaultAction        `json:"defaultAction"`
	DefaultActionExclusion []*BgpFilterRuleInput   `json:"defaultActionExclusion"`
	HoldTime               int64                   `json:"holdTime"`
	KeepaliveInterval      int64                   `json:"keepaliveInterval"`
	Md5AuthKey             *string                 `json:"md5AuthKey,omitempty"`
	Metric                 int64                   `json:"metric"`
	Name                   string                  `json:"name"`
	PeerAsn                scalars.Asn32           `json:"peerAsn"`
	PeerIP                 string                  `json:"peerIp"`
	PerformNat             bool                    `json:"performNat"`
	Site                   *SiteRefInput           `json:"site"`
	SummaryRoute           []*BgpSummaryRouteInput `json:"summaryRoute"`
	Tracking               *BgpTrackingInput       `json:"tracking,omitempty"`
}

type AddBgpPeerPayload struct {
	BgpPeer *BgpPeer `json:"bgpPeer"`
}

// Input for adding a new physical connection to a cloud interconnect site.
type AddCloudInterconnectPhysicalConnectionInput struct {
	DownstreamBwLimit   string               `json:"downstreamBwLimit"`
	EncapsulationMethod TaggingMethod        `json:"encapsulationMethod"`
	HaRole              HaRole               `json:"haRole"`
	PopLocation         *PopLocationRefInput `json:"popLocation"`
	PrivateCatoIP       string               `json:"privateCatoIp"`
	PrivateSiteIP       string               `json:"privateSiteIp"`
	ServiceProviderName string               `json:"serviceProviderName"`
	Site                *SiteRefInput        `json:"site"`
	Subnet              string               `json:"subnet"`
	UpstreamBwLimit     string               `json:"upstreamBwLimit"`
}

// Payload for adding a new physical connection to a cloud interconnect site.
type AddCloudInterconnectPhysicalConnectionPayload struct {
	ID string `json:"id"`
}

// Input for adding a new cloud interconnect site.
type AddCloudInterconnectSiteInput struct {
	Description  *string               `json:"description,omitempty"`
	Name         string                `json:"name"`
	SiteLocation *AddSiteLocationInput `json:"siteLocation"`
	SiteType     SiteType              `json:"siteType"`
}

// Payload for adding a new cloud interconnect site.
type AddCloudInterconnectSitePayload struct {
	SiteID string `json:"siteId"`
}

type AddIpsecIkeV2SiteInput struct {
	Description        *string               `json:"description,omitempty"`
	Name               string                `json:"name"`
	NativeNetworkRange string                `json:"nativeNetworkRange"`
	SiteLocation       *AddSiteLocationInput `json:"siteLocation"`
	SiteType           SiteType              `json:"siteType"`
	Vlan               *string               `json:"vlan,omitempty"`
}

type AddIpsecIkeV2SiteMultiTunnelPayload struct {
	Fqdn    *string                           `json:"fqdn,omitempty"`
	Tunnels []*AddIpsecIkeV2SiteTunnelPayload `json:"tunnels"`
}

type AddIpsecIkeV2SitePayload struct {
	SiteID string `json:"siteId"`
}

type AddIpsecIkeV2SiteTunnelPayload struct {
	LocalID  *string             `json:"localId,omitempty"`
	TunnelID *IPSecV2InterfaceID `json:"tunnelId,omitempty"`
}

type AddIpsecIkeV2SiteTunnelsInput struct {
	Primary   *AddIpsecIkeV2TunnelsInput `json:"primary,omitempty"`
	Secondary *AddIpsecIkeV2TunnelsInput `json:"secondary,omitempty"`
}

type AddIpsecIkeV2SiteTunnelsPayload struct {
	Primary   *AddIpsecIkeV2SiteMultiTunnelPayload `json:"primary,omitempty"`
	Secondary *AddIpsecIkeV2SiteMultiTunnelPayload `json:"secondary,omitempty"`
	SiteID    string                               `json:"siteId"`
}

type AddIpsecIkeV2TunnelInput struct {
	LastMileBw    *LastMileBwInput   `json:"lastMileBw,omitempty"`
	Name          *string            `json:"name,omitempty"`
	PrivateCatoIP *string            `json:"privateCatoIp,omitempty"`
	PrivateSiteIP *string            `json:"privateSiteIp,omitempty"`
	Psk           string             `json:"psk"`
	PublicSiteIP  *string            `json:"publicSiteIp,omitempty"`
	Role          *IPSecV2TunnelRole `json:"role,omitempty"`
}

type AddIpsecIkeV2TunnelsInput struct {
	DestinationType *DestinationType            `json:"destinationType,omitempty"`
	PopLocationID   *string                     `json:"popLocationId,omitempty"`
	PublicCatoIPID  *string                     `json:"publicCatoIpId,omitempty"`
	Tunnels         []*AddIpsecIkeV2TunnelInput `json:"tunnels"`
}

type AddNetworkRangeInput struct {
	AzureFloatingIP  *string                   `json:"azureFloatingIp,omitempty"`
	DhcpSettings     *NetworkDhcpSettingsInput `json:"dhcpSettings,omitempty"`
	Gateway          *string                   `json:"gateway,omitempty"`
	InternetOnly     *bool                     `json:"internetOnly,omitempty"`
	LocalIP          *string                   `json:"localIp,omitempty"`
	MdnsReflector    *bool                     `json:"mdnsReflector,omitempty"`
	Name             string                    `json:"name"`
	RangeType        SubnetType                `json:"rangeType"`
	Subnet           string                    `json:"subnet"`
	TranslatedSubnet *string                   `json:"translatedSubnet,omitempty"`
	Vlan             *int64                    `json:"vlan,omitempty"`
}

type AddNetworkRangePayload struct {
	NetworkRangeID string `json:"networkRangeId"`
}

type AddSecondaryAWSVSocketInput struct {
	EniIPAddress string        `json:"eniIpAddress"`
	EniIPSubnet  string        `json:"eniIpSubnet"`
	RouteTableID string        `json:"routeTableId"`
	Site         *SiteRefInput `json:"site"`
}

type AddSecondaryAWSVSocketPayload struct {
	ID string `json:"id"`
}

type AddSecondaryAzureVSocketInput struct {
	FloatingIP  string        `json:"floatingIp"`
	InterfaceIP string        `json:"interfaceIp"`
	Site        *SiteRefInput `json:"site"`
}

type AddSecondaryAzureVSocketPayload struct {
	ID string `json:"id"`
}

type AddServicePrincipalAdminInput struct {
	Email         *string                 `json:"email,omitempty"`
	ManagedRoles  []*UpdateAdminRoleInput `json:"managedRoles,omitempty"`
	Name          string                  `json:"name"`
	ResellerRoles []*UpdateAdminRoleInput `json:"resellerRoles,omitempty"`
}

type AddServicePrincipalAdminPayload struct {
	AdminID string `json:"adminID"`
}

type AddSiteLocationInput struct {
	Address     *string `json:"address,omitempty"`
	City        *string `json:"city,omitempty"`
	CountryCode string  `json:"countryCode"`
	StateCode   *string `json:"stateCode,omitempty"`
	Timezone    string  `json:"timezone"`
}

type AddSocketAddOnCardInput struct {
	AddOns []*SocketAddOnCardInput `json:"addOns"`
	Site   *SiteRefInput           `json:"site"`
}

type AddSocketAddOnCardPayload struct {
	AddOns []*SocketAddOnCard `json:"addOns"`
}

type AddSocketSiteInput struct {
	ConnectionType     SiteConnectionTypeEnum `json:"connectionType"`
	Description        *string                `json:"description,omitempty"`
	Name               string                 `json:"name"`
	NativeNetworkRange string                 `json:"nativeNetworkRange"`
	SiteLocation       *AddSiteLocationInput  `json:"siteLocation"`
	SiteType           SiteType               `json:"siteType"`
	TranslatedSubnet   *string                `json:"translatedSubnet,omitempty"`
	Vlan               *string                `json:"vlan,omitempty"`
}

type AddSocketSitePayload struct {
	SiteID string `json:"siteId"`
}

type AddStaticHostInput struct {
	IP         string  `json:"ip"`
	MacAddress *string `json:"macAddress,omitempty"`
	Name       string  `json:"name"`
}

type AddStaticHostPayload struct {
	HostID string `json:"hostId"`
}

type AddStoryCommentInput struct {
	StoryID string `json:"storyId"`
	Text    string `json:"text"`
}

type AddStoryCommentPayload struct {
	Comment *StoryComment `json:"comment"`
}

// Input for creating a new ZTNA App Connector
type AddZtnaAppConnectorInput struct {
	Description          *string                                    `json:"description,omitempty"`
	GroupName            string                                     `json:"groupName"`
	Location             *ZtnaAppConnectorLocationInput             `json:"location"`
	Name                 string                                     `json:"name"`
	PreferredPopLocation *ZtnaAppConnectorPreferredPopLocationInput `json:"preferredPopLocation"`
	Type                 ZtnaAppConnectorType                       `json:"type"`
}

type AddZtnaAppConnectorPayload struct {
	ZtnaAppConnector *ZtnaAppConnector `json:"ztnaAppConnector"`
}

// Input for creating ZTNA App Connectors configuration.
// If not provided, default ranges will be used (100.64.0.0/16 for Private Apps Service, 100.65.0.0/16
// for App Connector Service).
type AddZtnaAppConnectorsConfigurationInput struct {
	AppConnectorManagementRange string `json:"appConnectorManagementRange"`
	PrivateAppsServiceRange     string `json:"privateAppsServiceRange"`
}

// Payload returned after creating ZTNA App Connectors configuration.
type AddZtnaAppConnectorsConfigurationPayload struct {
	ZtnaAppConnectorsConfiguration *ZtnaAppConnectorsConfiguration `json:"ztnaAppConnectorsConfiguration"`
}

type AddressInput struct {
	CityName    string  `json:"cityName"`
	CompanyName string  `json:"companyName"`
	CountryName string  `json:"countryName"`
	StateName   *string `json:"stateName,omitempty"`
	Street      string  `json:"street"`
	ZipCode     string  `json:"zipCode"`
}

// A CC2 administrator
type Admin struct {
	AdminType             *AdminType                 `json:"adminType,omitempty"`
	AllowedItems          []*Entity                  `json:"allowedItems,omitempty"`
	CreationDate          *string                    `json:"creationDate,omitempty"`
	Email                 *string                    `json:"email,omitempty"`
	FirstName             *string                    `json:"firstName,omitempty"`
	ID                    string                     `json:"id"`
	LastName              *string                    `json:"lastName,omitempty"`
	ManagedRoles          []*AdminRole               `json:"managedRoles,omitempty"`
	MfaEnabled            *bool                      `json:"mfaEnabled,omitempty"`
	ModifyDate            *string                    `json:"modifyDate,omitempty"`
	NativeAccountID       *string                    `json:"nativeAccountID,omitempty"`
	PasswordNeverExpires  *bool                      `json:"passwordNeverExpires,omitempty"`
	PresentUsageAndEvents *bool                      `json:"presentUsageAndEvents,omitempty"`
	ResellerRoles         []*AdminRole               `json:"resellerRoles,omitempty"`
	Role                  *UserRole                  `json:"role,omitempty"`
	Status                *scalars.OperationalStatus `json:"status,omitempty"`
	Version               string                     `json:"version"`
}

type AdminMutations struct {
	AddAdmin                    *AddAdminPayload                    `json:"addAdmin,omitempty"`
	AddServicePrincipalAdmin    *AddServicePrincipalAdminPayload    `json:"addServicePrincipalAdmin,omitempty"`
	RemoveAdmin                 *RemoveAdminPayload                 `json:"removeAdmin,omitempty"`
	RemoveServicePrincipalAdmin *RemoveServicePrincipalAdminPayload `json:"removeServicePrincipalAdmin,omitempty"`
	UpdateAdmin                 *UpdateAdminPayload                 `json:"updateAdmin,omitempty"`
	UpdateServicePrincipalAdmin *UpdateServicePrincipalAdminPayload `json:"updateServicePrincipalAdmin,omitempty"`
}

// A reference identifying the Admin object. ID: Unique Admin Identifier, Name: The Admin Name
type AdminRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (AdminRef) IsActorRef()          {}
func (this AdminRef) GetID() string   { return this.ID }
func (this AdminRef) GetName() string { return this.Name }

func (AdminRef) IsObjectRef() {}

type AdminRole struct {
	AllowedAccounts []string  `json:"allowedAccounts,omitempty"`
	AllowedEntities []*Entity `json:"allowedEntities,omitempty"`
	Role            *RBACRole `json:"role"`
}

type AdminsResult struct {
	Items []*Admin `json:"items"`
	Total int64    `json:"total"`
}

type AdvancedStringFilterInput struct {
	Eq    *string  `json:"eq,omitempty"`
	In    []string `json:"in,omitempty"`
	Neq   *string  `json:"neq,omitempty"`
	Nin   []string `json:"nin,omitempty"`
	Regex *string  `json:"regex,omitempty"`
}

type AiOperationsIncident struct {
	AccountOperationIncident *AccountOperationsIncident    `json:"accountOperationIncident,omitempty"`
	AnalystFeedback          *AnalystFeedback              `json:"analystFeedback,omitempty"`
	ConnectionType           *ConnectionTypeEnum           `json:"connectionType,omitempty"`
	Criticality              *int64                        `json:"criticality,omitempty"`
	Description              *string                       `json:"description,omitempty"`
	EngineType               *StoryEngineTypeEnum          `json:"engineType,omitempty"`
	EventsGraphQuery         *EventsGraphQuery             `json:"eventsGraphQuery,omitempty"`
	FirstSignal              string                        `json:"firstSignal"`
	FlowLastTime             string                        `json:"flowLastTime"`
	FlowStartTime            string                        `json:"flowStartTime"`
	ID                       string                        `json:"id"`
	Indication               string                        `json:"indication"`
	Ioa                      string                        `json:"ioa"`
	LastSignal               string                        `json:"lastSignal"`
	Occurrences              *int64                        `json:"occurrences,omitempty"`
	PredictedThreatType      *string                       `json:"predictedThreatType,omitempty"`
	PredictedVerdict         *StoryVerdictEnum             `json:"predictedVerdict,omitempty"`
	Producer                 StoryProducerEnum             `json:"producer"`
	ProducerName             string                        `json:"producerName"`
	QueryName                *string                       `json:"queryName,omitempty"`
	Research                 *bool                         `json:"research,omitempty"`
	RiskScore                int64                         `json:"riskScore"`
	SimilarStoriesData       []*SimilarStoryData           `json:"similarStoriesData"`
	Site                     *SiteRef                      `json:"site,omitempty"`
	SiteName                 *string                       `json:"siteName,omitempty"`
	Source                   *string                       `json:"source,omitempty"`
	SourceIP                 *string                       `json:"sourceIp,omitempty"`
	Status                   *StoryStatusEnum              `json:"status,omitempty"`
	StoryDuration            *int64                        `json:"storyDuration,omitempty"`
	Ticket                   *string                       `json:"ticket,omitempty"`
	Type                     *AiOperationsIncidentTypeEnum `json:"type,omitempty"`
	User                     *UserRef                      `json:"user,omitempty"`
	Vendor                   *VendorEnum                   `json:"vendor,omitempty"`
}

func (AiOperationsIncident) IsMergedIncident()                           {}
func (this AiOperationsIncident) GetAnalystFeedback() *AnalystFeedback   { return this.AnalystFeedback }
func (this AiOperationsIncident) GetConnectionType() *ConnectionTypeEnum { return this.ConnectionType }
func (this AiOperationsIncident) GetCriticality() *int64                 { return this.Criticality }
func (this AiOperationsIncident) GetDescription() *string                { return this.Description }
func (this AiOperationsIncident) GetEngineType() *StoryEngineTypeEnum    { return this.EngineType }
func (this AiOperationsIncident) GetFirstSignal() string                 { return this.FirstSignal }
func (this AiOperationsIncident) GetID() string                          { return this.ID }
func (this AiOperationsIncident) GetIndication() string                  { return this.Indication }
func (this AiOperationsIncident) GetLastSignal() string                  { return this.LastSignal }
func (this AiOperationsIncident) GetPredictedThreatType() *string        { return this.PredictedThreatType }
func (this AiOperationsIncident) GetPredictedVerdict() *StoryVerdictEnum {
	return this.PredictedVerdict
}
func (this AiOperationsIncident) GetProducer() StoryProducerEnum { return this.Producer }
func (this AiOperationsIncident) GetProducerName() string        { return this.ProducerName }
func (this AiOperationsIncident) GetQueryName() *string          { return this.QueryName }
func (this AiOperationsIncident) GetResearch() *bool             { return this.Research }
func (this AiOperationsIncident) GetSite() *SiteRef              { return this.Site }
func (this AiOperationsIncident) GetSiteName() *string           { return this.SiteName }
func (this AiOperationsIncident) GetSource() *string             { return this.Source }
func (this AiOperationsIncident) GetSourceIP() *string           { return this.SourceIP }
func (this AiOperationsIncident) GetStatus() *StoryStatusEnum    { return this.Status }
func (this AiOperationsIncident) GetStoryDuration() *int64       { return this.StoryDuration }
func (this AiOperationsIncident) GetTicket() *string             { return this.Ticket }
func (this AiOperationsIncident) GetUser() *UserRef              { return this.User }
func (this AiOperationsIncident) GetVendor() *VendorEnum         { return this.Vendor }

type AiOperationsPlaybook struct {
	Description string  `json:"description"`
	Link        *string `json:"link,omitempty"`
	Title       string  `json:"title"`
}

// A reference identifying the AllocatedIp object. ID: Unique AllocatedIp Identifier, Name: The AllocatedIp Name
type AllocatedIPRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (AllocatedIPRef) IsObjectRef()         {}
func (this AllocatedIPRef) GetID() string   { return this.ID }
func (this AllocatedIPRef) GetName() string { return this.Name }

type AllocatedIPRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

type AnalystFeedback struct {
	AdditionalInfo       *string                    `json:"additionalInfo,omitempty"`
	Severity             *SeverityEnum              `json:"severity,omitempty"`
	ThreatClassification *string                    `json:"threatClassification,omitempty"`
	ThreatType           *AnalystFeedbackThreatType `json:"threatType,omitempty"`
	Verdict              *StoryVerdictEnum          `json:"verdict,omitempty"`
}

type AnalystFeedbackInput struct {
	AdditionalInfo       *string           `json:"additionalInfo,omitempty"`
	Severity             *SeverityEnum     `json:"severity,omitempty"`
	Status               *StoryStatusEnum  `json:"status,omitempty"`
	StoryID              string            `json:"storyId"`
	ThreatClassification *string           `json:"threatClassification,omitempty"`
	ThreatType           *StoryThreatType  `json:"threatType,omitempty"`
	Verdict              *StoryVerdictEnum `json:"verdict,omitempty"`
}

type AnalystFeedbackPayload struct {
	Story *Story `json:"story,omitempty"`
}

type AnalystFeedbackThreatType struct {
	Details           *string `json:"details,omitempty"`
	Name              *string `json:"name,omitempty"`
	RecommendedAction *string `json:"recommendedAction,omitempty"`
}

type AnalystInfo struct {
	Email *string `json:"email,omitempty"`
	Name  *string `json:"name,omitempty"`
}

// The `AnomalyEvents` object represents a data structure used in GraphQL queries or mutations, containing fields related to security anomalies, such as analyst feedback, connection type, criticality, description, and various identifiers and metrics, to provide detailed information about potential security incidents.
type AnomalyEvents struct {
	AnalystFeedback     *AnalystFeedback        `json:"analystFeedback,omitempty"`
	BreakdownField      *string                 `json:"breakdownField,omitempty"`
	ClientClass         []string                `json:"clientClass"`
	ConnectionType      *ConnectionTypeEnum     `json:"connectionType,omitempty"`
	Criticality         *int64                  `json:"criticality,omitempty"`
	Description         *string                 `json:"description,omitempty"`
	DeviceName          *string                 `json:"deviceName,omitempty"`
	Direction           *string                 `json:"direction,omitempty"`
	DrillDownFilter     []*StoryDrillDownFilter `json:"drillDownFilter,omitempty"`
	EngineType          *StoryEngineTypeEnum    `json:"engineType,omitempty"`
	Extra               []*Extra                `json:"extra,omitempty"`
	FirstSignal         string                  `json:"firstSignal"`
	Gaussian            *Gaussian               `json:"gaussian,omitempty"`
	ID                  string                  `json:"id"`
	Indication          string                  `json:"indication"`
	LastSignal          string                  `json:"lastSignal"`
	LogonName           *string                 `json:"logonName,omitempty"`
	MacAddress          *string                 `json:"macAddress,omitempty"`
	Metric              *Metric                 `json:"metric,omitempty"`
	MetricDetails       *MetricDetails          `json:"metricDetails,omitempty"`
	Mitres              []*Mitre                `json:"mitres,omitempty"`
	Os                  *string                 `json:"os,omitempty"`
	PredictedThreatType *string                 `json:"predictedThreatType,omitempty"`
	PredictedVerdict    *StoryVerdictEnum       `json:"predictedVerdict,omitempty"`
	Producer            StoryProducerEnum       `json:"producer"`
	ProducerName        string                  `json:"producerName"`
	QueryName           *string                 `json:"queryName,omitempty"`
	Research            *bool                   `json:"research,omitempty"`
	Rules               []string                `json:"rules,omitempty"`
	SimilarStoriesData  []*SimilarStoryData     `json:"similarStoriesData"`
	Site                *SiteRef                `json:"site,omitempty"`
	SiteName            *string                 `json:"siteName,omitempty"`
	Source              *string                 `json:"source,omitempty"`
	SourceIP            *string                 `json:"sourceIp,omitempty"`
	SrcSiteID           *string                 `json:"srcSiteId,omitempty"`
	Status              *StoryStatusEnum        `json:"status,omitempty"`
	StoryDuration       *int64                  `json:"storyDuration,omitempty"`
	SubjectType         *string                 `json:"subjectType,omitempty"`
	Targets             []*IncidentTargetRep    `json:"targets"`
	Ticket              *string                 `json:"ticket,omitempty"`
	TimeSeries          []*IncidentTimeseries   `json:"timeSeries,omitempty"`
	User                *UserRef                `json:"user,omitempty"`
	Vendor              *VendorEnum             `json:"vendor,omitempty"`
}

func (AnomalyEvents) IsAnomalies()                                {}
func (this AnomalyEvents) GetAnalystFeedback() *AnalystFeedback   { return this.AnalystFeedback }
func (this AnomalyEvents) GetConnectionType() *ConnectionTypeEnum { return this.ConnectionType }
func (this AnomalyEvents) GetCriticality() *int64                 { return this.Criticality }
func (this AnomalyEvents) GetDescription() *string                { return this.Description }
func (this AnomalyEvents) GetDirection() *string                  { return this.Direction }
func (this AnomalyEvents) GetEngineType() *StoryEngineTypeEnum    { return this.EngineType }
func (this AnomalyEvents) GetFirstSignal() string                 { return this.FirstSignal }
func (this AnomalyEvents) GetID() string                          { return this.ID }
func (this AnomalyEvents) GetIndication() string                  { return this.Indication }
func (this AnomalyEvents) GetLastSignal() string                  { return this.LastSignal }
func (this AnomalyEvents) GetPredictedThreatType() *string        { return this.PredictedThreatType }
func (this AnomalyEvents) GetPredictedVerdict() *StoryVerdictEnum { return this.PredictedVerdict }
func (this AnomalyEvents) GetProducer() StoryProducerEnum         { return this.Producer }
func (this AnomalyEvents) GetProducerName() string                { return this.ProducerName }
func (this AnomalyEvents) GetQueryName() *string                  { return this.QueryName }
func (this AnomalyEvents) GetResearch() *bool                     { return this.Research }
func (this AnomalyEvents) GetSimilarStoriesData() []*SimilarStoryData {
	if this.SimilarStoriesData == nil {
		return nil
	}
	interfaceSlice := make([]*SimilarStoryData, 0, len(this.SimilarStoriesData))
	for _, concrete := range this.SimilarStoriesData {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this AnomalyEvents) GetSite() *SiteRef           { return this.Site }
func (this AnomalyEvents) GetSiteName() *string        { return this.SiteName }
func (this AnomalyEvents) GetSource() *string          { return this.Source }
func (this AnomalyEvents) GetSourceIP() *string        { return this.SourceIP }
func (this AnomalyEvents) GetStatus() *StoryStatusEnum { return this.Status }
func (this AnomalyEvents) GetStoryDuration() *int64    { return this.StoryDuration }
func (this AnomalyEvents) GetTicket() *string          { return this.Ticket }
func (this AnomalyEvents) GetUser() *UserRef           { return this.User }
func (this AnomalyEvents) GetVendor() *VendorEnum      { return this.Vendor }

func (AnomalyEvents) IsMergedIncident() {}

// The `AnomalyStats` object is a GraphQL type that represents statistical data related to anomalies, including fields such as analyst feedback, connection type, criticality, device information, and various metrics, along with associated metadata like timestamps, status, and predicted verdicts.
type AnomalyStats struct {
	AnalystFeedback     *AnalystFeedback        `json:"analystFeedback,omitempty"`
	BreakdownField      *string                 `json:"breakdownField,omitempty"`
	ClientClass         []string                `json:"clientClass"`
	ConnectionType      *ConnectionTypeEnum     `json:"connectionType,omitempty"`
	Criticality         *int64                  `json:"criticality,omitempty"`
	Description         *string                 `json:"description,omitempty"`
	DeviceName          *string                 `json:"deviceName,omitempty"`
	Direction           *string                 `json:"direction,omitempty"`
	DrillDownFilter     []*StoryDrillDownFilter `json:"drillDownFilter,omitempty"`
	EngineType          *StoryEngineTypeEnum    `json:"engineType,omitempty"`
	Extra               []*Extra                `json:"extra,omitempty"`
	FirstSignal         string                  `json:"firstSignal"`
	Gaussian            *Gaussian               `json:"gaussian,omitempty"`
	ID                  string                  `json:"id"`
	Indication          string                  `json:"indication"`
	LastSignal          string                  `json:"lastSignal"`
	LogonName           *string                 `json:"logonName,omitempty"`
	MacAddress          *string                 `json:"macAddress,omitempty"`
	Metric              *Metric                 `json:"metric,omitempty"`
	MetricDetails       *MetricDetails          `json:"metricDetails,omitempty"`
	Mitres              []*Mitre                `json:"mitres,omitempty"`
	Os                  *string                 `json:"os,omitempty"`
	PredictedThreatType *string                 `json:"predictedThreatType,omitempty"`
	PredictedVerdict    *StoryVerdictEnum       `json:"predictedVerdict,omitempty"`
	Producer            StoryProducerEnum       `json:"producer"`
	ProducerName        string                  `json:"producerName"`
	QueryName           *string                 `json:"queryName,omitempty"`
	Research            *bool                   `json:"research,omitempty"`
	Rules               []string                `json:"rules,omitempty"`
	SimilarStoriesData  []*SimilarStoryData     `json:"similarStoriesData"`
	Site                *SiteRef                `json:"site,omitempty"`
	SiteName            *string                 `json:"siteName,omitempty"`
	Source              *string                 `json:"source,omitempty"`
	SourceIP            *string                 `json:"sourceIp,omitempty"`
	SrcSiteID           *string                 `json:"srcSiteId,omitempty"`
	Status              *StoryStatusEnum        `json:"status,omitempty"`
	StoryDuration       *int64                  `json:"storyDuration,omitempty"`
	SubjectType         *string                 `json:"subjectType,omitempty"`
	Targets             []*IncidentTargetRep    `json:"targets"`
	Ticket              *string                 `json:"ticket,omitempty"`
	TimeSeries          []*IncidentTimeseries   `json:"timeSeries,omitempty"`
	User                *UserRef                `json:"user,omitempty"`
	Vendor              *VendorEnum             `json:"vendor,omitempty"`
}

func (AnomalyStats) IsAnomalies()                                {}
func (this AnomalyStats) GetAnalystFeedback() *AnalystFeedback   { return this.AnalystFeedback }
func (this AnomalyStats) GetConnectionType() *ConnectionTypeEnum { return this.ConnectionType }
func (this AnomalyStats) GetCriticality() *int64                 { return this.Criticality }
func (this AnomalyStats) GetDescription() *string                { return this.Description }
func (this AnomalyStats) GetDirection() *string                  { return this.Direction }
func (this AnomalyStats) GetEngineType() *StoryEngineTypeEnum    { return this.EngineType }
func (this AnomalyStats) GetFirstSignal() string                 { return this.FirstSignal }
func (this AnomalyStats) GetID() string                          { return this.ID }
func (this AnomalyStats) GetIndication() string                  { return this.Indication }
func (this AnomalyStats) GetLastSignal() string                  { return this.LastSignal }
func (this AnomalyStats) GetPredictedThreatType() *string        { return this.PredictedThreatType }
func (this AnomalyStats) GetPredictedVerdict() *StoryVerdictEnum { return this.PredictedVerdict }
func (this AnomalyStats) GetProducer() StoryProducerEnum         { return this.Producer }
func (this AnomalyStats) GetProducerName() string                { return this.ProducerName }
func (this AnomalyStats) GetQueryName() *string                  { return this.QueryName }
func (this AnomalyStats) GetResearch() *bool                     { return this.Research }
func (this AnomalyStats) GetSimilarStoriesData() []*SimilarStoryData {
	if this.SimilarStoriesData == nil {
		return nil
	}
	interfaceSlice := make([]*SimilarStoryData, 0, len(this.SimilarStoriesData))
	for _, concrete := range this.SimilarStoriesData {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this AnomalyStats) GetSite() *SiteRef           { return this.Site }
func (this AnomalyStats) GetSiteName() *string        { return this.SiteName }
func (this AnomalyStats) GetSource() *string          { return this.Source }
func (this AnomalyStats) GetSourceIP() *string        { return this.SourceIP }
func (this AnomalyStats) GetStatus() *StoryStatusEnum { return this.Status }
func (this AnomalyStats) GetStoryDuration() *int64    { return this.StoryDuration }
func (this AnomalyStats) GetTicket() *string          { return this.Ticket }
func (this AnomalyStats) GetUser() *UserRef           { return this.User }
func (this AnomalyStats) GetVendor() *VendorEnum      { return this.Vendor }

func (AnomalyStats) IsMergedIncident() {}

type AntiMalwareFileHashAddRuleDataInput struct {
	Action         AntiMalwareFileHashAction `json:"action"`
	Description    string                    `json:"description"`
	Enabled        bool                      `json:"enabled"`
	ExpirationDate string                    `json:"expirationDate"`
	FileName       string                    `json:"fileName"`
	Name           string                    `json:"name"`
	Sha256         string                    `json:"sha256"`
}

type AntiMalwareFileHashAddRuleInput struct {
	At   *PolicyRulePositionInput             `json:"at,omitempty"`
	Rule *AntiMalwareFileHashAddRuleDataInput `json:"rule"`
}

type AntiMalwareFileHashPolicy struct {
	Audit    *PolicyAudit                      `json:"audit,omitempty"`
	Enabled  bool                              `json:"enabled"`
	Revision *PolicyRevision                   `json:"revision,omitempty"`
	Rules    []*AntiMalwareFileHashRulePayload `json:"rules"`
	Sections []*PolicySectionPayload           `json:"sections"`
}

func (AntiMalwareFileHashPolicy) IsIPolicy()                        {}
func (this AntiMalwareFileHashPolicy) GetAudit() *PolicyAudit       { return this.Audit }
func (this AntiMalwareFileHashPolicy) GetEnabled() bool             { return this.Enabled }
func (this AntiMalwareFileHashPolicy) GetRevision() *PolicyRevision { return this.Revision }
func (this AntiMalwareFileHashPolicy) GetRules() []IPolicyRulePayload {
	if this.Rules == nil {
		return nil
	}
	interfaceSlice := make([]IPolicyRulePayload, 0, len(this.Rules))
	for _, concrete := range this.Rules {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this AntiMalwareFileHashPolicy) GetSections() []*PolicySectionPayload {
	if this.Sections == nil {
		return nil
	}
	interfaceSlice := make([]*PolicySectionPayload, 0, len(this.Sections))
	for _, concrete := range this.Sections {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

type AntiMalwareFileHashPolicyInput struct {
	Revision *PolicyRevisionInput `json:"revision,omitempty"`
}

type AntiMalwareFileHashPolicyMutationInput struct {
	Revision *PolicyMutationRevisionInput `json:"revision,omitempty"`
}

type AntiMalwareFileHashPolicyMutationPayload struct {
	Errors []*PolicyMutationError     `json:"errors"`
	Policy *AntiMalwareFileHashPolicy `json:"policy,omitempty"`
	Status PolicyMutationStatus       `json:"status"`
}

func (AntiMalwareFileHashPolicyMutationPayload) IsIPolicyMutationPayload() {}
func (this AntiMalwareFileHashPolicyMutationPayload) GetErrors() []*PolicyMutationError {
	if this.Errors == nil {
		return nil
	}
	interfaceSlice := make([]*PolicyMutationError, 0, len(this.Errors))
	for _, concrete := range this.Errors {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this AntiMalwareFileHashPolicyMutationPayload) GetPolicy() IPolicy { return *this.Policy }
func (this AntiMalwareFileHashPolicyMutationPayload) GetStatus() PolicyMutationStatus {
	return this.Status
}

type AntiMalwareFileHashPolicyMutations struct {
	AddRule               *AntiMalwareFileHashRuleMutationPayload   `json:"addRule"`
	AddSection            *PolicySectionMutationPayload             `json:"addSection"`
	CreatePolicyRevision  *AntiMalwareFileHashPolicyMutationPayload `json:"createPolicyRevision"`
	DiscardPolicyRevision *AntiMalwareFileHashPolicyMutationPayload `json:"discardPolicyRevision"`
	MoveRule              *AntiMalwareFileHashRuleMutationPayload   `json:"moveRule"`
	MoveSection           *PolicySectionMutationPayload             `json:"moveSection"`
	PublishPolicyRevision *AntiMalwareFileHashPolicyMutationPayload `json:"publishPolicyRevision"`
	RemoveRule            *AntiMalwareFileHashRuleMutationPayload   `json:"removeRule"`
	RemoveSection         *PolicySectionMutationPayload             `json:"removeSection"`
	UpdatePolicy          *AntiMalwareFileHashPolicyMutationPayload `json:"updatePolicy"`
	UpdateRule            *AntiMalwareFileHashRuleMutationPayload   `json:"updateRule"`
	UpdateSection         *PolicySectionMutationPayload             `json:"updateSection"`
}

type AntiMalwareFileHashPolicyQueries struct {
	Policy    *AntiMalwareFileHashPolicy `json:"policy"`
	Revisions *PolicyRevisionsPayload    `json:"revisions,omitempty"`
}

type AntiMalwareFileHashPolicyUpdateInput struct {
	State *PolicyToggleState `json:"state,omitempty"`
}

type AntiMalwareFileHashRemoveRuleInput struct {
	ID string `json:"id"`
}

type AntiMalwareFileHashRule struct {
	Action         AntiMalwareFileHashAction `json:"action"`
	Description    string                    `json:"description"`
	Enabled        bool                      `json:"enabled"`
	ExpirationDate string                    `json:"expirationDate"`
	FileName       string                    `json:"fileName"`
	ID             string                    `json:"id"`
	Index          int64                     `json:"index"`
	Name           string                    `json:"name"`
	Section        *PolicySectionInfo        `json:"section"`
	Sha256         string                    `json:"sha256"`
}

func (AntiMalwareFileHashRule) IsIPolicyRule()                      {}
func (this AntiMalwareFileHashRule) GetDescription() *string        { return &this.Description }
func (this AntiMalwareFileHashRule) GetEnabled() bool               { return this.Enabled }
func (this AntiMalwareFileHashRule) GetID() string                  { return this.ID }
func (this AntiMalwareFileHashRule) GetIndex() int64                { return this.Index }
func (this AntiMalwareFileHashRule) GetName() string                { return this.Name }
func (this AntiMalwareFileHashRule) GetSection() *PolicySectionInfo { return this.Section }

type AntiMalwareFileHashRuleMutationPayload struct {
	Errors []*PolicyMutationError          `json:"errors"`
	Rule   *AntiMalwareFileHashRulePayload `json:"rule,omitempty"`
	Status PolicyMutationStatus            `json:"status"`
}

func (AntiMalwareFileHashRuleMutationPayload) IsIPolicyRuleMutationPayload() {}
func (this AntiMalwareFileHashRuleMutationPayload) GetErrors() []*PolicyMutationError {
	if this.Errors == nil {
		return nil
	}
	interfaceSlice := make([]*PolicyMutationError, 0, len(this.Errors))
	for _, concrete := range this.Errors {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this AntiMalwareFileHashRuleMutationPayload) GetRule() IPolicyRulePayload { return *this.Rule }
func (this AntiMalwareFileHashRuleMutationPayload) GetStatus() PolicyMutationStatus {
	return this.Status
}

type AntiMalwareFileHashRulePayload struct {
	Audit      *PolicyElementAudit           `json:"audit"`
	Properties []PolicyElementPropertiesEnum `json:"properties"`
	Rule       *AntiMalwareFileHashRule      `json:"rule"`
}

func (AntiMalwareFileHashRulePayload) IsIPolicyRulePayload()              {}
func (this AntiMalwareFileHashRulePayload) GetAudit() *PolicyElementAudit { return this.Audit }
func (this AntiMalwareFileHashRulePayload) GetProperties() []PolicyElementPropertiesEnum {
	if this.Properties == nil {
		return nil
	}
	interfaceSlice := make([]PolicyElementPropertiesEnum, 0, len(this.Properties))
	for _, concrete := range this.Properties {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this AntiMalwareFileHashRulePayload) GetRule() IPolicyRule { return *this.Rule }

type AntiMalwareFileHashUpdateRuleDataInput struct {
	Action         *AntiMalwareFileHashAction `json:"action,omitempty"`
	Description    *string                    `json:"description,omitempty"`
	Enabled        *bool                      `json:"enabled,omitempty"`
	ExpirationDate *string                    `json:"expirationDate,omitempty"`
	FileName       *string                    `json:"fileName,omitempty"`
	Name           *string                    `json:"name,omitempty"`
	Sha256         *string                    `json:"sha256,omitempty"`
}

type AntiMalwareFileHashUpdateRuleInput struct {
	ID   string                                  `json:"id"`
	Rule *AntiMalwareFileHashUpdateRuleDataInput `json:"rule"`
}

// A reference identifying the ApiKey object. ID: Unique ApiKey Identifier, Name: The ApiKey Name
type APIKeyRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (APIKeyRef) IsActorRef()          {}
func (this APIKeyRef) GetID() string   { return this.ID }
func (this APIKeyRef) GetName() string { return this.Name }

func (APIKeyRef) IsObjectRef() {}

type AppStats struct {
	From    *string           `json:"from,omitempty"`
	ID      *string           `json:"id,omitempty"`
	Records []*AppStatsRecord `json:"records,omitempty"`
	To      *string           `json:"to,omitempty"`
	Total   *int64            `json:"total,omitempty"`
	Totals  map[string]any    `json:"totals,omitempty"`
}

type AppStatsField struct {
	Name  AppStatsFieldName `json:"name"`
	Value Value             `json:"value"`
}

type AppStatsFilter struct {
	FieldName AppStatsFieldName `json:"fieldName"`
	Operator  FilterOperator    `json:"operator"`
	Values    []string          `json:"values"`
}

type AppStatsRecord struct {
	Fields          []*AppStatsField `json:"fields,omitempty"`
	FieldsMap       map[string]any   `json:"fieldsMap,omitempty"`
	FieldsUnitTypes []UnitType       `json:"fieldsUnitTypes,omitempty"`
	FlatFields      [][]string       `json:"flatFields,omitempty"`
	PrevTimeFrame   map[string]any   `json:"prevTimeFrame,omitempty"`
	Trends          map[string]any   `json:"trends,omitempty"`
}

type AppStatsSort struct {
	FieldName AppStatsFieldName `json:"fieldName"`
	Order     DirectionEnum     `json:"order"`
}

type AppStatsTimeSeries struct {
	From        *string       `json:"from,omitempty"`
	Granularity *int64        `json:"granularity,omitempty"`
	ID          *string       `json:"id,omitempty"`
	Timeseries  []*Timeseries `json:"timeseries,omitempty"`
	To          *string       `json:"to,omitempty"`
}

type AppTenantRestrictionAddRuleDataInput struct {
	Action      AppTenantRestrictionActionEnum          `json:"action"`
	Application *ApplicationRefInput                    `json:"application"`
	Description string                                  `json:"description"`
	Enabled     bool                                    `json:"enabled"`
	Headers     []*AppTenantRestrictionHeaderValueInput `json:"headers"`
	Name        string                                  `json:"name"`
	Schedule    *PolicyScheduleInput                    `json:"schedule"`
	Severity    AppTenantRestrictionSeverityEnum        `json:"severity"`
	Source      *AppTenantRestrictionSourceInput        `json:"source"`
}

type AppTenantRestrictionAddRuleInput struct {
	At   *PolicyRulePositionInput              `json:"at,omitempty"`
	Rule *AppTenantRestrictionAddRuleDataInput `json:"rule"`
}

// pair of header name and value
type AppTenantRestrictionHeaderValue struct {
	Name  string `json:"name"`
	Value string `json:"value"`
}

// pair of header name and value
type AppTenantRestrictionHeaderValueInput struct {
	Name  string `json:"name"`
	Value string `json:"value"`
}

type AppTenantRestrictionPolicy struct {
	Audit    *PolicyAudit                       `json:"audit,omitempty"`
	Enabled  bool                               `json:"enabled"`
	Revision *PolicyRevision                    `json:"revision,omitempty"`
	Rules    []*AppTenantRestrictionRulePayload `json:"rules"`
	Sections []*PolicySectionPayload            `json:"sections"`
}

func (AppTenantRestrictionPolicy) IsIPolicy()                        {}
func (this AppTenantRestrictionPolicy) GetAudit() *PolicyAudit       { return this.Audit }
func (this AppTenantRestrictionPolicy) GetEnabled() bool             { return this.Enabled }
func (this AppTenantRestrictionPolicy) GetRevision() *PolicyRevision { return this.Revision }
func (this AppTenantRestrictionPolicy) GetRules() []IPolicyRulePayload {
	if this.Rules == nil {
		return nil
	}
	interfaceSlice := make([]IPolicyRulePayload, 0, len(this.Rules))
	for _, concrete := range this.Rules {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this AppTenantRestrictionPolicy) GetSections() []*PolicySectionPayload {
	if this.Sections == nil {
		return nil
	}
	interfaceSlice := make([]*PolicySectionPayload, 0, len(this.Sections))
	for _, concrete := range this.Sections {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

type AppTenantRestrictionPolicyInput struct {
	Revision *PolicyRevisionInput `json:"revision,omitempty"`
}

type AppTenantRestrictionPolicyMutationInput struct {
	Revision *PolicyMutationRevisionInput `json:"revision,omitempty"`
}

type AppTenantRestrictionPolicyMutationPayload struct {
	Errors []*PolicyMutationError      `json:"errors"`
	Policy *AppTenantRestrictionPolicy `json:"policy,omitempty"`
	Status PolicyMutationStatus        `json:"status"`
}

func (AppTenantRestrictionPolicyMutationPayload) IsIPolicyMutationPayload() {}
func (this AppTenantRestrictionPolicyMutationPayload) GetErrors() []*PolicyMutationError {
	if this.Errors == nil {
		return nil
	}
	interfaceSlice := make([]*PolicyMutationError, 0, len(this.Errors))
	for _, concrete := range this.Errors {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this AppTenantRestrictionPolicyMutationPayload) GetPolicy() IPolicy { return *this.Policy }
func (this AppTenantRestrictionPolicyMutationPayload) GetStatus() PolicyMutationStatus {
	return this.Status
}

type AppTenantRestrictionPolicyMutations struct {
	AddRule               *AppTenantRestrictionRuleMutationPayload   `json:"addRule"`
	AddSection            *PolicySectionMutationPayload              `json:"addSection"`
	CreatePolicyRevision  *AppTenantRestrictionPolicyMutationPayload `json:"createPolicyRevision"`
	DiscardPolicyRevision *AppTenantRestrictionPolicyMutationPayload `json:"discardPolicyRevision"`
	MoveRule              *AppTenantRestrictionRuleMutationPayload   `json:"moveRule"`
	MoveSection           *PolicySectionMutationPayload              `json:"moveSection"`
	PublishPolicyRevision *AppTenantRestrictionPolicyMutationPayload `json:"publishPolicyRevision"`
	RemoveRule            *AppTenantRestrictionRuleMutationPayload   `json:"removeRule"`
	RemoveSection         *PolicySectionMutationPayload              `json:"removeSection"`
	UpdatePolicy          *AppTenantRestrictionPolicyMutationPayload `json:"updatePolicy"`
	UpdateRule            *AppTenantRestrictionRuleMutationPayload   `json:"updateRule"`
	UpdateSection         *PolicySectionMutationPayload              `json:"updateSection"`
}

type AppTenantRestrictionPolicyQueries struct {
	Policy    *AppTenantRestrictionPolicy `json:"policy"`
	Revisions *PolicyRevisionsPayload     `json:"revisions,omitempty"`
}

type AppTenantRestrictionPolicyUpdateInput struct {
	State *PolicyToggleState `json:"state,omitempty"`
}

type AppTenantRestrictionRemoveRuleInput struct {
	ID string `json:"id"`
}

type AppTenantRestrictionRule struct {
	Action      AppTenantRestrictionActionEnum     `json:"action"`
	Application *ApplicationRef                    `json:"application"`
	Description string                             `json:"description"`
	Enabled     bool                               `json:"enabled"`
	Headers     []*AppTenantRestrictionHeaderValue `json:"headers"`
	ID          string                             `json:"id"`
	Index       int64                              `json:"index"`
	Name        string                             `json:"name"`
	Schedule    *PolicySchedule                    `json:"schedule"`
	Section     *PolicySectionInfo                 `json:"section"`
	Severity    AppTenantRestrictionSeverityEnum   `json:"severity"`
	Source      *AppTenantRestrictionSource        `json:"source"`
}

func (AppTenantRestrictionRule) IsIPolicyRule()                      {}
func (this AppTenantRestrictionRule) GetDescription() *string        { return &this.Description }
func (this AppTenantRestrictionRule) GetEnabled() bool               { return this.Enabled }
func (this AppTenantRestrictionRule) GetID() string                  { return this.ID }
func (this AppTenantRestrictionRule) GetIndex() int64                { return this.Index }
func (this AppTenantRestrictionRule) GetName() string                { return this.Name }
func (this AppTenantRestrictionRule) GetSection() *PolicySectionInfo { return this.Section }

type AppTenantRestrictionRuleMutationPayload struct {
	Errors []*PolicyMutationError           `json:"errors"`
	Rule   *AppTenantRestrictionRulePayload `json:"rule,omitempty"`
	Status PolicyMutationStatus             `json:"status"`
}

func (AppTenantRestrictionRuleMutationPayload) IsIPolicyRuleMutationPayload() {}
func (this AppTenantRestrictionRuleMutationPayload) GetErrors() []*PolicyMutationError {
	if this.Errors == nil {
		return nil
	}
	interfaceSlice := make([]*PolicyMutationError, 0, len(this.Errors))
	for _, concrete := range this.Errors {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this AppTenantRestrictionRuleMutationPayload) GetRule() IPolicyRulePayload { return *this.Rule }
func (this AppTenantRestrictionRuleMutationPayload) GetStatus() PolicyMutationStatus {
	return this.Status
}

type AppTenantRestrictionRulePayload struct {
	Audit      *PolicyElementAudit           `json:"audit"`
	Properties []PolicyElementPropertiesEnum `json:"properties"`
	Rule       *AppTenantRestrictionRule     `json:"rule"`
}

func (AppTenantRestrictionRulePayload) IsIPolicyRulePayload()              {}
func (this AppTenantRestrictionRulePayload) GetAudit() *PolicyElementAudit { return this.Audit }
func (this AppTenantRestrictionRulePayload) GetProperties() []PolicyElementPropertiesEnum {
	if this.Properties == nil {
		return nil
	}
	interfaceSlice := make([]PolicyElementPropertiesEnum, 0, len(this.Properties))
	for _, concrete := range this.Properties {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this AppTenantRestrictionRulePayload) GetRule() IPolicyRule { return *this.Rule }

// Returns the settings for Source of an App Tenant Restriction rule
type AppTenantRestrictionSource struct {
	Country           []*CountryRef           `json:"country"`
	FloatingSubnet    []*FloatingSubnetRef    `json:"floatingSubnet"`
	GlobalIPRange     []*GlobalIPRangeRef     `json:"globalIpRange"`
	Group             []*GroupRef             `json:"group"`
	Host              []*HostRef              `json:"host"`
	IP                []string                `json:"ip"`
	IPRange           []*IPAddressRange       `json:"ipRange"`
	NetworkInterface  []*NetworkInterfaceRef  `json:"networkInterface"`
	Site              []*SiteRef              `json:"site"`
	SiteNetworkSubnet []*SiteNetworkSubnetRef `json:"siteNetworkSubnet"`
	Subnet            []string                `json:"subnet"`
	SystemGroup       []*SystemGroupRef       `json:"systemGroup"`
	User              []*UserRef              `json:"user"`
	UsersGroup        []*UsersGroupRef        `json:"usersGroup"`
}

// Input of the settings for Source of an App Tenant Restriction rule
type AppTenantRestrictionSourceInput struct {
	Country           []*CountryRefInput           `json:"country"`
	FloatingSubnet    []*FloatingSubnetRefInput    `json:"floatingSubnet"`
	GlobalIPRange     []*GlobalIPRangeRefInput     `json:"globalIpRange"`
	Group             []*GroupRefInput             `json:"group"`
	Host              []*HostRefInput              `json:"host"`
	IP                []string                     `json:"ip"`
	IPRange           []*IPAddressRangeInput       `json:"ipRange"`
	NetworkInterface  []*NetworkInterfaceRefInput  `json:"networkInterface"`
	Site              []*SiteRefInput              `json:"site"`
	SiteNetworkSubnet []*SiteNetworkSubnetRefInput `json:"siteNetworkSubnet"`
	Subnet            []string                     `json:"subnet"`
	SystemGroup       []*SystemGroupRefInput       `json:"systemGroup"`
	User              []*UserRefInput              `json:"user"`
	UsersGroup        []*UsersGroupRefInput        `json:"usersGroup"`
}

// Input of the settings for Source of an App Tenant Restriction rule
type AppTenantRestrictionSourceUpdateInput struct {
	Country           []*CountryRefInput           `json:"country,omitempty"`
	FloatingSubnet    []*FloatingSubnetRefInput    `json:"floatingSubnet,omitempty"`
	GlobalIPRange     []*GlobalIPRangeRefInput     `json:"globalIpRange,omitempty"`
	Group             []*GroupRefInput             `json:"group,omitempty"`
	Host              []*HostRefInput              `json:"host,omitempty"`
	IP                []string                     `json:"ip,omitempty"`
	IPRange           []*IPAddressRangeInput       `json:"ipRange,omitempty"`
	NetworkInterface  []*NetworkInterfaceRefInput  `json:"networkInterface,omitempty"`
	Site              []*SiteRefInput              `json:"site,omitempty"`
	SiteNetworkSubnet []*SiteNetworkSubnetRefInput `json:"siteNetworkSubnet,omitempty"`
	Subnet            []string                     `json:"subnet,omitempty"`
	SystemGroup       []*SystemGroupRefInput       `json:"systemGroup,omitempty"`
	User              []*UserRefInput              `json:"user,omitempty"`
	UsersGroup        []*UsersGroupRefInput        `json:"usersGroup,omitempty"`
}

type AppTenantRestrictionUpdateRuleDataInput struct {
	Action      *AppTenantRestrictionActionEnum         `json:"action,omitempty"`
	Application *ApplicationRefInput                    `json:"application,omitempty"`
	Description *string                                 `json:"description,omitempty"`
	Enabled     *bool                                   `json:"enabled,omitempty"`
	Headers     []*AppTenantRestrictionHeaderValueInput `json:"headers,omitempty"`
	Name        *string                                 `json:"name,omitempty"`
	Schedule    *PolicyScheduleUpdateInput              `json:"schedule,omitempty"`
	Severity    *AppTenantRestrictionSeverityEnum       `json:"severity,omitempty"`
	Source      *AppTenantRestrictionSourceUpdateInput  `json:"source,omitempty"`
}

type AppTenantRestrictionUpdateRuleInput struct {
	ID   string                                   `json:"id"`
	Rule *AppTenantRestrictionUpdateRuleDataInput `json:"rule"`
}

// A reference identifying the ApplicationCategory object. ID: Unique ApplicationCategory Identifier, Name: The ApplicationCategory Name
type ApplicationCategoryRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (ApplicationCategoryRef) IsObjectRef()         {}
func (this ApplicationCategoryRef) GetID() string   { return this.ID }
func (this ApplicationCategoryRef) GetName() string { return this.Name }

type ApplicationCategoryRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

// Access method matching configuration
type ApplicationControlAccessMethod struct {
	AccessMethod ApplicationControlAccessMethodType `json:"accessMethod"`
	Operator     ApplicationControlOperator         `json:"operator"`
	Value        *string                            `json:"value,omitempty"`
	ValueSet     *StringValueSetRef                 `json:"valueSet,omitempty"`
}

// Access method matching configuration
type ApplicationControlAccessMethodInput struct {
	AccessMethod ApplicationControlAccessMethodType `json:"accessMethod"`
	Operator     ApplicationControlOperator         `json:"operator"`
	Value        *string                            `json:"value,omitempty"`
	ValueSet     *StringValueSetRefInput            `json:"valueSet,omitempty"`
}

// Activity matching configuration
type ApplicationControlActivity struct {
	Activity *ApplicationControlActivityRef      `json:"activity"`
	Field    *ApplicationControlActivityFieldRef `json:"field,omitempty"`
	Operator *ApplicationControlOperator         `json:"operator,omitempty"`
	Value    *string                             `json:"value,omitempty"`
	ValueSet *StringValueSetRef                  `json:"valueSet,omitempty"`
}

type ApplicationControlActivityFieldRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (ApplicationControlActivityFieldRef) IsObjectRef()         {}
func (this ApplicationControlActivityFieldRef) GetID() string   { return this.ID }
func (this ApplicationControlActivityFieldRef) GetName() string { return this.Name }

type ApplicationControlActivityFieldRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

// Activity matching configuration
type ApplicationControlActivityInput struct {
	Activity *ApplicationControlActivityRefInput      `json:"activity"`
	Field    *ApplicationControlActivityFieldRefInput `json:"field,omitempty"`
	Operator *ApplicationControlOperator              `json:"operator,omitempty"`
	Value    *string                                  `json:"value,omitempty"`
	ValueSet *StringValueSetRefInput                  `json:"valueSet,omitempty"`
}

type ApplicationControlActivityRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (ApplicationControlActivityRef) IsObjectRef()         {}
func (this ApplicationControlActivityRef) GetID() string   { return this.ID }
func (this ApplicationControlActivityRef) GetName() string { return this.Name }

type ApplicationControlActivityRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

type ApplicationControlAddRuleDataInput struct {
	ApplicationRule *ApplicationControlApplicationRuleInput `json:"applicationRule,omitempty"`
	DataRule        *ApplicationControlDataRuleInput        `json:"dataRule,omitempty"`
	Description     string                                  `json:"description"`
	Enabled         bool                                    `json:"enabled"`
	FileRule        *ApplicationControlFileRuleInput        `json:"fileRule,omitempty"`
	Name            string                                  `json:"name"`
	RuleType        ApplicationControlRuleType              `json:"ruleType"`
}

type ApplicationControlAddRuleInput struct {
	At   *PolicyRulePositionInput            `json:"at,omitempty"`
	Rule *ApplicationControlAddRuleDataInput `json:"rule"`
}

// Application matching configuration. Only one of the following fields should be filled - the others must remain empty.
type ApplicationControlApplication struct {
	AppCategory            *ApplicationCategoryRef    `json:"appCategory,omitempty"`
	Application            *ApplicationRef            `json:"application,omitempty"`
	ApplicationType        []ApplicationType          `json:"applicationType"`
	CustomApp              *CustomApplicationRef      `json:"customApp,omitempty"`
	CustomCategory         *CustomCategoryRef         `json:"customCategory,omitempty"`
	SanctionedAppsCategory *SanctionedAppsCategoryRef `json:"sanctionedAppsCategory,omitempty"`
}

// Application matching configuration. Only one of the following fields should be filled - the others must remain empty.
type ApplicationControlApplicationInput struct {
	AppCategory            *ApplicationCategoryRefInput    `json:"appCategory,omitempty"`
	Application            *ApplicationRefInput            `json:"application,omitempty"`
	ApplicationType        []ApplicationType               `json:"applicationType"`
	CustomApp              *CustomApplicationRefInput      `json:"customApp,omitempty"`
	CustomCategory         *CustomCategoryRefInput         `json:"customCategory,omitempty"`
	SanctionedAppsCategory *SanctionedAppsCategoryRefInput `json:"sanctionedAppsCategory,omitempty"`
}

// Configuration for application-based control rules
type ApplicationControlApplicationRule struct {
	AccessMethod               []*ApplicationControlAccessMethod `json:"accessMethod"`
	Action                     ApplicationControlAction          `json:"action"`
	Application                *ApplicationControlApplication    `json:"application"`
	ApplicationActivity        []*ApplicationControlActivity     `json:"applicationActivity"`
	ApplicationActivitySatisfy ApplicationControlSatisfy         `json:"applicationActivitySatisfy"`
	ApplicationContext         *ApplicationControlContext        `json:"applicationContext"`
	ApplicationCriteria        *ApplicationControlCriteria       `json:"applicationCriteria"`
	ApplicationCriteriaSatisfy ApplicationControlSatisfy         `json:"applicationCriteriaSatisfy"`
	Device                     []*DeviceProfileRef               `json:"device"`
	Schedule                   *PolicySchedule                   `json:"schedule"`
	Severity                   ApplicationControlSeverity        `json:"severity"`
	Source                     *ApplicationControlSource         `json:"source"`
	Tracking                   *PolicyTracking                   `json:"tracking"`
}

// Configuration for application-based control rules
type ApplicationControlApplicationRuleInput struct {
	AccessMethod               []*ApplicationControlAccessMethodInput `json:"accessMethod"`
	Action                     ApplicationControlAction               `json:"action"`
	Application                *ApplicationControlApplicationInput    `json:"application"`
	ApplicationActivity        []*ApplicationControlActivityInput     `json:"applicationActivity"`
	ApplicationActivitySatisfy ApplicationControlSatisfy              `json:"applicationActivitySatisfy"`
	ApplicationContext         *ApplicationControlContextInput        `json:"applicationContext"`
	ApplicationCriteria        *ApplicationControlCriteriaInput       `json:"applicationCriteria"`
	ApplicationCriteriaSatisfy ApplicationControlSatisfy              `json:"applicationCriteriaSatisfy"`
	Device                     []*DeviceProfileRefInput               `json:"device"`
	Schedule                   *PolicyScheduleInput                   `json:"schedule"`
	Severity                   ApplicationControlSeverity             `json:"severity"`
	Source                     *ApplicationControlSourceInput         `json:"source"`
	Tracking                   *PolicyTrackingInput                   `json:"tracking"`
}

// Configuration for application-based control rules
type ApplicationControlApplicationRuleUpdateInput struct {
	AccessMethod               []*ApplicationControlAccessMethodInput    `json:"accessMethod,omitempty"`
	Action                     *ApplicationControlAction                 `json:"action,omitempty"`
	Application                *ApplicationControlApplicationUpdateInput `json:"application,omitempty"`
	ApplicationActivity        []*ApplicationControlActivityInput        `json:"applicationActivity,omitempty"`
	ApplicationActivitySatisfy *ApplicationControlSatisfy                `json:"applicationActivitySatisfy,omitempty"`
	ApplicationContext         *ApplicationControlContextUpdateInput     `json:"applicationContext,omitempty"`
	ApplicationCriteria        *ApplicationControlCriteriaUpdateInput    `json:"applicationCriteria,omitempty"`
	ApplicationCriteriaSatisfy *ApplicationControlSatisfy                `json:"applicationCriteriaSatisfy,omitempty"`
	Device                     []*DeviceProfileRefInput                  `json:"device,omitempty"`
	Schedule                   *PolicyScheduleUpdateInput                `json:"schedule,omitempty"`
	Severity                   *ApplicationControlSeverity               `json:"severity,omitempty"`
	Source                     *ApplicationControlSourceUpdateInput      `json:"source,omitempty"`
	Tracking                   *PolicyTrackingUpdateInput                `json:"tracking,omitempty"`
}

// Application matching configuration. Only one of the following fields should be filled - the others must remain empty.
type ApplicationControlApplicationUpdateInput struct {
	AppCategory            *ApplicationCategoryRefInput    `json:"appCategory,omitempty"`
	Application            *ApplicationRefInput            `json:"application,omitempty"`
	ApplicationType        []ApplicationType               `json:"applicationType,omitempty"`
	CustomApp              *CustomApplicationRefInput      `json:"customApp,omitempty"`
	CustomCategory         *CustomCategoryRefInput         `json:"customCategory,omitempty"`
	SanctionedAppsCategory *SanctionedAppsCategoryRefInput `json:"sanctionedAppsCategory,omitempty"`
}

// Application attributes, such as compliance and security, see the app catalog for details
type ApplicationControlAttributes struct {
	ComplianceAttributes *ApplicationControlComplianceAttributes `json:"complianceAttributes"`
	SecurityAttributes   *ApplicationControlSecurityAttributes   `json:"securityAttributes"`
}

// Application attributes, such as compliance and security, see the app catalog for details
type ApplicationControlAttributesInput struct {
	ComplianceAttributes *ApplicationControlComplianceAttributesInput `json:"complianceAttributes"`
	SecurityAttributes   *ApplicationControlSecurityAttributesInput   `json:"securityAttributes"`
}

// Application attributes, such as compliance and security, see the app catalog for details
type ApplicationControlAttributesUpdateInput struct {
	ComplianceAttributes *ApplicationControlComplianceAttributesUpdateInput `json:"complianceAttributes,omitempty"`
	SecurityAttributes   *ApplicationControlSecurityAttributesUpdateInput   `json:"securityAttributes,omitempty"`
}

// Compliance attributes
type ApplicationControlComplianceAttributes struct {
	Hippa    ApplicationControlAttributeValue `json:"hippa"`
	Isae3402 ApplicationControlAttributeValue `json:"isae3402"`
	Iso27001 ApplicationControlAttributeValue `json:"iso27001"`
	PciDss   ApplicationControlAttributeValue `json:"pciDss"`
	Soc1     ApplicationControlAttributeValue `json:"soc1"`
	Soc2     ApplicationControlAttributeValue `json:"soc2"`
	Soc3     ApplicationControlAttributeValue `json:"soc3"`
	Sox      ApplicationControlAttributeValue `json:"sox"`
}

// Compliance attributes
type ApplicationControlComplianceAttributesInput struct {
	Hippa    ApplicationControlAttributeValue `json:"hippa"`
	Isae3402 ApplicationControlAttributeValue `json:"isae3402"`
	Iso27001 ApplicationControlAttributeValue `json:"iso27001"`
	PciDss   ApplicationControlAttributeValue `json:"pciDss"`
	Soc1     ApplicationControlAttributeValue `json:"soc1"`
	Soc2     ApplicationControlAttributeValue `json:"soc2"`
	Soc3     ApplicationControlAttributeValue `json:"soc3"`
	Sox      ApplicationControlAttributeValue `json:"sox"`
}

// Compliance attributes
type ApplicationControlComplianceAttributesUpdateInput struct {
	Hippa    *ApplicationControlAttributeValue `json:"hippa,omitempty"`
	Isae3402 *ApplicationControlAttributeValue `json:"isae3402,omitempty"`
	Iso27001 *ApplicationControlAttributeValue `json:"iso27001,omitempty"`
	PciDss   *ApplicationControlAttributeValue `json:"pciDss,omitempty"`
	Soc1     *ApplicationControlAttributeValue `json:"soc1,omitempty"`
	Soc2     *ApplicationControlAttributeValue `json:"soc2,omitempty"`
	Soc3     *ApplicationControlAttributeValue `json:"soc3,omitempty"`
	Sox      *ApplicationControlAttributeValue `json:"sox,omitempty"`
}

// Additional attributes for application control
type ApplicationControlConfig struct {
	DataControlEnabled PolicyToggleState `json:"dataControlEnabled"`
}

type ApplicationControlConfigInput struct {
	DataControlEnabled PolicyToggleState `json:"dataControlEnabled"`
}

type ApplicationControlContentTypeGroupRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (ApplicationControlContentTypeGroupRef) IsObjectRef()         {}
func (this ApplicationControlContentTypeGroupRef) GetID() string   { return this.ID }
func (this ApplicationControlContentTypeGroupRef) GetName() string { return this.Name }

type ApplicationControlContentTypeGroupRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

type ApplicationControlContentTypeRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (ApplicationControlContentTypeRef) IsObjectRef()         {}
func (this ApplicationControlContentTypeRef) GetID() string   { return this.ID }
func (this ApplicationControlContentTypeRef) GetName() string { return this.Name }

type ApplicationControlContentTypeRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

type ApplicationControlContext struct {
	ApplicationTenant []*ApplicationControlTenant `json:"applicationTenant"`
}

type ApplicationControlContextInput struct {
	ApplicationTenant []*ApplicationControlTenantInput `json:"applicationTenant"`
}

type ApplicationControlContextUpdateInput struct {
	ApplicationTenant []*ApplicationControlTenantInput `json:"applicationTenant,omitempty"`
}

// Application criteria configuration
type ApplicationControlCriteria struct {
	Attributes    *ApplicationControlAttributes     `json:"attributes"`
	OriginCountry []*CountryRef                     `json:"originCountry"`
	Risk          []*ApplicationControlRiskCriteria `json:"risk"`
}

// Application criteria configuration
type ApplicationControlCriteriaInput struct {
	Attributes    *ApplicationControlAttributesInput     `json:"attributes"`
	OriginCountry []*CountryRefInput                     `json:"originCountry"`
	Risk          []*ApplicationControlRiskCriteriaInput `json:"risk"`
}

// Application criteria configuration
type ApplicationControlCriteriaUpdateInput struct {
	Attributes    *ApplicationControlAttributesUpdateInput `json:"attributes,omitempty"`
	OriginCountry []*CountryRefInput                       `json:"originCountry,omitempty"`
	Risk          []*ApplicationControlRiskCriteriaInput   `json:"risk,omitempty"`
}

// Configuration for data-based control rules
type ApplicationControlDataRule struct {
	AccessMethod               []*ApplicationControlAccessMethod  `json:"accessMethod"`
	Action                     ApplicationControlAction           `json:"action"`
	Application                *ApplicationControlApplication     `json:"application"`
	ApplicationActivity        []*ApplicationControlActivity      `json:"applicationActivity"`
	ApplicationActivitySatisfy ApplicationControlSatisfy          `json:"applicationActivitySatisfy"`
	ApplicationContext         *ApplicationControlContext         `json:"applicationContext"`
	Device                     []*DeviceProfileRef                `json:"device"`
	DlpProfile                 *ApplicationControlDlpProfile      `json:"dlpProfile"`
	FileAttribute              []*ApplicationControlFileAttribute `json:"fileAttribute"`
	FileAttributeSatisfy       ApplicationControlSatisfy          `json:"fileAttributeSatisfy"`
	Schedule                   *PolicySchedule                    `json:"schedule"`
	Severity                   ApplicationControlSeverity         `json:"severity"`
	Source                     *ApplicationControlSource          `json:"source"`
	Tracking                   *PolicyTracking                    `json:"tracking"`
}

// Configuration for data-based control rules
type ApplicationControlDataRuleInput struct {
	AccessMethod               []*ApplicationControlAccessMethodInput  `json:"accessMethod"`
	Action                     ApplicationControlAction                `json:"action"`
	Application                *ApplicationControlApplicationInput     `json:"application"`
	ApplicationActivity        []*ApplicationControlActivityInput      `json:"applicationActivity"`
	ApplicationActivitySatisfy ApplicationControlSatisfy               `json:"applicationActivitySatisfy"`
	ApplicationContext         *ApplicationControlContextInput         `json:"applicationContext"`
	Device                     []*DeviceProfileRefInput                `json:"device"`
	DlpProfile                 *ApplicationControlDlpProfileInput      `json:"dlpProfile"`
	FileAttribute              []*ApplicationControlFileAttributeInput `json:"fileAttribute"`
	FileAttributeSatisfy       ApplicationControlSatisfy               `json:"fileAttributeSatisfy"`
	Schedule                   *PolicyScheduleInput                    `json:"schedule"`
	Severity                   ApplicationControlSeverity              `json:"severity"`
	Source                     *ApplicationControlSourceInput          `json:"source"`
	Tracking                   *PolicyTrackingInput                    `json:"tracking"`
}

// Configuration for data-based control rules
type ApplicationControlDataRuleUpdateInput struct {
	AccessMethod               []*ApplicationControlAccessMethodInput    `json:"accessMethod,omitempty"`
	Action                     *ApplicationControlAction                 `json:"action,omitempty"`
	Application                *ApplicationControlApplicationUpdateInput `json:"application,omitempty"`
	ApplicationActivity        []*ApplicationControlActivityInput        `json:"applicationActivity,omitempty"`
	ApplicationActivitySatisfy *ApplicationControlSatisfy                `json:"applicationActivitySatisfy,omitempty"`
	ApplicationContext         *ApplicationControlContextUpdateInput     `json:"applicationContext,omitempty"`
	Device                     []*DeviceProfileRefInput                  `json:"device,omitempty"`
	DlpProfile                 *ApplicationControlDlpProfileUpdateInput  `json:"dlpProfile,omitempty"`
	FileAttribute              []*ApplicationControlFileAttributeInput   `json:"fileAttribute,omitempty"`
	FileAttributeSatisfy       *ApplicationControlSatisfy                `json:"fileAttributeSatisfy,omitempty"`
	Schedule                   *PolicyScheduleUpdateInput                `json:"schedule,omitempty"`
	Severity                   *ApplicationControlSeverity               `json:"severity,omitempty"`
	Source                     *ApplicationControlSourceUpdateInput      `json:"source,omitempty"`
	Tracking                   *PolicyTrackingUpdateInput                `json:"tracking,omitempty"`
}

// DLP profile configuration
type ApplicationControlDlpProfile struct {
	ContentProfile []*DlpContentProfileRef `json:"contentProfile"`
	EdmProfile     []*DlpEdmProfileRef     `json:"edmProfile"`
}

// DLP profile configuration
type ApplicationControlDlpProfileInput struct {
	ContentProfile []*DlpContentProfileRefInput `json:"contentProfile"`
	EdmProfile     []*DlpEdmProfileRefInput     `json:"edmProfile"`
}

// DLP profile configuration
type ApplicationControlDlpProfileUpdateInput struct {
	ContentProfile []*DlpContentProfileRefInput `json:"contentProfile,omitempty"`
	EdmProfile     []*DlpEdmProfileRefInput     `json:"edmProfile,omitempty"`
}

// File attribute matching configuration
type ApplicationControlFileAttribute struct {
	ContentTypeGroupValues []*ApplicationControlContentTypeGroupRef `json:"contentTypeGroupValues"`
	ContentTypeValues      []*ApplicationControlContentTypeRef      `json:"contentTypeValues"`
	FileAttribute          ApplicationControlFileAttributeType      `json:"fileAttribute"`
	Operator               ApplicationControlOperator               `json:"operator"`
	Value                  *string                                  `json:"value,omitempty"`
}

// File attribute matching configuration
type ApplicationControlFileAttributeInput struct {
	ContentTypeGroupValues []*ApplicationControlContentTypeGroupRefInput `json:"contentTypeGroupValues"`
	ContentTypeValues      []*ApplicationControlContentTypeRefInput      `json:"contentTypeValues"`
	FileAttribute          ApplicationControlFileAttributeType           `json:"fileAttribute"`
	Operator               ApplicationControlOperator                    `json:"operator"`
	Value                  *string                                       `json:"value,omitempty"`
}

// Configuration for file-based control rules
type ApplicationControlFileRule struct {
	AccessMethod               []*ApplicationControlAccessMethod  `json:"accessMethod"`
	Action                     ApplicationControlAction           `json:"action"`
	Application                *ApplicationControlApplication     `json:"application"`
	ApplicationActivity        []*ApplicationControlActivity      `json:"applicationActivity"`
	ApplicationActivitySatisfy ApplicationControlSatisfy          `json:"applicationActivitySatisfy"`
	Device                     []*DeviceProfileRef                `json:"device"`
	FileAttribute              []*ApplicationControlFileAttribute `json:"fileAttribute"`
	FileAttributeSatisfy       ApplicationControlSatisfy          `json:"fileAttributeSatisfy"`
	Schedule                   *PolicySchedule                    `json:"schedule"`
	Severity                   ApplicationControlSeverity         `json:"severity"`
	Source                     *ApplicationControlSource          `json:"source"`
	Tracking                   *PolicyTracking                    `json:"tracking"`
}

// Configuration for file-based control rules
type ApplicationControlFileRuleInput struct {
	AccessMethod               []*ApplicationControlAccessMethodInput  `json:"accessMethod"`
	Action                     ApplicationControlAction                `json:"action"`
	Application                *ApplicationControlApplicationInput     `json:"application"`
	ApplicationActivity        []*ApplicationControlActivityInput      `json:"applicationActivity"`
	ApplicationActivitySatisfy ApplicationControlSatisfy               `json:"applicationActivitySatisfy"`
	Device                     []*DeviceProfileRefInput                `json:"device"`
	FileAttribute              []*ApplicationControlFileAttributeInput `json:"fileAttribute"`
	FileAttributeSatisfy       ApplicationControlSatisfy               `json:"fileAttributeSatisfy"`
	Schedule                   *PolicyScheduleInput                    `json:"schedule"`
	Severity                   ApplicationControlSeverity              `json:"severity"`
	Source                     *ApplicationControlSourceInput          `json:"source"`
	Tracking                   *PolicyTrackingInput                    `json:"tracking"`
}

// Configuration for file-based control rules
type ApplicationControlFileRuleUpdateInput struct {
	AccessMethod               []*ApplicationControlAccessMethodInput    `json:"accessMethod,omitempty"`
	Action                     *ApplicationControlAction                 `json:"action,omitempty"`
	Application                *ApplicationControlApplicationUpdateInput `json:"application,omitempty"`
	ApplicationActivity        []*ApplicationControlActivityInput        `json:"applicationActivity,omitempty"`
	ApplicationActivitySatisfy *ApplicationControlSatisfy                `json:"applicationActivitySatisfy,omitempty"`
	Device                     []*DeviceProfileRefInput                  `json:"device,omitempty"`
	FileAttribute              []*ApplicationControlFileAttributeInput   `json:"fileAttribute,omitempty"`
	FileAttributeSatisfy       *ApplicationControlSatisfy                `json:"fileAttributeSatisfy,omitempty"`
	Schedule                   *PolicyScheduleUpdateInput                `json:"schedule,omitempty"`
	Severity                   *ApplicationControlSeverity               `json:"severity,omitempty"`
	Source                     *ApplicationControlSourceUpdateInput      `json:"source,omitempty"`
	Tracking                   *PolicyTrackingUpdateInput                `json:"tracking,omitempty"`
}

type ApplicationControlPolicy struct {
	AdditionalAttributes *ApplicationControlConfig        `json:"additionalAttributes,omitempty"`
	Audit                *PolicyAudit                     `json:"audit,omitempty"`
	Enabled              bool                             `json:"enabled"`
	Revision             *PolicyRevision                  `json:"revision,omitempty"`
	Rules                []*ApplicationControlRulePayload `json:"rules"`
	Sections             []*PolicySectionPayload          `json:"sections"`
}

func (ApplicationControlPolicy) IsIPolicy()                        {}
func (this ApplicationControlPolicy) GetAudit() *PolicyAudit       { return this.Audit }
func (this ApplicationControlPolicy) GetEnabled() bool             { return this.Enabled }
func (this ApplicationControlPolicy) GetRevision() *PolicyRevision { return this.Revision }
func (this ApplicationControlPolicy) GetRules() []IPolicyRulePayload {
	if this.Rules == nil {
		return nil
	}
	interfaceSlice := make([]IPolicyRulePayload, 0, len(this.Rules))
	for _, concrete := range this.Rules {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this ApplicationControlPolicy) GetSections() []*PolicySectionPayload {
	if this.Sections == nil {
		return nil
	}
	interfaceSlice := make([]*PolicySectionPayload, 0, len(this.Sections))
	for _, concrete := range this.Sections {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

type ApplicationControlPolicyInput struct {
	Revision *PolicyRevisionInput `json:"revision,omitempty"`
}

type ApplicationControlPolicyMutationInput struct {
	Revision *PolicyMutationRevisionInput `json:"revision,omitempty"`
}

type ApplicationControlPolicyMutationPayload struct {
	Errors []*PolicyMutationError    `json:"errors"`
	Policy *ApplicationControlPolicy `json:"policy,omitempty"`
	Status PolicyMutationStatus      `json:"status"`
}

func (ApplicationControlPolicyMutationPayload) IsIPolicyMutationPayload() {}
func (this ApplicationControlPolicyMutationPayload) GetErrors() []*PolicyMutationError {
	if this.Errors == nil {
		return nil
	}
	interfaceSlice := make([]*PolicyMutationError, 0, len(this.Errors))
	for _, concrete := range this.Errors {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this ApplicationControlPolicyMutationPayload) GetPolicy() IPolicy { return *this.Policy }
func (this ApplicationControlPolicyMutationPayload) GetStatus() PolicyMutationStatus {
	return this.Status
}

type ApplicationControlPolicyMutations struct {
	AddRule               *ApplicationControlRuleMutationPayload   `json:"addRule"`
	AddSection            *PolicySectionMutationPayload            `json:"addSection"`
	CreatePolicyRevision  *ApplicationControlPolicyMutationPayload `json:"createPolicyRevision"`
	DiscardPolicyRevision *ApplicationControlPolicyMutationPayload `json:"discardPolicyRevision"`
	MoveRule              *ApplicationControlRuleMutationPayload   `json:"moveRule"`
	MoveSection           *PolicySectionMutationPayload            `json:"moveSection"`
	PublishPolicyRevision *ApplicationControlPolicyMutationPayload `json:"publishPolicyRevision"`
	RemoveRule            *ApplicationControlRuleMutationPayload   `json:"removeRule"`
	RemoveSection         *PolicySectionMutationPayload            `json:"removeSection"`
	UpdatePolicy          *ApplicationControlPolicyMutationPayload `json:"updatePolicy"`
	UpdateRule            *ApplicationControlRuleMutationPayload   `json:"updateRule"`
	UpdateSection         *PolicySectionMutationPayload            `json:"updateSection"`
}

type ApplicationControlPolicyQueries struct {
	Policy    *ApplicationControlPolicy `json:"policy"`
	Revisions *PolicyRevisionsPayload   `json:"revisions,omitempty"`
}

type ApplicationControlPolicyUpdateInput struct {
	AdditionalAttributes *ApplicationControlConfigInput `json:"additionalAttributes,omitempty"`
	State                *PolicyToggleState             `json:"state,omitempty"`
}

type ApplicationControlRemoveRuleInput struct {
	ID string `json:"id"`
}

// Application risk
type ApplicationControlRiskCriteria struct {
	Risk         string                     `json:"risk"`
	RiskOperator ApplicationControlOperator `json:"riskOperator"`
}

// Application risk
type ApplicationControlRiskCriteriaInput struct {
	Risk         string                     `json:"risk"`
	RiskOperator ApplicationControlOperator `json:"riskOperator"`
}

type ApplicationControlRule struct {
	ApplicationRule *ApplicationControlApplicationRule `json:"applicationRule,omitempty"`
	DataRule        *ApplicationControlDataRule        `json:"dataRule,omitempty"`
	Description     string                             `json:"description"`
	Enabled         bool                               `json:"enabled"`
	FileRule        *ApplicationControlFileRule        `json:"fileRule,omitempty"`
	ID              string                             `json:"id"`
	Index           int64                              `json:"index"`
	Name            string                             `json:"name"`
	RuleType        ApplicationControlRuleType         `json:"ruleType"`
	Section         *PolicySectionInfo                 `json:"section"`
}

func (ApplicationControlRule) IsIPolicyRule()                      {}
func (this ApplicationControlRule) GetDescription() *string        { return &this.Description }
func (this ApplicationControlRule) GetEnabled() bool               { return this.Enabled }
func (this ApplicationControlRule) GetID() string                  { return this.ID }
func (this ApplicationControlRule) GetIndex() int64                { return this.Index }
func (this ApplicationControlRule) GetName() string                { return this.Name }
func (this ApplicationControlRule) GetSection() *PolicySectionInfo { return this.Section }

type ApplicationControlRuleMutationPayload struct {
	Errors []*PolicyMutationError         `json:"errors"`
	Rule   *ApplicationControlRulePayload `json:"rule,omitempty"`
	Status PolicyMutationStatus           `json:"status"`
}

func (ApplicationControlRuleMutationPayload) IsIPolicyRuleMutationPayload() {}
func (this ApplicationControlRuleMutationPayload) GetErrors() []*PolicyMutationError {
	if this.Errors == nil {
		return nil
	}
	interfaceSlice := make([]*PolicyMutationError, 0, len(this.Errors))
	for _, concrete := range this.Errors {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this ApplicationControlRuleMutationPayload) GetRule() IPolicyRulePayload { return *this.Rule }
func (this ApplicationControlRuleMutationPayload) GetStatus() PolicyMutationStatus {
	return this.Status
}

type ApplicationControlRulePayload struct {
	Audit      *PolicyElementAudit           `json:"audit"`
	Properties []PolicyElementPropertiesEnum `json:"properties"`
	Rule       *ApplicationControlRule       `json:"rule"`
}

func (ApplicationControlRulePayload) IsIPolicyRulePayload()              {}
func (this ApplicationControlRulePayload) GetAudit() *PolicyElementAudit { return this.Audit }
func (this ApplicationControlRulePayload) GetProperties() []PolicyElementPropertiesEnum {
	if this.Properties == nil {
		return nil
	}
	interfaceSlice := make([]PolicyElementPropertiesEnum, 0, len(this.Properties))
	for _, concrete := range this.Properties {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this ApplicationControlRulePayload) GetRule() IPolicyRule { return *this.Rule }

// Security attributes
type ApplicationControlSecurityAttributes struct {
	AuditTrail          ApplicationControlAttributeValue `json:"auditTrail"`
	EncryptionAtRest    ApplicationControlAttributeValue `json:"encryptionAtRest"`
	HTTPSecurityHeaders ApplicationControlAttributeValue `json:"httpSecurityHeaders"`
	Mfa                 ApplicationControlAttributeValue `json:"mfa"`
	Rbac                ApplicationControlAttributeValue `json:"rbac"`
	RememberPassword    ApplicationControlAttributeValue `json:"rememberPassword"`
	Sso                 ApplicationControlAttributeValue `json:"sso"`
	TLSEnforcement      ApplicationControlAttributeValue `json:"tlsEnforcement"`
	TrustedCertificate  ApplicationControlAttributeValue `json:"trustedCertificate"`
}

// Security attributes
type ApplicationControlSecurityAttributesInput struct {
	AuditTrail          ApplicationControlAttributeValue `json:"auditTrail"`
	EncryptionAtRest    ApplicationControlAttributeValue `json:"encryptionAtRest"`
	HTTPSecurityHeaders ApplicationControlAttributeValue `json:"httpSecurityHeaders"`
	Mfa                 ApplicationControlAttributeValue `json:"mfa"`
	Rbac                ApplicationControlAttributeValue `json:"rbac"`
	RememberPassword    ApplicationControlAttributeValue `json:"rememberPassword"`
	Sso                 ApplicationControlAttributeValue `json:"sso"`
	TLSEnforcement      ApplicationControlAttributeValue `json:"tlsEnforcement"`
	TrustedCertificate  ApplicationControlAttributeValue `json:"trustedCertificate"`
}

// Security attributes
type ApplicationControlSecurityAttributesUpdateInput struct {
	AuditTrail          *ApplicationControlAttributeValue `json:"auditTrail,omitempty"`
	EncryptionAtRest    *ApplicationControlAttributeValue `json:"encryptionAtRest,omitempty"`
	HTTPSecurityHeaders *ApplicationControlAttributeValue `json:"httpSecurityHeaders,omitempty"`
	Mfa                 *ApplicationControlAttributeValue `json:"mfa,omitempty"`
	Rbac                *ApplicationControlAttributeValue `json:"rbac,omitempty"`
	RememberPassword    *ApplicationControlAttributeValue `json:"rememberPassword,omitempty"`
	Sso                 *ApplicationControlAttributeValue `json:"sso,omitempty"`
	TLSEnforcement      *ApplicationControlAttributeValue `json:"tlsEnforcement,omitempty"`
	TrustedCertificate  *ApplicationControlAttributeValue `json:"trustedCertificate,omitempty"`
}

// Source traffic matching configuration
type ApplicationControlSource struct {
	Country           []*CountryRef           `json:"country"`
	FloatingSubnet    []*FloatingSubnetRef    `json:"floatingSubnet"`
	GlobalIPRange     []*GlobalIPRangeRef     `json:"globalIpRange"`
	Group             []*GroupRef             `json:"group"`
	Host              []*HostRef              `json:"host"`
	IP                []string                `json:"ip"`
	IPRange           []*IPAddressRange       `json:"ipRange"`
	NetworkInterface  []*NetworkInterfaceRef  `json:"networkInterface"`
	Site              []*SiteRef              `json:"site"`
	SiteNetworkSubnet []*SiteNetworkSubnetRef `json:"siteNetworkSubnet"`
	Subnet            []string                `json:"subnet"`
	SystemGroup       []*SystemGroupRef       `json:"systemGroup"`
	User              []*UserRef              `json:"user"`
	UsersGroup        []*UsersGroupRef        `json:"usersGroup"`
}

// Source traffic matching configuration
type ApplicationControlSourceInput struct {
	Country           []*CountryRefInput           `json:"country"`
	FloatingSubnet    []*FloatingSubnetRefInput    `json:"floatingSubnet"`
	GlobalIPRange     []*GlobalIPRangeRefInput     `json:"globalIpRange"`
	Group             []*GroupRefInput             `json:"group"`
	Host              []*HostRefInput              `json:"host"`
	IP                []string                     `json:"ip"`
	IPRange           []*IPAddressRangeInput       `json:"ipRange"`
	NetworkInterface  []*NetworkInterfaceRefInput  `json:"networkInterface"`
	Site              []*SiteRefInput              `json:"site"`
	SiteNetworkSubnet []*SiteNetworkSubnetRefInput `json:"siteNetworkSubnet"`
	Subnet            []string                     `json:"subnet"`
	SystemGroup       []*SystemGroupRefInput       `json:"systemGroup"`
	User              []*UserRefInput              `json:"user"`
	UsersGroup        []*UsersGroupRefInput        `json:"usersGroup"`
}

// Source traffic matching configuration
type ApplicationControlSourceUpdateInput struct {
	Country           []*CountryRefInput           `json:"country,omitempty"`
	FloatingSubnet    []*FloatingSubnetRefInput    `json:"floatingSubnet,omitempty"`
	GlobalIPRange     []*GlobalIPRangeRefInput     `json:"globalIpRange,omitempty"`
	Group             []*GroupRefInput             `json:"group,omitempty"`
	Host              []*HostRefInput              `json:"host,omitempty"`
	IP                []string                     `json:"ip,omitempty"`
	IPRange           []*IPAddressRangeInput       `json:"ipRange,omitempty"`
	NetworkInterface  []*NetworkInterfaceRefInput  `json:"networkInterface,omitempty"`
	Site              []*SiteRefInput              `json:"site,omitempty"`
	SiteNetworkSubnet []*SiteNetworkSubnetRefInput `json:"siteNetworkSubnet,omitempty"`
	Subnet            []string                     `json:"subnet,omitempty"`
	SystemGroup       []*SystemGroupRefInput       `json:"systemGroup,omitempty"`
	User              []*UserRefInput              `json:"user,omitempty"`
	UsersGroup        []*UsersGroupRefInput        `json:"usersGroup,omitempty"`
}

// Tenant matching configuration
type ApplicationControlTenant struct {
	Operator *ApplicationControlOperator `json:"operator,omitempty"`
	Value    *string                     `json:"value,omitempty"`
	ValueSet *StringValueSetRef          `json:"valueSet,omitempty"`
}

// Tenant matching configuration
type ApplicationControlTenantInput struct {
	Operator *ApplicationControlOperator `json:"operator,omitempty"`
	Value    *string                     `json:"value,omitempty"`
	ValueSet *StringValueSetRefInput     `json:"valueSet,omitempty"`
}

type ApplicationControlUpdateRuleDataInput struct {
	ApplicationRule *ApplicationControlApplicationRuleUpdateInput `json:"applicationRule,omitempty"`
	DataRule        *ApplicationControlDataRuleUpdateInput        `json:"dataRule,omitempty"`
	Description     *string                                       `json:"description,omitempty"`
	Enabled         *bool                                         `json:"enabled,omitempty"`
	FileRule        *ApplicationControlFileRuleUpdateInput        `json:"fileRule,omitempty"`
	Name            *string                                       `json:"name,omitempty"`
	RuleType        *ApplicationControlRuleType                   `json:"ruleType,omitempty"`
}

type ApplicationControlUpdateRuleInput struct {
	ID   string                                 `json:"id"`
	Rule *ApplicationControlUpdateRuleDataInput `json:"rule"`
}

// A reference identifying the Application object. ID: Unique Application Identifier, Name: The Application Name
type ApplicationRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (ApplicationRef) IsObjectRef()         {}
func (this ApplicationRef) GetID() string   { return this.ID }
func (this ApplicationRef) GetName() string { return this.Name }

type ApplicationRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

type AssignSiteBwLicenseInput struct {
	Bw        *int64        `json:"bw,omitempty"`
	LicenseID string        `json:"licenseId"`
	Site      *SiteRefInput `json:"site"`
}

type AssignSiteBwLicensePayload struct {
	License License `json:"license"`
}

type AssignSocketToZtnaAppConnectorInput struct {
	Description      string                    `json:"description"`
	SocketSerial     string                    `json:"socketSerial"`
	ZtnaAppConnector *ZtnaAppConnectorRefInput `json:"ztnaAppConnector"`
}

type AssignSocketToZtnaAppConnectorPayload struct {
	ZtnaAppConnector *ZtnaAppConnector `json:"ztnaAppConnector"`
}

// Advanced Threat Prevention (ATP) service license details
type AtpLicense struct {
	Description    *string       `json:"description,omitempty"`
	ExpirationDate string        `json:"expirationDate"`
	ID             *string       `json:"id,omitempty"`
	LastUpdated    *string       `json:"lastUpdated,omitempty"`
	Plan           LicensePlan   `json:"plan"`
	Sku            LicenseSku    `json:"sku"`
	StartDate      *string       `json:"startDate,omitempty"`
	Status         LicenseStatus `json:"status"`
}

func (AtpLicense) IsLicense()                     {}
func (this AtpLicense) GetDescription() *string   { return this.Description }
func (this AtpLicense) GetExpirationDate() string { return this.ExpirationDate }
func (this AtpLicense) GetID() *string            { return this.ID }
func (this AtpLicense) GetLastUpdated() *string   { return this.LastUpdated }
func (this AtpLicense) GetPlan() LicensePlan      { return this.Plan }
func (this AtpLicense) GetSku() LicenseSku        { return this.Sku }
func (this AtpLicense) GetStartDate() *string     { return this.StartDate }
func (this AtpLicense) GetStatus() LicenseStatus  { return this.Status }

type AuditFeed struct {
	Accounts     []*AuditFeedAccountRecords `json:"accounts,omitempty"`
	FetchedCount int64                      `json:"fetchedCount"`
	From         *string                    `json:"from,omitempty"`
	HasMore      *bool                      `json:"hasMore,omitempty"`
	Marker       *string                    `json:"marker,omitempty"`
	To           *string                    `json:"to,omitempty"`
}

type AuditFeedAccountRecords struct {
	ID      *string        `json:"id,omitempty"`
	Records []*AuditRecord `json:"records,omitempty"`
}

type AuditField struct {
	Name  string `json:"name"`
	Value Value  `json:"value"`
}

type AuditFieldFilterInput struct {
	FieldName *FieldNameInput `json:"fieldName"`
	Operator  ElasticOperator `json:"operator"`
	Values    []string        `json:"values,omitempty"`
}

// Represents a single event in the audit database
type AuditRecord struct {
	Account    *EntityInfo    `json:"account,omitempty"`
	Admin      *Entity        `json:"admin,omitempty"`
	APIKey     *Entity        `json:"apiKey,omitempty"`
	Fields     []*AuditField  `json:"fields,omitempty"`
	FieldsMap  map[string]any `json:"fieldsMap,omitempty"`
	FlatFields [][]string     `json:"flatFields,omitempty"`
	Object     *Entity        `json:"object,omitempty"`
	Time       *string        `json:"time,omitempty"`
}

type AuditingMetadata struct {
	UpdatedBy   ActorRef `json:"updatedBy"`
	UpdatedTime string   `json:"updatedTime"`
}

type AuditingMetadataFilterInput struct {
	UpdatedBy   *ActorRefInput       `json:"updatedBy,omitempty"`
	UpdatedTime *DateTimeFilterInput `json:"updatedTime,omitempty"`
}

type AuditingMetadataSortInput struct {
	UpdatedBy   *SortOrderInput `json:"updatedBy,omitempty"`
	UpdatedTime *SortOrderInput `json:"updatedTime,omitempty"`
}

// Input parameters for querying available versions.
type AvailableVersionListInput struct {
	Platforms []string `json:"platforms"`
}

// Response payload for available versions query.
type AvailableVersionListPayload struct {
	Items []*PlatformVersions `json:"items"`
}

type BGPConnection struct {
	CatoAsn        *scalars.Asn16 `json:"catoAsn,omitempty"`
	CatoIP         *string        `json:"catoIp,omitempty"`
	ConnectionName *string        `json:"connectionName,omitempty"`
	PeerAsn        *scalars.Asn32 `json:"peerAsn,omitempty"`
	PeerIP         *string        `json:"peerIp,omitempty"`
}

type BandwidthManagementRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (BandwidthManagementRef) IsObjectRef()         {}
func (this BandwidthManagementRef) GetID() string   { return this.ID }
func (this BandwidthManagementRef) GetName() string { return this.Name }

type BandwidthManagementRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

type BfdSettings struct {
	Multiplier       int64 `json:"multiplier"`
	ReceiveInterval  int64 `json:"receiveInterval"`
	TransmitInterval int64 `json:"transmitInterval"`
}

type BfdSettingsInput struct {
	Multiplier       int64 `json:"multiplier"`
	ReceiveInterval  int64 `json:"receiveInterval"`
	TransmitInterval int64 `json:"transmitInterval"`
}

type BgpCommunity struct {
	From scalars.Asn16 `json:"from"`
	To   scalars.Asn16 `json:"to"`
}

type BgpCommunityFilterRule struct {
	Community []*BgpCommunity             `json:"community"`
	ID        string                      `json:"id"`
	Predicate BgpCommunityFilterPredicate `json:"predicate"`
}

type BgpCommunityFilterRuleInput struct {
	Community []*BgpCommunityInput         `json:"community"`
	Predicate *BgpCommunityFilterPredicate `json:"predicate,omitempty"`
}

type BgpCommunityInput struct {
	From scalars.Asn16 `json:"from"`
	To   scalars.Asn16 `json:"to"`
}

type BgpDetailedStatus struct {
	BfdSession             *string                      `json:"bfdSession,omitempty"`
	BgpSession             string                       `json:"bgpSession"`
	RejectedRoutesFromPeer []*BgpRejectedRoutesFromPeer `json:"rejectedRoutesFromPeer"`
	RemoteIP               string                       `json:"remoteIp"`
	RoutesFromPeer         []string                     `json:"routesFromPeer"`
	RoutesToPeer           []string                     `json:"routesToPeer"`
}

type BgpFilterRule struct {
	BgpRouteExactAndInclusiveFilterRule *BgpRouteExactAndInclusiveFilterRule `json:"bgpRouteExactAndInclusiveFilterRule,omitempty"`
	BgpRouteExactFilterRule             *BgpRouteExactFilterRule             `json:"bgpRouteExactFilterRule,omitempty"`
	CommunityFilterRule                 *BgpCommunityFilterRule              `json:"communityFilterRule,omitempty"`
}

type BgpFilterRuleInput struct {
	BgpRouteExactAndInclusiveFilterRule *BgpRouteExactAndInclusiveFilterRuleInput `json:"bgpRouteExactAndInclusiveFilterRule,omitempty"`
	BgpRouteExactFilterRule             *BgpRouteExactFilterRuleInput             `json:"bgpRouteExactFilterRule,omitempty"`
	CommunityFilterRule                 *BgpCommunityFilterRuleInput              `json:"communityFilterRule,omitempty"`
}

type BgpPeer struct {
	AdvertiseAllRoutes     bool               `json:"advertiseAllRoutes"`
	AdvertiseDefaultRoute  bool               `json:"advertiseDefaultRoute"`
	AdvertiseSummaryRoutes bool               `json:"advertiseSummaryRoutes"`
	BfdEnabled             bool               `json:"bfdEnabled"`
	BfdSettings            *BfdSettings       `json:"bfdSettings,omitempty"`
	CatoAsn                scalars.Asn16      `json:"catoAsn"`
	CatoIP                 string             `json:"catoIp"`
	DefaultAction          BgpDefaultAction   `json:"defaultAction"`
	DefaultActionExclusion []*BgpFilterRule   `json:"defaultActionExclusion"`
	HoldTime               int64              `json:"holdTime"`
	ID                     string             `json:"id"`
	KeepaliveInterval      int64              `json:"keepaliveInterval"`
	Md5AuthKey             *string            `json:"md5AuthKey,omitempty"`
	Metric                 int64              `json:"metric"`
	Name                   string             `json:"name"`
	PeerAsn                scalars.Asn32      `json:"peerAsn"`
	PeerIP                 string             `json:"peerIp"`
	PerformNat             bool               `json:"performNat"`
	Site                   *SiteRef           `json:"site"`
	SummaryRoute           []*BgpSummaryRoute `json:"summaryRoute"`
	Tracking               *BgpTracking       `json:"tracking,omitempty"`
}

type BgpPeerListInput struct {
	Site *SiteRefInput `json:"site"`
}

type BgpPeerListPayload struct {
	BgpPeer []*BgpPeer `json:"bgpPeer"`
	Total   int64      `json:"total"`
}

type BgpPeerRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

type BgpRejectedRoutesFromPeer struct {
	Community          []*BgpCommunity `json:"community"`
	LastPublishAttempt *string         `json:"lastPublishAttempt,omitempty"`
	Rule               *string         `json:"rule,omitempty"`
	Subnet             *string         `json:"subnet,omitempty"`
	Type               *string         `json:"type,omitempty"`
}

type BgpRouteExactAndInclusiveFilterRule struct {
	Ge                     *int64              `json:"ge,omitempty"`
	GlobalIPRange          []*GlobalIPRangeRef `json:"globalIpRange"`
	GlobalIPRangeException []*GlobalIPRangeRef `json:"globalIpRangeException"`
	ID                     string              `json:"id"`
	Le                     *int64              `json:"le,omitempty"`
	NetworkSubnet          []string            `json:"networkSubnet"`
	NetworkSubnetException []string            `json:"networkSubnetException"`
}

type BgpRouteExactAndInclusiveFilterRuleInput struct {
	Ge                     *int64                   `json:"ge,omitempty"`
	GlobalIPRange          []*GlobalIPRangeRefInput `json:"globalIpRange"`
	GlobalIPRangeException []*GlobalIPRangeRefInput `json:"globalIpRangeException"`
	Le                     *int64                   `json:"le,omitempty"`
	NetworkSubnet          []string                 `json:"networkSubnet"`
	NetworkSubnetException []string                 `json:"networkSubnetException"`
}

type BgpRouteExactFilterRule struct {
	GlobalIPRange []*GlobalIPRangeRef `json:"globalIpRange"`
	ID            string              `json:"id"`
	NetworkSubnet []string            `json:"networkSubnet"`
}

type BgpRouteExactFilterRuleInput struct {
	GlobalIPRange []*GlobalIPRangeRefInput `json:"globalIpRange"`
	NetworkSubnet []string                 `json:"networkSubnet"`
}

type BgpSummaryRoute struct {
	Community []*BgpCommunity `json:"community"`
	ID        string          `json:"id"`
	Route     string          `json:"route"`
}

type BgpSummaryRouteInput struct {
	Community []*BgpCommunityInput `json:"community"`
	Route     string               `json:"route"`
}

type BgpTracking struct {
	AlertFrequency PolicyRuleTrackingFrequencyEnum `json:"alertFrequency"`
	Enabled        bool                            `json:"enabled"`
	ID             string                          `json:"id"`
	SubscriptionID *string                         `json:"subscriptionId,omitempty"`
}

type BgpTrackingInput struct {
	AlertFrequency PolicyRuleTrackingFrequencyEnum `json:"alertFrequency"`
	Enabled        bool                            `json:"enabled"`
	SubscriptionID string                          `json:"subscriptionId"`
}

type BooleanFilterInput struct {
	Eq  *bool `json:"eq,omitempty"`
	Neq *bool `json:"neq,omitempty"`
}

type BooleanPredicate struct {
	Is string `json:"is"`
}

type BulkUpgradeSiteInfo struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

// Cloud Access Security Broker (CASB) service license details
type CasbLicense struct {
	Description    *string       `json:"description,omitempty"`
	ExpirationDate string        `json:"expirationDate"`
	ID             *string       `json:"id,omitempty"`
	LastUpdated    *string       `json:"lastUpdated,omitempty"`
	Plan           LicensePlan   `json:"plan"`
	Sku            LicenseSku    `json:"sku"`
	StartDate      *string       `json:"startDate,omitempty"`
	Status         LicenseStatus `json:"status"`
}

func (CasbLicense) IsLicense()                     {}
func (this CasbLicense) GetDescription() *string   { return this.Description }
func (this CasbLicense) GetExpirationDate() string { return this.ExpirationDate }
func (this CasbLicense) GetID() *string            { return this.ID }
func (this CasbLicense) GetLastUpdated() *string   { return this.LastUpdated }
func (this CasbLicense) GetPlan() LicensePlan      { return this.Plan }
func (this CasbLicense) GetSku() LicenseSku        { return this.Sku }
func (this CasbLicense) GetStartDate() *string     { return this.StartDate }
func (this CasbLicense) GetStatus() LicenseStatus  { return this.Status }

type CatalogApplication struct {
	Activity             []*CatalogApplicationActivity           `json:"activity"`
	Capability           []CatalogApplicationCapability          `json:"capability"`
	Category             []*ApplicationCategoryRef               `json:"category"`
	City                 *string                                 `json:"city,omitempty"`
	ComplianceAttributes *CatalogApplicationComplianceAttributes `json:"complianceAttributes"`
	Description          *string                                 `json:"description,omitempty"`
	DescriptionSummary   *string                                 `json:"descriptionSummary,omitempty"`
	ID                   string                                  `json:"id"`
	IpoStatus            *string                                 `json:"ipoStatus,omitempty"`
	Name                 string                                  `json:"name"`
	NumOfEmployees       *EmployeeRange                          `json:"numOfEmployees,omitempty"`
	OriginCountry        *CountryRef                             `json:"originCountry,omitempty"`
	RecentlyAdded        bool                                    `json:"recentlyAdded"`
	Region               *string                                 `json:"region,omitempty"`
	Risk                 *string                                 `json:"risk,omitempty"`
	Sanctioned           bool                                    `json:"sanctioned"`
	SecurityAttributes   *CatalogApplicationSecurityAttributes   `json:"securityAttributes"`
	StandardPorts        []*CustomService                        `json:"standardPorts"`
	Type                 CatalogApplicationType                  `json:"type"`
	Website              *string                                 `json:"website,omitempty"`
}

type CatalogApplicationActivity struct {
	Fields []*CatalogApplicationActivityField `json:"fields"`
	ID     string                             `json:"id"`
	Name   string                             `json:"name"`
}

type CatalogApplicationActivityField struct {
	ID                string                                    `json:"id"`
	Name              string                                    `json:"name"`
	PossibleOperators []CatalogApplicationActivityFieldOperator `json:"possibleOperators"`
	PossibleValues    []string                                  `json:"possibleValues"`
}

type CatalogApplicationActivityFilterInput struct {
	HasAny []*CatalogApplicationActivityRefInput `json:"hasAny,omitempty"`
}

type CatalogApplicationActivityRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

type CatalogApplicationCapabilityFilterInput struct {
	HasAny []CatalogApplicationCapability `json:"hasAny,omitempty"`
}

type CatalogApplicationCategoryFilterInput struct {
	HasAny []*ApplicationCategoryRefInput `json:"hasAny,omitempty"`
}

type CatalogApplicationCategorySortInput struct {
	Name *SortOrderInput `json:"name,omitempty"`
}

type CatalogApplicationComplianceAttributes struct {
	Hippa    CatalogApplicationAttribute `json:"hippa"`
	Isae3402 CatalogApplicationAttribute `json:"isae3402"`
	Iso27001 CatalogApplicationAttribute `json:"iso27001"`
	PciDss   CatalogApplicationAttribute `json:"pciDss"`
	Soc1     CatalogApplicationAttribute `json:"soc1"`
	Soc2     CatalogApplicationAttribute `json:"soc2"`
	Soc3     CatalogApplicationAttribute `json:"soc3"`
	Sox      CatalogApplicationAttribute `json:"sox"`
}

type CatalogApplicationContentType struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

type CatalogApplicationContentTypeFilterInput struct {
	ID   []*IDFilterInput     `json:"id,omitempty"`
	Name []*StringFilterInput `json:"name,omitempty"`
}

type CatalogApplicationContentTypeGroup struct {
	ContentType []*CatalogApplicationContentType `json:"contentType"`
	ID          string                           `json:"id"`
	Name        string                           `json:"name"`
}

type CatalogApplicationContentTypeGroupFilterInput struct {
	ContentType []*CatalogApplicationContentTypeFilterInput `json:"contentType,omitempty"`
	ID          []*IDFilterInput                            `json:"id,omitempty"`
	Name        []*StringFilterInput                        `json:"name,omitempty"`
}

type CatalogApplicationContentTypeGroupListInput struct {
	Filter []*CatalogApplicationContentTypeGroupFilterInput `json:"filter,omitempty"`
	Paging *PagingInput                                     `json:"paging,omitempty"`
	Sort   *CatalogApplicationContentTypeGroupSortInput     `json:"sort,omitempty"`
}

type CatalogApplicationContentTypeGroupListPayload struct {
	ContentTypeGroup []*CatalogApplicationContentTypeGroup `json:"contentTypeGroup"`
	PageInfo         *PageInfo                             `json:"pageInfo"`
}

type CatalogApplicationContentTypeGroupSortInput struct {
	Name *SortOrderInput `json:"name,omitempty"`
}

type CatalogApplicationFilterInput struct {
	Activity      []*CatalogApplicationActivityFilterInput   `json:"activity,omitempty"`
	Capability    []*CatalogApplicationCapabilityFilterInput `json:"capability,omitempty"`
	Category      []*CatalogApplicationCategoryFilterInput   `json:"category,omitempty"`
	ID            []*IDFilterInput                           `json:"id,omitempty"`
	Name          []*StringFilterInput                       `json:"name,omitempty"`
	RecentlyAdded []*BooleanFilterInput                      `json:"recentlyAdded,omitempty"`
	Risk          []*IntFilterInput                          `json:"risk,omitempty"`
	Type          []*CatalogApplicationTypeFilterInput       `json:"type,omitempty"`
}

type CatalogApplicationListInput struct {
	Filter []*CatalogApplicationFilterInput `json:"filter,omitempty"`
	Paging *PagingInput                     `json:"paging,omitempty"`
	Sort   *CatalogApplicationSortInput     `json:"sort,omitempty"`
}

type CatalogApplicationListPayload struct {
	Application []*CatalogApplication `json:"application"`
	PageInfo    *PageInfo             `json:"pageInfo"`
}

type CatalogApplicationSecurityAttributes struct {
	AuditTrail          CatalogApplicationAttribute `json:"auditTrail"`
	EncryptionAtRest    CatalogApplicationAttribute `json:"encryptionAtRest"`
	HTTPSecurityHeaders CatalogApplicationAttribute `json:"httpSecurityHeaders"`
	Mfa                 CatalogApplicationAttribute `json:"mfa"`
	Rbac                CatalogApplicationAttribute `json:"rbac"`
	RememberPassword    CatalogApplicationAttribute `json:"rememberPassword"`
	Sso                 CatalogApplicationAttribute `json:"sso"`
	TLSEnforcement      CatalogApplicationAttribute `json:"tlsEnforcement"`
	TrustedCertificate  CatalogApplicationAttribute `json:"trustedCertificate"`
}

type CatalogApplicationSortInput struct {
	Category    *CatalogApplicationCategorySortInput `json:"category,omitempty"`
	Description *SortOrderInput                      `json:"description,omitempty"`
	Name        *SortOrderInput                      `json:"name,omitempty"`
	Risk        *SortOrderInput                      `json:"risk,omitempty"`
	Type        *SortOrderInput                      `json:"type,omitempty"`
}

type CatalogApplicationTypeFilterInput struct {
	Eq  *CatalogApplicationType  `json:"eq,omitempty"`
	In  []CatalogApplicationType `json:"in,omitempty"`
	Neq *CatalogApplicationType  `json:"neq,omitempty"`
	Nin []CatalogApplicationType `json:"nin,omitempty"`
}

type CatalogQueries struct {
	CatalogApplication     *CatalogApplication                            `json:"catalogApplication,omitempty"`
	CatalogApplicationList *CatalogApplicationListPayload                 `json:"catalogApplicationList,omitempty"`
	ContentTypeGroupList   *CatalogApplicationContentTypeGroupListPayload `json:"contentTypeGroupList,omitempty"`
}

// CatoActivity is an object type representing an activity in a Cato alert, containing unique identifiers for the activity itself, the preceding resource, and the involved resource.
type CatoActivity struct {
	ID               string `json:"id"`
	ParentResourceID string `json:"parentResourceId"`
	ResourceID       string `json:"resourceId"`
}

func (CatoActivity) IsActivity()                      {}
func (this CatoActivity) GetID() string               { return this.ID }
func (this CatoActivity) GetParentResourceID() string { return this.ParentResourceID }
func (this CatoActivity) GetResourceID() string       { return this.ResourceID }

// The `CatoEndpoint` object represents a comprehensive data structure used in GraphQL queries or mutations to encapsulate details about a security incident detected by an Endpoint Protection Platform (EPP). It includes fields such as threat alerts, analyst feedback, connection type, criticality score, device details, timestamps for incident signals, and various enums and strings that describe the incident's status, source, and producer.
type CatoEndpoint struct {
	Alerts              []*CatoEndpointAlert       `json:"alerts"`
	AnalystFeedback     *AnalystFeedback           `json:"analystFeedback,omitempty"`
	ConnectionType      *ConnectionTypeEnum        `json:"connectionType,omitempty"`
	Criticality         *int64                     `json:"criticality,omitempty"`
	Description         *string                    `json:"description,omitempty"`
	Device              *CatoEndpointDeviceDetails `json:"device,omitempty"`
	EngineType          *StoryEngineTypeEnum       `json:"engineType,omitempty"`
	FirstSignal         string                     `json:"firstSignal"`
	ID                  string                     `json:"id"`
	Indication          string                     `json:"indication"`
	LastSignal          string                     `json:"lastSignal"`
	PredictedThreatType *string                    `json:"predictedThreatType,omitempty"`
	PredictedVerdict    *StoryVerdictEnum          `json:"predictedVerdict,omitempty"`
	Producer            StoryProducerEnum          `json:"producer"`
	ProducerName        string                     `json:"producerName"`
	QueryName           *string                    `json:"queryName,omitempty"`
	Research            *bool                      `json:"research,omitempty"`
	SimilarStoriesData  []*SimilarStoryData        `json:"similarStoriesData"`
	Site                *SiteRef                   `json:"site,omitempty"`
	SiteName            *string                    `json:"siteName,omitempty"`
	Source              *string                    `json:"source,omitempty"`
	SourceIP            *string                    `json:"sourceIp,omitempty"`
	Status              *StoryStatusEnum           `json:"status,omitempty"`
	StoryDuration       *int64                     `json:"storyDuration,omitempty"`
	Ticket              *string                    `json:"ticket,omitempty"`
	User                *UserRef                   `json:"user,omitempty"`
	Vendor              *VendorEnum                `json:"vendor,omitempty"`
}

func (CatoEndpoint) IsEndpoint() {}
func (this CatoEndpoint) GetAlerts() []EndpointAlert {
	if this.Alerts == nil {
		return nil
	}
	interfaceSlice := make([]EndpointAlert, 0, len(this.Alerts))
	for _, concrete := range this.Alerts {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this CatoEndpoint) GetAnalystFeedback() *AnalystFeedback   { return this.AnalystFeedback }
func (this CatoEndpoint) GetConnectionType() *ConnectionTypeEnum { return this.ConnectionType }
func (this CatoEndpoint) GetCriticality() *int64                 { return this.Criticality }
func (this CatoEndpoint) GetDescription() *string                { return this.Description }
func (this CatoEndpoint) GetDevice() DeviceDetails               { return *this.Device }
func (this CatoEndpoint) GetEngineType() *StoryEngineTypeEnum    { return this.EngineType }
func (this CatoEndpoint) GetFirstSignal() string                 { return this.FirstSignal }
func (this CatoEndpoint) GetID() string                          { return this.ID }
func (this CatoEndpoint) GetIndication() string                  { return this.Indication }
func (this CatoEndpoint) GetLastSignal() string                  { return this.LastSignal }
func (this CatoEndpoint) GetPredictedThreatType() *string        { return this.PredictedThreatType }
func (this CatoEndpoint) GetPredictedVerdict() *StoryVerdictEnum { return this.PredictedVerdict }
func (this CatoEndpoint) GetProducer() StoryProducerEnum         { return this.Producer }
func (this CatoEndpoint) GetProducerName() string                { return this.ProducerName }
func (this CatoEndpoint) GetQueryName() *string                  { return this.QueryName }
func (this CatoEndpoint) GetResearch() *bool                     { return this.Research }
func (this CatoEndpoint) GetSimilarStoriesData() []*SimilarStoryData {
	if this.SimilarStoriesData == nil {
		return nil
	}
	interfaceSlice := make([]*SimilarStoryData, 0, len(this.SimilarStoriesData))
	for _, concrete := range this.SimilarStoriesData {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this CatoEndpoint) GetSite() *SiteRef           { return this.Site }
func (this CatoEndpoint) GetSiteName() *string        { return this.SiteName }
func (this CatoEndpoint) GetSource() *string          { return this.Source }
func (this CatoEndpoint) GetSourceIP() *string        { return this.SourceIP }
func (this CatoEndpoint) GetStatus() *StoryStatusEnum { return this.Status }
func (this CatoEndpoint) GetStoryDuration() *int64    { return this.StoryDuration }
func (this CatoEndpoint) GetTicket() *string          { return this.Ticket }
func (this CatoEndpoint) GetUser() *UserRef           { return this.User }
func (this CatoEndpoint) GetVendor() *VendorEnum      { return this.Vendor }

func (CatoEndpoint) IsMergedIncident() {}

// The `CatoEndpointAlert` object represents an alert generated by Cato's endpoint protection system, detailing information about detected threats, including associated activities, threat description, criticality level, endpoint protection profile, and remediation status.
type CatoEndpointAlert struct {
	Activities                []*CatoActivity         `json:"activities"`
	CreatedDateTime           *string                 `json:"createdDateTime,omitempty"`
	Criticality               *int64                  `json:"criticality,omitempty"`
	Description               *string                 `json:"description,omitempty"`
	EndpointProtectionProfile *string                 `json:"endpointProtectionProfile,omitempty"`
	EngineType                *CatoEndpointEngineType `json:"engineType,omitempty"`
	ExternalIP                *string                 `json:"externalIp,omitempty"`
	ID                        string                  `json:"id"`
	LocalIP                   *string                 `json:"localIp,omitempty"`
	MitreSubTechnique         []*Mitre                `json:"mitreSubTechnique"`
	MitreTechnique            []*Mitre                `json:"mitreTechnique"`
	Resources                 []CatoResource          `json:"resources"`
	Status                    *RemediationStatusEnum  `json:"status,omitempty"`
	ThreatName                *string                 `json:"threatName,omitempty"`
	Title                     *string                 `json:"title,omitempty"`
}

func (CatoEndpointAlert) IsEndpointAlert() {}
func (this CatoEndpointAlert) GetActivities() []Activity {
	if this.Activities == nil {
		return nil
	}
	interfaceSlice := make([]Activity, 0, len(this.Activities))
	for _, concrete := range this.Activities {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this CatoEndpointAlert) GetCreatedDateTime() *string { return this.CreatedDateTime }
func (this CatoEndpointAlert) GetCriticality() *int64      { return this.Criticality }
func (this CatoEndpointAlert) GetDescription() *string     { return this.Description }
func (this CatoEndpointAlert) GetExternalIP() *string      { return this.ExternalIP }
func (this CatoEndpointAlert) GetID() string               { return this.ID }
func (this CatoEndpointAlert) GetLocalIP() *string         { return this.LocalIP }
func (this CatoEndpointAlert) GetMitreSubTechnique() []*Mitre {
	if this.MitreSubTechnique == nil {
		return nil
	}
	interfaceSlice := make([]*Mitre, 0, len(this.MitreSubTechnique))
	for _, concrete := range this.MitreSubTechnique {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this CatoEndpointAlert) GetMitreTechnique() []*Mitre {
	if this.MitreTechnique == nil {
		return nil
	}
	interfaceSlice := make([]*Mitre, 0, len(this.MitreTechnique))
	for _, concrete := range this.MitreTechnique {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this CatoEndpointAlert) GetResources() []EndpointResource {
	if this.Resources == nil {
		return nil
	}
	interfaceSlice := make([]EndpointResource, 0, len(this.Resources))
	for _, concrete := range this.Resources {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this CatoEndpointAlert) GetThreatName() *string { return this.ThreatName }
func (this CatoEndpointAlert) GetTitle() *string      { return this.Title }

// The `CatoEndpointDeviceDetails` object represents detailed information about a device, including its name, unique ID, logged-on users, MAC address, and operating system details.
type CatoEndpointDeviceDetails struct {
	DeviceName    *string        `json:"deviceName,omitempty"`
	ExternalIP    *string        `json:"externalIp,omitempty"`
	ID            string         `json:"id"`
	LocalIP       *string        `json:"localIp,omitempty"`
	LoggedOnUsers []EndpointUser `json:"loggedOnUsers"`
	MacAddress    *string        `json:"macAddress,omitempty"`
	OsDetails     *OsDetails     `json:"osDetails,omitempty"`
}

func (CatoEndpointDeviceDetails) IsDeviceDetails()            {}
func (this CatoEndpointDeviceDetails) GetDeviceName() *string { return this.DeviceName }
func (this CatoEndpointDeviceDetails) GetExternalIP() *string { return this.ExternalIP }
func (this CatoEndpointDeviceDetails) GetID() string          { return this.ID }
func (this CatoEndpointDeviceDetails) GetLocalIP() *string    { return this.LocalIP }
func (this CatoEndpointDeviceDetails) GetLoggedOnUsers() []EndpointUser {
	if this.LoggedOnUsers == nil {
		return nil
	}
	interfaceSlice := make([]EndpointUser, 0, len(this.LoggedOnUsers))
	for _, concrete := range this.LoggedOnUsers {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this CatoEndpointDeviceDetails) GetOsDetails() *OsDetails { return this.OsDetails }

// The `CatoEndpointUser` is a GraphQL object type representing a user, with fields for a unique identifier (`id`) and a username (`name`), both of which are required.
type CatoEndpointUser struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (CatoEndpointUser) IsEndpointUser()      {}
func (this CatoEndpointUser) GetID() string   { return this.ID }
func (this CatoEndpointUser) GetName() string { return this.Name }

// The `CatoFileResource` is a GraphQL object type that represents a file resource with fields for its creation timestamp, detection and remediation statuses, file details, and a unique identifier.
type CatoFileResource struct {
	CreatedDateTime   *string                `json:"createdDateTime,omitempty"`
	DetectionStatus   *DetectionStatusEnum   `json:"detectionStatus,omitempty"`
	FileDetails       *FileDetails           `json:"fileDetails,omitempty"`
	ID                string                 `json:"id"`
	RemediationStatus *RemediationStatusEnum `json:"remediationStatus,omitempty"`
}

func (CatoFileResource) IsCatoResource()                  {}
func (this CatoFileResource) GetCreatedDateTime() *string { return this.CreatedDateTime }
func (this CatoFileResource) GetID() string               { return this.ID }
func (this CatoFileResource) GetRemediationStatus() *RemediationStatusEnum {
	return this.RemediationStatus
}

func (CatoFileResource) IsEndpointResource() {}

func (CatoFileResource) IsFileResource() {}

func (this CatoFileResource) GetDetectionStatus() *DetectionStatusEnum { return this.DetectionStatus }
func (this CatoFileResource) GetFileDetails() *FileDetails             { return this.FileDetails }

// The `CatoProcessResource` is a GraphQL object type that represents a process resource, including details such as a unique Cato ID, the timestamp of usage, associated file details, command line information, process ID, remediation status, and the related user account.
type CatoProcessResource struct {
	CreatedDateTime    *string                `json:"createdDateTime,omitempty"`
	ID                 string                 `json:"id"`
	ImageFile          *FileDetails           `json:"imageFile,omitempty"`
	ProcessCommandLine *string                `json:"processCommandLine,omitempty"`
	ProcessID          int64                  `json:"processId"`
	RemediationStatus  *RemediationStatusEnum `json:"remediationStatus,omitempty"`
	UserAccount        EndpointUser           `json:"userAccount,omitempty"`
}

func (CatoProcessResource) IsCatoResource()                  {}
func (this CatoProcessResource) GetCreatedDateTime() *string { return this.CreatedDateTime }
func (this CatoProcessResource) GetID() string               { return this.ID }
func (this CatoProcessResource) GetRemediationStatus() *RemediationStatusEnum {
	return this.RemediationStatus
}

func (CatoProcessResource) IsEndpointResource() {}

func (CatoProcessResource) IsProcessResource() {}

func (this CatoProcessResource) GetImageFile() *FileDetails     { return this.ImageFile }
func (this CatoProcessResource) GetProcessCommandLine() *string { return this.ProcessCommandLine }
func (this CatoProcessResource) GetProcessID() int64            { return this.ProcessID }

func (this CatoProcessResource) GetUserAccount() EndpointUser { return this.UserAccount }

type CellularInterface struct {
	Apn                 *string                      `json:"apn,omitempty"`
	ApnSelectionMethod  *ApnMethod                   `json:"apnSelectionMethod,omitempty"`
	DisconnectionReason *CellularDisconnectionReason `json:"disconnectionReason,omitempty"`
	Iccid               *string                      `json:"iccid,omitempty"`
	Imei                *string                      `json:"imei,omitempty"`
	IsModemConnected    bool                         `json:"isModemConnected"`
	IsModemSuspended    bool                         `json:"isModemSuspended"`
	IsRoamingAllowed    bool                         `json:"isRoamingAllowed"`
	IsSimSlot1Detected  bool                         `json:"isSimSlot1Detected"`
	IsSimSlot2Detected  bool                         `json:"isSimSlot2Detected"`
	ModemStatus         *CellularModemStatus         `json:"modemStatus,omitempty"`
	NetworkType         *CellularNetworkType         `json:"networkType,omitempty"`
	OperatorName        *string                      `json:"operatorName,omitempty"`
	SignalStrength      *string                      `json:"signalStrength,omitempty"`
	SimNumber           *string                      `json:"simNumber,omitempty"`
	SimSlotID           *int64                       `json:"simSlotId,omitempty"`
}

// Connectivity status of a cloud interconnect connection.
type CloudInterconnectConnectionConnectivity struct {
	Success bool `json:"success"`
}

// Input for checking the connectivity status of a cloud interconnect connection.
type CloudInterconnectConnectionConnectivityInput struct {
	ID string `json:"id"`
}

// Details of a physical connection at a cloud interconnect site.
type CloudInterconnectPhysicalConnection struct {
	CVlan               *string         `json:"cVlan,omitempty"`
	DownstreamBwLimit   string          `json:"downstreamBwLimit"`
	EncapsulationMethod TaggingMethod   `json:"encapsulationMethod"`
	HaRole              HaRole          `json:"haRole"`
	ID                  string          `json:"id"`
	PopLocation         *PopLocationRef `json:"popLocation"`
	PrivateCatoIP       string          `json:"privateCatoIp"`
	PrivateSiteIP       string          `json:"privateSiteIp"`
	SVlan               *string         `json:"sVlan,omitempty"`
	ServiceProviderName string          `json:"serviceProviderName"`
	Site                *SiteRef        `json:"site"`
	Subnet              string          `json:"subnet"`
	UpstreamBwLimit     string          `json:"upstreamBwLimit"`
	Vlan                *string         `json:"vlan,omitempty"`
}

// ID of a physical connection at a cloud interconnect site.
type CloudInterconnectPhysicalConnectionID struct {
	ID string `json:"id"`
}

// Input for getting the ID of a physical connection at a cloud interconnect site.
type CloudInterconnectPhysicalConnectionIDInput struct {
	HaRole HaRole        `json:"haRole"`
	Site   *SiteRefInput `json:"site"`
}

// Input for getting details of a physical connection at a cloud interconnect site.
type CloudInterconnectPhysicalConnectionInput struct {
	ID string `json:"id"`
}

type ContactDetails struct {
	Email *string `json:"email,omitempty"`
	Name  *string `json:"name,omitempty"`
	Phone *string `json:"phone,omitempty"`
}

type ContactDetailsInput struct {
	Email *string `json:"email,omitempty"`
	Name  *string `json:"name,omitempty"`
	Phone *string `json:"phone,omitempty"`
}

// Audit metadata about the container
type ContainerAudit struct {
	CreatedAt      string `json:"createdAt"`
	CreatedBy      string `json:"createdBy"`
	LastModifiedAt string `json:"lastModifiedAt"`
	LastModifiedBy string `json:"lastModifiedBy"`
}

type ContainerMutations struct {
	Delete         *DeleteContainerPayload           `json:"delete"`
	Fqdn           *FqdnContainerMutations           `json:"fqdn"`
	IPAddressRange *IPAddressRangeContainerMutations `json:"ipAddressRange"`
}

type ContainerQueries struct {
	Fqdn           *FqdnContainerQueries           `json:"fqdn"`
	IPAddressRange *IPAddressRangeContainerQueries `json:"ipAddressRange"`
	List           *ContainerSearchPayload         `json:"list"`
}

// Add a container by ID or name
type ContainerRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

// Filtering input to container search
type ContainerSearchInput struct {
	Refs  []*ContainerRefInput `json:"refs"`
	Types []ContainerType      `json:"types"`
}

// Container search result, including all containers that matched input criteria
type ContainerSearchPayload struct {
	Containers []Container `json:"containers"`
}

// A reference identifying the Country object. ID: Unique Country Identifier, Name: The Country Name
type CountryRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (CountryRef) IsObjectRef()         {}
func (this CountryRef) GetID() string   { return this.ID }
func (this CountryRef) GetName() string { return this.Name }

type CountryRefFilterInput struct {
	Eq  *CountryRefInput   `json:"eq,omitempty"`
	In  []*CountryRefInput `json:"in,omitempty"`
	Neq *CountryRefInput   `json:"neq,omitempty"`
	Nin []*CountryRefInput `json:"nin,omitempty"`
}

type CountryRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

// Input for creating FQDN typed container from file
type CreateFqdnContainerFromFileInput struct {
	Description string            `json:"description"`
	FileType    ContainerFileType `json:"fileType"`
	Name        string            `json:"name"`
	UploadFile  *graphql.Upload   `json:"uploadFile,omitempty"`
}

// Payload of CreateFromFile operation on FQDN typed container
type CreateFqdnContainerFromFilePayload struct {
	Container *FqdnContainer `json:"container"`
}

type CreateFqdnContainerFromListInput struct {
	Description string   `json:"description"`
	Name        string   `json:"name"`
	Values      []string `json:"values"`
}

// Payload of CreateFromList operation on FQDN typed container
type CreateFqdnContainerFromListPayload struct {
	Container *FqdnContainer `json:"container"`
}

// Create a new group
type CreateGroupInput struct {
	Description *string                     `json:"description,omitempty"`
	Members     []*GroupMemberRefTypedInput `json:"members,omitempty"`
	Name        string                      `json:"name"`
}

// The created group object.
type CreateGroupPayload struct {
	Group *Group `json:"group"`
}

// Input for creating IPAddressRange typed container from file
type CreateIPAddressRangeContainerFromFileInput struct {
	Description string            `json:"description"`
	FileType    ContainerFileType `json:"fileType"`
	Name        string            `json:"name"`
	UploadFile  *graphql.Upload   `json:"uploadFile,omitempty"`
}

// Payload of CreateFromFile operation on IPAddressRange typed container
type CreateIPAddressRangeContainerFromFilePayload struct {
	Container *IPAddressRangeContainer `json:"container"`
}

type CreateIPAddressRangeContainerFromListInput struct {
	Description string                 `json:"description"`
	Name        string                 `json:"name"`
	Values      []*IPAddressRangeInput `json:"values"`
}

// Payload of CreateFromList operation on IPAddressRange typed container
type CreateIPAddressRangeContainerFromListPayload struct {
	Container *IPAddressRangeContainer `json:"container"`
}

type CreateLocationDetailsInput struct {
	CompanyName   *string              `json:"companyName,omitempty"`
	Contact       *ContactDetailsInput `json:"contact,omitempty"`
	PostalAddress *PostalAddressInput  `json:"postalAddress"`
	VatID         *string              `json:"vatId,omitempty"`
}

type CreatePrivateApplicationInput struct {
	AllowICMPProtocol  bool                     `json:"allowIcmpProtocol"`
	Description        *string                  `json:"description,omitempty"`
	InternalAppAddress string                   `json:"internalAppAddress"`
	Name               string                   `json:"name"`
	PrivateAppProbing  *PrivateAppProbingInput  `json:"privateAppProbing,omitempty"`
	ProbingEnabled     bool                     `json:"probingEnabled"`
	ProtocolPorts      []*CustomServiceInput    `json:"protocolPorts,omitempty"`
	Published          bool                     `json:"published"`
	PublishedAppDomain *PublishedAppDomainInput `json:"publishedAppDomain,omitempty"`
}

// A reference identifying the CustomApplication object. ID: Unique CustomApplication Identifier, Name: The CustomApplication Name
type CreatePrivateApplicationPayload struct {
	Application *PrivateApplication `json:"application"`
}

type CustomApplicationRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (CustomApplicationRef) IsObjectRef()         {}
func (this CustomApplicationRef) GetID() string   { return this.ID }
func (this CustomApplicationRef) GetName() string { return this.Name }

type CustomApplicationRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

// A reference identifying the CustomCategory object. ID: Unique CustomCategory Identifier, Name: The CustomCategory Name
type CustomCategoryRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (CustomCategoryRef) IsObjectRef()         {}
func (this CustomCategoryRef) GetID() string   { return this.ID }
func (this CustomCategoryRef) GetName() string { return this.Name }

type CustomCategoryRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

// Returns data for Custom Service defined by a combination of L4 ports and an IP Protocol
type CustomService struct {
	Port      []scalars.Port `json:"port,omitempty"`
	PortRange *PortRange     `json:"portRange,omitempty"`
	Protocol  IPProtocol     `json:"protocol"`
}

// Add a Custom Service defined by a combination of L4 ports and an IP Protocol
type CustomServiceInput struct {
	Port      []scalars.Port  `json:"port,omitempty"`
	PortRange *PortRangeInput `json:"portRange,omitempty"`
	Protocol  IPProtocol      `json:"protocol"`
}

type CustomServiceIP struct {
	IP      *string         `json:"ip,omitempty"`
	IPRange *IPAddressRange `json:"ipRange,omitempty"`
	Name    string          `json:"name"`
}

type CustomServiceIPInput struct {
	IP      *string              `json:"ip,omitempty"`
	IPRange *IPAddressRangeInput `json:"ipRange,omitempty"`
	Name    string               `json:"name"`
}

type DataLakeLicense struct {
	Description     *string       `json:"description,omitempty"`
	DpaVersion      DpaVersion    `json:"dpaVersion"`
	ExpirationDate  string        `json:"expirationDate"`
	ID              *string       `json:"id,omitempty"`
	LastUpdated     *string       `json:"lastUpdated,omitempty"`
	Plan            LicensePlan   `json:"plan"`
	RetentionPeriod *int64        `json:"retentionPeriod,omitempty"`
	Sku             LicenseSku    `json:"sku"`
	StartDate       *string       `json:"startDate,omitempty"`
	Status          LicenseStatus `json:"status"`
	Total           int64         `json:"total"`
}

func (DataLakeLicense) IsLicense()                     {}
func (this DataLakeLicense) GetDescription() *string   { return this.Description }
func (this DataLakeLicense) GetExpirationDate() string { return this.ExpirationDate }
func (this DataLakeLicense) GetID() *string            { return this.ID }
func (this DataLakeLicense) GetLastUpdated() *string   { return this.LastUpdated }
func (this DataLakeLicense) GetPlan() LicensePlan      { return this.Plan }
func (this DataLakeLicense) GetSku() LicenseSku        { return this.Sku }
func (this DataLakeLicense) GetStartDate() *string     { return this.StartDate }
func (this DataLakeLicense) GetStatus() LicenseStatus  { return this.Status }

func (DataLakeLicense) IsQuantifiableLicense() {}

func (this DataLakeLicense) GetTotal() int64 { return this.Total }

type DateTimeFilterInput struct {
	Between []string `json:"between,omitempty"`
	Eq      *string  `json:"eq,omitempty"`
	Gt      *string  `json:"gt,omitempty"`
	Gte     *string  `json:"gte,omitempty"`
	In      []string `json:"in,omitempty"`
	Lt      *string  `json:"lt,omitempty"`
	Lte     *string  `json:"lte,omitempty"`
	Neq     *string  `json:"neq,omitempty"`
	Nin     []string `json:"nin,omitempty"`
}

type DateValue struct {
	Date *string `json:"date,omitempty"`
}

func (DateValue) IsValue() {}

type DegradedDetail struct {
	Args   DegradedStatusArgs   `json:"args,omitempty"`
	Reason DegradedStatusReason `json:"reason"`
}

type DegradedStatus struct {
	DegradedDetails []*DegradedDetail `json:"degradedDetails"`
	IsDegraded      bool              `json:"isDegraded"`
}

type DegradedStatusBasicDataArgs struct {
	DeviceName        string  `json:"deviceName"`
	LastConnectedDate *string `json:"lastConnectedDate,omitempty"`
}

func (DegradedStatusBasicDataArgs) IsDegradedStatusArgs() {}

type DegradedStatusLastConnectedArgs struct {
	LastConnectedDate *string `json:"lastConnectedDate,omitempty"`
}

func (DegradedStatusLastConnectedArgs) IsDegradedStatusArgs() {}

type DegradedStatusMultiTunnelArgs struct {
	DeviceName        string  `json:"deviceName"`
	LastConnectedDate *string `json:"lastConnectedDate,omitempty"`
	TunnelID          string  `json:"tunnelID"`
	TunnelName        string  `json:"tunnelName"`
}

func (DegradedStatusMultiTunnelArgs) IsDegradedStatusArgs() {}

type DegradedStatusSocketArgs struct {
	DeviceName        string  `json:"deviceName"`
	LastConnectedDate *string `json:"lastConnectedDate,omitempty"`
	PortID            string  `json:"portID"`
	PortName          string  `json:"portName"`
}

func (DegradedStatusSocketArgs) IsDegradedStatusArgs() {}

type DegradedStatusSocketVersionsArgs struct {
	PrimaryVersion   string `json:"primaryVersion"`
	SecondaryVersion string `json:"secondaryVersion"`
}

func (DegradedStatusSocketVersionsArgs) IsDegradedStatusArgs() {}

// Identification of container for delete operation
type DeleteContainerInput struct {
	Ref *ContainerRefInput `json:"ref"`
}

type DeleteContainerPayload struct {
	Container Container `json:"container"`
}

// The deleted group object
type DeleteGroupPayload struct {
	Group *Group `json:"group"`
}

type DeletePrivateApplicationInput struct {
	PrivateApplication *PrivateApplicationRefInput `json:"privateApplication"`
}

type DeletePrivateApplicationPayload struct {
	Application string `json:"application"`
}

// Delete report input
type DeleteReportInput struct {
	FileHash string `json:"fileHash"`
}

// Delete report response
type DeleteReportPayload struct {
	FileHash string `json:"fileHash"`
}

type DeleteStoryCommentInput struct {
	CommentID string `json:"commentId"`
	StoryID   string `json:"storyId"`
}

type DeleteStoryCommentPayload struct {
	Comment *StoryComment `json:"comment"`
}

// DEM service license details
type DemLicense struct {
	Description    *string       `json:"description,omitempty"`
	ExpirationDate string        `json:"expirationDate"`
	ID             *string       `json:"id,omitempty"`
	LastUpdated    *string       `json:"lastUpdated,omitempty"`
	Plan           LicensePlan   `json:"plan"`
	Sku            LicenseSku    `json:"sku"`
	StartDate      *string       `json:"startDate,omitempty"`
	Status         LicenseStatus `json:"status"`
	Total          int64         `json:"total"`
}

func (DemLicense) IsLicense()                     {}
func (this DemLicense) GetDescription() *string   { return this.Description }
func (this DemLicense) GetExpirationDate() string { return this.ExpirationDate }
func (this DemLicense) GetID() *string            { return this.ID }
func (this DemLicense) GetLastUpdated() *string   { return this.LastUpdated }
func (this DemLicense) GetPlan() LicensePlan      { return this.Plan }
func (this DemLicense) GetSku() LicenseSku        { return this.Sku }
func (this DemLicense) GetStartDate() *string     { return this.StartDate }
func (this DemLicense) GetStatus() LicenseStatus  { return this.Status }

func (DemLicense) IsQuantifiableLicense() {}

func (this DemLicense) GetTotal() int64 { return this.Total }

type DeviceAttributeCatalogInput struct {
	Filter *StringFilterInput `json:"filter,omitempty"`
	Paging *PagingInput       `json:"paging,omitempty"`
	Sort   *SortOrderInput    `json:"sort,omitempty"`
}

type DeviceAttributeCatalogPayload struct {
	Items    []string  `json:"items"`
	PageInfo *PageInfo `json:"pageInfo"`
}

type DeviceAttributes struct {
	Category     []string `json:"category"`
	Manufacturer []string `json:"manufacturer"`
	Model        []string `json:"model"`
	Os           []string `json:"os"`
	OsVersion    []string `json:"osVersion"`
	Type         []string `json:"type"`
}

type DeviceAttributesCatalogQueries struct {
	Category     *DeviceAttributeCatalogPayload `json:"category"`
	Manufacturer *DeviceAttributeCatalogPayload `json:"manufacturer"`
	Model        *DeviceAttributeCatalogPayload `json:"model"`
	Os           *DeviceAttributeCatalogPayload `json:"os"`
	Type         *DeviceAttributeCatalogPayload `json:"type"`
}

type DeviceAttributesInput struct {
	Category     []string `json:"category"`
	Manufacturer []string `json:"manufacturer"`
	Model        []string `json:"model"`
	Os           []string `json:"os"`
	OsVersion    []string `json:"osVersion"`
	Type         []string `json:"type"`
}

type DeviceAttributesUpdateInput struct {
	Category     []string `json:"category,omitempty"`
	Manufacturer []string `json:"manufacturer,omitempty"`
	Model        []string `json:"model,omitempty"`
	Os           []string `json:"os,omitempty"`
	OsVersion    []string `json:"osVersion,omitempty"`
	Type         []string `json:"type,omitempty"`
}

// Filter input for device confidence level with equality and inclusion operators
type DeviceCategoryFilterInput struct {
	Eq  *DeviceCategory  `json:"eq,omitempty"`
	In  []DeviceCategory `json:"in,omitempty"`
	Neq *DeviceCategory  `json:"neq,omitempty"`
	Nin []DeviceCategory `json:"nin,omitempty"`
}

type DeviceConfidenceLevelFilterInput struct {
	Eq  *DeviceConfidenceLevel  `json:"eq,omitempty"`
	In  []DeviceConfidenceLevel `json:"in,omitempty"`
	Neq *DeviceConfidenceLevel  `json:"neq,omitempty"`
	Nin []DeviceConfidenceLevel `json:"nin,omitempty"`
}

type DeviceConnectionProfile struct {
	DestApps    []string `json:"destApps"`
	DestDomains []string `json:"destDomains"`
	DestHosts   []string `json:"destHosts"`
	Directions  []string `json:"directions"`
}

// Input for CSV export with optional filtering
type DeviceCSVExportInput struct {
	Filter []*DeviceV2FilterInput `json:"filter,omitempty"`
}

type DeviceHw struct {
	Manufacturer *string `json:"manufacturer,omitempty"`
	Model        *string `json:"model,omitempty"`
	Type         *string `json:"type,omitempty"`
}

type DeviceHwFilterInput struct {
	Manufacturer []*StringFilterInput `json:"manufacturer,omitempty"`
	Model        []*StringFilterInput `json:"model,omitempty"`
	Type         []*StringFilterInput `json:"type,omitempty"`
}

type DeviceHwSortOrderInput struct {
	Manufacturer *SortOrderInput `json:"manufacturer,omitempty"`
	Model        *SortOrderInput `json:"model,omitempty"`
	Type         *SortOrderInput `json:"type,omitempty"`
}

type DeviceNetwork struct {
	NetworkName *string `json:"networkName,omitempty"`
	Subnet      *string `json:"subnet,omitempty"`
}

type DeviceNetworkFilterInput struct {
	NetworkName []*StringFilterInput `json:"networkName,omitempty"`
	Subnet      []*StringFilterInput `json:"subnet,omitempty"`
}

type DeviceNetworkSortOrderInput struct {
	NetworkName *SortOrderInput `json:"networkName,omitempty"`
	Subnet      *SortOrderInput `json:"subnet,omitempty"`
}

type DeviceNic struct {
	MacAddress *string `json:"macAddress,omitempty"`
	Vendor     *string `json:"vendor,omitempty"`
}

type DeviceNicFilterInput struct {
	MacAddress []*MacAddressFilterInput `json:"macAddress,omitempty"`
	Vendor     []*StringFilterInput     `json:"vendor,omitempty"`
}

type DeviceNicSortOrderInput struct {
	MacAddress *SortOrderInput `json:"macAddress,omitempty"`
	Vendor     *SortOrderInput `json:"vendor,omitempty"`
}

type DeviceOs struct {
	Product *string `json:"product,omitempty"`
	Vendor  *string `json:"vendor,omitempty"`
	Version *string `json:"version,omitempty"`
}

type DeviceOsFilterInput struct {
	Product []*StringFilterInput `json:"product,omitempty"`
	Vendor  []*StringFilterInput `json:"vendor,omitempty"`
	Version []*StringFilterInput `json:"version,omitempty"`
}

type DeviceOsSortOrderInput struct {
	Product *SortOrderInput `json:"product,omitempty"`
	Vendor  *SortOrderInput `json:"vendor,omitempty"`
	Version *SortOrderInput `json:"version,omitempty"`
}

// A reference identifying the DeviceProfile object. ID: Unique DeviceProfile Identifier, Name: The DeviceProfile Name
type DeviceProfileRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (DeviceProfileRef) IsObjectRef()         {}
func (this DeviceProfileRef) GetID() string   { return this.ID }
func (this DeviceProfileRef) GetName() string { return this.Name }

type DeviceProfileRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

type DeviceSiteSortOrderInput struct {
	ID   *SortOrderInput `json:"id,omitempty"`
	Name *SortOrderInput `json:"name,omitempty"`
}

type DeviceSnapshot struct {
	Connected           *bool                 `json:"connected,omitempty"`
	ConnectedSince      *string               `json:"connectedSince,omitempty"`
	DeviceUptime        *int64                `json:"deviceUptime,omitempty"`
	HaRole              *string               `json:"haRole,omitempty"`
	ID                  *string               `json:"id,omitempty"`
	Identifier          *string               `json:"identifier,omitempty"`
	Interfaces          []*InterfaceSnapshot  `json:"interfaces,omitempty"`
	InterfacesLinkState []*InterfaceLinkState `json:"interfacesLinkState,omitempty"`
	InternalIP          *string               `json:"internalIP,omitempty"`
	LastConnected       *string               `json:"lastConnected,omitempty"`
	LastDuration        *int64                `json:"lastDuration,omitempty"`
	LastPopID           *int64                `json:"lastPopID,omitempty"`
	LastPopName         *string               `json:"lastPopName,omitempty"`
	MfaCreationTime     *int64                `json:"mfaCreationTime,omitempty"`
	MfaExpirationTime   *int64                `json:"mfaExpirationTime,omitempty"`
	Name                *string               `json:"name,omitempty"`
	OsType              *string               `json:"osType,omitempty"`
	OsVersion           *string               `json:"osVersion,omitempty"`
	RecentConnections   []*RecentConnection   `json:"recentConnections,omitempty"`
	ReleaseGroup        *string               `json:"releaseGroup,omitempty"`
	SocketInfo          *SocketInfo           `json:"socketInfo,omitempty"`
	Type                *string               `json:"type,omitempty"`
	Version             *string               `json:"version,omitempty"`
	VersionNumber       *int64                `json:"versionNumber,omitempty"`
}

// Input for sorting devices by various fields
type DeviceSortInput struct {
	Category   *SortOrderInput              `json:"category,omitempty"`
	Confidence *SortOrderInput              `json:"confidence,omitempty"`
	FirstSeen  *SortOrderInput              `json:"firstSeen,omitempty"`
	Hw         *DeviceHwSortOrderInput      `json:"hw,omitempty"`
	ID         *SortOrderInput              `json:"id,omitempty"`
	IP         *SortOrderInput              `json:"ip,omitempty"`
	LastSeen   *SortOrderInput              `json:"lastSeen,omitempty"`
	Name       *SortOrderInput              `json:"name,omitempty"`
	Network    *DeviceNetworkSortOrderInput `json:"network,omitempty"`
	Nic        *DeviceNicSortOrderInput     `json:"nic,omitempty"`
	Os         *DeviceOsSortOrderInput      `json:"os,omitempty"`
	RiskScore  *SortOrderInput              `json:"riskScore,omitempty"`
	Site       *DeviceSiteSortOrderInput    `json:"site,omitempty"`
	User       *DeviceUserSortOrderInput    `json:"user,omitempty"`
}

type DeviceUserSortOrderInput struct {
	ID   *SortOrderInput `json:"id,omitempty"`
	Name *SortOrderInput `json:"name,omitempty"`
}

type DeviceV2 struct {
	Category          *string                  `json:"category,omitempty"`
	ComplianceState   *string                  `json:"complianceState,omitempty"`
	Confidence        *DeviceConfidenceLevel   `json:"confidence,omitempty"`
	ConnectionProfile *DeviceConnectionProfile `json:"connectionProfile,omitempty"`
	FirstSeen         *string                  `json:"firstSeen,omitempty"`
	Hw                *DeviceHw                `json:"hw,omitempty"`
	ID                string                   `json:"id"`
	IP                *string                  `json:"ip,omitempty"`
	IPAddress         *string                  `json:"ipAddress,omitempty"`
	IsManaged         bool                     `json:"isManaged"`
	LastSeen          *string                  `json:"lastSeen,omitempty"`
	Name              *string                  `json:"name,omitempty"`
	Network           *DeviceNetwork           `json:"network,omitempty"`
	NetworkInfo       DeviceNetworkRef         `json:"networkInfo,omitempty"`
	Nic               *DeviceNic               `json:"nic,omitempty"`
	OriginTypes       []OriginType             `json:"originTypes"`
	Os                *DeviceOs                `json:"os,omitempty"`
	RiskScore         *int64                   `json:"riskScore,omitempty"`
	Site              *SiteRef                 `json:"site,omitempty"`
	User              *UserRef                 `json:"user,omitempty"`
}

// Input for filtering devices by various criteria
type DeviceV2FilterInput struct {
	Category        []*StringFilterInput                `json:"category,omitempty"`
	ComplianceState []*StringFilterInput                `json:"complianceState,omitempty"`
	Confidence      []*DeviceConfidenceLevelFilterInput `json:"confidence,omitempty"`
	FirstSeen       []*DateTimeFilterInput              `json:"firstSeen,omitempty"`
	Hw              *DeviceHwFilterInput                `json:"hw,omitempty"`
	ID              []*IDFilterInput                    `json:"id,omitempty"`
	IP              []*StringFilterInput                `json:"ip,omitempty"`
	IPAddress       []*IPAddressFilterInput             `json:"ipAddress,omitempty"`
	IsManaged       []*BooleanFilterInput               `json:"isManaged,omitempty"`
	LastSeen        []*DateTimeFilterInput              `json:"lastSeen,omitempty"`
	Name            []*StringFilterInput                `json:"name,omitempty"`
	Network         *DeviceNetworkFilterInput           `json:"network,omitempty"`
	Nic             *DeviceNicFilterInput               `json:"nic,omitempty"`
	OriginTypes     []*OriginTypeFilterInput            `json:"originTypes,omitempty"`
	Os              *DeviceOsFilterInput                `json:"os,omitempty"`
	RiskScore       []*IntFilterInput                   `json:"riskScore,omitempty"`
	Site            []*SiteRefFilterInput               `json:"site,omitempty"`
	User            []*UserRefFilterInput               `json:"user,omitempty"`
}

type DeviceV2Input struct {
	Filter []*DeviceV2FilterInput `json:"filter,omitempty"`
	Paging *PagingInput           `json:"paging"`
	Sort   *DeviceSortInput       `json:"sort"`
}

type DevicesPayload struct {
	Device []*DeviceV2 `json:"device"`
	Paging *PageInfo   `json:"paging"`
}

type DevicesQueries struct {
	AttributesCatalog *DeviceAttributesCatalogQueries `json:"attributesCatalog"`
	CSVExport         *ExportJobResponse              `json:"csvExport"`
	CSVExportStatus   *ExportStatusResponse           `json:"csvExportStatus"`
	List              *DevicesPayload                 `json:"list,omitempty"`
}

type Dimension struct {
	FieldName AppStatsFieldName `json:"fieldName"`
}

type DimensionData struct {
	Label string  `json:"label"`
	Value *string `json:"value,omitempty"`
}

type DimensionKey struct {
	FieldName string  `json:"fieldName"`
	Value     *string `json:"value,omitempty"`
}

type DisableAccountPayload struct {
	AccountInfo *AccountInfo `json:"accountInfo"`
}

type DlpContentProfileRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (DlpContentProfileRef) IsObjectRef()         {}
func (this DlpContentProfileRef) GetID() string   { return this.ID }
func (this DlpContentProfileRef) GetName() string { return this.Name }

type DlpContentProfileRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

type DlpEdmProfileRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (DlpEdmProfileRef) IsObjectRef()         {}
func (this DlpEdmProfileRef) GetID() string   { return this.ID }
func (this DlpEdmProfileRef) GetName() string { return this.Name }

type DlpEdmProfileRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

// Data Loss Prevention (DLP) Service license details
type DlpLicense struct {
	Description    *string       `json:"description,omitempty"`
	ExpirationDate string        `json:"expirationDate"`
	ID             *string       `json:"id,omitempty"`
	LastUpdated    *string       `json:"lastUpdated,omitempty"`
	Plan           LicensePlan   `json:"plan"`
	Sku            LicenseSku    `json:"sku"`
	StartDate      *string       `json:"startDate,omitempty"`
	Status         LicenseStatus `json:"status"`
}

func (DlpLicense) IsLicense()                     {}
func (this DlpLicense) GetDescription() *string   { return this.Description }
func (this DlpLicense) GetExpirationDate() string { return this.ExpirationDate }
func (this DlpLicense) GetID() *string            { return this.ID }
func (this DlpLicense) GetLastUpdated() *string   { return this.LastUpdated }
func (this DlpLicense) GetPlan() LicensePlan      { return this.Plan }
func (this DlpLicense) GetSku() LicenseSku        { return this.Sku }
func (this DlpLicense) GetStartDate() *string     { return this.StartDate }
func (this DlpLicense) GetStatus() LicenseStatus  { return this.Status }

// Input for searching FQDN typed container to download its content
type DownloadFqdnContainerFileInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

// Payload of download FQDN typed container file
type DownloadFqdnContainerFilePayload struct {
	EncodedFile string `json:"encodedFile"`
	ID          string `json:"id"`
	Name        string `json:"name"`
}

// Input for searching IPAddressRange typed container to download its content
type DownloadIPAddressRangeContainerFileInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

// Payload of download IPAddressRange typed container file
type DownloadIPAddressRangeContainerFilePayload struct {
	EncodedFile string `json:"encodedFile"`
	ID          string `json:"id"`
	Name        string `json:"name"`
}

type DynamicIPAllocationAddRuleDataInput struct {
	Country     []*CountryRefInput              `json:"country"`
	Description string                          `json:"description"`
	Enabled     bool                            `json:"enabled"`
	Name        string                          `json:"name"`
	Platform    []OperatingSystem               `json:"platform"`
	Range       *DynamicIPAllocationRangeInput  `json:"range"`
	Source      *DynamicIPAllocationSourceInput `json:"source"`
}

type DynamicIPAllocationAddRuleInput struct {
	At   *PolicyRulePositionInput             `json:"at,omitempty"`
	Rule *DynamicIPAllocationAddRuleDataInput `json:"rule"`
}

type DynamicIPAllocationPolicy struct {
	Audit    *PolicyAudit                      `json:"audit,omitempty"`
	Enabled  bool                              `json:"enabled"`
	Revision *PolicyRevision                   `json:"revision,omitempty"`
	Rules    []*DynamicIPAllocationRulePayload `json:"rules"`
	Sections []*PolicySectionPayload           `json:"sections"`
}

func (DynamicIPAllocationPolicy) IsIPolicy()                        {}
func (this DynamicIPAllocationPolicy) GetAudit() *PolicyAudit       { return this.Audit }
func (this DynamicIPAllocationPolicy) GetEnabled() bool             { return this.Enabled }
func (this DynamicIPAllocationPolicy) GetRevision() *PolicyRevision { return this.Revision }
func (this DynamicIPAllocationPolicy) GetRules() []IPolicyRulePayload {
	if this.Rules == nil {
		return nil
	}
	interfaceSlice := make([]IPolicyRulePayload, 0, len(this.Rules))
	for _, concrete := range this.Rules {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this DynamicIPAllocationPolicy) GetSections() []*PolicySectionPayload {
	if this.Sections == nil {
		return nil
	}
	interfaceSlice := make([]*PolicySectionPayload, 0, len(this.Sections))
	for _, concrete := range this.Sections {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

type DynamicIPAllocationPolicyInput struct {
	Revision *PolicyRevisionInput `json:"revision,omitempty"`
}

type DynamicIPAllocationPolicyMutationInput struct {
	Revision *PolicyMutationRevisionInput `json:"revision,omitempty"`
}

type DynamicIPAllocationPolicyMutationPayload struct {
	Errors []*PolicyMutationError     `json:"errors"`
	Policy *DynamicIPAllocationPolicy `json:"policy,omitempty"`
	Status PolicyMutationStatus       `json:"status"`
}

func (DynamicIPAllocationPolicyMutationPayload) IsIPolicyMutationPayload() {}
func (this DynamicIPAllocationPolicyMutationPayload) GetErrors() []*PolicyMutationError {
	if this.Errors == nil {
		return nil
	}
	interfaceSlice := make([]*PolicyMutationError, 0, len(this.Errors))
	for _, concrete := range this.Errors {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this DynamicIPAllocationPolicyMutationPayload) GetPolicy() IPolicy { return *this.Policy }
func (this DynamicIPAllocationPolicyMutationPayload) GetStatus() PolicyMutationStatus {
	return this.Status
}

type DynamicIPAllocationPolicyMutations struct {
	AddRule               *DynamicIPAllocationRuleMutationPayload   `json:"addRule"`
	AddSection            *PolicySectionMutationPayload             `json:"addSection"`
	CreatePolicyRevision  *DynamicIPAllocationPolicyMutationPayload `json:"createPolicyRevision"`
	DiscardPolicyRevision *DynamicIPAllocationPolicyMutationPayload `json:"discardPolicyRevision"`
	MoveRule              *DynamicIPAllocationRuleMutationPayload   `json:"moveRule"`
	MoveSection           *PolicySectionMutationPayload             `json:"moveSection"`
	PublishPolicyRevision *DynamicIPAllocationPolicyMutationPayload `json:"publishPolicyRevision"`
	RemoveRule            *DynamicIPAllocationRuleMutationPayload   `json:"removeRule"`
	RemoveSection         *PolicySectionMutationPayload             `json:"removeSection"`
	UpdatePolicy          *DynamicIPAllocationPolicyMutationPayload `json:"updatePolicy"`
	UpdateRule            *DynamicIPAllocationRuleMutationPayload   `json:"updateRule"`
	UpdateSection         *PolicySectionMutationPayload             `json:"updateSection"`
}

type DynamicIPAllocationPolicyQueries struct {
	Policy    *DynamicIPAllocationPolicy `json:"policy"`
	Revisions *PolicyRevisionsPayload    `json:"revisions,omitempty"`
}

type DynamicIPAllocationPolicyUpdateInput struct {
	State *PolicyToggleState `json:"state,omitempty"`
}

type DynamicIPAllocationRange struct {
	GlobalIPRange *GlobalIPRangeRef `json:"globalIpRange"`
}

type DynamicIPAllocationRangeInput struct {
	GlobalIPRange *GlobalIPRangeRefInput `json:"globalIpRange"`
}

type DynamicIPAllocationRangeUpdateInput struct {
	GlobalIPRange *GlobalIPRangeRefInput `json:"globalIpRange,omitempty"`
}

type DynamicIPAllocationRemoveRuleInput struct {
	ID string `json:"id"`
}

type DynamicIPAllocationRule struct {
	Country     []*CountryRef              `json:"country"`
	Description string                     `json:"description"`
	Enabled     bool                       `json:"enabled"`
	ID          string                     `json:"id"`
	Index       int64                      `json:"index"`
	Name        string                     `json:"name"`
	Platform    []OperatingSystem          `json:"platform"`
	Range       *DynamicIPAllocationRange  `json:"range"`
	Section     *PolicySectionInfo         `json:"section"`
	Source      *DynamicIPAllocationSource `json:"source"`
}

func (DynamicIPAllocationRule) IsIPolicyRule()                      {}
func (this DynamicIPAllocationRule) GetDescription() *string        { return &this.Description }
func (this DynamicIPAllocationRule) GetEnabled() bool               { return this.Enabled }
func (this DynamicIPAllocationRule) GetID() string                  { return this.ID }
func (this DynamicIPAllocationRule) GetIndex() int64                { return this.Index }
func (this DynamicIPAllocationRule) GetName() string                { return this.Name }
func (this DynamicIPAllocationRule) GetSection() *PolicySectionInfo { return this.Section }

type DynamicIPAllocationRuleMutationPayload struct {
	Errors []*PolicyMutationError          `json:"errors"`
	Rule   *DynamicIPAllocationRulePayload `json:"rule,omitempty"`
	Status PolicyMutationStatus            `json:"status"`
}

func (DynamicIPAllocationRuleMutationPayload) IsIPolicyRuleMutationPayload() {}
func (this DynamicIPAllocationRuleMutationPayload) GetErrors() []*PolicyMutationError {
	if this.Errors == nil {
		return nil
	}
	interfaceSlice := make([]*PolicyMutationError, 0, len(this.Errors))
	for _, concrete := range this.Errors {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this DynamicIPAllocationRuleMutationPayload) GetRule() IPolicyRulePayload { return *this.Rule }
func (this DynamicIPAllocationRuleMutationPayload) GetStatus() PolicyMutationStatus {
	return this.Status
}

type DynamicIPAllocationRulePayload struct {
	Audit      *PolicyElementAudit           `json:"audit"`
	Properties []PolicyElementPropertiesEnum `json:"properties"`
	Rule       *DynamicIPAllocationRule      `json:"rule"`
}

func (DynamicIPAllocationRulePayload) IsIPolicyRulePayload()              {}
func (this DynamicIPAllocationRulePayload) GetAudit() *PolicyElementAudit { return this.Audit }
func (this DynamicIPAllocationRulePayload) GetProperties() []PolicyElementPropertiesEnum {
	if this.Properties == nil {
		return nil
	}
	interfaceSlice := make([]PolicyElementPropertiesEnum, 0, len(this.Properties))
	for _, concrete := range this.Properties {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this DynamicIPAllocationRulePayload) GetRule() IPolicyRule { return *this.Rule }

type DynamicIPAllocationSource struct {
	User       []*UserRef       `json:"user"`
	UsersGroup []*UsersGroupRef `json:"usersGroup"`
}

type DynamicIPAllocationSourceInput struct {
	User       []*UserRefInput       `json:"user"`
	UsersGroup []*UsersGroupRefInput `json:"usersGroup"`
}

type DynamicIPAllocationSourceUpdateInput struct {
	User       []*UserRefInput       `json:"user,omitempty"`
	UsersGroup []*UsersGroupRefInput `json:"usersGroup,omitempty"`
}

type DynamicIPAllocationUpdateRuleDataInput struct {
	Country     []*CountryRefInput                    `json:"country,omitempty"`
	Description *string                               `json:"description,omitempty"`
	Enabled     *bool                                 `json:"enabled,omitempty"`
	Name        *string                               `json:"name,omitempty"`
	Platform    []OperatingSystem                     `json:"platform,omitempty"`
	Range       *DynamicIPAllocationRangeUpdateInput  `json:"range,omitempty"`
	Source      *DynamicIPAllocationSourceUpdateInput `json:"source,omitempty"`
}

type DynamicIPAllocationUpdateRuleInput struct {
	ID   string                                  `json:"id"`
	Rule *DynamicIPAllocationUpdateRuleDataInput `json:"rule"`
}

// End Point Protection (EPP) license details
type EndpointProtectionLicense struct {
	Description    *string       `json:"description,omitempty"`
	ExpirationDate string        `json:"expirationDate"`
	ID             *string       `json:"id,omitempty"`
	LastUpdated    *string       `json:"lastUpdated,omitempty"`
	Plan           LicensePlan   `json:"plan"`
	Sku            LicenseSku    `json:"sku"`
	StartDate      *string       `json:"startDate,omitempty"`
	Status         LicenseStatus `json:"status"`
	Total          int64         `json:"total"`
}

func (EndpointProtectionLicense) IsLicense()                     {}
func (this EndpointProtectionLicense) GetDescription() *string   { return this.Description }
func (this EndpointProtectionLicense) GetExpirationDate() string { return this.ExpirationDate }
func (this EndpointProtectionLicense) GetID() *string            { return this.ID }
func (this EndpointProtectionLicense) GetLastUpdated() *string   { return this.LastUpdated }
func (this EndpointProtectionLicense) GetPlan() LicensePlan      { return this.Plan }
func (this EndpointProtectionLicense) GetSku() LicenseSku        { return this.Sku }
func (this EndpointProtectionLicense) GetStartDate() *string     { return this.StartDate }
func (this EndpointProtectionLicense) GetStatus() LicenseStatus  { return this.Status }

func (EndpointProtectionLicense) IsQuantifiableLicense() {}

func (this EndpointProtectionLicense) GetTotal() int64 { return this.Total }

type EngineTypePredicate struct {
	In    []StoryEngineTypeEnum `json:"in,omitempty"`
	NotIn []StoryEngineTypeEnum `json:"not_in,omitempty"`
}

type EnterpriseDirectoryArchiveLocationPayload struct {
	Location *Location `json:"location"`
}

type EnterpriseDirectoryCreateLocationInput struct {
	BusinessUnit *string                     `json:"businessUnit,omitempty"`
	Description  *string                     `json:"description,omitempty"`
	Details      *CreateLocationDetailsInput `json:"details"`
	Name         string                      `json:"name"`
	Type         LocationType                `json:"type"`
}

type EnterpriseDirectoryCreateLocationPayload struct {
	Location *Location `json:"location"`
}

type EnterpriseDirectoryLocationListInput struct {
	Filter *LocationFilterInput `json:"filter,omitempty"`
	Paging *PagingInput         `json:"paging,omitempty"`
	Sort   *LocationSortInput   `json:"sort,omitempty"`
}

type EnterpriseDirectoryLocationListPayload struct {
	Items    []*Location `json:"items"`
	PageInfo *PageInfo   `json:"pageInfo,omitempty"`
}

type EnterpriseDirectoryMutations struct {
	ArchiveLocation *EnterpriseDirectoryArchiveLocationPayload `json:"archiveLocation,omitempty"`
	CreateLocation  *EnterpriseDirectoryCreateLocationPayload  `json:"createLocation,omitempty"`
	RestoreLocation *EnterpriseDirectoryRestoreLocationPayload `json:"restoreLocation,omitempty"`
	UpdateLocation  *EnterpriseDirectoryUpdateLocationPayload  `json:"updateLocation,omitempty"`
}

type EnterpriseDirectoryQueries struct {
	LocationList *EnterpriseDirectoryLocationListPayload `json:"locationList"`
}

type EnterpriseDirectoryRestoreLocationPayload struct {
	Location *Location `json:"location"`
}

type EnterpriseDirectoryUpdateLocationInput struct {
	BusinessUnit *string                     `json:"businessUnit,omitempty"`
	Description  *string                     `json:"description,omitempty"`
	Details      *UpdateLocationDetailsInput `json:"details,omitempty"`
	ID           string                      `json:"id"`
	Name         *string                     `json:"name,omitempty"`
	Type         *LocationType               `json:"type,omitempty"`
}

type EnterpriseDirectoryUpdateLocationPayload struct {
	Location *Location `json:"location"`
}

type Entity struct {
	ID   string     `json:"id"`
	Name *string    `json:"name,omitempty"`
	Type EntityType `json:"type"`
}

func (Entity) IsValue() {}

type EntityAccess struct {
	Action RBACAction `json:"action"`
}

type EntityInfo struct {
	Description  string         `json:"description"`
	Entity       *Entity        `json:"entity"`
	HelperFields map[string]any `json:"helperFields"`
}

type EntityInput struct {
	ID   string     `json:"id"`
	Name *string    `json:"name,omitempty"`
	Type EntityType `json:"type"`
}

type EntityLookupResult struct {
	Items []*EntityInfo `json:"items"`
	Total *int64        `json:"total,omitempty"`
}

type Event struct {
	Action                *string     `json:"action,omitempty"`
	AppID                 *string     `json:"appId,omitempty"`
	AppName               *string     `json:"appName,omitempty"`
	DNSProtectionCategory *string     `json:"dnsProtectionCategory,omitempty"`
	EventType             *string     `json:"eventType,omitempty"`
	RuleID                *string     `json:"ruleId,omitempty"`
	ScanResult            *ScanResult `json:"scanResult,omitempty"`
	Severity              *string     `json:"severity,omitempty"`
	SignatureID           *string     `json:"signatureId,omitempty"`
	ThreatName            *string     `json:"threatName,omitempty"`
	ThreatType            *string     `json:"threatType,omitempty"`
	VirusName             *string     `json:"virusName,omitempty"`
}

type EventFeedFieldFilterInput struct {
	FieldName EventFeedFilterFieldName `json:"fieldName"`
	Operator  EventFeedFilterOperator  `json:"operator"`
	Values    []string                 `json:"values,omitempty"`
}

type EventField struct {
	Name  EventFieldName `json:"name"`
	Value Value          `json:"value"`
}

type EventRecord struct {
	FieldsMap  map[string]any `json:"fieldsMap,omitempty"`
	FlatFields [][]string     `json:"flatFields,omitempty"`
	Time       *string        `json:"time,omitempty"`
}

type Events struct {
	From    *string         `json:"from,omitempty"`
	ID      *string         `json:"id,omitempty"`
	Records []*EventsRecord `json:"records,omitempty"`
	To      *string         `json:"to,omitempty"`
	Total   *int64          `json:"total,omitempty"`
	Totals  map[string]any  `json:"totals,omitempty"`
}

type EventsDimension struct {
	FieldName EventFieldName `json:"fieldName"`
}

type EventsFeedAccountRecords struct {
	ErrorString *string        `json:"errorString,omitempty"`
	ID          *string        `json:"id,omitempty"`
	Records     []*EventRecord `json:"records,omitempty"`
}

type EventsFeedData struct {
	Accounts     []*EventsFeedAccountRecords `json:"accounts,omitempty"`
	FetchedCount int64                       `json:"fetchedCount"`
	Marker       *string                     `json:"marker,omitempty"`
}

type EventsFilter struct {
	FieldName EventFieldName `json:"fieldName"`
	Operator  FilterOperator `json:"operator"`
	Values    []string       `json:"values"`
}

type EventsGraphQuery struct {
	TimeSeriesEvents *TimeSeriesEvents `json:"timeSeriesEvents,omitempty"`
	Type             GraphType         `json:"type"`
}

type EventsMeasure struct {
	AggType   AggregationType `json:"aggType"`
	FieldName EventFieldName  `json:"fieldName"`
	Trend     *bool           `json:"trend,omitempty"`
}

type EventsRecord struct {
	Fields          []*EventField  `json:"fields,omitempty"`
	FieldsMap       map[string]any `json:"fieldsMap,omitempty"`
	FieldsUnitTypes []UnitType     `json:"fieldsUnitTypes,omitempty"`
	FlatFields      [][]string     `json:"flatFields,omitempty"`
	PrevTimeFrame   map[string]any `json:"prevTimeFrame,omitempty"`
	Trends          map[string]any `json:"trends,omitempty"`
}

type EventsSort struct {
	FieldName EventFieldName `json:"fieldName"`
	Order     DirectionEnum  `json:"order"`
}

type EventsTimeSeries struct {
	From        *string       `json:"from,omitempty"`
	Granularity *int64        `json:"granularity,omitempty"`
	ID          *string       `json:"id,omitempty"`
	Timeseries  []*Timeseries `json:"timeseries,omitempty"`
	To          *string       `json:"to,omitempty"`
}

// Response returned when initiating a CSV export job
type ExportJobResponse struct {
	JobID   string  `json:"jobId"`
	Message *string `json:"message,omitempty"`
}

// Response containing the current status and details of an export job
type ExportStatusResponse struct {
	DownloadURL *string         `json:"downloadUrl,omitempty"`
	ExpiresAt   *string         `json:"expiresAt,omitempty"`
	JobID       string          `json:"jobId"`
	Message     *string         `json:"message,omitempty"`
	Progress    *float64        `json:"progress,omitempty"`
	Status      ExportJobStatus `json:"status"`
}

type Extra struct {
	Name  string `json:"name"`
	Type  string `json:"type"`
	Value string `json:"value"`
}

// FieldName for the different types of FieldName inputs
// Use the EventFieldName for events, and AuditFieldName for audit
type FieldNameInput struct {
	AuditFieldName *AuditFieldName `json:"AuditFieldName,omitempty"`
	EventFieldName *EventFieldName `json:"EventFieldName,omitempty"`
}

type FileDetails struct {
	Issuer    *string `json:"issuer,omitempty"`
	Md5       *string `json:"md5,omitempty"`
	Name      *string `json:"name,omitempty"`
	Path      *string `json:"path,omitempty"`
	Publisher *string `json:"publisher,omitempty"`
	Sha1      *string `json:"sha1,omitempty"`
	Sha256    *string `json:"sha256,omitempty"`
	Signer    *string `json:"signer,omitempty"`
	Size      *int64  `json:"size,omitempty"`
}

// Returns data for the Floating Subnet object. Floating Subnets (ie. Floating Ranges) are used to identify traffic exactly matched
// to the route advertised by BGP. They are not associated with a specific site.
// This is useful in scenarios such as active-standby high availability routed via BGP.
type FloatingSubnetRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (FloatingSubnetRef) IsObjectRef()         {}
func (this FloatingSubnetRef) GetID() string   { return this.ID }
func (this FloatingSubnetRef) GetName() string { return this.Name }

// Defines the Floating Subnet object. Floating Subnets (ie. Floating Ranges) are used to identify traffic exactly matched
// to the route advertised by BGP. They are not associated with a specific site.
// This is useful in scenarios such as active-standby high availability routed via BGP.
type FloatingSubnetRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

// A group with members of FQDN type
type FqdnContainer struct {
	Audit       *ContainerAudit `json:"audit"`
	Description *string         `json:"description,omitempty"`
	ID          string          `json:"id"`
	Name        string          `json:"name"`
	Size        int64           `json:"size"`
}

func (FqdnContainer) IsContainer()                   {}
func (this FqdnContainer) GetAudit() *ContainerAudit { return this.Audit }
func (this FqdnContainer) GetDescription() *string   { return this.Description }
func (this FqdnContainer) GetID() string             { return this.ID }
func (this FqdnContainer) GetName() string           { return this.Name }
func (this FqdnContainer) GetSize() int64            { return this.Size }

// Input for adding values to existing FQDN typed container
type FqdnContainerAddValuesInput struct {
	Ref    *ContainerRefInput `json:"ref"`
	Values []string           `json:"values"`
}

// Payload of AddValues operation on FQDN typed container
type FqdnContainerAddValuesPayload struct {
	Container *FqdnContainer `json:"container"`
}

type FqdnContainerMutations struct {
	AddValues      *FqdnContainerAddValuesPayload      `json:"addValues"`
	CreateFromFile *CreateFqdnContainerFromFilePayload `json:"createFromFile"`
	CreateFromList *CreateFqdnContainerFromListPayload `json:"createFromList"`
	RemoveValues   *FqdnContainerRemoveValuesPayload   `json:"removeValues"`
	UpdateFromFile *UpdateFqdnContainerFromFilePayload `json:"updateFromFile"`
	UpdateFromList *UpdateFqdnContainerFromListPayload `json:"updateFromList"`
}

type FqdnContainerQueries struct {
	DownloadFile *DownloadFqdnContainerFilePayload `json:"downloadFile"`
	Search       *FqdnContainerSearchPayload       `json:"search"`
	SearchFqdn   *FqdnContainerSearchFqdnPayload   `json:"searchFqdn"`
}

// A group with members of FQDN type
type FqdnContainerRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (FqdnContainerRef) IsObjectRef()         {}
func (this FqdnContainerRef) GetID() string   { return this.ID }
func (this FqdnContainerRef) GetName() string { return this.Name }

type FqdnContainerRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

// Input for removing values from existing FQDN typed container
type FqdnContainerRemoveValuesInput struct {
	Ref    *ContainerRefInput `json:"ref"`
	Values []string           `json:"values"`
}

// Payload of RemoveValues operation on FQDN typed container
type FqdnContainerRemoveValuesPayload struct {
	Container *FqdnContainer `json:"container"`
}

// Input for searching FQDN typed containers that contain a specific FQDN
type FqdnContainerSearchFqdnInput struct {
	Fqdn string `json:"fqdn"`
}

// Payload of FQDN search query
type FqdnContainerSearchFqdnPayload struct {
	Containers []*FqdnContainer `json:"containers"`
}

// Input for searching FQDN typed container
type FqdnContainerSearchInput struct {
	Ref *ContainerRefInput `json:"ref"`
}

// Payload of FQDN container search
type FqdnContainerSearchPayload struct {
	Container *FqdnContainer `json:"container"`
}

type FreeTextFilterInput struct {
	Search string `json:"search"`
}

type Gaussian struct {
	Avg    *float64 `json:"avg,omitempty"`
	N      *float64 `json:"n,omitempty"`
	Ss     *float64 `json:"ss,omitempty"`
	Std    *float64 `json:"std,omitempty"`
	ZScore *float64 `json:"z_score,omitempty"`
}

type GetAdminPayload struct {
	AdminType            AdminType    `json:"adminType"`
	CreationDate         string       `json:"creationDate"`
	Email                string       `json:"email"`
	FirstName            string       `json:"firstName"`
	ID                   string       `json:"id"`
	LastName             string       `json:"lastName"`
	ManagedRoles         []*AdminRole `json:"managedRoles,omitempty"`
	MfaEnabled           bool         `json:"mfaEnabled"`
	PasswordNeverExpires bool         `json:"passwordNeverExpires"`
	ResellerRoles        []*AdminRole `json:"resellerRoles,omitempty"`
}

type GetServicePrincipalAdminPayload struct {
	AdminType     AdminType    `json:"adminType"`
	CreationDate  string       `json:"creationDate"`
	Email         *string      `json:"email,omitempty"`
	ID            string       `json:"id"`
	ManagedRoles  []*AdminRole `json:"managedRoles,omitempty"`
	Name          string       `json:"name"`
	ResellerRoles []*AdminRole `json:"resellerRoles,omitempty"`
}

// A reference identifying the GlobalIpRange object. ID: Unique GlobalIpRange Identifier, Name: The GlobalIpRange Name
type GlobalIPRangeRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (GlobalIPRangeRef) IsObjectRef()         {}
func (this GlobalIPRangeRef) GetID() string   { return this.ID }
func (this GlobalIPRangeRef) GetName() string { return this.Name }

type GlobalIPRangeRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

// License usage and allocation across all accounts
type GlobalLicenseAllocations struct {
	PublicIps *PublicIpsLicenseAllocations `json:"publicIps,omitempty"`
	ZtnaUsers *ZtnaUsersLicenseAllocations `json:"ztnaUsers,omitempty"`
}

type GlobalRangeRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (GlobalRangeRef) IsDeviceNetworkRef() {}

func (GlobalRangeRef) IsObjectRef()         {}
func (this GlobalRangeRef) GetID() string   { return this.ID }
func (this GlobalRangeRef) GetName() string { return this.Name }

type GraphEventsDimension struct {
	FieldName string `json:"fieldName"`
}

type GraphEventsFilter struct {
	FieldName string   `json:"fieldName"`
	Operator  string   `json:"operator"`
	Values    []string `json:"values"`
}

type GraphEventsMeasure struct {
	AggType   string `json:"aggType"`
	FieldName string `json:"fieldName"`
	Trend     *bool  `json:"trend,omitempty"`
}

// A group is a collection of typed members (e.g., sites, hosts).
// Groups can include members of different types.
//
// When you update a group or use it in a policy, the system verifies that all members are allowed in the policy's scope.
// If a group is used in a policy that doesnt support certain member types, you can't add those types to the group.
// If a group already includes unsupported types, you can only assign it to a policy that supports those types.
// A member type is valid if it's supported in the group and allowed in the policy scope.
type Group struct {
	Audit               *AuditingMetadata        `json:"audit"`
	Description         *string                  `json:"description,omitempty"`
	ID                  string                   `json:"id"`
	Members             *GroupMembersListPayload `json:"members"`
	MembersCount        int64                    `json:"membersCount"`
	MembersCountPerType []*GroupMemberTypeCount  `json:"membersCountPerType"`
	Name                string                   `json:"name"`
}

// Apply filters when fetching the list of groups.
type GroupListFilterInput struct {
	Audit    []*AuditingMetadataFilterInput `json:"audit,omitempty"`
	FreeText *FreeTextFilterInput           `json:"freeText,omitempty"`
	ID       []*IDFilterInput               `json:"id,omitempty"`
	Member   []*GroupMemberFilterInput      `json:"member,omitempty"`
	Name     []*AdvancedStringFilterInput   `json:"name,omitempty"`
}

// List groups with optional filters, sorting, and pagination.
type GroupListInput struct {
	Filter []*GroupListFilterInput `json:"filter,omitempty"`
	Paging *PagingInput            `json:"paging"`
	Sort   *GroupListSortInput     `json:"sort"`
}

// A list of groups returned by the groupList query, with pagination info.
type GroupListPayload struct {
	Items  []*Group  `json:"items"`
	Paging *PageInfo `json:"paging"`
}

// Sort groups by name or audit metadata
type GroupListSortInput struct {
	Audit *AuditingMetadataSortInput `json:"audit,omitempty"`
	Name  *SortOrderInput            `json:"name,omitempty"`
}

// Filter groups by member reference.
type GroupMemberFilterInput struct {
	Ref *GroupMemberRefTypedInput `json:"ref"`
}

// Filter member types using the supported operators
type GroupMemberRefTypeFilterInput struct {
	Eq  *GroupMemberRefType  `json:"eq,omitempty"`
	In  []GroupMemberRefType `json:"in,omitempty"`
	Neq *GroupMemberRefType  `json:"neq,omitempty"`
	Nin []GroupMemberRefType `json:"nin,omitempty"`
}

// Reference to a group member, including its ID, name, and type.
// Used when listing or identifying members within a group.
type GroupMemberRefTyped struct {
	ID   string             `json:"id"`
	Name string             `json:"name"`
	Type GroupMemberRefType `json:"type"`
}

func (GroupMemberRefTyped) IsObjectRef()         {}
func (this GroupMemberRefTyped) GetID() string   { return this.ID }
func (this GroupMemberRefTyped) GetName() string { return this.Name }

// A reference to a group member, used when adding or filtering members.
type GroupMemberRefTypedInput struct {
	By    ObjectRefBy        `json:"by"`
	Input string             `json:"input"`
	Type  GroupMemberRefType `json:"type"`
}

// Counts how many members of each type the group contains.
type GroupMemberTypeCount struct {
	MembersCount int64              `json:"membersCount"`
	Type         GroupMemberRefType `json:"type"`
}

// Filters to narrow down group members that are fetched.
type GroupMembersListFilterInput struct {
	Name []*AdvancedStringFilterInput     `json:"name,omitempty"`
	Type []*GroupMemberRefTypeFilterInput `json:"type,omitempty"`
}

// Filter, sort, and pagination applied when fetching the the list of group members.
type GroupMembersListInput struct {
	Filter []*GroupMembersListFilterInput `json:"filter,omitempty"`
	Paging *PagingInput                   `json:"paging"`
	Sort   *GroupMembersListSortInput     `json:"sort"`
}

// A list of group members, pagination details, applied filters, and sorting information.
type GroupMembersListPayload struct {
	Items  []*GroupMemberRefTyped `json:"items"`
	Paging *PageInfo              `json:"paging"`
}

// Sort group members by one or more fields.
// If multiple fields are specified, the system uses their priority to determine order. For example, type with priority 1 will be used first, then name with priority 2.
type GroupMembersListSortInput struct {
	Name *SortOrderInput `json:"name,omitempty"`
	Type *SortOrderInput `json:"type,omitempty"`
}

// A reference identifying the Group object. ID: Unique Group Identifier, Name: The Group Name
type GroupRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (GroupRef) IsObjectRef()         {}
func (this GroupRef) GetID() string   { return this.ID }
func (this GroupRef) GetName() string { return this.Name }

type GroupRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

// The scope (context) in which a group is used or supported.
// Includes the policy type and the specific field name(s) where the group is used.
type GroupScope struct {
	Field []string `json:"field"`
	Type  string   `json:"type"`
}

// Describes where the group is used across policies and scopes.
//
// Includes a list of policy scopes where the group is applied,
// and identifies any member types that are not supported in those policy scopes.
type GroupWhereUsedPayload struct {
	InvalidMemberTypes []*InvalidGroupMemberTypeInScope `json:"invalidMemberTypes"`
	Usage              []*GroupScope                    `json:"usage"`
	Used               bool                             `json:"used"`
}

// Operations for managing groups
type GroupsMutations struct {
	CreateGroup *CreateGroupPayload `json:"createGroup,omitempty"`
	DeleteGroup *DeleteGroupPayload `json:"deleteGroup,omitempty"`
	UpdateGroup *UpdateGroupPayload `json:"updateGroup,omitempty"`
}

// Queries for reading groups-related information
type GroupsQueries struct {
	Group     *Group                 `json:"group,omitempty"`
	GroupList *GroupListPayload      `json:"groupList,omitempty"`
	WhereUsed *GroupWhereUsedPayload `json:"whereUsed,omitempty"`
}

// Basic Site Ha readiness information
type HaStatus struct {
	Keepalive       *HaSubStatus `json:"keepalive,omitempty"`
	Readiness       *HaReadiness `json:"readiness,omitempty"`
	SocketVersion   *HaSubStatus `json:"socketVersion,omitempty"`
	WanConnectivity *HaSubStatus `json:"wanConnectivity,omitempty"`
}

type Hardware struct {
	Account          *AccountRef         `json:"account,omitempty"`
	ID               string              `json:"id"`
	LastModified     *string             `json:"lastModified,omitempty"`
	LicenseID        *string             `json:"licenseId,omitempty"`
	LicenseStartDate *time.Time          `json:"licenseStartDate,omitempty"`
	LocationID       *string             `json:"locationId,omitempty"`
	MacAddress       *string             `json:"macAddress,omitempty"`
	Model            *string             `json:"model,omitempty"`
	PoNumber         *string             `json:"poNumber,omitempty"`
	ProductType      *string             `json:"productType,omitempty"`
	QuoteID          *string             `json:"quoteId,omitempty"`
	SerialNumber     *string             `json:"serialNumber,omitempty"`
	ShippingDetail   *ShippingDetails    `json:"shippingDetail,omitempty"`
	ShippingTracking *ShippingTracking   `json:"shippingTracking,omitempty"`
	SiteCountryName  *string             `json:"siteCountryName,omitempty"`
	Validation       *HardwareValidation `json:"validation,omitempty"`
}

type HardwareFilterInput struct {
	Account          []*AccountFilter             `json:"account,omitempty"`
	CountryCode      *StringFilterInput           `json:"countryCode,omitempty"`
	CountryName      []*StringFilterInput         `json:"countryName,omitempty"`
	FreeText         *FreeTextFilterInput         `json:"freeText,omitempty"`
	ID               []*IDFilterInput             `json:"id,omitempty"`
	LicenseStartDate []*DateTimeFilterInput       `json:"licenseStartDate,omitempty"`
	Product          []*StringFilterInput         `json:"product,omitempty"`
	SerialNumber     []*StringFilterInput         `json:"serialNumber,omitempty"`
	ShippingStatus   []*ShippingStatusFilterInput `json:"shippingStatus,omitempty"`
	ValidAddress     *BooleanFilterInput          `json:"validAddress,omitempty"`
}

type HardwareManagementQueries struct {
	SocketInventory *SocketInventoryPayload `json:"socketInventory"`
}

type HardwareMutations struct {
	UpdateHardwareShipping *HardwarePayload `json:"updateHardwareShipping,omitempty"`
}

type HardwarePayload struct {
	Items    []*Hardware `json:"items"`
	PageInfo *PageInfo   `json:"pageInfo,omitempty"`
}

type HardwareQueries struct {
	Hardware *HardwarePayload `json:"hardware,omitempty"`
}

type HardwareSearchInput struct {
	Filter *HardwareFilterInput `json:"filter,omitempty"`
	Paging *PagingInput         `json:"paging,omitempty"`
	Sort   *HardwareSortInput   `json:"sort,omitempty"`
}

type HardwareShippingDetailsInput struct {
	Details    *ShippingDetailsInput `json:"details"`
	PowerCable *string               `json:"powerCable,omitempty"`
}

type HardwareSortInput struct {
	AccountName      *SortOrderInput `json:"accountName,omitempty"`
	Country          *SortOrderInput `json:"country,omitempty"`
	Incoterms        *SortOrderInput `json:"incoterms,omitempty"`
	LicenseID        *SortOrderInput `json:"licenseId,omitempty"`
	LicenseStartDate *SortOrderInput `json:"licenseStartDate,omitempty"`
	ProductType      *SortOrderInput `json:"productType,omitempty"`
	QuoteID          *SortOrderInput `json:"quoteId,omitempty"`
	ShippingDate     *SortOrderInput `json:"shippingDate,omitempty"`
	ShippingStatus   *SortOrderInput `json:"shippingStatus,omitempty"`
	SiteName         *SortOrderInput `json:"siteName,omitempty"`
}

type HardwareValidation struct {
	AddressValidationStatus *AddressValidationStatus `json:"addressValidationStatus,omitempty"`
	Completed               bool                     `json:"completed"`
	IncompleteReason        *string                  `json:"incompleteReason,omitempty"`
}

// A reference identifying the Host object. ID: Unique Host Identifier, Name: The Host Name
type HostRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (HostRef) IsObjectRef()         {}
func (this HostRef) GetID() string   { return this.ID }
func (this HostRef) GetName() string { return this.Name }

type HostRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

type IPAddressFilterInput struct {
	Between []string `json:"between,omitempty"`
	Eq      *string  `json:"eq,omitempty"`
	In      []string `json:"in,omitempty"`
	Neq     *string  `json:"neq,omitempty"`
	Nin     []string `json:"nin,omitempty"`
	Nwithin *string  `json:"nwithin,omitempty"`
	Within  *string  `json:"within,omitempty"`
}

// A general structure to contain IP detailed information
type IPInfo struct {
	City        *string  `json:"city,omitempty"`
	CountryCode *string  `json:"countryCode,omitempty"`
	CountryName *string  `json:"countryName,omitempty"`
	IP          *string  `json:"ip,omitempty"`
	Latitude    *float64 `json:"latitude,omitempty"`
	Longitude   *float64 `json:"longitude,omitempty"`
	Provider    *string  `json:"provider,omitempty"`
	State       *string  `json:"state,omitempty"`
}

// Basic IPSec configuration information
type IPSecInfo struct {
	CatoIP       *string         `json:"catoIP,omitempty"`
	IkeVersion   *int64          `json:"ikeVersion,omitempty"`
	IsPrimary    *bool           `json:"isPrimary,omitempty"`
	RemoteIP     *string         `json:"remoteIP,omitempty"`
	TunnelConfig []*TunnelConfig `json:"tunnelConfig"`
}

type IDFilterInput struct {
	Eq  *string  `json:"eq,omitempty"`
	In  []string `json:"in,omitempty"`
	Neq *string  `json:"neq,omitempty"`
	Nin []string `json:"nin,omitempty"`
}

type IlmmContact struct {
	Email *string `json:"email,omitempty"`
	Name  *string `json:"name,omitempty"`
	Phone *string `json:"phone,omitempty"`
}

type IlmmDetails struct {
	Contacts    []*IlmmContact   `json:"contacts,omitempty"`
	IspDetails  *IlmmIspDetails  `json:"ispDetails,omitempty"`
	LinkDetails *IlmmLinkDetails `json:"linkDetails,omitempty"`
}

type IlmmIspDetails struct {
	CountryCode  *string     `json:"countryCode,omitempty"`
	Description  *string     `json:"description,omitempty"`
	IspAccountID *string     `json:"ispAccountId,omitempty"`
	LoaFile      *IspLoaFile `json:"loaFile,omitempty"`
	Name         *string     `json:"name,omitempty"`
	SupportEmail *string     `json:"supportEmail,omitempty"`
	SupportPhone *string     `json:"supportPhone,omitempty"`
}

// Intelligent Last Mile Monitoring (ILMM) License details
type IlmmLicense struct {
	Description    *string       `json:"description,omitempty"`
	ExpirationDate string        `json:"expirationDate"`
	ID             *string       `json:"id,omitempty"`
	LastUpdated    *string       `json:"lastUpdated,omitempty"`
	Plan           LicensePlan   `json:"plan"`
	Sku            LicenseSku    `json:"sku"`
	StartDate      *string       `json:"startDate,omitempty"`
	Status         LicenseStatus `json:"status"`
	Total          int64         `json:"total"`
}

func (IlmmLicense) IsLicense()                     {}
func (this IlmmLicense) GetDescription() *string   { return this.Description }
func (this IlmmLicense) GetExpirationDate() string { return this.ExpirationDate }
func (this IlmmLicense) GetID() *string            { return this.ID }
func (this IlmmLicense) GetLastUpdated() *string   { return this.LastUpdated }
func (this IlmmLicense) GetPlan() LicensePlan      { return this.Plan }
func (this IlmmLicense) GetSku() LicenseSku        { return this.Sku }
func (this IlmmLicense) GetStartDate() *string     { return this.StartDate }
func (this IlmmLicense) GetStatus() LicenseStatus  { return this.Status }

func (IlmmLicense) IsQuantifiableLicense() {}

func (this IlmmLicense) GetTotal() int64 { return this.Total }

type IlmmLinkDetails struct {
	ActiveLicense    *bool                 `json:"activeLicense,omitempty"`
	Comments         *string               `json:"comments,omitempty"`
	Description      *string               `json:"description,omitempty"`
	IspLinkID        *string               `json:"ispLinkId,omitempty"`
	LinkID           *string               `json:"linkId,omitempty"`
	OnboardingStatus *IlmmOnboardingStatus `json:"onboardingStatus,omitempty"`
}

type IncidentFlow struct {
	AppName                *string `json:"appName,omitempty"`
	ClientClass            *string `json:"clientClass,omitempty"`
	CreatedAt              *string `json:"createdAt,omitempty"`
	DestinationCountry     *string `json:"destinationCountry,omitempty"`
	DestinationGeolocation *string `json:"destinationGeolocation,omitempty"`
	DestinationIP          *string `json:"destinationIp,omitempty"`
	DestinationPort        *int64  `json:"destinationPort,omitempty"`
	Direction              *string `json:"direction,omitempty"`
	DNSResponseIP          *string `json:"dnsResponseIP,omitempty"`
	Domain                 *string `json:"domain,omitempty"`
	FileHash               *string `json:"fileHash,omitempty"`
	HTTPResponseCode       *int64  `json:"httpResponseCode,omitempty"`
	Ja3                    *string `json:"ja3,omitempty"`
	Method                 *string `json:"method,omitempty"`
	Referer                *string `json:"referer,omitempty"`
	SmbFileName            *string `json:"smbFileName,omitempty"`
	SourceGeolocation      *string `json:"sourceGeolocation,omitempty"`
	SourceIP               *string `json:"sourceIp,omitempty"`
	SourcePort             *int64  `json:"sourcePort,omitempty"`
	Target                 *string `json:"target,omitempty"`
	TunnelGeolocation      *string `json:"tunnelGeolocation,omitempty"`
	URL                    *string `json:"url,omitempty"`
	User                   *string `json:"user,omitempty"`
	UserAgent              *string `json:"userAgent,omitempty"`
}

type IncidentTargetRep struct {
	AnalysisScore         *float64    `json:"analysisScore,omitempty"`
	Categories            *string     `json:"categories,omitempty"`
	CatoPopularity        *int64      `json:"catoPopularity,omitempty"`
	CountryOfRegistration *string     `json:"countryOfRegistration,omitempty"`
	CreationTime          *string     `json:"creationTime,omitempty"`
	Engines               *int64      `json:"engines,omitempty"`
	EventData             []*Event    `json:"eventData"`
	InfectionSource       *bool       `json:"infectionSource,omitempty"`
	Name                  *string     `json:"name,omitempty"`
	SearchHits            *string     `json:"searchHits,omitempty"`
	ThreatFeeds           *int64      `json:"threatFeeds,omitempty"`
	ThreatReference       *string     `json:"threatReference,omitempty"`
	Type                  *TargetType `json:"type,omitempty"`
}

type IncidentTimeseries struct {
	Data    [][]float64    `json:"data,omitempty"`
	GroupBy *string        `json:"groupBy,omitempty"`
	Info    []string       `json:"info,omitempty"`
	Key     *TimeseriesKey `json:"key,omitempty"`
	Label   string         `json:"label"`
	Sum     *float64       `json:"sum,omitempty"`
	Units   *UnitType      `json:"units,omitempty"`
}

type IntFilterInput struct {
	Between []int64 `json:"between,omitempty"`
	Eq      *int64  `json:"eq,omitempty"`
	Gt      *int64  `json:"gt,omitempty"`
	Gte     *int64  `json:"gte,omitempty"`
	In      []int64 `json:"in,omitempty"`
	Lt      *int64  `json:"lt,omitempty"`
	Lte     *int64  `json:"lte,omitempty"`
	Neq     *int64  `json:"neq,omitempty"`
	Nin     []int64 `json:"nin,omitempty"`
}

type IntPredicate struct {
	Eq    *int64  `json:"eq,omitempty"`
	Gt    *int64  `json:"gt,omitempty"`
	Gte   *int64  `json:"gte,omitempty"`
	In    []int64 `json:"in,omitempty"`
	Lt    *int64  `json:"lt,omitempty"`
	Lte   *int64  `json:"lte,omitempty"`
	NotIn []int64 `json:"not_in,omitempty"`
}

// Basic Socket Interface configuration information
type InterfaceInfo struct {
	DestType                         *string                 `json:"destType,omitempty"`
	DownstreamBandwidth              *int64                  `json:"downstreamBandwidth,omitempty"`
	DownstreamBandwidthMbpsPrecision *float64                `json:"downstreamBandwidthMbpsPrecision,omitempty"`
	ID                               string                  `json:"id"`
	Name                             *string                 `json:"name,omitempty"`
	UpstreamBandwidth                *int64                  `json:"upstreamBandwidth,omitempty"`
	UpstreamBandwidthMbpsPrecision   *float64                `json:"upstreamBandwidthMbpsPrecision,omitempty"`
	WanRole                          *SocketInterfaceWanRole `json:"wanRole,omitempty"`
}

type InterfaceLinkState struct {
	Duplex      *string `json:"duplex,omitempty"`
	HasAddress  *bool   `json:"hasAddress,omitempty"`
	HasInternet *bool   `json:"hasInternet,omitempty"`
	HasTunnel   *bool   `json:"hasTunnel,omitempty"`
	ID          *string `json:"id,omitempty"`
	LinkSpeed   *string `json:"linkSpeed,omitempty"`
	MediaIn     *bool   `json:"mediaIn,omitempty"`
	Up          *bool   `json:"up,omitempty"`
}

type InterfaceMetrics struct {
	Annotations   []*TimeAnnotation `json:"annotations,omitempty"`
	InterfaceInfo *InterfaceInfo    `json:"interfaceInfo,omitempty"`
	IpsecInfo     *IPSecInfo        `json:"ipsecInfo,omitempty"`
	Metrics       *Metrics          `json:"metrics,omitempty"`
	Name          *string           `json:"name,omitempty"`
	Periods       []*TimePeriod     `json:"periods,omitempty"`
	RemoteIP      *string           `json:"remoteIP,omitempty"`
	RemoteIPInfo  *IPInfo           `json:"remoteIPInfo,omitempty"`
	SocketInfo    *SocketInfo       `json:"socketInfo,omitempty"`
	Timeseries    []*Timeseries     `json:"timeseries,omitempty"`
}

type InterfaceSnapshot struct {
	BgpState               *BgpState          `json:"bgpState,omitempty"`
	CellularInterfaceInfo  *CellularInterface `json:"cellularInterfaceInfo,omitempty"`
	Connected              *bool              `json:"connected,omitempty"`
	ID                     *string            `json:"id,omitempty"`
	Info                   *InterfaceInfo     `json:"info,omitempty"`
	Name                   *string            `json:"name,omitempty"`
	NaturalOrder           *int64             `json:"naturalOrder,omitempty"`
	PhysicalPort           *int64             `json:"physicalPort,omitempty"`
	PopName                *string            `json:"popName,omitempty"`
	PreviousPopID          *int64             `json:"previousPopID,omitempty"`
	PreviousPopName        *string            `json:"previousPopName,omitempty"`
	TunnelConnectionReason *string            `json:"tunnelConnectionReason,omitempty"`
	TunnelRemoteIP         *string            `json:"tunnelRemoteIP,omitempty"`
	TunnelRemoteIPInfo     *IPInfo            `json:"tunnelRemoteIPInfo,omitempty"`
	TunnelUptime           *int64             `json:"tunnelUptime,omitempty"`
	Type                   *string            `json:"type,omitempty"`
}

type InternetFirewallAddRuleDataInput struct {
	Action           InternetFirewallActionEnum            `json:"action"`
	ActivePeriod     *PolicyRuleActivePeriodInput          `json:"activePeriod"`
	ConnectionOrigin ConnectionOriginEnum                  `json:"connectionOrigin"`
	Country          []*CountryRefInput                    `json:"country"`
	Description      string                                `json:"description"`
	Destination      *InternetFirewallDestinationInput     `json:"destination"`
	Device           []*DeviceProfileRefInput              `json:"device"`
	DeviceAttributes *DeviceAttributesInput                `json:"deviceAttributes"`
	DeviceOs         []OperatingSystem                     `json:"deviceOS"`
	Enabled          bool                                  `json:"enabled"`
	Exceptions       []*InternetFirewallRuleExceptionInput `json:"exceptions"`
	Name             string                                `json:"name"`
	Schedule         *PolicyScheduleInput                  `json:"schedule"`
	Service          *InternetFirewallServiceTypeInput     `json:"service,omitempty"`
	Source           *InternetFirewallSourceInput          `json:"source"`
	Tracking         *PolicyTrackingInput                  `json:"tracking"`
}

// Rule parameters and relevant position
type InternetFirewallAddRuleInput struct {
	At   *PolicyRulePositionInput          `json:"at,omitempty"`
	Rule *InternetFirewallAddRuleDataInput `json:"rule"`
}

type InternetFirewallContainer struct {
	FqdnContainer           []*FqdnContainerRef           `json:"fqdnContainer"`
	IPAddressRangeContainer []*IPAddressRangeContainerRef `json:"ipAddressRangeContainer"`
}

type InternetFirewallContainerInput struct {
	FqdnContainer           []*FqdnContainerRefInput           `json:"fqdnContainer"`
	IPAddressRangeContainer []*IPAddressRangeContainerRefInput `json:"ipAddressRangeContainer"`
}

type InternetFirewallContainerUpdateInput struct {
	FqdnContainer           []*FqdnContainerRefInput           `json:"fqdnContainer,omitempty"`
	IPAddressRangeContainer []*IPAddressRangeContainerRefInput `json:"ipAddressRangeContainer,omitempty"`
}

// Returns the settings for Destination of an Internet Firewall rule
type InternetFirewallDestination struct {
	AppCategory            []*ApplicationCategoryRef    `json:"appCategory"`
	Application            []*ApplicationRef            `json:"application"`
	Containers             *InternetFirewallContainer   `json:"containers"`
	Country                []*CountryRef                `json:"country"`
	CustomApp              []*CustomApplicationRef      `json:"customApp"`
	CustomCategory         []*CustomCategoryRef         `json:"customCategory"`
	Domain                 []string                     `json:"domain"`
	Fqdn                   []string                     `json:"fqdn"`
	GlobalIPRange          []*GlobalIPRangeRef          `json:"globalIpRange"`
	IP                     []string                     `json:"ip"`
	IPRange                []*IPAddressRange            `json:"ipRange"`
	RemoteAsn              []scalars.Asn16              `json:"remoteAsn"`
	SanctionedAppsCategory []*SanctionedAppsCategoryRef `json:"sanctionedAppsCategory"`
	Subnet                 []string                     `json:"subnet"`
}

// Input of the settings for Destination of an Internet Firewall rule. To specify 'ANY' destination, an empty list must be provided for each match criteria field (e.g. application: [], country: [], etc...)
type InternetFirewallDestinationInput struct {
	AppCategory            []*ApplicationCategoryRefInput    `json:"appCategory"`
	Application            []*ApplicationRefInput            `json:"application"`
	Country                []*CountryRefInput                `json:"country"`
	CustomApp              []*CustomApplicationRefInput      `json:"customApp"`
	CustomCategory         []*CustomCategoryRefInput         `json:"customCategory"`
	Domain                 []string                          `json:"domain"`
	Fqdn                   []string                          `json:"fqdn"`
	GlobalIPRange          []*GlobalIPRangeRefInput          `json:"globalIpRange"`
	IP                     []string                          `json:"ip"`
	IPRange                []*IPAddressRangeInput            `json:"ipRange"`
	RemoteAsn              []scalars.Asn16                   `json:"remoteAsn"`
	SanctionedAppsCategory []*SanctionedAppsCategoryRefInput `json:"sanctionedAppsCategory"`
	Subnet                 []string                          `json:"subnet"`
}

// Input of the settings for Destination of an Internet Firewall rule. To specify 'ANY' destination, an empty list must be provided for each match criteria field (e.g. application: [], country: [], etc...)
type InternetFirewallDestinationUpdateInput struct {
	AppCategory            []*ApplicationCategoryRefInput    `json:"appCategory,omitempty"`
	Application            []*ApplicationRefInput            `json:"application,omitempty"`
	Country                []*CountryRefInput                `json:"country,omitempty"`
	CustomApp              []*CustomApplicationRefInput      `json:"customApp,omitempty"`
	CustomCategory         []*CustomCategoryRefInput         `json:"customCategory,omitempty"`
	Domain                 []string                          `json:"domain,omitempty"`
	Fqdn                   []string                          `json:"fqdn,omitempty"`
	GlobalIPRange          []*GlobalIPRangeRefInput          `json:"globalIpRange,omitempty"`
	IP                     []string                          `json:"ip,omitempty"`
	IPRange                []*IPAddressRangeInput            `json:"ipRange,omitempty"`
	RemoteAsn              []scalars.Asn16                   `json:"remoteAsn,omitempty"`
	SanctionedAppsCategory []*SanctionedAppsCategoryRefInput `json:"sanctionedAppsCategory,omitempty"`
	Subnet                 []string                          `json:"subnet,omitempty"`
}

type InternetFirewallPolicy struct {
	Audit    *PolicyAudit                   `json:"audit,omitempty"`
	Enabled  bool                           `json:"enabled"`
	Revision *PolicyRevision                `json:"revision,omitempty"`
	Rules    []*InternetFirewallRulePayload `json:"rules"`
	Sections []*PolicySectionPayload        `json:"sections"`
}

func (InternetFirewallPolicy) IsIPolicy()                        {}
func (this InternetFirewallPolicy) GetAudit() *PolicyAudit       { return this.Audit }
func (this InternetFirewallPolicy) GetEnabled() bool             { return this.Enabled }
func (this InternetFirewallPolicy) GetRevision() *PolicyRevision { return this.Revision }
func (this InternetFirewallPolicy) GetRules() []IPolicyRulePayload {
	if this.Rules == nil {
		return nil
	}
	interfaceSlice := make([]IPolicyRulePayload, 0, len(this.Rules))
	for _, concrete := range this.Rules {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this InternetFirewallPolicy) GetSections() []*PolicySectionPayload {
	if this.Sections == nil {
		return nil
	}
	interfaceSlice := make([]*PolicySectionPayload, 0, len(this.Sections))
	for _, concrete := range this.Sections {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

type InternetFirewallPolicyInput struct {
	Revision *PolicyRevisionInput `json:"revision,omitempty"`
}

type InternetFirewallPolicyMutationInput struct {
	Revision *PolicyMutationRevisionInput `json:"revision,omitempty"`
}

// Internet Firewall policy information provided in the API response
type InternetFirewallPolicyMutationPayload struct {
	Errors []*PolicyMutationError  `json:"errors"`
	Policy *InternetFirewallPolicy `json:"policy,omitempty"`
	Status PolicyMutationStatus    `json:"status"`
}

func (InternetFirewallPolicyMutationPayload) IsIPolicyMutationPayload() {}
func (this InternetFirewallPolicyMutationPayload) GetErrors() []*PolicyMutationError {
	if this.Errors == nil {
		return nil
	}
	interfaceSlice := make([]*PolicyMutationError, 0, len(this.Errors))
	for _, concrete := range this.Errors {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this InternetFirewallPolicyMutationPayload) GetPolicy() IPolicy { return *this.Policy }
func (this InternetFirewallPolicyMutationPayload) GetStatus() PolicyMutationStatus {
	return this.Status
}

// The Internet firewall Policy information returned to the caller in the API response.
type InternetFirewallPolicyMutations struct {
	AddRule               *InternetFirewallRuleMutationPayload   `json:"addRule"`
	AddSection            *PolicySectionMutationPayload          `json:"addSection"`
	CreatePolicyRevision  *InternetFirewallPolicyMutationPayload `json:"createPolicyRevision"`
	DiscardPolicyRevision *InternetFirewallPolicyMutationPayload `json:"discardPolicyRevision"`
	MoveRule              *InternetFirewallRuleMutationPayload   `json:"moveRule"`
	MoveSection           *PolicySectionMutationPayload          `json:"moveSection"`
	PublishPolicyRevision *InternetFirewallPolicyMutationPayload `json:"publishPolicyRevision"`
	RemoveRule            *InternetFirewallRuleMutationPayload   `json:"removeRule"`
	RemoveSection         *PolicySectionMutationPayload          `json:"removeSection"`
	UpdatePolicy          *InternetFirewallPolicyMutationPayload `json:"updatePolicy"`
	UpdateRule            *InternetFirewallRuleMutationPayload   `json:"updateRule"`
	UpdateSection         *PolicySectionMutationPayload          `json:"updateSection"`
}

type InternetFirewallPolicyQueries struct {
	Policy    *InternetFirewallPolicy `json:"policy"`
	Revisions *PolicyRevisionsPayload `json:"revisions,omitempty"`
}

type InternetFirewallPolicyUpdateInput struct {
	State *PolicyToggleState `json:"state,omitempty"`
}

type InternetFirewallRemoveRuleInput struct {
	ID string `json:"id"`
}

type InternetFirewallRule struct {
	Action           InternetFirewallActionEnum       `json:"action"`
	ActivePeriod     *PolicyRuleActivePeriod          `json:"activePeriod"`
	ConnectionOrigin ConnectionOriginEnum             `json:"connectionOrigin"`
	Country          []*CountryRef                    `json:"country"`
	Description      string                           `json:"description"`
	Destination      *InternetFirewallDestination     `json:"destination"`
	Device           []*DeviceProfileRef              `json:"device"`
	DeviceAttributes *DeviceAttributes                `json:"deviceAttributes"`
	DeviceOs         []OperatingSystem                `json:"deviceOS"`
	Enabled          bool                             `json:"enabled"`
	Exceptions       []*InternetFirewallRuleException `json:"exceptions"`
	ID               string                           `json:"id"`
	Index            int64                            `json:"index"`
	Name             string                           `json:"name"`
	Schedule         *PolicySchedule                  `json:"schedule"`
	Section          *PolicySectionInfo               `json:"section"`
	Service          *InternetFirewallServiceType     `json:"service"`
	Source           *InternetFirewallSource          `json:"source"`
	Tracking         *PolicyTracking                  `json:"tracking"`
}

func (InternetFirewallRule) IsIPolicyRule()                      {}
func (this InternetFirewallRule) GetDescription() *string        { return &this.Description }
func (this InternetFirewallRule) GetEnabled() bool               { return this.Enabled }
func (this InternetFirewallRule) GetID() string                  { return this.ID }
func (this InternetFirewallRule) GetIndex() int64                { return this.Index }
func (this InternetFirewallRule) GetName() string                { return this.Name }
func (this InternetFirewallRule) GetSection() *PolicySectionInfo { return this.Section }

// Exceptions define when a rule is ignored, and the firewall policy evaluation continues with the lower priority rules.
type InternetFirewallRuleException struct {
	ConnectionOrigin ConnectionOriginEnum         `json:"connectionOrigin"`
	Country          []*CountryRef                `json:"country"`
	Destination      *InternetFirewallDestination `json:"destination"`
	Device           []*DeviceProfileRef          `json:"device"`
	DeviceAttributes *DeviceAttributes            `json:"deviceAttributes"`
	DeviceOs         []OperatingSystem            `json:"deviceOS"`
	Name             string                       `json:"name"`
	Service          *InternetFirewallServiceType `json:"service"`
	Source           *InternetFirewallSource      `json:"source"`
}

// Exceptions define when a rule is ignored, and the firewall policy evaluation continues with the lower priority rules.
type InternetFirewallRuleExceptionInput struct {
	ConnectionOrigin ConnectionOriginEnum              `json:"connectionOrigin"`
	Country          []*CountryRefInput                `json:"country"`
	Destination      *InternetFirewallDestinationInput `json:"destination"`
	Device           []*DeviceProfileRefInput          `json:"device"`
	DeviceAttributes *DeviceAttributesInput            `json:"deviceAttributes"`
	DeviceOs         []OperatingSystem                 `json:"deviceOS"`
	Name             string                            `json:"name"`
	Service          *InternetFirewallServiceTypeInput `json:"service"`
	Source           *InternetFirewallSourceInput      `json:"source"`
}

type InternetFirewallRuleMutationPayload struct {
	Errors []*PolicyMutationError       `json:"errors"`
	Rule   *InternetFirewallRulePayload `json:"rule,omitempty"`
	Status PolicyMutationStatus         `json:"status"`
}

func (InternetFirewallRuleMutationPayload) IsIPolicyRuleMutationPayload() {}
func (this InternetFirewallRuleMutationPayload) GetErrors() []*PolicyMutationError {
	if this.Errors == nil {
		return nil
	}
	interfaceSlice := make([]*PolicyMutationError, 0, len(this.Errors))
	for _, concrete := range this.Errors {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this InternetFirewallRuleMutationPayload) GetRule() IPolicyRulePayload     { return *this.Rule }
func (this InternetFirewallRuleMutationPayload) GetStatus() PolicyMutationStatus { return this.Status }

// Internet Firewall policy information for a specific revision
type InternetFirewallRulePayload struct {
	Audit      *PolicyElementAudit           `json:"audit"`
	Properties []PolicyElementPropertiesEnum `json:"properties"`
	Rule       *InternetFirewallRule         `json:"rule"`
}

func (InternetFirewallRulePayload) IsIPolicyRulePayload()              {}
func (this InternetFirewallRulePayload) GetAudit() *PolicyElementAudit { return this.Audit }
func (this InternetFirewallRulePayload) GetProperties() []PolicyElementPropertiesEnum {
	if this.Properties == nil {
		return nil
	}
	interfaceSlice := make([]PolicyElementPropertiesEnum, 0, len(this.Properties))
	for _, concrete := range this.Properties {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this InternetFirewallRulePayload) GetRule() IPolicyRule { return *this.Rule }

// Returns the Service Type to which this Internet Firewall rule applies
type InternetFirewallServiceType struct {
	Custom   []*CustomService `json:"custom"`
	Standard []*ServiceRef    `json:"standard"`
}

// Input of the Service Type to which this Internet Firewall rule applies. To specify 'ANY' source, an empty list must be provided for each match criteria field (e.g. standard: [], custom: [], etc...)
type InternetFirewallServiceTypeInput struct {
	Custom   []*CustomServiceInput `json:"custom"`
	Standard []*ServiceRefInput    `json:"standard"`
}

// Input of the Service Type to which this Internet Firewall rule applies. To specify 'ANY' source, an empty list must be provided for each match criteria field (e.g. standard: [], custom: [], etc...)
type InternetFirewallServiceTypeUpdateInput struct {
	Custom   []*CustomServiceInput `json:"custom,omitempty"`
	Standard []*ServiceRefInput    `json:"standard,omitempty"`
}

// Returns the settings for Source of an Internet Firewall rule
type InternetFirewallSource struct {
	FloatingSubnet    []*FloatingSubnetRef    `json:"floatingSubnet"`
	GlobalIPRange     []*GlobalIPRangeRef     `json:"globalIpRange"`
	Group             []*GroupRef             `json:"group"`
	Host              []*HostRef              `json:"host"`
	IP                []string                `json:"ip"`
	IPRange           []*IPAddressRange       `json:"ipRange"`
	NetworkInterface  []*NetworkInterfaceRef  `json:"networkInterface"`
	Site              []*SiteRef              `json:"site"`
	SiteNetworkSubnet []*SiteNetworkSubnetRef `json:"siteNetworkSubnet"`
	Subnet            []string                `json:"subnet"`
	SystemGroup       []*SystemGroupRef       `json:"systemGroup"`
	User              []*UserRef              `json:"user"`
	UsersGroup        []*UsersGroupRef        `json:"usersGroup"`
}

// Input of the settings for Source of an Internet Firewall rule. To specify 'ANY' source, an empty list must be provided for each match criteria field (e.g. ip: [], group: [], etc...)
type InternetFirewallSourceInput struct {
	FloatingSubnet    []*FloatingSubnetRefInput    `json:"floatingSubnet"`
	GlobalIPRange     []*GlobalIPRangeRefInput     `json:"globalIpRange"`
	Group             []*GroupRefInput             `json:"group"`
	Host              []*HostRefInput              `json:"host"`
	IP                []string                     `json:"ip"`
	IPRange           []*IPAddressRangeInput       `json:"ipRange"`
	NetworkInterface  []*NetworkInterfaceRefInput  `json:"networkInterface"`
	Site              []*SiteRefInput              `json:"site"`
	SiteNetworkSubnet []*SiteNetworkSubnetRefInput `json:"siteNetworkSubnet"`
	Subnet            []string                     `json:"subnet"`
	SystemGroup       []*SystemGroupRefInput       `json:"systemGroup"`
	User              []*UserRefInput              `json:"user"`
	UsersGroup        []*UsersGroupRefInput        `json:"usersGroup"`
}

// Input of the settings for Source of an Internet Firewall rule. To specify 'ANY' source, an empty list must be provided for each match criteria field (e.g. ip: [], group: [], etc...)
type InternetFirewallSourceUpdateInput struct {
	FloatingSubnet    []*FloatingSubnetRefInput    `json:"floatingSubnet,omitempty"`
	GlobalIPRange     []*GlobalIPRangeRefInput     `json:"globalIpRange,omitempty"`
	Group             []*GroupRefInput             `json:"group,omitempty"`
	Host              []*HostRefInput              `json:"host,omitempty"`
	IP                []string                     `json:"ip,omitempty"`
	IPRange           []*IPAddressRangeInput       `json:"ipRange,omitempty"`
	NetworkInterface  []*NetworkInterfaceRefInput  `json:"networkInterface,omitempty"`
	Site              []*SiteRefInput              `json:"site,omitempty"`
	SiteNetworkSubnet []*SiteNetworkSubnetRefInput `json:"siteNetworkSubnet,omitempty"`
	Subnet            []string                     `json:"subnet,omitempty"`
	SystemGroup       []*SystemGroupRefInput       `json:"systemGroup,omitempty"`
	User              []*UserRefInput              `json:"user,omitempty"`
	UsersGroup        []*UsersGroupRefInput        `json:"usersGroup,omitempty"`
}

type InternetFirewallUpdateRuleDataInput struct {
	Action           *InternetFirewallActionEnum             `json:"action,omitempty"`
	ActivePeriod     *PolicyRuleActivePeriodUpdateInput      `json:"activePeriod,omitempty"`
	ConnectionOrigin *ConnectionOriginEnum                   `json:"connectionOrigin,omitempty"`
	Country          []*CountryRefInput                      `json:"country,omitempty"`
	Description      *string                                 `json:"description,omitempty"`
	Destination      *InternetFirewallDestinationUpdateInput `json:"destination,omitempty"`
	Device           []*DeviceProfileRefInput                `json:"device,omitempty"`
	DeviceAttributes *DeviceAttributesUpdateInput            `json:"deviceAttributes,omitempty"`
	DeviceOs         []OperatingSystem                       `json:"deviceOS,omitempty"`
	Enabled          *bool                                   `json:"enabled,omitempty"`
	Exceptions       []*InternetFirewallRuleExceptionInput   `json:"exceptions,omitempty"`
	Name             *string                                 `json:"name,omitempty"`
	Schedule         *PolicyScheduleUpdateInput              `json:"schedule,omitempty"`
	Service          *InternetFirewallServiceTypeUpdateInput `json:"service,omitempty"`
	Source           *InternetFirewallSourceUpdateInput      `json:"source,omitempty"`
	Tracking         *PolicyTrackingUpdateInput              `json:"tracking,omitempty"`
}

type InternetFirewallUpdateRuleInput struct {
	ID   string                               `json:"id"`
	Rule *InternetFirewallUpdateRuleDataInput `json:"rule"`
}

// Represents a member type in the group that is not supported in one or more scopes.
// Each scope indicates where the member type is not allowed.
type InvalidGroupMemberTypeInScope struct {
	Scope []*GroupScope      `json:"scope"`
	Type  GroupMemberRefType `json:"type"`
}

// IoT/OT Security service license details
type IotOtLicense struct {
	Description    *string       `json:"description,omitempty"`
	ExpirationDate string        `json:"expirationDate"`
	ID             *string       `json:"id,omitempty"`
	LastUpdated    *string       `json:"lastUpdated,omitempty"`
	Plan           LicensePlan   `json:"plan"`
	Sku            LicenseSku    `json:"sku"`
	StartDate      *string       `json:"startDate,omitempty"`
	Status         LicenseStatus `json:"status"`
}

func (IotOtLicense) IsLicense()                     {}
func (this IotOtLicense) GetDescription() *string   { return this.Description }
func (this IotOtLicense) GetExpirationDate() string { return this.ExpirationDate }
func (this IotOtLicense) GetID() *string            { return this.ID }
func (this IotOtLicense) GetLastUpdated() *string   { return this.LastUpdated }
func (this IotOtLicense) GetPlan() LicensePlan      { return this.Plan }
func (this IotOtLicense) GetSku() LicenseSku        { return this.Sku }
func (this IotOtLicense) GetStartDate() *string     { return this.StartDate }
func (this IotOtLicense) GetStatus() LicenseStatus  { return this.Status }

// Inclusive range of IPs
type IPAddressRange struct {
	From string `json:"from"`
	To   string `json:"to"`
}

// A group with members of IPAddressRange type
type IPAddressRangeContainer struct {
	Audit       *ContainerAudit `json:"audit"`
	Description *string         `json:"description,omitempty"`
	ID          string          `json:"id"`
	Name        string          `json:"name"`
	Size        int64           `json:"size"`
}

func (IPAddressRangeContainer) IsContainer()                   {}
func (this IPAddressRangeContainer) GetAudit() *ContainerAudit { return this.Audit }
func (this IPAddressRangeContainer) GetDescription() *string   { return this.Description }
func (this IPAddressRangeContainer) GetID() string             { return this.ID }
func (this IPAddressRangeContainer) GetName() string           { return this.Name }
func (this IPAddressRangeContainer) GetSize() int64            { return this.Size }

// Input for adding values to existing IPAddressRange typed container
type IPAddressRangeContainerAddValuesInput struct {
	Ref    *ContainerRefInput     `json:"ref"`
	Values []*IPAddressRangeInput `json:"values"`
}

// Payload of AddValues operation on IPAddressRange typed container
type IPAddressRangeContainerAddValuesPayload struct {
	Container *IPAddressRangeContainer `json:"container"`
}

type IPAddressRangeContainerMutations struct {
	AddValues      *IPAddressRangeContainerAddValuesPayload      `json:"addValues"`
	CreateFromFile *CreateIPAddressRangeContainerFromFilePayload `json:"createFromFile"`
	CreateFromList *CreateIPAddressRangeContainerFromListPayload `json:"createFromList"`
	RemoveValues   *IPAddressRangeContainerRemoveValuesPayload   `json:"removeValues"`
	UpdateFromFile *UpdateIPAddressRangeContainerFromFilePayload `json:"updateFromFile"`
	UpdateFromList *UpdateIPAddressRangeContainerFromListPayload `json:"updateFromList"`
}

type IPAddressRangeContainerQueries struct {
	DownloadFile         *DownloadIPAddressRangeContainerFilePayload         `json:"downloadFile"`
	Search               *IPAddressRangeContainerSearchPayload               `json:"search"`
	SearchIPAddressRange *IPAddressRangeContainerSearchIPAddressRangePayload `json:"searchIpAddressRange"`
}

// A group with members of IPAddressRange type
type IPAddressRangeContainerRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (IPAddressRangeContainerRef) IsObjectRef()         {}
func (this IPAddressRangeContainerRef) GetID() string   { return this.ID }
func (this IPAddressRangeContainerRef) GetName() string { return this.Name }

type IPAddressRangeContainerRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

// Input for removing values from existing IPAddressRange typed container
type IPAddressRangeContainerRemoveValuesInput struct {
	Ref    *ContainerRefInput     `json:"ref"`
	Values []*IPAddressRangeInput `json:"values"`
}

// Payload of AddValues operation on IPAddressRange typed container
type IPAddressRangeContainerRemoveValuesPayload struct {
	Container *IPAddressRangeContainer `json:"container"`
}

// Filtering input to IPAddressRange container search
type IPAddressRangeContainerSearchInput struct {
	Ref *ContainerRefInput `json:"ref"`
}

// Input for searching IPAddressRange typed containers that contain a specific IPAddressRange
type IPAddressRangeContainerSearchIPAddressRangeInput struct {
	IPAddressRange *IPAddressRangeInput `json:"ipAddressRange"`
}

// Payload of IPAddressRange search query
type IPAddressRangeContainerSearchIPAddressRangePayload struct {
	Containers []*IPAddressRangeContainer `json:"containers"`
}

// Payload of IPAddressRange container search
type IPAddressRangeContainerSearchPayload struct {
	Container *IPAddressRangeContainer `json:"container"`
}

// Inclusive range of IPs
type IPAddressRangeInput struct {
	From string `json:"from"`
	To   string `json:"to"`
}

// Intrusion Prevention System (IPS) service license (Legacy license, replaced by TP)
type IpsLicense struct {
	Description    *string       `json:"description,omitempty"`
	ExpirationDate string        `json:"expirationDate"`
	ID             *string       `json:"id,omitempty"`
	LastUpdated    *string       `json:"lastUpdated,omitempty"`
	Plan           LicensePlan   `json:"plan"`
	Sku            LicenseSku    `json:"sku"`
	StartDate      *string       `json:"startDate,omitempty"`
	Status         LicenseStatus `json:"status"`
}

func (IpsLicense) IsLicense()                     {}
func (this IpsLicense) GetDescription() *string   { return this.Description }
func (this IpsLicense) GetExpirationDate() string { return this.ExpirationDate }
func (this IpsLicense) GetID() *string            { return this.ID }
func (this IpsLicense) GetLastUpdated() *string   { return this.LastUpdated }
func (this IpsLicense) GetPlan() LicensePlan      { return this.Plan }
func (this IpsLicense) GetSku() LicenseSku        { return this.Sku }
func (this IpsLicense) GetStartDate() *string     { return this.StartDate }
func (this IpsLicense) GetStatus() LicenseStatus  { return this.Status }

type IpsecIkeV2MessageInput struct {
	Cipher    *IPSecCipher  `json:"cipher,omitempty"`
	DhGroup   *IPSecDHGroup `json:"dhGroup,omitempty"`
	Integrity *IPSecHash    `json:"integrity,omitempty"`
	Prf       *IPSecHash    `json:"prf,omitempty"`
}

type IspLoaFile struct {
	FileHash   *string       `json:"fileHash,omitempty"`
	FileName   *string       `json:"fileName,omitempty"`
	UploadedAt *scalars.Time `json:"uploadedAt,omitempty"`
}

type LastMileBwInput struct {
	Downstream              *int64   `json:"downstream,omitempty"`
	DownstreamMbpsPrecision *float64 `json:"downstreamMbpsPrecision,omitempty"`
	Upstream                *int64   `json:"upstream,omitempty"`
	UpstreamMbpsPrecision   *float64 `json:"upstreamMbpsPrecision,omitempty"`
}

// Public license API
type LicensingInfo struct {
	Atp                      []*AtpLicense                      `json:"atp"`
	Casb                     []*CasbLicense                     `json:"casb"`
	DataLake                 []*DataLakeLicense                 `json:"dataLake"`
	Dem                      []*DemLicense                      `json:"dem"`
	Dlp                      []*DlpLicense                      `json:"dlp"`
	EndpointProtection       []*EndpointProtectionLicense       `json:"endpointProtection"`
	GlobalLicenseAllocations *GlobalLicenseAllocations          `json:"globalLicenseAllocations"`
	Ilmm                     []*IlmmLicense                     `json:"ilmm"`
	IotOt                    []*IotOtLicense                    `json:"iotOt"`
	Ips                      []*IpsLicense                      `json:"ips"`
	Licenses                 []License                          `json:"licenses"`
	MalwareProtection        []*MalwareProtectionLicense        `json:"malwareProtection"`
	ManagedXdr               []*ManagedXdrLicense               `json:"managedXdr"`
	Mdr                      []*MdrLicense                      `json:"mdr"`
	NextGenMalwareProtection []*NextGenMalwareProtectionLicense `json:"nextGenMalwareProtection"`
	Nocaas                   []*NOCaaSLicense                   `json:"nocaas"`
	PooledBandwidth          []*PooledBandwidthLicense          `json:"pooledBandwidth"`
	PublicIps                []*PublicIpsLicense                `json:"publicIps"`
	Rbi                      []*RbiLicense                      `json:"rbi"`
	SaasSecurityAPI          []*SaasSecurityAPILicense          `json:"saasSecurityApi"`
	Site                     []*SiteLicense                     `json:"site"`
	ThreatPrevention         []*ThreatPreventionLicense         `json:"threatPrevention"`
	XOps                     []*XOpsLicense                     `json:"xOps"`
	XdrPro                   []*XdrProLicense                   `json:"xdrPro"`
	ZtnaUsers                []*ZtnaUsersLicense                `json:"ztnaUsers"`
}

type LicensingMutations struct {
	UpdateCommercialLicense *UpdateCommercialLicensePayload `json:"updateCommercialLicense,omitempty"`
}

type LicensingQueries struct {
	LicensingInfo *LicensingInfo `json:"licensingInfo,omitempty"`
}

type LinkQualityIssue struct {
	Current   *int64                    `json:"current,omitempty"`
	Direction *TrafficDirectionEnum     `json:"direction,omitempty"`
	IssueType *LinkQualityIssueTypeEnum `json:"issueType,omitempty"`
	Threshold *int64                    `json:"threshold,omitempty"`
}

type Location struct {
	Account      *AccountRef       `json:"account"`
	Archived     bool              `json:"archived"`
	Audit        *AuditingMetadata `json:"audit"`
	BusinessUnit *string           `json:"businessUnit,omitempty"`
	Description  *string           `json:"description,omitempty"`
	Details      *LocationDetails  `json:"details"`
	ID           string            `json:"id"`
	Name         string            `json:"name"`
	Type         LocationType      `json:"type"`
}

type LocationDetails struct {
	CompanyName      *string         `json:"companyName,omitempty"`
	Contact          *ContactDetails `json:"contact,omitempty"`
	PostalAddress    *PostalAddress  `json:"postalAddress"`
	ShippingLocation bool            `json:"shippingLocation"`
	VatID            *string         `json:"vatId,omitempty"`
}

type LocationFilterInput struct {
	Account            []*AccountFilter           `json:"account,omitempty"`
	CountryCode        []*StringFilterInput       `json:"countryCode,omitempty"`
	FreeText           *FreeTextFilterInput       `json:"freeText,omitempty"`
	ID                 []*IDFilterInput           `json:"id,omitempty"`
	IncludeArchived    *bool                      `json:"includeArchived,omitempty"`
	IsShippingLocation *bool                      `json:"isShippingLocation,omitempty"`
	Name               []*StringFilterInput       `json:"name,omitempty"`
	Type               []*LocationTypeFilterInput `json:"type,omitempty"`
}

type LocationSortInput struct {
	Country *SortOrderInput `json:"country,omitempty"`
	Name    *SortOrderInput `json:"name,omitempty"`
	Type    *SortOrderInput `json:"type,omitempty"`
}

type LocationTypeFilterInput struct {
	Eq  *LocationType  `json:"eq,omitempty"`
	In  []LocationType `json:"in,omitempty"`
	Neq *LocationType  `json:"neq,omitempty"`
	Nin []LocationType `json:"nin,omitempty"`
}

type LookupFilterInput struct {
	Filter *LookupFilterType `json:"filter,omitempty"`
	Value  *string           `json:"value,omitempty"`
}

type MacAddressFilterInput struct {
	Eq  *string  `json:"eq,omitempty"`
	In  []string `json:"in,omitempty"`
	Neq *string  `json:"neq,omitempty"`
	Nin []string `json:"nin,omitempty"`
}

// Anti-Malware service license details (Legacy license, replaced by TP)
type MalwareProtectionLicense struct {
	Description    *string       `json:"description,omitempty"`
	ExpirationDate string        `json:"expirationDate"`
	ID             *string       `json:"id,omitempty"`
	LastUpdated    *string       `json:"lastUpdated,omitempty"`
	Plan           LicensePlan   `json:"plan"`
	Sku            LicenseSku    `json:"sku"`
	StartDate      *string       `json:"startDate,omitempty"`
	Status         LicenseStatus `json:"status"`
}

func (MalwareProtectionLicense) IsLicense()                     {}
func (this MalwareProtectionLicense) GetDescription() *string   { return this.Description }
func (this MalwareProtectionLicense) GetExpirationDate() string { return this.ExpirationDate }
func (this MalwareProtectionLicense) GetID() *string            { return this.ID }
func (this MalwareProtectionLicense) GetLastUpdated() *string   { return this.LastUpdated }
func (this MalwareProtectionLicense) GetPlan() LicensePlan      { return this.Plan }
func (this MalwareProtectionLicense) GetSku() LicenseSku        { return this.Sku }
func (this MalwareProtectionLicense) GetStartDate() *string     { return this.StartDate }
func (this MalwareProtectionLicense) GetStatus() LicenseStatus  { return this.Status }

// Managed XDR service license details
type ManagedXdrLicense struct {
	Description    *string       `json:"description,omitempty"`
	ExpirationDate string        `json:"expirationDate"`
	ID             *string       `json:"id,omitempty"`
	LastUpdated    *string       `json:"lastUpdated,omitempty"`
	Plan           LicensePlan   `json:"plan"`
	Sku            LicenseSku    `json:"sku"`
	StartDate      *string       `json:"startDate,omitempty"`
	Status         LicenseStatus `json:"status"`
}

func (ManagedXdrLicense) IsLicense()                     {}
func (this ManagedXdrLicense) GetDescription() *string   { return this.Description }
func (this ManagedXdrLicense) GetExpirationDate() string { return this.ExpirationDate }
func (this ManagedXdrLicense) GetID() *string            { return this.ID }
func (this ManagedXdrLicense) GetLastUpdated() *string   { return this.LastUpdated }
func (this ManagedXdrLicense) GetPlan() LicensePlan      { return this.Plan }
func (this ManagedXdrLicense) GetSku() LicenseSku        { return this.Sku }
func (this ManagedXdrLicense) GetStartDate() *string     { return this.StartDate }
func (this ManagedXdrLicense) GetStatus() LicenseStatus  { return this.Status }

// MDR service license details
type MdrLicense struct {
	Description    *string       `json:"description,omitempty"`
	ExpirationDate string        `json:"expirationDate"`
	ID             *string       `json:"id,omitempty"`
	LastUpdated    *string       `json:"lastUpdated,omitempty"`
	Plan           LicensePlan   `json:"plan"`
	Sku            LicenseSku    `json:"sku"`
	StartDate      *string       `json:"startDate,omitempty"`
	Status         LicenseStatus `json:"status"`
}

func (MdrLicense) IsLicense()                     {}
func (this MdrLicense) GetDescription() *string   { return this.Description }
func (this MdrLicense) GetExpirationDate() string { return this.ExpirationDate }
func (this MdrLicense) GetID() *string            { return this.ID }
func (this MdrLicense) GetLastUpdated() *string   { return this.LastUpdated }
func (this MdrLicense) GetPlan() LicensePlan      { return this.Plan }
func (this MdrLicense) GetSku() LicenseSku        { return this.Sku }
func (this MdrLicense) GetStartDate() *string     { return this.StartDate }
func (this MdrLicense) GetStatus() LicenseStatus  { return this.Status }

type Measure struct {
	AggType   AggregationType   `json:"aggType"`
	FieldName AppStatsFieldName `json:"fieldName"`
	Trend     *bool             `json:"trend,omitempty"`
}

type Metric struct {
	Name  string  `json:"name"`
	Value float64 `json:"value"`
}

type MetricDetails struct {
	Name  string `json:"name"`
	Units string `json:"units"`
}

type Metrics struct {
	BytesDownstream            *float64 `json:"bytesDownstream,omitempty"`
	BytesTotal                 *float64 `json:"bytesTotal,omitempty"`
	BytesUpstream              *float64 `json:"bytesUpstream,omitempty"`
	Duration                   *int64   `json:"duration,omitempty"`
	FlowCount                  *float64 `json:"flowCount,omitempty"`
	Granularity                *int64   `json:"granularity,omitempty"`
	HostCount                  *float64 `json:"hostCount,omitempty"`
	HostLimit                  *float64 `json:"hostLimit,omitempty"`
	JitterDownstream           *float64 `json:"jitterDownstream,omitempty"`
	JitterUpstream             *float64 `json:"jitterUpstream,omitempty"`
	LostDownstream             *float64 `json:"lostDownstream,omitempty"`
	LostDownstreamPcnt         *float64 `json:"lostDownstreamPcnt,omitempty"`
	LostUpstream               *float64 `json:"lostUpstream,omitempty"`
	LostUpstreamPcnt           *float64 `json:"lostUpstreamPcnt,omitempty"`
	PacketsDiscardedDownstream *float64 `json:"packetsDiscardedDownstream,omitempty"`
	PacketsDiscardedUpstream   *float64 `json:"packetsDiscardedUpstream,omitempty"`
	PacketsDownstream          *float64 `json:"packetsDownstream,omitempty"`
	PacketsUpstream            *float64 `json:"packetsUpstream,omitempty"`
	Rtt                        *int64   `json:"rtt,omitempty"`
}

// The `MicrosoftActivity` object represents an activity within Microsoft services, containing fields such as action type, timestamps for the first and last activity, and identifiers for the activity and its associated resources.
type MicrosoftActivity struct {
	Action                *string `json:"action,omitempty"`
	FirstActivityDateTime *string `json:"firstActivityDateTime,omitempty"`
	ID                    string  `json:"id"`
	LastActivityDateTime  *string `json:"lastActivityDateTime,omitempty"`
	ParentResourceID      string  `json:"parentResourceId"`
	ResourceID            string  `json:"resourceId"`
}

func (MicrosoftActivity) IsActivity()                      {}
func (this MicrosoftActivity) GetID() string               { return this.ID }
func (this MicrosoftActivity) GetParentResourceID() string { return this.ParentResourceID }
func (this MicrosoftActivity) GetResourceID() string       { return this.ResourceID }

// The `MicrosoftDefenderEndpointAlert` object represents an alert generated by Microsoft Defender for Endpoint, containing details such as activities, classification, criticality, detection source, and recommended actions, among other attributes, to help in identifying and managing security threats.
type MicrosoftDefenderEndpointAlert struct {
	Activities            []*MicrosoftActivity        `json:"activities"`
	AlertWebURL           *string                     `json:"alertWebUrl,omitempty"`
	Category              *string                     `json:"category,omitempty"`
	Classification        *AlertClassificationEnum    `json:"classification,omitempty"`
	Comments              []string                    `json:"comments"`
	CreatedDateTime       *string                     `json:"createdDateTime,omitempty"`
	Criticality           *int64                      `json:"criticality,omitempty"`
	Description           *string                     `json:"description,omitempty"`
	DestinationIP         *string                     `json:"destinationIp,omitempty"`
	DestinationURL        *string                     `json:"destinationUrl,omitempty"`
	DetectionSource       *DetectionSourceEnum        `json:"detectionSource,omitempty"`
	Determination         *AlertDeterminationEnum     `json:"determination,omitempty"`
	ExternalIP            *string                     `json:"externalIp,omitempty"`
	FirstActivityDateTime *string                     `json:"firstActivityDateTime,omitempty"`
	ID                    string                      `json:"id"`
	LastActivityDateTime  *string                     `json:"lastActivityDateTime,omitempty"`
	LastUpdateDateTime    *string                     `json:"lastUpdateDateTime,omitempty"`
	LocalIP               *string                     `json:"localIp,omitempty"`
	MitreSubTechnique     []*Mitre                    `json:"mitreSubTechnique"`
	MitreTechnique        []*Mitre                    `json:"mitreTechnique"`
	OwnerName             *string                     `json:"ownerName,omitempty"`
	ProviderAlertID       *string                     `json:"providerAlertId,omitempty"`
	RecommendedActions    *string                     `json:"recommendedActions,omitempty"`
	ResolvedDateTime      *string                     `json:"resolvedDateTime,omitempty"`
	Resources             []MicrosoftEndpointResource `json:"resources"`
	Status                *MsAlertStatus              `json:"status,omitempty"`
	ThreatFamilyName      *string                     `json:"threatFamilyName,omitempty"`
	ThreatName            *string                     `json:"threatName,omitempty"`
	ThreatType            *string                     `json:"threatType,omitempty"`
	Title                 *string                     `json:"title,omitempty"`
}

func (MicrosoftDefenderEndpointAlert) IsEndpointAlert() {}
func (this MicrosoftDefenderEndpointAlert) GetActivities() []Activity {
	if this.Activities == nil {
		return nil
	}
	interfaceSlice := make([]Activity, 0, len(this.Activities))
	for _, concrete := range this.Activities {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this MicrosoftDefenderEndpointAlert) GetCreatedDateTime() *string { return this.CreatedDateTime }
func (this MicrosoftDefenderEndpointAlert) GetCriticality() *int64      { return this.Criticality }
func (this MicrosoftDefenderEndpointAlert) GetDescription() *string     { return this.Description }
func (this MicrosoftDefenderEndpointAlert) GetExternalIP() *string      { return this.ExternalIP }
func (this MicrosoftDefenderEndpointAlert) GetID() string               { return this.ID }
func (this MicrosoftDefenderEndpointAlert) GetLocalIP() *string         { return this.LocalIP }
func (this MicrosoftDefenderEndpointAlert) GetMitreSubTechnique() []*Mitre {
	if this.MitreSubTechnique == nil {
		return nil
	}
	interfaceSlice := make([]*Mitre, 0, len(this.MitreSubTechnique))
	for _, concrete := range this.MitreSubTechnique {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this MicrosoftDefenderEndpointAlert) GetMitreTechnique() []*Mitre {
	if this.MitreTechnique == nil {
		return nil
	}
	interfaceSlice := make([]*Mitre, 0, len(this.MitreTechnique))
	for _, concrete := range this.MitreTechnique {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this MicrosoftDefenderEndpointAlert) GetResources() []EndpointResource {
	if this.Resources == nil {
		return nil
	}
	interfaceSlice := make([]EndpointResource, 0, len(this.Resources))
	for _, concrete := range this.Resources {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this MicrosoftDefenderEndpointAlert) GetThreatName() *string { return this.ThreatName }
func (this MicrosoftDefenderEndpointAlert) GetTitle() *string      { return this.Title }

// The `MicrosoftDeviceDetails` object represents detailed information about a Microsoft device, including its antivirus status, Azure AD device ID, device name, first seen date and time, health status, IP interfaces, logged-on users, onboarding status, operating system details, and RBAC group.
type MicrosoftDeviceDetails struct {
	AvStatus          *DeviceAvStatusEnum     `json:"avStatus,omitempty"`
	AzureAdDeviceID   *string                 `json:"azureAdDeviceId,omitempty"`
	DeviceName        *string                 `json:"deviceName,omitempty"`
	ExternalIP        *string                 `json:"externalIp,omitempty"`
	FirstSeenDateTime *string                 `json:"firstSeenDateTime,omitempty"`
	HealthStatus      *DeviceHealthStatusEnum `json:"healthStatus,omitempty"`
	ID                string                  `json:"id"`
	IPInterfaces      []string                `json:"ipInterfaces"`
	LocalIP           *string                 `json:"localIp,omitempty"`
	LoggedOnUsers     []EndpointUser          `json:"loggedOnUsers"`
	OnboardingStatus  *OnboardingStatusEnum   `json:"onboardingStatus,omitempty"`
	OsDetails         *OsDetails              `json:"osDetails,omitempty"`
	RbacGroup         *RbacGroup              `json:"rbacGroup,omitempty"`
}

func (MicrosoftDeviceDetails) IsDeviceDetails()            {}
func (this MicrosoftDeviceDetails) GetDeviceName() *string { return this.DeviceName }
func (this MicrosoftDeviceDetails) GetExternalIP() *string { return this.ExternalIP }
func (this MicrosoftDeviceDetails) GetID() string          { return this.ID }
func (this MicrosoftDeviceDetails) GetLocalIP() *string    { return this.LocalIP }
func (this MicrosoftDeviceDetails) GetLoggedOnUsers() []EndpointUser {
	if this.LoggedOnUsers == nil {
		return nil
	}
	interfaceSlice := make([]EndpointUser, 0, len(this.LoggedOnUsers))
	for _, concrete := range this.LoggedOnUsers {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this MicrosoftDeviceDetails) GetOsDetails() *OsDetails { return this.OsDetails }

// The `MicrosoftEndpoint` object represents a comprehensive data structure used in GraphQL queries or mutations, containing fields related to security alerts, device details, threat predictions, and other metadata associated with Microsoft's security ecosystem.
type MicrosoftEndpoint struct {
	Alerts              []*MicrosoftDefenderEndpointAlert `json:"alerts"`
	AnalystFeedback     *AnalystFeedback                  `json:"analystFeedback,omitempty"`
	ConnectionType      *ConnectionTypeEnum               `json:"connectionType,omitempty"`
	Criticality         *int64                            `json:"criticality,omitempty"`
	Description         *string                           `json:"description,omitempty"`
	Device              *MicrosoftDeviceDetails           `json:"device,omitempty"`
	EngineType          *StoryEngineTypeEnum              `json:"engineType,omitempty"`
	FirstSignal         string                            `json:"firstSignal"`
	ID                  string                            `json:"id"`
	Indication          string                            `json:"indication"`
	LastSignal          string                            `json:"lastSignal"`
	PredictedThreatType *string                           `json:"predictedThreatType,omitempty"`
	PredictedVerdict    *StoryVerdictEnum                 `json:"predictedVerdict,omitempty"`
	Producer            StoryProducerEnum                 `json:"producer"`
	ProducerName        string                            `json:"producerName"`
	QueryName           *string                           `json:"queryName,omitempty"`
	Research            *bool                             `json:"research,omitempty"`
	SimilarStoriesData  []*SimilarStoryData               `json:"similarStoriesData"`
	Site                *SiteRef                          `json:"site,omitempty"`
	SiteName            *string                           `json:"siteName,omitempty"`
	Source              *string                           `json:"source,omitempty"`
	SourceIP            *string                           `json:"sourceIp,omitempty"`
	Status              *StoryStatusEnum                  `json:"status,omitempty"`
	StoryDuration       *int64                            `json:"storyDuration,omitempty"`
	Ticket              *string                           `json:"ticket,omitempty"`
	User                *UserRef                          `json:"user,omitempty"`
	Vendor              *VendorEnum                       `json:"vendor,omitempty"`
}

func (MicrosoftEndpoint) IsEndpoint() {}
func (this MicrosoftEndpoint) GetAlerts() []EndpointAlert {
	if this.Alerts == nil {
		return nil
	}
	interfaceSlice := make([]EndpointAlert, 0, len(this.Alerts))
	for _, concrete := range this.Alerts {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this MicrosoftEndpoint) GetAnalystFeedback() *AnalystFeedback   { return this.AnalystFeedback }
func (this MicrosoftEndpoint) GetConnectionType() *ConnectionTypeEnum { return this.ConnectionType }
func (this MicrosoftEndpoint) GetCriticality() *int64                 { return this.Criticality }
func (this MicrosoftEndpoint) GetDescription() *string                { return this.Description }
func (this MicrosoftEndpoint) GetDevice() DeviceDetails               { return *this.Device }
func (this MicrosoftEndpoint) GetEngineType() *StoryEngineTypeEnum    { return this.EngineType }
func (this MicrosoftEndpoint) GetFirstSignal() string                 { return this.FirstSignal }
func (this MicrosoftEndpoint) GetID() string                          { return this.ID }
func (this MicrosoftEndpoint) GetIndication() string                  { return this.Indication }
func (this MicrosoftEndpoint) GetLastSignal() string                  { return this.LastSignal }
func (this MicrosoftEndpoint) GetPredictedThreatType() *string        { return this.PredictedThreatType }
func (this MicrosoftEndpoint) GetPredictedVerdict() *StoryVerdictEnum { return this.PredictedVerdict }
func (this MicrosoftEndpoint) GetProducer() StoryProducerEnum         { return this.Producer }
func (this MicrosoftEndpoint) GetProducerName() string                { return this.ProducerName }
func (this MicrosoftEndpoint) GetQueryName() *string                  { return this.QueryName }
func (this MicrosoftEndpoint) GetResearch() *bool                     { return this.Research }
func (this MicrosoftEndpoint) GetSimilarStoriesData() []*SimilarStoryData {
	if this.SimilarStoriesData == nil {
		return nil
	}
	interfaceSlice := make([]*SimilarStoryData, 0, len(this.SimilarStoriesData))
	for _, concrete := range this.SimilarStoriesData {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this MicrosoftEndpoint) GetSite() *SiteRef           { return this.Site }
func (this MicrosoftEndpoint) GetSiteName() *string        { return this.SiteName }
func (this MicrosoftEndpoint) GetSource() *string          { return this.Source }
func (this MicrosoftEndpoint) GetSourceIP() *string        { return this.SourceIP }
func (this MicrosoftEndpoint) GetStatus() *StoryStatusEnum { return this.Status }
func (this MicrosoftEndpoint) GetStoryDuration() *int64    { return this.StoryDuration }
func (this MicrosoftEndpoint) GetTicket() *string          { return this.Ticket }
func (this MicrosoftEndpoint) GetUser() *UserRef           { return this.User }
func (this MicrosoftEndpoint) GetVendor() *VendorEnum      { return this.Vendor }

func (MicrosoftEndpoint) IsMergedIncident() {}

// The `MicrosoftEndpointUser` object represents a user associated with a Microsoft endpoint, containing fields such as account name, domain name, unique identifier, user name, principal name, and user security identifier.
type MicrosoftEndpointUser struct {
	AccountName   *string `json:"accountName,omitempty"`
	DomainName    *string `json:"domainName,omitempty"`
	ID            string  `json:"id"`
	Name          string  `json:"name"`
	PrincipalName *string `json:"principalName,omitempty"`
	UserSid       *string `json:"userSid,omitempty"`
}

func (MicrosoftEndpointUser) IsEndpointUser()      {}
func (this MicrosoftEndpointUser) GetID() string   { return this.ID }
func (this MicrosoftEndpointUser) GetName() string { return this.Name }

// The `MicrosoftFileResource` object represents a file resource in a Microsoft system, containing fields such as creation date, detection and remediation status, file details, unique identifier, roles, tags, and a verdict on the file's status.
type MicrosoftFileResource struct {
	CreatedDateTime          *string                `json:"createdDateTime,omitempty"`
	DetectionStatus          *DetectionStatusEnum   `json:"detectionStatus,omitempty"`
	FileDetails              *FileDetails           `json:"fileDetails,omitempty"`
	ID                       string                 `json:"id"`
	RemediationStatus        *RemediationStatusEnum `json:"remediationStatus,omitempty"`
	RemediationStatusDetails *string                `json:"remediationStatusDetails,omitempty"`
	Roles                    []ResourceRoleEnum     `json:"roles"`
	Tags                     []string               `json:"tags"`
	Verdict                  *MsResourceVerdictEnum `json:"verdict,omitempty"`
}

func (MicrosoftFileResource) IsEndpointResource()              {}
func (this MicrosoftFileResource) GetCreatedDateTime() *string { return this.CreatedDateTime }
func (this MicrosoftFileResource) GetID() string               { return this.ID }
func (this MicrosoftFileResource) GetRemediationStatus() *RemediationStatusEnum {
	return this.RemediationStatus
}

func (MicrosoftFileResource) IsFileResource() {}

func (this MicrosoftFileResource) GetDetectionStatus() *DetectionStatusEnum {
	return this.DetectionStatus
}
func (this MicrosoftFileResource) GetFileDetails() *FileDetails { return this.FileDetails }

func (MicrosoftFileResource) IsMicrosoftEndpointResource() {}

func (this MicrosoftFileResource) GetRemediationStatusDetails() *string {
	return this.RemediationStatusDetails
}
func (this MicrosoftFileResource) GetRoles() []ResourceRoleEnum {
	if this.Roles == nil {
		return nil
	}
	interfaceSlice := make([]ResourceRoleEnum, 0, len(this.Roles))
	for _, concrete := range this.Roles {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this MicrosoftFileResource) GetTags() []string {
	if this.Tags == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.Tags))
	for _, concrete := range this.Tags {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this MicrosoftFileResource) GetVerdict() *MsResourceVerdictEnum { return this.Verdict }

// The `MicrosoftNetworkResource` object represents a registry resource in a Microsoft environment, containing fields such as creation date, remediation status, roles, tags, and verdict, which are used to manage and assess the resource's status and attributes.
type MicrosoftNetworkResource struct {
	Action                   *string                `json:"action,omitempty"`
	CreatedDateTime          *string                `json:"createdDateTime,omitempty"`
	DestinationIP            *string                `json:"destinationIp,omitempty"`
	DestinationPort          *int64                 `json:"destinationPort,omitempty"`
	DNSRequest               *string                `json:"dnsRequest,omitempty"`
	DNSResponse              *string                `json:"dnsResponse,omitempty"`
	ID                       string                 `json:"id"`
	Method                   *string                `json:"method,omitempty"`
	RemediationStatus        *RemediationStatusEnum `json:"remediationStatus,omitempty"`
	RemediationStatusDetails *string                `json:"remediationStatusDetails,omitempty"`
	Roles                    []ResourceRoleEnum     `json:"roles"`
	SourcePort               *int64                 `json:"sourcePort,omitempty"`
	Tags                     []string               `json:"tags"`
	URL                      *string                `json:"url,omitempty"`
	Verdict                  *MsResourceVerdictEnum `json:"verdict,omitempty"`
}

func (MicrosoftNetworkResource) IsEndpointResource()              {}
func (this MicrosoftNetworkResource) GetCreatedDateTime() *string { return this.CreatedDateTime }
func (this MicrosoftNetworkResource) GetID() string               { return this.ID }
func (this MicrosoftNetworkResource) GetRemediationStatus() *RemediationStatusEnum {
	return this.RemediationStatus
}

func (MicrosoftNetworkResource) IsMicrosoftEndpointResource() {}

func (this MicrosoftNetworkResource) GetRemediationStatusDetails() *string {
	return this.RemediationStatusDetails
}
func (this MicrosoftNetworkResource) GetRoles() []ResourceRoleEnum {
	if this.Roles == nil {
		return nil
	}
	interfaceSlice := make([]ResourceRoleEnum, 0, len(this.Roles))
	for _, concrete := range this.Roles {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this MicrosoftNetworkResource) GetTags() []string {
	if this.Tags == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.Tags))
	for _, concrete := range this.Tags {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this MicrosoftNetworkResource) GetVerdict() *MsResourceVerdictEnum { return this.Verdict }

func (MicrosoftNetworkResource) IsNetworkResource() {}

func (this MicrosoftNetworkResource) GetDestinationIP() *string  { return this.DestinationIP }
func (this MicrosoftNetworkResource) GetDestinationPort() *int64 { return this.DestinationPort }
func (this MicrosoftNetworkResource) GetDNSRequest() *string     { return this.DNSRequest }
func (this MicrosoftNetworkResource) GetDNSResponse() *string    { return this.DNSResponse }

func (this MicrosoftNetworkResource) GetMethod() *string { return this.Method }

func (this MicrosoftNetworkResource) GetSourcePort() *int64 { return this.SourcePort }
func (this MicrosoftNetworkResource) GetURL() *string       { return this.URL }

// The `MicrosoftProcessResource` object represents a process resource in a Microsoft environment, containing fields such as creation date, process ID, command line details, remediation status, roles, tags, user account information, and a verdict on the process's nature.
type MicrosoftProcessResource struct {
	Action                   *string                `json:"action,omitempty"`
	CreatedDateTime          *string                `json:"createdDateTime,omitempty"`
	ID                       string                 `json:"id"`
	ImageFile                *FileDetails           `json:"imageFile,omitempty"`
	ProcessCommandLine       *string                `json:"processCommandLine,omitempty"`
	ProcessID                int64                  `json:"processId"`
	RemediationStatus        *RemediationStatusEnum `json:"remediationStatus,omitempty"`
	RemediationStatusDetails *string                `json:"remediationStatusDetails,omitempty"`
	Roles                    []ResourceRoleEnum     `json:"roles"`
	Tags                     []string               `json:"tags"`
	UserAccount              EndpointUser           `json:"userAccount,omitempty"`
	Verdict                  *MsResourceVerdictEnum `json:"verdict,omitempty"`
}

func (MicrosoftProcessResource) IsEndpointResource()              {}
func (this MicrosoftProcessResource) GetCreatedDateTime() *string { return this.CreatedDateTime }
func (this MicrosoftProcessResource) GetID() string               { return this.ID }
func (this MicrosoftProcessResource) GetRemediationStatus() *RemediationStatusEnum {
	return this.RemediationStatus
}

func (MicrosoftProcessResource) IsMicrosoftEndpointResource() {}

func (this MicrosoftProcessResource) GetRemediationStatusDetails() *string {
	return this.RemediationStatusDetails
}
func (this MicrosoftProcessResource) GetRoles() []ResourceRoleEnum {
	if this.Roles == nil {
		return nil
	}
	interfaceSlice := make([]ResourceRoleEnum, 0, len(this.Roles))
	for _, concrete := range this.Roles {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this MicrosoftProcessResource) GetTags() []string {
	if this.Tags == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.Tags))
	for _, concrete := range this.Tags {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this MicrosoftProcessResource) GetVerdict() *MsResourceVerdictEnum { return this.Verdict }

func (MicrosoftProcessResource) IsProcessResource() {}

func (this MicrosoftProcessResource) GetImageFile() *FileDetails     { return this.ImageFile }
func (this MicrosoftProcessResource) GetProcessCommandLine() *string { return this.ProcessCommandLine }
func (this MicrosoftProcessResource) GetProcessID() int64            { return this.ProcessID }

func (this MicrosoftProcessResource) GetUserAccount() EndpointUser { return this.UserAccount }

// The `MicrosoftRegistryResource` object represents a registry resource in a Microsoft environment, containing fields such as creation date, hive, key, remediation status, roles, tags, and verdict, which are used to manage and assess the resource's status and attributes.
type MicrosoftRegistryResource struct {
	CreatedDateTime          *string                `json:"createdDateTime,omitempty"`
	Hive                     *string                `json:"hive,omitempty"`
	ID                       string                 `json:"id"`
	Key                      *string                `json:"key,omitempty"`
	RemediationStatus        *RemediationStatusEnum `json:"remediationStatus,omitempty"`
	RemediationStatusDetails *string                `json:"remediationStatusDetails,omitempty"`
	Roles                    []ResourceRoleEnum     `json:"roles"`
	Tags                     []string               `json:"tags"`
	Value                    *string                `json:"value,omitempty"`
	ValueName                *string                `json:"valueName,omitempty"`
	ValueType                *string                `json:"valueType,omitempty"`
	Verdict                  *MsResourceVerdictEnum `json:"verdict,omitempty"`
}

func (MicrosoftRegistryResource) IsEndpointResource()              {}
func (this MicrosoftRegistryResource) GetCreatedDateTime() *string { return this.CreatedDateTime }
func (this MicrosoftRegistryResource) GetID() string               { return this.ID }
func (this MicrosoftRegistryResource) GetRemediationStatus() *RemediationStatusEnum {
	return this.RemediationStatus
}

func (MicrosoftRegistryResource) IsMicrosoftEndpointResource() {}

func (this MicrosoftRegistryResource) GetRemediationStatusDetails() *string {
	return this.RemediationStatusDetails
}
func (this MicrosoftRegistryResource) GetRoles() []ResourceRoleEnum {
	if this.Roles == nil {
		return nil
	}
	interfaceSlice := make([]ResourceRoleEnum, 0, len(this.Roles))
	for _, concrete := range this.Roles {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this MicrosoftRegistryResource) GetTags() []string {
	if this.Tags == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.Tags))
	for _, concrete := range this.Tags {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this MicrosoftRegistryResource) GetVerdict() *MsResourceVerdictEnum { return this.Verdict }

func (MicrosoftRegistryResource) IsRegistryResource() {}

func (this MicrosoftRegistryResource) GetHive() *string { return this.Hive }

func (this MicrosoftRegistryResource) GetKey() *string { return this.Key }

func (this MicrosoftRegistryResource) GetValue() *string     { return this.Value }
func (this MicrosoftRegistryResource) GetValueName() *string { return this.ValueName }
func (this MicrosoftRegistryResource) GetValueType() *string { return this.ValueType }

type Mitre struct {
	ID   *string `json:"id,omitempty"`
	Name *string `json:"name,omitempty"`
}

type Mutation struct {
}

// NOC as a Service (NOCaaS) service license details
type NOCaaSLicense struct {
	Description    *string       `json:"description,omitempty"`
	ExpirationDate string        `json:"expirationDate"`
	ID             *string       `json:"id,omitempty"`
	LastUpdated    *string       `json:"lastUpdated,omitempty"`
	Plan           LicensePlan   `json:"plan"`
	Sku            LicenseSku    `json:"sku"`
	StartDate      *string       `json:"startDate,omitempty"`
	Status         LicenseStatus `json:"status"`
}

func (NOCaaSLicense) IsLicense()                     {}
func (this NOCaaSLicense) GetDescription() *string   { return this.Description }
func (this NOCaaSLicense) GetExpirationDate() string { return this.ExpirationDate }
func (this NOCaaSLicense) GetID() *string            { return this.ID }
func (this NOCaaSLicense) GetLastUpdated() *string   { return this.LastUpdated }
func (this NOCaaSLicense) GetPlan() LicensePlan      { return this.Plan }
func (this NOCaaSLicense) GetSku() LicenseSku        { return this.Sku }
func (this NOCaaSLicense) GetStartDate() *string     { return this.StartDate }
func (this NOCaaSLicense) GetStatus() LicenseStatus  { return this.Status }

type NetworkDhcpSettingsInput struct {
	DhcpMicrosegmentation *bool    `json:"dhcpMicrosegmentation,omitempty"`
	DhcpType              DhcpType `json:"dhcpType"`
	IPRange               *string  `json:"ipRange,omitempty"`
	RelayGroupID          *string  `json:"relayGroupId,omitempty"`
}

// A reference identifying the NetworkInterface object. ID: Unique NetworkInterface Identifier, Name: The NetworkInterface Name
type NetworkInterfaceRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (NetworkInterfaceRef) IsObjectRef()         {}
func (this NetworkInterfaceRef) GetID() string   { return this.ID }
func (this NetworkInterfaceRef) GetName() string { return this.Name }

type NetworkInterfaceRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

type NetworkTimelineEvent struct {
	Acknowledged         *bool                     `json:"acknowledged,omitempty"`
	BgpConnection        *BGPConnection            `json:"bgpConnection,omitempty"`
	Created              string                    `json:"created"`
	Description          *string                   `json:"description,omitempty"`
	DeviceConfigHaRole   *DeviceConfigHaRoleEnum   `json:"deviceConfigHaRole,omitempty"`
	DeviceHaRoleState    *DeviceHaRoleStateEnum    `json:"deviceHaRoleState,omitempty"`
	EventIds             []string                  `json:"eventIds"`
	EventType            *NetworkXDREventTypeEnum  `json:"eventType,omitempty"`
	HostIP               *string                   `json:"hostIp,omitempty"`
	IncidentID           *string                   `json:"incidentId,omitempty"`
	Isp                  *string                   `json:"isp,omitempty"`
	LinkConfigBandwidth  *string                   `json:"linkConfigBandwidth,omitempty"`
	LinkConfigPrecedence *LinkConfigPrecedenceEnum `json:"linkConfigPrecedence,omitempty"`
	LinkID               *string                   `json:"linkId,omitempty"`
	LinkName             *string                   `json:"linkName,omitempty"`
	LinkQualityIssue     *LinkQualityIssue         `json:"linkQualityIssue,omitempty"`
	LinkStatus           *LinkStatusEnum           `json:"linkStatus,omitempty"`
	Muted                *bool                     `json:"muted,omitempty"`
	NetworkEventSource   *NetworkEventSourceEnum   `json:"networkEventSource,omitempty"`
	Pop                  *string                   `json:"pop,omitempty"`
	RuleName             *string                   `json:"ruleName,omitempty"`
	SocketSerialID       *string                   `json:"socketSerialId,omitempty"`
	TunnelResetCount     *int64                    `json:"tunnelResetCount,omitempty"`
	Validated            string                    `json:"validated"`
}

// The `NetworkXDRIncident` object represents a detailed incident report within a network, containing various fields such as incident ID, description, criticality, timeline events, and associated metadata like connection type, site information, and predicted threat type, used for analyzing and managing network security incidents.
type NetworkXDRIncident struct {
	Acknowledged            *bool                     `json:"acknowledged,omitempty"`
	AnalystFeedback         *AnalystFeedback          `json:"analystFeedback,omitempty"`
	BgpConnection           *BGPConnection            `json:"bgpConnection,omitempty"`
	ConnectionType          *ConnectionTypeEnum       `json:"connectionType,omitempty"`
	Criticality             *int64                    `json:"criticality,omitempty"`
	Description             *string                   `json:"description,omitempty"`
	DeviceConfigHaRole      *DeviceConfigHaRoleEnum   `json:"deviceConfigHaRole,omitempty"`
	EngineType              *StoryEngineTypeEnum      `json:"engineType,omitempty"`
	FirstSignal             string                    `json:"firstSignal"`
	HostIP                  *string                   `json:"hostIp,omitempty"`
	ID                      string                    `json:"id"`
	IlmmDetails             *IlmmDetails              `json:"ilmmDetails,omitempty"`
	Indication              string                    `json:"indication"`
	Isp                     *string                   `json:"isp,omitempty"`
	LastSignal              string                    `json:"lastSignal"`
	LicenseBandwidth        *string                   `json:"licenseBandwidth,omitempty"`
	LicenseRegion           *string                   `json:"licenseRegion,omitempty"`
	LinkConfigPrecedence    *LinkConfigPrecedenceEnum `json:"linkConfigPrecedence,omitempty"`
	LinkID                  *string                   `json:"linkId,omitempty"`
	LinkName                *string                   `json:"linkName,omitempty"`
	Muted                   *bool                     `json:"muted,omitempty"`
	NetworkIncidentTimeline []*NetworkTimelineEvent   `json:"networkIncidentTimeline"`
	Occurrences             *int64                    `json:"occurrences,omitempty"`
	Pop                     *string                   `json:"pop,omitempty"`
	PredictedThreatType     *string                   `json:"predictedThreatType,omitempty"`
	PredictedVerdict        *StoryVerdictEnum         `json:"predictedVerdict,omitempty"`
	Producer                StoryProducerEnum         `json:"producer"`
	ProducerName            string                    `json:"producerName"`
	QueryName               *string                   `json:"queryName,omitempty"`
	Research                *bool                     `json:"research,omitempty"`
	RuleName                *string                   `json:"ruleName,omitempty"`
	SimilarStoriesData      []*SimilarStoryData       `json:"similarStoriesData"`
	Site                    *SiteRef                  `json:"site,omitempty"`
	SiteConfigLocation      *string                   `json:"siteConfigLocation,omitempty"`
	SiteConnectionType      *string                   `json:"siteConnectionType,omitempty"`
	SiteName                string                    `json:"siteName"`
	Source                  *string                   `json:"source,omitempty"`
	SourceIP                *string                   `json:"sourceIp,omitempty"`
	Status                  *StoryStatusEnum          `json:"status,omitempty"`
	StoryDuration           *int64                    `json:"storyDuration,omitempty"`
	StoryType               string                    `json:"storyType"`
	Ticket                  *string                   `json:"ticket,omitempty"`
	User                    *UserRef                  `json:"user,omitempty"`
	Vendor                  *VendorEnum               `json:"vendor,omitempty"`
}

func (NetworkXDRIncident) IsMergedIncident()                           {}
func (this NetworkXDRIncident) GetAnalystFeedback() *AnalystFeedback   { return this.AnalystFeedback }
func (this NetworkXDRIncident) GetConnectionType() *ConnectionTypeEnum { return this.ConnectionType }
func (this NetworkXDRIncident) GetCriticality() *int64                 { return this.Criticality }
func (this NetworkXDRIncident) GetDescription() *string                { return this.Description }
func (this NetworkXDRIncident) GetEngineType() *StoryEngineTypeEnum    { return this.EngineType }
func (this NetworkXDRIncident) GetFirstSignal() string                 { return this.FirstSignal }
func (this NetworkXDRIncident) GetID() string                          { return this.ID }
func (this NetworkXDRIncident) GetIndication() string                  { return this.Indication }
func (this NetworkXDRIncident) GetLastSignal() string                  { return this.LastSignal }
func (this NetworkXDRIncident) GetPredictedThreatType() *string        { return this.PredictedThreatType }
func (this NetworkXDRIncident) GetPredictedVerdict() *StoryVerdictEnum { return this.PredictedVerdict }
func (this NetworkXDRIncident) GetProducer() StoryProducerEnum         { return this.Producer }
func (this NetworkXDRIncident) GetProducerName() string                { return this.ProducerName }
func (this NetworkXDRIncident) GetQueryName() *string                  { return this.QueryName }
func (this NetworkXDRIncident) GetResearch() *bool                     { return this.Research }
func (this NetworkXDRIncident) GetSite() *SiteRef                      { return this.Site }
func (this NetworkXDRIncident) GetSiteName() *string                   { return &this.SiteName }
func (this NetworkXDRIncident) GetSource() *string                     { return this.Source }
func (this NetworkXDRIncident) GetSourceIP() *string                   { return this.SourceIP }
func (this NetworkXDRIncident) GetStatus() *StoryStatusEnum            { return this.Status }
func (this NetworkXDRIncident) GetStoryDuration() *int64               { return this.StoryDuration }
func (this NetworkXDRIncident) GetTicket() *string                     { return this.Ticket }
func (this NetworkXDRIncident) GetUser() *UserRef                      { return this.User }
func (this NetworkXDRIncident) GetVendor() *VendorEnum                 { return this.Vendor }

// NG Anti-Malware service license details (Legacy license, replaced by TP)
type NextGenMalwareProtectionLicense struct {
	Description    *string       `json:"description,omitempty"`
	ExpirationDate string        `json:"expirationDate"`
	ID             *string       `json:"id,omitempty"`
	LastUpdated    *string       `json:"lastUpdated,omitempty"`
	Plan           LicensePlan   `json:"plan"`
	Sku            LicenseSku    `json:"sku"`
	StartDate      *string       `json:"startDate,omitempty"`
	Status         LicenseStatus `json:"status"`
}

func (NextGenMalwareProtectionLicense) IsLicense()                     {}
func (this NextGenMalwareProtectionLicense) GetDescription() *string   { return this.Description }
func (this NextGenMalwareProtectionLicense) GetExpirationDate() string { return this.ExpirationDate }
func (this NextGenMalwareProtectionLicense) GetID() *string            { return this.ID }
func (this NextGenMalwareProtectionLicense) GetLastUpdated() *string   { return this.LastUpdated }
func (this NextGenMalwareProtectionLicense) GetPlan() LicensePlan      { return this.Plan }
func (this NextGenMalwareProtectionLicense) GetSku() LicenseSku        { return this.Sku }
func (this NextGenMalwareProtectionLicense) GetStartDate() *string     { return this.StartDate }
func (this NextGenMalwareProtectionLicense) GetStatus() LicenseStatus  { return this.Status }

type OriginTypeFilterInput struct {
	HasAll []OriginType `json:"hasAll,omitempty"`
	In     []OriginType `json:"in,omitempty"`
	Nin    []OriginType `json:"nin,omitempty"`
}

type OsDetails struct {
	OsBuild   *int64  `json:"osBuild,omitempty"`
	OsType    string  `json:"osType"`
	OsVersion *string `json:"osVersion,omitempty"`
}

type PageInfo struct {
	Total int64 `json:"total"`
}

type Paging struct {
	From  int64 `json:"from"`
	Limit int64 `json:"limit"`
	Total int64 `json:"total"`
}

type PagingInput struct {
	From  int64 `json:"from"`
	Limit int64 `json:"limit"`
}

type PartnerPooledBandwidthLicenseAccount struct {
	Account            *AccountRef `json:"account"`
	AllocatedBandwidth int64       `json:"allocatedBandwidth"`
}

// Represents available versions for a specific platform.
type PlatformVersions struct {
	Platform string   `json:"platform"`
	Versions []string `json:"versions"`
}

// Input for adding section info to a policy
type PolicyAddSectionInfoInput struct {
	Name string `json:"name"`
}

// Input for adding a section to a policy
type PolicyAddSectionInput struct {
	At      *PolicySectionPositionInput `json:"at"`
	Section *PolicyAddSectionInfoInput  `json:"section"`
}

type PolicyAudit struct {
	PublishedBy   string `json:"publishedBy"`
	PublishedTime string `json:"publishedTime"`
}

type PolicyCreateRevisionInput struct {
	Description string `json:"description"`
	Name        string `json:"name"`
}

// Returns data for a custom recurring time range that a rule is active
type PolicyCustomRecurring struct {
	Days []DayOfWeek  `json:"days"`
	From scalars.Time `json:"from"`
	To   scalars.Time `json:"to"`
}

// Input of data for a custom recurring time range that a rule is active
type PolicyCustomRecurringInput struct {
	Days []DayOfWeek  `json:"days"`
	From scalars.Time `json:"from"`
	To   scalars.Time `json:"to"`
}

// Input of data for a custom recurring time range that a rule is active
type PolicyCustomRecurringUpdateInput struct {
	Days []DayOfWeek   `json:"days,omitempty"`
	From *scalars.Time `json:"from,omitempty"`
	To   *scalars.Time `json:"to,omitempty"`
}

// Returns data for a custom one-time time range that a rule is active
type PolicyCustomTimeframe struct {
	From string `json:"from"`
	To   string `json:"to"`
}

// Input of data for a custom one-time time range that a rule is active
type PolicyCustomTimeframeInput struct {
	From string `json:"from"`
	To   string `json:"to"`
}

// Input of data for a custom one-time time range that a rule is active
type PolicyCustomTimeframeUpdateInput struct {
	From *string `json:"from,omitempty"`
	To   *string `json:"to,omitempty"`
}

// Discards unpublished revision for the policy and reverts to the settings for the published policy.
type PolicyDiscardRevisionInput struct {
	ID *string `json:"id,omitempty"`
}

type PolicyElementAudit struct {
	UpdatedBy   string `json:"updatedBy"`
	UpdatedTime string `json:"updatedTime"`
}

// Move the rule to a different position in the policy
type PolicyMoveRuleInput struct {
	ID string                   `json:"id"`
	To *PolicyRulePositionInput `json:"to,omitempty"`
}

// Input for moving a section within a policy
type PolicyMoveSectionInput struct {
	ID string                      `json:"id"`
	To *PolicySectionPositionInput `json:"to,omitempty"`
}

// Move the sub rule to a different position in the policy
type PolicyMoveSubRuleInput struct {
	ID string                      `json:"id"`
	To *PolicySubRulePositionInput `json:"to"`
}

// The `PolicyMutationError` enum defines various error messages related to policy publishing in the policy platform service.
//
// ## Policy Errors
//
// ### `ConcurrentPolicyPublish`
// - **Error Message:** "Another policy is currently publishing"
//
// ### `PolicyRevisionMismatch`
// - **Error Message:** "Revision is not owned by the admin"
//
// ### `PolicyRevisionNotFound`
// - **Error Message:** "Revision was not found"
//
// ### `PolicyInvalidEntity`
// - **Error Message:** "Invalid entity"
//
// ### `DuplicateRuleName`
// - **Error Message:** "Rule with the same name already exists"
//
// ### `DuplicateSectionName`
// - **Error Message:** "Section with the same name already exists"
//
// ### `PolicyFailure`
// - **Error Message:** "Cant publish policy due to an internal error. Please try again in a few minutes"
//
// ## Rule Errors
//
// ### `ruleIsLocked`
// - **Error Message:** "Rule is locked by another revision"
//
// ### `ruleWasRemoved`
// - **Error Message:** "Rule was already removed"
//
// ### `ruleNotExist`
// - **Error Message:** "Rule does not exist"
//
// ### `ruleSectionNotExist`
// - **Error Message:** "Section does not exist"
//
// ### `ruleSectionIsLocked`
// - **Error Message:** "Section is locked by another revision"
//
// ### `rulePositionInvalid`
// - **Error Message:** "Rule position is invalid"
//
// ### `ruleNameIsEmpty`
// - **Error Message:** "Rule name can't be empty"
//
// ### `ruleNameAlreadyExists`
// - **Error Message:** "Rule with the same name already exists"
//
// ### `ruleSystemModification`
// - **Error Message:** "Can't modify a system rule"
//
// ### `ruleSystemMove`
// - **Error Message:** "Can't add a rule above the system rules"
//
// ### `ruleHasInvalidEntity`
// - **Error Message:** "Rule has an invalid entity"
//
// ### `failedValidatingRule`
// - **Error Message:** "Something went wrong, couldn't validate rule"
//
// ## Section Errors
//
// ### `sectionIsLocked`
// - **Error Message:** "Section is locked by another revision"
//
// ### `sectionSystemMove`
// - **Error Message:** "Section with system rules cannot be moved or removed"
//
// ### `sectionNotExist`
// - **Error Message:** "Section does not exist"
//
// ### `sectionPositionInvalid`
// - **Error Message:** "Section position is invalid"
type PolicyMutationError struct {
	ErrorCode    *string `json:"errorCode,omitempty"`
	ErrorMessage *string `json:"errorMessage,omitempty"`
}

type PolicyMutationRevisionInput struct {
	ID *string `json:"id,omitempty"`
}

type PolicyMutations struct {
	AntiMalwareFileHash  *AntiMalwareFileHashPolicyMutations  `json:"antiMalwareFileHash,omitempty"`
	AppTenantRestriction *AppTenantRestrictionPolicyMutations `json:"appTenantRestriction,omitempty"`
	ApplicationControl   *ApplicationControlPolicyMutations   `json:"applicationControl,omitempty"`
	DynamicIPAllocation  *DynamicIPAllocationPolicyMutations  `json:"dynamicIpAllocation,omitempty"`
	InternetFirewall     *InternetFirewallPolicyMutations     `json:"internetFirewall,omitempty"`
	PrivateAccess        *PrivateAccessPolicyMutations        `json:"privateAccess,omitempty"`
	RemotePortFwd        *RemotePortFwdPolicyMutations        `json:"remotePortFwd,omitempty"`
	SocketLan            *SocketLanPolicyMutations            `json:"socketLan,omitempty"`
	TerminalServer       *TerminalServerPolicyMutations       `json:"terminalServer,omitempty"`
	TLSInspect           *TLSInspectPolicyMutations           `json:"tlsInspect,omitempty"`
	WanFirewall          *WanFirewallPolicyMutations          `json:"wanFirewall,omitempty"`
	WanNetwork           *WanNetworkPolicyMutations           `json:"wanNetwork,omitempty"`
}

// Published revision is the active policy
// applied on the traffic.
// In addition, when a policy is published, revision changes become visible
// to other admins, and rules locked by the revision become unlocked
type PolicyPublishRevisionInput struct {
	Description *string `json:"description,omitempty"`
	Name        *string `json:"name,omitempty"`
}

// policies which configuration can be read with query APIs.
type PolicyQueries struct {
	AntiMalwareFileHash  *AntiMalwareFileHashPolicyQueries  `json:"antiMalwareFileHash,omitempty"`
	AppTenantRestriction *AppTenantRestrictionPolicyQueries `json:"appTenantRestriction,omitempty"`
	ApplicationControl   *ApplicationControlPolicyQueries   `json:"applicationControl,omitempty"`
	DynamicIPAllocation  *DynamicIPAllocationPolicyQueries  `json:"dynamicIpAllocation,omitempty"`
	InternetFirewall     *InternetFirewallPolicyQueries     `json:"internetFirewall,omitempty"`
	PrivateAccess        *PrivateAccessPolicyQueries        `json:"privateAccess,omitempty"`
	RemotePortFwd        *RemotePortFwdPolicyQueries        `json:"remotePortFwd,omitempty"`
	SocketLan            *SocketLanPolicyQueries            `json:"socketLan,omitempty"`
	TerminalServer       *TerminalServerPolicyQueries       `json:"terminalServer,omitempty"`
	TLSInspect           *TLSInspectPolicyQueries           `json:"tlsInspect,omitempty"`
	WanFirewall          *WanFirewallPolicyQueries          `json:"wanFirewall,omitempty"`
	WanNetwork           *WanNetworkPolicyQueries           `json:"wanNetwork,omitempty"`
}

// Input for removing a section from a policy
type PolicyRemoveSectionInput struct {
	ID string `json:"id"`
}

// Returns data about the policy revision, such as when the change was made, how many rules were changed, etc.
type PolicyRevision struct {
	Changes     int64  `json:"changes"`
	CreatedTime string `json:"createdTime"`
	Description string `json:"description"`
	ID          string `json:"id"`
	Name        string `json:"name"`
	UpdatedTime string `json:"updatedTime"`
}

// Input for specifying a policy revision
type PolicyRevisionInput struct {
	ID   *string             `json:"id,omitempty"`
	Type *PolicyRevisionType `json:"type,omitempty"`
}

// Returns data for publishing the policy
type PolicyRevisionsPayload struct {
	Revision []*PolicyRevision `json:"revision"`
}

// Returns the time period during which the rule is active, outside this period, the rule is inactive
type PolicyRuleActivePeriod struct {
	EffectiveFrom    *string `json:"effectiveFrom,omitempty"`
	ExpiresAt        *string `json:"expiresAt,omitempty"`
	UseEffectiveFrom bool    `json:"useEffectiveFrom"`
	UseExpiresAt     bool    `json:"useExpiresAt"`
}

// Input of the time period during which the rule is active, outside this period, the rule is inactive
type PolicyRuleActivePeriodInput struct {
	EffectiveFrom    *string `json:"effectiveFrom,omitempty"`
	ExpiresAt        *string `json:"expiresAt,omitempty"`
	UseEffectiveFrom bool    `json:"useEffectiveFrom"`
	UseExpiresAt     bool    `json:"useExpiresAt"`
}

// Input of the time period during which the rule is active, outside this period, the rule is inactive
type PolicyRuleActivePeriodUpdateInput struct {
	EffectiveFrom    *string `json:"effectiveFrom,omitempty"`
	ExpiresAt        *string `json:"expiresAt,omitempty"`
	UseEffectiveFrom *bool   `json:"useEffectiveFrom,omitempty"`
	UseExpiresAt     *bool   `json:"useExpiresAt,omitempty"`
}

// Parameters required to define the rule position
type PolicyRulePositionInput struct {
	Position *PolicyRulePositionEnum `json:"position,omitempty"`
	Ref      *string                 `json:"ref,omitempty"`
}

// Returns data for the alert settings for the rule
type PolicyRuleTrackingAlert struct {
	Enabled           bool                            `json:"enabled"`
	Frequency         PolicyRuleTrackingFrequencyEnum `json:"frequency"`
	MailingList       []*SubscriptionMailingListRef   `json:"mailingList"`
	SubscriptionGroup []*SubscriptionGroupRef         `json:"subscriptionGroup"`
	Webhook           []*SubscriptionWebhookRef       `json:"webhook"`
}

// Input of data for the alert settings for the rule
type PolicyRuleTrackingAlertInput struct {
	Enabled           bool                               `json:"enabled"`
	Frequency         PolicyRuleTrackingFrequencyEnum    `json:"frequency"`
	MailingList       []*SubscriptionMailingListRefInput `json:"mailingList"`
	SubscriptionGroup []*SubscriptionGroupRefInput       `json:"subscriptionGroup"`
	Webhook           []*SubscriptionWebhookRefInput     `json:"webhook"`
}

// Input of data for the alert settings for the rule
type PolicyRuleTrackingAlertUpdateInput struct {
	Enabled           *bool                              `json:"enabled,omitempty"`
	Frequency         *PolicyRuleTrackingFrequencyEnum   `json:"frequency,omitempty"`
	MailingList       []*SubscriptionMailingListRefInput `json:"mailingList,omitempty"`
	SubscriptionGroup []*SubscriptionGroupRefInput       `json:"subscriptionGroup,omitempty"`
	Webhook           []*SubscriptionWebhookRefInput     `json:"webhook,omitempty"`
}

// Returns data if an alert is sent for a rule
type PolicyRuleTrackingEvent struct {
	Enabled bool `json:"enabled"`
}

// Input of data if an alert is sent for a rule
type PolicyRuleTrackingEventInput struct {
	Enabled bool `json:"enabled"`
}

// Input of data if an alert is sent for a rule
type PolicyRuleTrackingEventUpdateInput struct {
	Enabled *bool `json:"enabled,omitempty"`
}

type PolicySchedule struct {
	ActiveOn        PolicyActiveOnEnum     `json:"activeOn"`
	CustomRecurring *PolicyCustomRecurring `json:"customRecurring,omitempty"`
	CustomTimeframe *PolicyCustomTimeframe `json:"customTimeframe,omitempty"`
}

type PolicyScheduleInput struct {
	ActiveOn        PolicyActiveOnEnum          `json:"activeOn"`
	CustomRecurring *PolicyCustomRecurringInput `json:"customRecurring,omitempty"`
	CustomTimeframe *PolicyCustomTimeframeInput `json:"customTimeframe,omitempty"`
}

type PolicyScheduleUpdateInput struct {
	ActiveOn        *PolicyActiveOnEnum               `json:"activeOn,omitempty"`
	CustomRecurring *PolicyCustomRecurringUpdateInput `json:"customRecurring,omitempty"`
	CustomTimeframe *PolicyCustomTimeframeUpdateInput `json:"customTimeframe,omitempty"`
}

// Define settings for a policy section
type PolicySectionInfo struct {
	ID          string  `json:"id"`
	Name        string  `json:"name"`
	SubPolicyID *string `json:"subPolicyId,omitempty"`
}

type PolicySectionMutationPayload struct {
	Errors  []*PolicyMutationError `json:"errors"`
	Section *PolicySectionPayload  `json:"section,omitempty"`
	Status  PolicyMutationStatus   `json:"status"`
}

type PolicySectionPayload struct {
	Access     *EntityAccess                 `json:"access,omitempty"`
	Audit      *PolicyElementAudit           `json:"audit"`
	Properties []PolicyElementPropertiesEnum `json:"properties"`
	Section    *PolicySectionInfo            `json:"section"`
}

type PolicySectionPositionInput struct {
	Position PolicySectionPositionEnum `json:"position"`
	Ref      *string                   `json:"ref,omitempty"`
}

// Parameters required to define the rule position
type PolicySubRulePositionInput struct {
	Position PolicySubRulePositionEnum `json:"position"`
	Ref      string                    `json:"ref"`
}

type PolicyTracking struct {
	Alert *PolicyRuleTrackingAlert `json:"alert"`
	Event *PolicyRuleTrackingEvent `json:"event"`
}

type PolicyTrackingInput struct {
	Alert *PolicyRuleTrackingAlertInput `json:"alert"`
	Event *PolicyRuleTrackingEventInput `json:"event"`
}

type PolicyTrackingUpdateInput struct {
	Alert *PolicyRuleTrackingAlertUpdateInput `json:"alert,omitempty"`
	Event *PolicyRuleTrackingEventUpdateInput `json:"event,omitempty"`
}

type PolicyUpdateSectionInfoInput struct {
	Name *string `json:"name,omitempty"`
}

type PolicyUpdateSectionInput struct {
	ID      string                        `json:"id"`
	Section *PolicyUpdateSectionInfoInput `json:"section"`
}

type PooledBandwidthLicense struct {
	Accounts           []*PartnerPooledBandwidthLicenseAccount `json:"accounts"`
	AllocatedBandwidth int64                                   `json:"allocatedBandwidth"`
	Description        *string                                 `json:"description,omitempty"`
	ExpirationDate     string                                  `json:"expirationDate"`
	ID                 *string                                 `json:"id,omitempty"`
	LastUpdated        *string                                 `json:"lastUpdated,omitempty"`
	Plan               LicensePlan                             `json:"plan"`
	SiteLicenseGroup   SiteLicenseGroup                        `json:"siteLicenseGroup"`
	SiteLicenseType    SiteLicenseType                         `json:"siteLicenseType"`
	Sites              []*PooledBandwidthLicenseSite           `json:"sites"`
	Sku                LicenseSku                              `json:"sku"`
	StartDate          *string                                 `json:"startDate,omitempty"`
	Status             LicenseStatus                           `json:"status"`
	Total              int64                                   `json:"total"`
}

func (PooledBandwidthLicense) IsLicense()                     {}
func (this PooledBandwidthLicense) GetDescription() *string   { return this.Description }
func (this PooledBandwidthLicense) GetExpirationDate() string { return this.ExpirationDate }
func (this PooledBandwidthLicense) GetID() *string            { return this.ID }
func (this PooledBandwidthLicense) GetLastUpdated() *string   { return this.LastUpdated }
func (this PooledBandwidthLicense) GetPlan() LicensePlan      { return this.Plan }
func (this PooledBandwidthLicense) GetSku() LicenseSku        { return this.Sku }
func (this PooledBandwidthLicense) GetStartDate() *string     { return this.StartDate }
func (this PooledBandwidthLicense) GetStatus() LicenseStatus  { return this.Status }

func (PooledBandwidthLicense) IsQuantifiableLicense() {}

func (this PooledBandwidthLicense) GetTotal() int64 { return this.Total }

type PooledBandwidthLicenseSite struct {
	AllocatedBandwidth int64    `json:"allocatedBandwidth"`
	Site               *SiteRef `json:"site"`
}

type PopLocation struct {
	CloudInterconnect []*PopLocationCloudInterconnect `json:"cloudInterconnect"`
	Country           *CountryRef                     `json:"country"`
	DisplayName       string                          `json:"displayName"`
	ID                string                          `json:"id"`
	IsPrivate         bool                            `json:"isPrivate"`
	Name              string                          `json:"name"`
}

type PopLocationCloudInterconnect struct {
	ProviderName  string        `json:"providerName"`
	TaggingMethod TaggingMethod `json:"taggingMethod"`
}

type PopLocationCloudInterconnectFilterInput struct {
	TaggingMethod *TaggingMethodFilterInput `json:"taggingMethod,omitempty"`
}

type PopLocationFilterInput struct {
	Country             *CountryRefFilterInput                   `json:"country,omitempty"`
	ID                  *IDFilterInput                           `json:"id,omitempty"`
	InterconnectTagging *PopLocationCloudInterconnectFilterInput `json:"interconnectTagging,omitempty"`
	IsPrivate           *BooleanFilterInput                      `json:"isPrivate,omitempty"`
	Name                *StringFilterInput                       `json:"name,omitempty"`
	Primary             *BooleanFilterInput                      `json:"primary,omitempty"`
	SiteLicenseRegion   *StringFilterInput                       `json:"siteLicenseRegion,omitempty"`
}

type PopLocationPayload struct {
	Items []*PopLocation `json:"items"`
}

type PopLocationQueries struct {
	PopLocationList *PopLocationPayload `json:"popLocationList,omitempty"`
}

// A reference identifying the PopLocation object. ID: Unique PopLocation Identifier, Name: The PopLocation Name
type PopLocationRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (PopLocationRef) IsObjectRef()         {}
func (this PopLocationRef) GetID() string   { return this.ID }
func (this PopLocationRef) GetName() string { return this.Name }

type PopLocationRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

// Inclusive network port range
type PortRange struct {
	From scalars.Port `json:"from"`
	To   scalars.Port `json:"to"`
}

// Inclusive network port range
type PortRangeInput struct {
	From scalars.Port `json:"from"`
	To   scalars.Port `json:"to"`
}

type PortRangeUpdateInput struct {
	From *scalars.Port `json:"from,omitempty"`
	To   *scalars.Port `json:"to,omitempty"`
}

type PostalAddress struct {
	AddressValidated AddressValidationStatus `json:"addressValidated"`
	CityName         *string                 `json:"cityName,omitempty"`
	Country          *CountryRef             `json:"country"`
	StateName        *string                 `json:"stateName,omitempty"`
	Street           *string                 `json:"street,omitempty"`
	ZipCode          *string                 `json:"zipCode,omitempty"`
}

type PostalAddressInput struct {
	CityName  *string          `json:"cityName,omitempty"`
	Country   *CountryRefInput `json:"country"`
	StateName *string          `json:"stateName,omitempty"`
	Street    *string          `json:"street,omitempty"`
	ZipCode   *string          `json:"zipCode,omitempty"`
}

type PrivateAccessAddRuleDataInput struct {
	Action           *PrivateAccessPolicyActionInput      `json:"action"`
	ActivePeriod     *PolicyRuleActivePeriodInput         `json:"activePeriod"`
	Applications     *PrivateAccessPolicyApplicationInput `json:"applications"`
	ConnectionOrigin []PrivateAccessPolicyOriginEnum      `json:"connectionOrigin"`
	Country          []*CountryRefInput                   `json:"country"`
	Description      string                               `json:"description"`
	Device           []*DeviceProfileRefInput             `json:"device"`
	Enabled          bool                                 `json:"enabled"`
	Name             string                               `json:"name"`
	Platform         []OperatingSystem                    `json:"platform"`
	Schedule         *PolicyScheduleInput                 `json:"schedule"`
	Source           *PrivateAccessPolicySourceInput      `json:"source"`
	Tracking         *PolicyTrackingInput                 `json:"tracking"`
	UserAttributes   *PrivateAccessUserAttributesInput    `json:"userAttributes"`
}

type PrivateAccessAddRuleInput struct {
	At   *PolicyRulePositionInput       `json:"at,omitempty"`
	Rule *PrivateAccessAddRuleDataInput `json:"rule"`
}

type PrivateAccessPolicy struct {
	Audit    *PolicyAudit                `json:"audit,omitempty"`
	Enabled  bool                        `json:"enabled"`
	Revision *PolicyRevision             `json:"revision,omitempty"`
	Rules    []*PrivateAccessRulePayload `json:"rules"`
	Sections []*PolicySectionPayload     `json:"sections"`
}

func (PrivateAccessPolicy) IsIPolicy()                        {}
func (this PrivateAccessPolicy) GetAudit() *PolicyAudit       { return this.Audit }
func (this PrivateAccessPolicy) GetEnabled() bool             { return this.Enabled }
func (this PrivateAccessPolicy) GetRevision() *PolicyRevision { return this.Revision }
func (this PrivateAccessPolicy) GetRules() []IPolicyRulePayload {
	if this.Rules == nil {
		return nil
	}
	interfaceSlice := make([]IPolicyRulePayload, 0, len(this.Rules))
	for _, concrete := range this.Rules {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this PrivateAccessPolicy) GetSections() []*PolicySectionPayload {
	if this.Sections == nil {
		return nil
	}
	interfaceSlice := make([]*PolicySectionPayload, 0, len(this.Sections))
	for _, concrete := range this.Sections {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

type PrivateAccessPolicyAction struct {
	Action PrivateAccessPolicyActionEnum `json:"action"`
}

type PrivateAccessPolicyActionInput struct {
	Action PrivateAccessPolicyActionEnum `json:"action"`
}

type PrivateAccessPolicyActionUpdateInput struct {
	Action *PrivateAccessPolicyActionEnum `json:"action,omitempty"`
}

type PrivateAccessPolicyApplication struct {
	Application []*PrivateApplicationRef `json:"application"`
}

type PrivateAccessPolicyApplicationInput struct {
	Application []*PrivateApplicationRefInput `json:"application"`
}

type PrivateAccessPolicyApplicationUpdateInput struct {
	Application []*PrivateApplicationRefInput `json:"application,omitempty"`
}

type PrivateAccessPolicyInput struct {
	Revision *PolicyRevisionInput `json:"revision,omitempty"`
}

type PrivateAccessPolicyMutationInput struct {
	Revision *PolicyMutationRevisionInput `json:"revision,omitempty"`
}

type PrivateAccessPolicyMutationPayload struct {
	Errors []*PolicyMutationError `json:"errors"`
	Policy *PrivateAccessPolicy   `json:"policy,omitempty"`
	Status PolicyMutationStatus   `json:"status"`
}

func (PrivateAccessPolicyMutationPayload) IsIPolicyMutationPayload() {}
func (this PrivateAccessPolicyMutationPayload) GetErrors() []*PolicyMutationError {
	if this.Errors == nil {
		return nil
	}
	interfaceSlice := make([]*PolicyMutationError, 0, len(this.Errors))
	for _, concrete := range this.Errors {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this PrivateAccessPolicyMutationPayload) GetPolicy() IPolicy              { return *this.Policy }
func (this PrivateAccessPolicyMutationPayload) GetStatus() PolicyMutationStatus { return this.Status }

type PrivateAccessPolicyMutations struct {
	AddRule               *PrivateAccessRuleMutationPayload   `json:"addRule"`
	AddSection            *PolicySectionMutationPayload       `json:"addSection"`
	CreatePolicyRevision  *PrivateAccessPolicyMutationPayload `json:"createPolicyRevision"`
	DiscardPolicyRevision *PrivateAccessPolicyMutationPayload `json:"discardPolicyRevision"`
	MoveRule              *PrivateAccessRuleMutationPayload   `json:"moveRule"`
	MoveSection           *PolicySectionMutationPayload       `json:"moveSection"`
	PublishPolicyRevision *PrivateAccessPolicyMutationPayload `json:"publishPolicyRevision"`
	RemoveRule            *PrivateAccessRuleMutationPayload   `json:"removeRule"`
	RemoveSection         *PolicySectionMutationPayload       `json:"removeSection"`
	UpdatePolicy          *PrivateAccessPolicyMutationPayload `json:"updatePolicy"`
	UpdateRule            *PrivateAccessRuleMutationPayload   `json:"updateRule"`
	UpdateSection         *PolicySectionMutationPayload       `json:"updateSection"`
}

type PrivateAccessPolicyQueries struct {
	Policy    *PrivateAccessPolicy    `json:"policy"`
	Revisions *PolicyRevisionsPayload `json:"revisions,omitempty"`
}

type PrivateAccessPolicySource struct {
	User       []*UserRef       `json:"user"`
	UsersGroup []*UsersGroupRef `json:"usersGroup"`
}

type PrivateAccessPolicySourceInput struct {
	User       []*UserRefInput       `json:"user"`
	UsersGroup []*UsersGroupRefInput `json:"usersGroup"`
}

type PrivateAccessPolicySourceUpdateInput struct {
	User       []*UserRefInput       `json:"user,omitempty"`
	UsersGroup []*UsersGroupRefInput `json:"usersGroup,omitempty"`
}

type PrivateAccessPolicyUpdateInput struct {
	State *PolicyToggleState `json:"state,omitempty"`
}

type PrivateAccessRemoveRuleInput struct {
	ID string `json:"id"`
}

type PrivateAccessRule struct {
	Action           *PrivateAccessPolicyAction      `json:"action"`
	ActivePeriod     *PolicyRuleActivePeriod         `json:"activePeriod"`
	Applications     *PrivateAccessPolicyApplication `json:"applications"`
	ConnectionOrigin []PrivateAccessPolicyOriginEnum `json:"connectionOrigin"`
	Country          []*CountryRef                   `json:"country"`
	Description      string                          `json:"description"`
	Device           []*DeviceProfileRef             `json:"device"`
	Enabled          bool                            `json:"enabled"`
	ID               string                          `json:"id"`
	Index            int64                           `json:"index"`
	Name             string                          `json:"name"`
	Platform         []OperatingSystem               `json:"platform"`
	Schedule         *PolicySchedule                 `json:"schedule"`
	Section          *PolicySectionInfo              `json:"section"`
	Source           *PrivateAccessPolicySource      `json:"source"`
	Tracking         *PolicyTracking                 `json:"tracking"`
	UserAttributes   *PrivateAccessUserAttributes    `json:"userAttributes"`
}

func (PrivateAccessRule) IsIPolicyRule()                      {}
func (this PrivateAccessRule) GetDescription() *string        { return &this.Description }
func (this PrivateAccessRule) GetEnabled() bool               { return this.Enabled }
func (this PrivateAccessRule) GetID() string                  { return this.ID }
func (this PrivateAccessRule) GetIndex() int64                { return this.Index }
func (this PrivateAccessRule) GetName() string                { return this.Name }
func (this PrivateAccessRule) GetSection() *PolicySectionInfo { return this.Section }

type PrivateAccessRuleMutationPayload struct {
	Errors []*PolicyMutationError    `json:"errors"`
	Rule   *PrivateAccessRulePayload `json:"rule,omitempty"`
	Status PolicyMutationStatus      `json:"status"`
}

func (PrivateAccessRuleMutationPayload) IsIPolicyRuleMutationPayload() {}
func (this PrivateAccessRuleMutationPayload) GetErrors() []*PolicyMutationError {
	if this.Errors == nil {
		return nil
	}
	interfaceSlice := make([]*PolicyMutationError, 0, len(this.Errors))
	for _, concrete := range this.Errors {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this PrivateAccessRuleMutationPayload) GetRule() IPolicyRulePayload     { return *this.Rule }
func (this PrivateAccessRuleMutationPayload) GetStatus() PolicyMutationStatus { return this.Status }

type PrivateAccessRulePayload struct {
	Audit      *PolicyElementAudit           `json:"audit"`
	Properties []PolicyElementPropertiesEnum `json:"properties"`
	Rule       *PrivateAccessRule            `json:"rule"`
}

func (PrivateAccessRulePayload) IsIPolicyRulePayload()              {}
func (this PrivateAccessRulePayload) GetAudit() *PolicyElementAudit { return this.Audit }
func (this PrivateAccessRulePayload) GetProperties() []PolicyElementPropertiesEnum {
	if this.Properties == nil {
		return nil
	}
	interfaceSlice := make([]PolicyElementPropertiesEnum, 0, len(this.Properties))
	for _, concrete := range this.Properties {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this PrivateAccessRulePayload) GetRule() IPolicyRule { return *this.Rule }

type PrivateAccessUpdateRuleDataInput struct {
	Action           *PrivateAccessPolicyActionUpdateInput      `json:"action,omitempty"`
	ActivePeriod     *PolicyRuleActivePeriodUpdateInput         `json:"activePeriod,omitempty"`
	Applications     *PrivateAccessPolicyApplicationUpdateInput `json:"applications,omitempty"`
	ConnectionOrigin []PrivateAccessPolicyOriginEnum            `json:"connectionOrigin,omitempty"`
	Country          []*CountryRefInput                         `json:"country,omitempty"`
	Description      *string                                    `json:"description,omitempty"`
	Device           []*DeviceProfileRefInput                   `json:"device,omitempty"`
	Enabled          *bool                                      `json:"enabled,omitempty"`
	Name             *string                                    `json:"name,omitempty"`
	Platform         []OperatingSystem                          `json:"platform,omitempty"`
	Schedule         *PolicyScheduleUpdateInput                 `json:"schedule,omitempty"`
	Source           *PrivateAccessPolicySourceUpdateInput      `json:"source,omitempty"`
	Tracking         *PolicyTrackingUpdateInput                 `json:"tracking,omitempty"`
	UserAttributes   *PrivateAccessUserAttributesUpdateInput    `json:"userAttributes,omitempty"`
}

type PrivateAccessUpdateRuleInput struct {
	ID   string                            `json:"id"`
	Rule *PrivateAccessUpdateRuleDataInput `json:"rule"`
}

type PrivateAccessUserAttributes struct {
	RiskScore *RiskScoreCondition `json:"riskScore"`
}

func (PrivateAccessUserAttributes) IsUserAttributes()                      {}
func (this PrivateAccessUserAttributes) GetRiskScore() *RiskScoreCondition { return this.RiskScore }

type PrivateAccessUserAttributesInput struct {
	RiskScore *RiskScoreConditionInput `json:"riskScore"`
}

type PrivateAccessUserAttributesUpdateInput struct {
	RiskScore *RiskScoreConditionUpdateInput `json:"riskScore,omitempty"`
}

type PrivateAppProbing struct {
	FaultThresholdDown int64  `json:"faultThresholdDown"`
	ID                 string `json:"id"`
	Interval           int64  `json:"interval"`
	Type               string `json:"type"`
}

type PrivateAppProbingInput struct {
	FaultThresholdDown *int64  `json:"faultThresholdDown,omitempty"`
	ID                 *string `json:"id,omitempty"`
	Interval           *int64  `json:"interval,omitempty"`
	Type               *string `json:"type,omitempty"`
}

type PrivateApplication struct {
	AllowICMPProtocol  bool                `json:"allowIcmpProtocol"`
	CreationTime       string              `json:"creationTime"`
	Description        *string             `json:"description,omitempty"`
	ID                 string              `json:"id"`
	InternalAppAddress string              `json:"internalAppAddress"`
	Name               string              `json:"name"`
	PrivateAppProbing  *PrivateAppProbing  `json:"privateAppProbing,omitempty"`
	ProbingEnabled     bool                `json:"probingEnabled"`
	ProtocolPorts      []*CustomService    `json:"protocolPorts"`
	Published          bool                `json:"published"`
	PublishedAppDomain *PublishedAppDomain `json:"publishedAppDomain,omitempty"`
}

type PrivateApplicationListPayload struct {
	Applications []*PrivateApplication `json:"applications"`
}

// A reference identifying of the PrivateApplication object. ID: Unique PrivateApplication Identifier,
// Name: The PrivateApplication Name
type PrivateApplicationRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (PrivateApplicationRef) IsObjectRef()         {}
func (this PrivateApplicationRef) GetID() string   { return this.ID }
func (this PrivateApplicationRef) GetName() string { return this.Name }

type PrivateApplicationRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

// Public IP address license
type PublicIpsLicense struct {
	Description    *string       `json:"description,omitempty"`
	ExpirationDate string        `json:"expirationDate"`
	ID             *string       `json:"id,omitempty"`
	LastUpdated    *string       `json:"lastUpdated,omitempty"`
	Plan           LicensePlan   `json:"plan"`
	Sku            LicenseSku    `json:"sku"`
	StartDate      *string       `json:"startDate,omitempty"`
	Status         LicenseStatus `json:"status"`
	Total          int64         `json:"total"`
}

func (PublicIpsLicense) IsLicense()                     {}
func (this PublicIpsLicense) GetDescription() *string   { return this.Description }
func (this PublicIpsLicense) GetExpirationDate() string { return this.ExpirationDate }
func (this PublicIpsLicense) GetID() *string            { return this.ID }
func (this PublicIpsLicense) GetLastUpdated() *string   { return this.LastUpdated }
func (this PublicIpsLicense) GetPlan() LicensePlan      { return this.Plan }
func (this PublicIpsLicense) GetSku() LicenseSku        { return this.Sku }
func (this PublicIpsLicense) GetStartDate() *string     { return this.StartDate }
func (this PublicIpsLicense) GetStatus() LicenseStatus  { return this.Status }

func (PublicIpsLicense) IsQuantifiableLicense() {}

func (this PublicIpsLicense) GetTotal() int64 { return this.Total }

// IP addresses license usage and allocation across all accounts
type PublicIpsLicenseAllocations struct {
	Allocated int64 `json:"allocated"`
	Available int64 `json:"available"`
	Total     int64 `json:"total"`
}

type PublishedAppDomain struct {
	CatoIP             *string `json:"catoIp,omitempty"`
	ConnectorGroupName *string `json:"connectorGroupName,omitempty"`
	CreationTime       string  `json:"creationTime"`
	ID                 string  `json:"id"`
	PublishedAppDomain string  `json:"publishedAppDomain"`
}

type PublishedAppDomainInput struct {
	CatoIP             *string `json:"catoIp,omitempty"`
	ConnectorGroupName *string `json:"connectorGroupName,omitempty"`
	CreationTime       *string `json:"creationTime,omitempty"`
	ID                 *string `json:"id,omitempty"`
	PublishedAppDomain *string `json:"publishedAppDomain,omitempty"`
}

type Query struct {
}

type RBACRole struct {
	Description  *string `json:"description,omitempty"`
	ID           string  `json:"id"`
	IsPredefined bool    `json:"isPredefined"`
	Name         string  `json:"name"`
}

type RbacGroup struct {
	ID   string  `json:"id"`
	Name *string `json:"name,omitempty"`
}

// Remote Browser Isolation (RBI) service license details
type RbiLicense struct {
	Description    *string       `json:"description,omitempty"`
	ExpirationDate string        `json:"expirationDate"`
	ID             *string       `json:"id,omitempty"`
	LastUpdated    *string       `json:"lastUpdated,omitempty"`
	Plan           LicensePlan   `json:"plan"`
	Sku            LicenseSku    `json:"sku"`
	StartDate      *string       `json:"startDate,omitempty"`
	Status         LicenseStatus `json:"status"`
}

func (RbiLicense) IsLicense()                     {}
func (this RbiLicense) GetDescription() *string   { return this.Description }
func (this RbiLicense) GetExpirationDate() string { return this.ExpirationDate }
func (this RbiLicense) GetID() *string            { return this.ID }
func (this RbiLicense) GetLastUpdated() *string   { return this.LastUpdated }
func (this RbiLicense) GetPlan() LicensePlan      { return this.Plan }
func (this RbiLicense) GetSku() LicenseSku        { return this.Sku }
func (this RbiLicense) GetStartDate() *string     { return this.StartDate }
func (this RbiLicense) GetStatus() LicenseStatus  { return this.Status }

type RecentConnection struct {
	DeviceName    *string `json:"deviceName,omitempty"`
	Duration      *int64  `json:"duration,omitempty"`
	InterfaceName *string `json:"interfaceName,omitempty"`
	LastConnected *string `json:"lastConnected,omitempty"`
	PopName       *string `json:"popName,omitempty"`
	RemoteIP      *string `json:"remoteIP,omitempty"`
	RemoteIPInfo  *IPInfo `json:"remoteIPInfo,omitempty"`
}

type RemotePortFwdAddRuleDataInput struct {
	Description       string                        `json:"description"`
	Enabled           bool                          `json:"enabled"`
	ExternalIP        *AllocatedIPRefInput          `json:"externalIp"`
	ExternalPortRange *PortRangeInput               `json:"externalPortRange"`
	ForwardICMP       bool                          `json:"forwardIcmp"`
	InternalIP        string                        `json:"internalIp"`
	InternalPortRange *PortRangeInput               `json:"internalPortRange"`
	Name              string                        `json:"name"`
	RemoteIPs         *RemotePortFwdRemoteIpsInput  `json:"remoteIPs"`
	RestrictionType   RemotePortFwdRestrictionType  `json:"restrictionType"`
	Tracking          *PolicyRuleTrackingAlertInput `json:"tracking"`
}

// Rule parameters and relevant position
type RemotePortFwdAddRuleInput struct {
	At   *PolicyRulePositionInput       `json:"at,omitempty"`
	Rule *RemotePortFwdAddRuleDataInput `json:"rule"`
}

type RemotePortFwdPolicy struct {
	Audit    *PolicyAudit                `json:"audit,omitempty"`
	Enabled  bool                        `json:"enabled"`
	Revision *PolicyRevision             `json:"revision,omitempty"`
	Rules    []*RemotePortFwdRulePayload `json:"rules"`
	Sections []*PolicySectionPayload     `json:"sections"`
}

func (RemotePortFwdPolicy) IsIPolicy()                        {}
func (this RemotePortFwdPolicy) GetAudit() *PolicyAudit       { return this.Audit }
func (this RemotePortFwdPolicy) GetEnabled() bool             { return this.Enabled }
func (this RemotePortFwdPolicy) GetRevision() *PolicyRevision { return this.Revision }
func (this RemotePortFwdPolicy) GetRules() []IPolicyRulePayload {
	if this.Rules == nil {
		return nil
	}
	interfaceSlice := make([]IPolicyRulePayload, 0, len(this.Rules))
	for _, concrete := range this.Rules {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this RemotePortFwdPolicy) GetSections() []*PolicySectionPayload {
	if this.Sections == nil {
		return nil
	}
	interfaceSlice := make([]*PolicySectionPayload, 0, len(this.Sections))
	for _, concrete := range this.Sections {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

type RemotePortFwdPolicyInput struct {
	Revision *PolicyRevisionInput `json:"revision,omitempty"`
}

type RemotePortFwdPolicyMutationInput struct {
	Revision *PolicyMutationRevisionInput `json:"revision,omitempty"`
}

// Remote port forwarding policy information provided in the API response
type RemotePortFwdPolicyMutationPayload struct {
	Errors []*PolicyMutationError `json:"errors"`
	Policy *RemotePortFwdPolicy   `json:"policy,omitempty"`
	Status PolicyMutationStatus   `json:"status"`
}

func (RemotePortFwdPolicyMutationPayload) IsIPolicyMutationPayload() {}
func (this RemotePortFwdPolicyMutationPayload) GetErrors() []*PolicyMutationError {
	if this.Errors == nil {
		return nil
	}
	interfaceSlice := make([]*PolicyMutationError, 0, len(this.Errors))
	for _, concrete := range this.Errors {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this RemotePortFwdPolicyMutationPayload) GetPolicy() IPolicy              { return *this.Policy }
func (this RemotePortFwdPolicyMutationPayload) GetStatus() PolicyMutationStatus { return this.Status }

// The Remote Port Forwarding Policy information returned to the caller in the API response.
type RemotePortFwdPolicyMutations struct {
	AddRule               *RemotePortFwdRuleMutationPayload   `json:"addRule"`
	AddSection            *PolicySectionMutationPayload       `json:"addSection"`
	CreatePolicyRevision  *RemotePortFwdPolicyMutationPayload `json:"createPolicyRevision"`
	DiscardPolicyRevision *RemotePortFwdPolicyMutationPayload `json:"discardPolicyRevision"`
	MoveRule              *RemotePortFwdRuleMutationPayload   `json:"moveRule"`
	MoveSection           *PolicySectionMutationPayload       `json:"moveSection"`
	PublishPolicyRevision *RemotePortFwdPolicyMutationPayload `json:"publishPolicyRevision"`
	RemoveRule            *RemotePortFwdRuleMutationPayload   `json:"removeRule"`
	RemoveSection         *PolicySectionMutationPayload       `json:"removeSection"`
	UpdatePolicy          *RemotePortFwdPolicyMutationPayload `json:"updatePolicy"`
	UpdateRule            *RemotePortFwdRuleMutationPayload   `json:"updateRule"`
	UpdateSection         *PolicySectionMutationPayload       `json:"updateSection"`
}

type RemotePortFwdPolicyQueries struct {
	Policy    *RemotePortFwdPolicy    `json:"policy"`
	Revisions *PolicyRevisionsPayload `json:"revisions,omitempty"`
}

type RemotePortFwdPolicyUpdateInput struct {
	State *PolicyToggleState `json:"state,omitempty"`
}

type RemotePortFwdRemoteIps struct {
	GlobalIPRange []*GlobalIPRangeRef `json:"globalIpRange"`
	IP            []string            `json:"ip"`
	IPRange       []*IPAddressRange   `json:"ipRange"`
	Subnet        []string            `json:"subnet"`
}

type RemotePortFwdRemoteIpsInput struct {
	GlobalIPRange []*GlobalIPRangeRefInput `json:"globalIpRange"`
	IP            []string                 `json:"ip"`
	IPRange       []*IPAddressRangeInput   `json:"ipRange"`
	Subnet        []string                 `json:"subnet"`
}

type RemotePortFwdRemoteIpsUpdateInput struct {
	GlobalIPRange []*GlobalIPRangeRefInput `json:"globalIpRange,omitempty"`
	IP            []string                 `json:"ip,omitempty"`
	IPRange       []*IPAddressRangeInput   `json:"ipRange,omitempty"`
	Subnet        []string                 `json:"subnet,omitempty"`
}

type RemotePortFwdRemoveRuleInput struct {
	ID string `json:"id"`
}

type RemotePortFwdRule struct {
	Description       string                       `json:"description"`
	Enabled           bool                         `json:"enabled"`
	ExternalIP        *AllocatedIPRef              `json:"externalIp"`
	ExternalPortRange *PortRange                   `json:"externalPortRange"`
	ForwardICMP       bool                         `json:"forwardIcmp"`
	ID                string                       `json:"id"`
	Index             int64                        `json:"index"`
	InternalIP        string                       `json:"internalIp"`
	InternalPortRange *PortRange                   `json:"internalPortRange"`
	Name              string                       `json:"name"`
	RemoteIPs         *RemotePortFwdRemoteIps      `json:"remoteIPs"`
	RestrictionType   RemotePortFwdRestrictionType `json:"restrictionType"`
	Section           *PolicySectionInfo           `json:"section"`
	Tracking          *PolicyRuleTrackingAlert     `json:"tracking"`
}

func (RemotePortFwdRule) IsIPolicyRule()                      {}
func (this RemotePortFwdRule) GetDescription() *string        { return &this.Description }
func (this RemotePortFwdRule) GetEnabled() bool               { return this.Enabled }
func (this RemotePortFwdRule) GetID() string                  { return this.ID }
func (this RemotePortFwdRule) GetIndex() int64                { return this.Index }
func (this RemotePortFwdRule) GetName() string                { return this.Name }
func (this RemotePortFwdRule) GetSection() *PolicySectionInfo { return this.Section }

type RemotePortFwdRuleMutationPayload struct {
	Errors []*PolicyMutationError    `json:"errors"`
	Rule   *RemotePortFwdRulePayload `json:"rule,omitempty"`
	Status PolicyMutationStatus      `json:"status"`
}

func (RemotePortFwdRuleMutationPayload) IsIPolicyRuleMutationPayload() {}
func (this RemotePortFwdRuleMutationPayload) GetErrors() []*PolicyMutationError {
	if this.Errors == nil {
		return nil
	}
	interfaceSlice := make([]*PolicyMutationError, 0, len(this.Errors))
	for _, concrete := range this.Errors {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this RemotePortFwdRuleMutationPayload) GetRule() IPolicyRulePayload     { return *this.Rule }
func (this RemotePortFwdRuleMutationPayload) GetStatus() PolicyMutationStatus { return this.Status }

type RemotePortFwdRulePayload struct {
	Audit      *PolicyElementAudit           `json:"audit"`
	Properties []PolicyElementPropertiesEnum `json:"properties"`
	Rule       *RemotePortFwdRule            `json:"rule"`
}

func (RemotePortFwdRulePayload) IsIPolicyRulePayload()              {}
func (this RemotePortFwdRulePayload) GetAudit() *PolicyElementAudit { return this.Audit }
func (this RemotePortFwdRulePayload) GetProperties() []PolicyElementPropertiesEnum {
	if this.Properties == nil {
		return nil
	}
	interfaceSlice := make([]PolicyElementPropertiesEnum, 0, len(this.Properties))
	for _, concrete := range this.Properties {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this RemotePortFwdRulePayload) GetRule() IPolicyRule { return *this.Rule }

type RemotePortFwdUpdateRuleDataInput struct {
	Description       *string                             `json:"description,omitempty"`
	Enabled           *bool                               `json:"enabled,omitempty"`
	ExternalIP        *AllocatedIPRefInput                `json:"externalIp,omitempty"`
	ExternalPortRange *PortRangeUpdateInput               `json:"externalPortRange,omitempty"`
	ForwardICMP       *bool                               `json:"forwardIcmp,omitempty"`
	InternalIP        *string                             `json:"internalIp,omitempty"`
	InternalPortRange *PortRangeUpdateInput               `json:"internalPortRange,omitempty"`
	Name              *string                             `json:"name,omitempty"`
	RemoteIPs         *RemotePortFwdRemoteIpsUpdateInput  `json:"remoteIPs,omitempty"`
	RestrictionType   *RemotePortFwdRestrictionType       `json:"restrictionType,omitempty"`
	Tracking          *PolicyRuleTrackingAlertUpdateInput `json:"tracking,omitempty"`
}

type RemotePortFwdUpdateRuleInput struct {
	ID   string                            `json:"id"`
	Rule *RemotePortFwdUpdateRuleDataInput `json:"rule"`
}

type RemoveAccountPayload struct {
	AccountInfo *AccountInfo `json:"accountInfo"`
}

type RemoveAdminPayload struct {
	AdminID string `json:"adminID"`
}

type RemoveBgpPeerInput struct {
	ID string `json:"id"`
}

type RemoveBgpPeerPayload struct {
	BgpPeer *BgpPeer `json:"bgpPeer"`
}

// Input for removing a physical connection from a cloud interconnect site.
type RemoveCloudInterconnectPhysicalConnectionInput struct {
	ID string `json:"id"`
}

// Payload for removing a physical connection from a cloud interconnect site.
type RemoveCloudInterconnectPhysicalConnectionPayload struct {
	ID string `json:"id"`
}

type RemoveIpsecIkeV2SiteMultiTunnelPayload struct {
	Fqdn    *string                              `json:"fqdn,omitempty"`
	Tunnels []*RemoveIpsecIkeV2SiteTunnelPayload `json:"tunnels"`
}

type RemoveIpsecIkeV2SiteTunnelPayload struct {
	LocalID  *string             `json:"localId,omitempty"`
	TunnelID *IPSecV2InterfaceID `json:"tunnelId,omitempty"`
}

type RemoveIpsecIkeV2SiteTunnelsInput struct {
	TunnelID []IPSecV2InterfaceID `json:"tunnelId"`
}

type RemoveIpsecIkeV2SiteTunnelsPayload struct {
	Primary   *RemoveIpsecIkeV2SiteMultiTunnelPayload `json:"primary,omitempty"`
	Secondary *RemoveIpsecIkeV2SiteMultiTunnelPayload `json:"secondary,omitempty"`
	SiteID    string                                  `json:"siteId"`
}

type RemoveNetworkRangePayload struct {
	NetworkRangeID string `json:"networkRangeId"`
}

type RemoveSecondaryAWSVSocketPayload struct {
	SecondaryAWSVSocket *SecondaryAWSVSocket `json:"secondaryAwsVSocket"`
}

type RemoveSecondaryAzureVSocketPayload struct {
	SecondaryAzureVSocket *SecondaryAzureVSocket `json:"secondaryAzureVSocket"`
}

type RemoveServicePrincipalAdminPayload struct {
	AdminID string `json:"adminID"`
}

type RemoveSiteBwLicenseInput struct {
	LicenseID string        `json:"licenseId"`
	Site      *SiteRefInput `json:"site"`
}

type RemoveSiteBwLicensePayload struct {
	License License `json:"license"`
}

type RemoveSitePayload struct {
	SiteID string `json:"siteId"`
}

type RemoveSocketAddOnCardInput struct {
	ExpansionSlotNumbers []SocketAddOnExpansionSlotNumber `json:"expansionSlotNumbers"`
	Site                 *SiteRefInput                    `json:"site"`
}

type RemoveSocketAddOnCardPayload struct {
	AddOns []*SocketAddOnCard `json:"addOns"`
}

type RemoveStaticHostPayload struct {
	HostID string `json:"hostId"`
}

type RemoveZtnaAppConnectorInput struct {
	ZtnaAppConnector *ZtnaAppConnectorRefInput `json:"ztnaAppConnector"`
}

type RemoveZtnaAppConnectorPayload struct {
	ZtnaAppConnector *ZtnaAppConnector `json:"ztnaAppConnector"`
}

// Payload returned after removing ZTNA App Connectors configuration.
type RemoveZtnaAppConnectorsConfigurationPayload struct {
	ZtnaAppConnectorsConfiguration *ZtnaAppConnectorsConfiguration `json:"ztnaAppConnectorsConfiguration"`
}

type ReplaceSiteBwLicenseInput struct {
	Bw                *int64        `json:"bw,omitempty"`
	LicenseIDToAdd    string        `json:"licenseIdToAdd"`
	LicenseIDToRemove string        `json:"licenseIdToRemove"`
	Site              *SiteRefInput `json:"site"`
}

type ReplaceSiteBwLicensePayload struct {
	License License `json:"license"`
}

type RiskScoreCondition struct {
	Category RiskScoreCategory `json:"category"`
	Operator RiskScoreOperator `json:"operator"`
}

type RiskScoreConditionInput struct {
	Category RiskScoreCategory `json:"category"`
	Operator RiskScoreOperator `json:"operator"`
}

type RiskScoreConditionUpdateInput struct {
	Category *RiskScoreCategory `json:"category,omitempty"`
	Operator *RiskScoreOperator `json:"operator,omitempty"`
}

// SaaS Security API service license details
type SaasSecurityAPILicense struct {
	Description    *string       `json:"description,omitempty"`
	ExpirationDate string        `json:"expirationDate"`
	ID             *string       `json:"id,omitempty"`
	LastUpdated    *string       `json:"lastUpdated,omitempty"`
	Plan           LicensePlan   `json:"plan"`
	Sku            LicenseSku    `json:"sku"`
	StartDate      *string       `json:"startDate,omitempty"`
	Status         LicenseStatus `json:"status"`
	Total          int64         `json:"total"`
}

func (SaasSecurityAPILicense) IsLicense()                     {}
func (this SaasSecurityAPILicense) GetDescription() *string   { return this.Description }
func (this SaasSecurityAPILicense) GetExpirationDate() string { return this.ExpirationDate }
func (this SaasSecurityAPILicense) GetID() *string            { return this.ID }
func (this SaasSecurityAPILicense) GetLastUpdated() *string   { return this.LastUpdated }
func (this SaasSecurityAPILicense) GetPlan() LicensePlan      { return this.Plan }
func (this SaasSecurityAPILicense) GetSku() LicenseSku        { return this.Sku }
func (this SaasSecurityAPILicense) GetStartDate() *string     { return this.StartDate }
func (this SaasSecurityAPILicense) GetStatus() LicenseStatus  { return this.Status }

func (SaasSecurityAPILicense) IsQuantifiableLicense() {}

func (this SaasSecurityAPILicense) GetTotal() int64 { return this.Total }

// A reference identifying the SanctionedAppsCategory object. ID: Unique SanctionedAppsCategory Identifier, Name: The SanctionedAppsCategory Name
type SanctionedAppsCategoryRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (SanctionedAppsCategoryRef) IsObjectRef()         {}
func (this SanctionedAppsCategoryRef) GetID() string   { return this.ID }
func (this SanctionedAppsCategoryRef) GetName() string { return this.Name }

type SanctionedAppsCategoryRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

type SandboxMutations struct {
	DeleteReport *DeleteReportPayload `json:"deleteReport"`
	UploadFile   *UploadFilePayload   `json:"uploadFile"`
}

type SandboxQueries struct {
	Reports *SandboxReportsPayload `json:"reports"`
}

// Sandbox report meta-data
type SandboxReport struct {
	CreationDate   string                `json:"creationDate"`
	DownloadURL    *string               `json:"downloadUrl,omitempty"`
	ExpirationDate *string               `json:"expirationDate,omitempty"`
	FailureReason  *SandboxFailureReason `json:"failureReason,omitempty"`
	FileHash       string                `json:"fileHash"`
	FileName       *string               `json:"fileName,omitempty"`
	Status         SandboxStatus         `json:"status"`
	Verdict        *SandboxVerdict       `json:"verdict,omitempty"`
}

// Sandbox reports query filter
type SandboxReportsFilterInput struct {
	FileHash         []*StringFilterInput   `json:"fileHash,omitempty"`
	FileName         []*StringFilterInput   `json:"fileName,omitempty"`
	ReportCreateDate []*DateTimeFilterInput `json:"reportCreateDate,omitempty"`
}

// Sandbox reports query input
type SandboxReportsInput struct {
	Filter *SandboxReportsFilterInput `json:"filter,omitempty"`
	Paging *PagingInput               `json:"paging"`
	Sort   *SandboxReportsSortInput   `json:"sort"`
}

// Output of sandbox reports query
type SandboxReportsPayload struct {
	PageInfo *PageInfo        `json:"pageInfo"`
	Report   []*SandboxReport `json:"report"`
}

// Sandbox reports query sorting
type SandboxReportsSortInput struct {
	FileName         *SortOrderInput `json:"fileName,omitempty"`
	ReportCreateDate *SortOrderInput `json:"reportCreateDate,omitempty"`
}

type SecondaryAWSVSocket struct {
	ID           string   `json:"id"`
	IPAddress    string   `json:"ipAddress"`
	RouteTableID string   `json:"routeTableId"`
	Site         *SiteRef `json:"site"`
	Subnet       string   `json:"subnet"`
}

type SecondaryAzureVSocket struct {
	FloatingIP  string   `json:"floatingIp"`
	ID          string   `json:"id"`
	InterfaceIP string   `json:"interfaceIp"`
	Site        *SiteRef `json:"site"`
}

// A reference identifying the Service object. ID: Unique Service Identifier, Name: The Service Name
type ServiceRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (ServiceRef) IsObjectRef()         {}
func (this ServiceRef) GetID() string   { return this.ID }
func (this ServiceRef) GetName() string { return this.Name }

type ServiceRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

type ShippingDetails struct {
	CityName    *string         `json:"cityName,omitempty"`
	Comment     *string         `json:"comment,omitempty"`
	CompanyName *string         `json:"companyName,omitempty"`
	Contact     *ContactDetails `json:"contact,omitempty"`
	CountryName *string         `json:"countryName,omitempty"`
	Incoterms   *string         `json:"incoterms,omitempty"`
	Instruction *string         `json:"instruction,omitempty"`
	PowerCable  *string         `json:"powerCable,omitempty"`
	StateName   *string         `json:"stateName,omitempty"`
	Street      *string         `json:"street,omitempty"`
	VatID       *string         `json:"vatId,omitempty"`
	ZipCode     *string         `json:"zipCode,omitempty"`
}

type ShippingDetailsInput struct {
	Address     *AddressInput        `json:"address,omitempty"`
	Comment     *string              `json:"comment,omitempty"`
	Contact     *ContactDetailsInput `json:"contact,omitempty"`
	Incoterms   *string              `json:"incoterms,omitempty"`
	Instruction *string              `json:"instruction,omitempty"`
	VatID       *string              `json:"vatId,omitempty"`
}

type ShippingStatusFilterInput struct {
	Eq  *ShippingStatus  `json:"eq,omitempty"`
	In  []ShippingStatus `json:"in,omitempty"`
	Neq *ShippingStatus  `json:"neq,omitempty"`
	Nin []ShippingStatus `json:"nin,omitempty"`
}

type ShippingTracking struct {
	Carrier        *string         `json:"carrier,omitempty"`
	ShippingDate   *time.Time      `json:"shippingDate,omitempty"`
	ShippingStatus *ShippingStatus `json:"shippingStatus,omitempty"`
	TrackingNumber *string         `json:"trackingNumber,omitempty"`
	TrackingURL    *string         `json:"trackingUrl,omitempty"`
}

type SimilarStoryData struct {
	Indication           *string  `json:"indication,omitempty"`
	SimilarityPercentage *float64 `json:"similarityPercentage,omitempty"`
	StoryID              *string  `json:"storyId,omitempty"`
	ThreatClassification *string  `json:"threatClassification,omitempty"`
	ThreatTypeName       *string  `json:"threatTypeName,omitempty"`
	Verdict              *string  `json:"verdict,omitempty"`
}

type SimpleService struct {
	Name SimpleServiceType `json:"name"`
}

type SimpleServiceInput struct {
	Name SimpleServiceType `json:"name"`
}

type SiteBgpStatus struct {
	RawStatus []string             `json:"rawStatus"`
	Status    []*BgpDetailedStatus `json:"status"`
}

type SiteBgpStatusInput struct {
	Site *SiteRefInput `json:"site"`
}

type SiteGeneralDetailsPayload struct {
	Description          *string                   `json:"description,omitempty"`
	PreferredPopLocation *SitePreferredPopLocation `json:"preferredPopLocation,omitempty"`
	Site                 *SiteRef                  `json:"site"`
	SiteLocation         *SiteLocation             `json:"siteLocation"`
	SiteType             SiteType                  `json:"siteType"`
}

// Basic Site configuration information
type SiteInfo struct {
	Address          *string          `json:"address,omitempty"`
	CityName         *string          `json:"cityName,omitempty"`
	ConnType         *ProtoType       `json:"connType,omitempty"`
	CountryCode      *string          `json:"countryCode,omitempty"`
	CountryName      *string          `json:"countryName,omitempty"`
	CountryStateName *string          `json:"countryStateName,omitempty"`
	CreationTime     *string          `json:"creationTime,omitempty"`
	Description      *string          `json:"description,omitempty"`
	Interfaces       []*InterfaceInfo `json:"interfaces,omitempty"`
	Ipsec            []*IPSecInfo     `json:"ipsec,omitempty"`
	IsHa             *bool            `json:"isHA,omitempty"`
	Name             *string          `json:"name,omitempty"`
	Region           *string          `json:"region,omitempty"`
	Sockets          []*SocketInfo    `json:"sockets,omitempty"`
	Type             *SiteType        `json:"type,omitempty"`
}

// Site bandwidth license
type SiteLicense struct {
	Description      *string          `json:"description,omitempty"`
	ExpirationDate   string           `json:"expirationDate"`
	ID               *string          `json:"id,omitempty"`
	LastUpdated      *string          `json:"lastUpdated,omitempty"`
	Plan             LicensePlan      `json:"plan"`
	Regionality      *Regionality     `json:"regionality,omitempty"`
	Site             *SiteRef         `json:"site,omitempty"`
	SiteLicenseGroup SiteLicenseGroup `json:"siteLicenseGroup"`
	SiteLicenseType  SiteLicenseType  `json:"siteLicenseType"`
	Sku              LicenseSku       `json:"sku"`
	StartDate        *string          `json:"startDate,omitempty"`
	Status           LicenseStatus    `json:"status"`
	Total            int64            `json:"total"`
}

func (SiteLicense) IsLicense()                     {}
func (this SiteLicense) GetDescription() *string   { return this.Description }
func (this SiteLicense) GetExpirationDate() string { return this.ExpirationDate }
func (this SiteLicense) GetID() *string            { return this.ID }
func (this SiteLicense) GetLastUpdated() *string   { return this.LastUpdated }
func (this SiteLicense) GetPlan() LicensePlan      { return this.Plan }
func (this SiteLicense) GetSku() LicenseSku        { return this.Sku }
func (this SiteLicense) GetStartDate() *string     { return this.StartDate }
func (this SiteLicense) GetStatus() LicenseStatus  { return this.Status }

func (SiteLicense) IsQuantifiableLicense() {}

func (this SiteLicense) GetTotal() int64 { return this.Total }

type SiteLocation struct {
	Address     *string `json:"address,omitempty"`
	CityName    *string `json:"cityName,omitempty"`
	CountryCode string  `json:"countryCode"`
	StateCode   *string `json:"stateCode,omitempty"`
	Timezone    string  `json:"timezone"`
}

type SiteMetrics struct {
	FlowCount  *Timeseries         `json:"flowCount,omitempty"`
	HostCount  *Timeseries         `json:"hostCount,omitempty"`
	HostLimit  *Timeseries         `json:"hostLimit,omitempty"`
	ID         *string             `json:"id,omitempty"`
	Info       *SiteInfo           `json:"info,omitempty"`
	Interfaces []*InterfaceMetrics `json:"interfaces,omitempty"`
	Metrics    *Metrics            `json:"metrics,omitempty"`
	Name       *string             `json:"name,omitempty"`
	Samples    *int64              `json:"samples,omitempty"`
}

type SiteMutations struct {
	AddBgpPeer                                *AddBgpPeerPayload                                `json:"addBgpPeer,omitempty"`
	AddCloudInterconnectPhysicalConnection    *AddCloudInterconnectPhysicalConnectionPayload    `json:"addCloudInterconnectPhysicalConnection,omitempty"`
	AddCloudInterconnectSite                  *AddCloudInterconnectSitePayload                  `json:"addCloudInterconnectSite,omitempty"`
	AddIpsecIkeV2Site                         *AddIpsecIkeV2SitePayload                         `json:"addIpsecIkeV2Site,omitempty"`
	AddIpsecIkeV2SiteTunnels                  *AddIpsecIkeV2SiteTunnelsPayload                  `json:"addIpsecIkeV2SiteTunnels,omitempty"`
	AddNetworkRange                           *AddNetworkRangePayload                           `json:"addNetworkRange,omitempty"`
	AddSecondaryAWSVSocket                    *AddSecondaryAWSVSocketPayload                    `json:"addSecondaryAwsVSocket,omitempty"`
	AddSecondaryAzureVSocket                  *AddSecondaryAzureVSocketPayload                  `json:"addSecondaryAzureVSocket,omitempty"`
	AddSocketAddOnCard                        *AddSocketAddOnCardPayload                        `json:"addSocketAddOnCard,omitempty"`
	AddSocketSite                             *AddSocketSitePayload                             `json:"addSocketSite,omitempty"`
	AddStaticHost                             *AddStaticHostPayload                             `json:"addStaticHost,omitempty"`
	AssignSiteBwLicense                       *AssignSiteBwLicensePayload                       `json:"assignSiteBwLicense,omitempty"`
	RemoveBgpPeer                             *RemoveBgpPeerPayload                             `json:"removeBgpPeer,omitempty"`
	RemoveCloudInterconnectPhysicalConnection *RemoveCloudInterconnectPhysicalConnectionPayload `json:"removeCloudInterconnectPhysicalConnection,omitempty"`
	RemoveIpsecIkeV2SiteTunnels               *RemoveIpsecIkeV2SiteTunnelsPayload               `json:"removeIpsecIkeV2SiteTunnels,omitempty"`
	RemoveNetworkRange                        *RemoveNetworkRangePayload                        `json:"removeNetworkRange,omitempty"`
	RemoveSecondaryAWSVSocket                 *RemoveSecondaryAWSVSocketPayload                 `json:"removeSecondaryAwsVSocket,omitempty"`
	RemoveSecondaryAzureVSocket               *RemoveSecondaryAzureVSocketPayload               `json:"removeSecondaryAzureVSocket,omitempty"`
	RemoveSite                                *RemoveSitePayload                                `json:"removeSite,omitempty"`
	RemoveSiteBwLicense                       *RemoveSiteBwLicensePayload                       `json:"removeSiteBwLicense,omitempty"`
	RemoveSocketAddOnCard                     *RemoveSocketAddOnCardPayload                     `json:"removeSocketAddOnCard,omitempty"`
	RemoveStaticHost                          *RemoveStaticHostPayload                          `json:"removeStaticHost,omitempty"`
	ReplaceSiteBwLicense                      *ReplaceSiteBwLicensePayload                      `json:"replaceSiteBwLicense,omitempty"`
	StartSiteUpgrade                          *StartSiteUpgradePayload                          `json:"startSiteUpgrade,omitempty"`
	UpdateBgpPeer                             *UpdateBgpPeerPayload                             `json:"updateBgpPeer,omitempty"`
	UpdateCloudInterconnectPhysicalConnection *UpdateCloudInterconnectPhysicalConnectionPayload `json:"updateCloudInterconnectPhysicalConnection,omitempty"`
	UpdateHa                                  *UpdateHaPayload                                  `json:"updateHa,omitempty"`
	UpdateIpsecIkeV2SiteGeneralDetails        *UpdateIpsecIkeV2SiteGeneralDetailsPayload        `json:"updateIpsecIkeV2SiteGeneralDetails,omitempty"`
	UpdateIpsecIkeV2SiteTunnels               *UpdateIpsecIkeV2SiteTunnelsPayload               `json:"updateIpsecIkeV2SiteTunnels,omitempty"`
	UpdateNetworkRange                        *UpdateNetworkRangePayload                        `json:"updateNetworkRange,omitempty"`
	UpdateSecondaryAWSVSocket                 *UpdateSecondaryAWSVSocketPayload                 `json:"updateSecondaryAwsVSocket,omitempty"`
	UpdateSecondaryAzureVSocket               *UpdateSecondaryAzureVSocketPayload               `json:"updateSecondaryAzureVSocket,omitempty"`
	UpdateSiteBwLicense                       *UpdateSiteBwLicensePayload                       `json:"updateSiteBwLicense,omitempty"`
	UpdateSiteGeneralDetails                  *UpdateSiteGeneralDetailsPayload                  `json:"updateSiteGeneralDetails,omitempty"`
	UpdateSocketInterface                     *UpdateSocketInterfacePayload                     `json:"updateSocketInterface,omitempty"`
	UpdateStaticHost                          *UpdateStaticHostPayload                          `json:"updateStaticHost,omitempty"`
}

// A reference identifying the SiteNetworkSubnet object. ID: Unique SiteNetworkSubnet Identifier, Name: The SiteNetworkSubnet Name
type SiteNetworkSubnetRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (SiteNetworkSubnetRef) IsDeviceNetworkRef() {}

func (SiteNetworkSubnetRef) IsObjectRef()         {}
func (this SiteNetworkSubnetRef) GetID() string   { return this.ID }
func (this SiteNetworkSubnetRef) GetName() string { return this.Name }

type SiteNetworkSubnetRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

type SitePreferredPopLocation struct {
	PreferredOnly bool            `json:"preferredOnly"`
	Primary       *PopLocationRef `json:"primary,omitempty"`
	Secondary     *PopLocationRef `json:"secondary,omitempty"`
}

type SiteQueries struct {
	AvailableVersionList                    *AvailableVersionListPayload             `json:"availableVersionList,omitempty"`
	BgpPeer                                 *BgpPeer                                 `json:"bgpPeer,omitempty"`
	BgpPeerList                             *BgpPeerListPayload                      `json:"bgpPeerList,omitempty"`
	CloudInterconnectConnectionConnectivity *CloudInterconnectConnectionConnectivity `json:"cloudInterconnectConnectionConnectivity,omitempty"`
	CloudInterconnectPhysicalConnection     *CloudInterconnectPhysicalConnection     `json:"cloudInterconnectPhysicalConnection,omitempty"`
	CloudInterconnectPhysicalConnectionID   *CloudInterconnectPhysicalConnectionID   `json:"cloudInterconnectPhysicalConnectionId,omitempty"`
	SecondaryAWSVSocket                     *SecondaryAWSVSocket                     `json:"secondaryAwsVSocket,omitempty"`
	SecondaryAzureVSocket                   *SecondaryAzureVSocket                   `json:"secondaryAzureVSocket,omitempty"`
	SiteBgpStatus                           *SiteBgpStatus                           `json:"siteBgpStatus,omitempty"`
	SiteGeneralDetails                      *SiteGeneralDetailsPayload               `json:"siteGeneralDetails,omitempty"`
}

// A reference identifying the Site object. ID: Unique Site Identifier, Name: The Site Name
type SiteRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (SiteRef) IsObjectRef()         {}
func (this SiteRef) GetID() string   { return this.ID }
func (this SiteRef) GetName() string { return this.Name }

type SiteRefFilterInput struct {
	Eq  *SiteRefInput   `json:"eq,omitempty"`
	In  []*SiteRefInput `json:"in,omitempty"`
	Neq *SiteRefInput   `json:"neq,omitempty"`
	Nin []*SiteRefInput `json:"nin,omitempty"`
}

type SiteRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

type SiteSnapshot struct {
	AltWanStatus       *string                    `json:"altWanStatus,omitempty"`
	ConnectedSince     *string                    `json:"connectedSince,omitempty"`
	ConnectivityStatus *ConnectivityStatus        `json:"connectivityStatus,omitempty"`
	DegradedStatus     *DegradedStatus            `json:"degradedStatus,omitempty"`
	Devices            []*DeviceSnapshot          `json:"devices,omitempty"`
	HaStatus           *HaStatus                  `json:"haStatus,omitempty"`
	HostCount          *int64                     `json:"hostCount,omitempty"`
	ID                 *string                    `json:"id,omitempty"`
	Info               *SiteInfo                  `json:"info,omitempty"`
	LastConnected      *string                    `json:"lastConnected,omitempty"`
	OperationalStatus  *scalars.OperationalStatus `json:"operationalStatus,omitempty"`
	PopName            *string                    `json:"popName,omitempty"`
	ProtoID            *int64                     `json:"protoId,omitempty"`
}

// Information about a site upgrade.
type SiteUpgradeInfo struct {
	ScheduledAt   string   `json:"scheduledAt"`
	Site          *SiteRef `json:"site"`
	TargetVersion string   `json:"targetVersion"`
}

// Represents a single site upgrade request.
type SiteUpgradeRequest struct {
	Site          *SiteRefInput `json:"site"`
	TargetVersion string        `json:"targetVersion"`
}

// Represents the result of an upgrade request.
type SiteUpgradeResult struct {
	Site          *BulkUpgradeSiteInfo `json:"site"`
	TargetVersion string               `json:"targetVersion"`
}

type SocketAddOnCard struct {
	ExpansionSlotNumber SocketAddOnExpansionSlotNumber `json:"expansionSlotNumber"`
	Type                SocketAddOnType                `json:"type"`
}

type SocketAddOnCardInput struct {
	ExpansionSlotNumber SocketAddOnExpansionSlotNumber `json:"expansionSlotNumber"`
	Type                SocketAddOnType                `json:"type"`
}

// Basic information about socket
type SocketInfo struct {
	ID                *string         `json:"id,omitempty"`
	IsPrimary         *bool           `json:"isPrimary,omitempty"`
	Platform          *SocketPlatform `json:"platform,omitempty"`
	Serial            *string         `json:"serial,omitempty"`
	Version           *string         `json:"version,omitempty"`
	VersionUpdateTime *string         `json:"versionUpdateTime,omitempty"`
}

type SocketInterfaceAltWanInput struct {
	PrivateGatewayIP   string  `json:"privateGatewayIp"`
	PrivateInterfaceIP string  `json:"privateInterfaceIp"`
	PrivateNetwork     string  `json:"privateNetwork"`
	PrivateVlanTag     *int64  `json:"privateVlanTag,omitempty"`
	PublicGatewayIP    *string `json:"publicGatewayIp,omitempty"`
	PublicInterfaceIP  *string `json:"publicInterfaceIp,omitempty"`
	PublicNetwork      *string `json:"publicNetwork,omitempty"`
	PublicVlanTag      *int64  `json:"publicVlanTag,omitempty"`
}

type SocketInterfaceBandwidthInput struct {
	DownstreamBandwidth              *int64   `json:"downstreamBandwidth,omitempty"`
	DownstreamBandwidthMbpsPrecision *float64 `json:"downstreamBandwidthMbpsPrecision,omitempty"`
	UpstreamBandwidth                *int64   `json:"upstreamBandwidth,omitempty"`
	UpstreamBandwidthMbpsPrecision   *float64 `json:"upstreamBandwidthMbpsPrecision,omitempty"`
}

type SocketInterfaceLagInput struct {
	MinLinks int64 `json:"minLinks"`
}

type SocketInterfaceLanInput struct {
	LocalIP          string  `json:"localIp"`
	Subnet           string  `json:"subnet"`
	TranslatedSubnet *string `json:"translatedSubnet,omitempty"`
}

type SocketInterfaceOffCloudInput struct {
	Enabled          bool    `json:"enabled"`
	PublicIP         *string `json:"publicIp,omitempty"`
	PublicStaticPort *int64  `json:"publicStaticPort,omitempty"`
}

type SocketInterfaceVrrpInput struct {
	VrrpType *VrrpType `json:"vrrpType,omitempty"`
}

type SocketInterfaceWanInput struct {
	Precedence SocketInterfacePrecedenceEnum `json:"precedence"`
	Role       SocketInterfaceRole           `json:"role"`
}

type SocketInventoryFilterInput struct {
	FreeText *FreeTextFilterInput `json:"freeText,omitempty"`
}

type SocketInventoryInput struct {
	Filter *SocketInventoryFilterInput `json:"filter,omitempty"`
	Paging *PagingInput                `json:"paging,omitempty"`
	Sort   *SocketInventoryOrderInput  `json:"sort,omitempty"`
}

type SocketInventoryItem struct {
	Account                  *AccountRef                `json:"account"`
	AvailableUpgradeVersions []string                   `json:"availableUpgradeVersions"`
	DeliverySiteName         *string                    `json:"deliverySiteName,omitempty"`
	Description              *string                    `json:"description,omitempty"`
	HardwareVersion          *string                    `json:"hardwareVersion,omitempty"`
	ID                       string                     `json:"id"`
	IsPrimary                bool                       `json:"isPrimary"`
	RegistrationStatus       *SocketRegistrationStatus  `json:"registrationStatus,omitempty"`
	SerialNumber             *string                    `json:"serialNumber,omitempty"`
	ShippingCompany          *string                    `json:"shippingCompany,omitempty"`
	ShippingDate             *string                    `json:"shippingDate,omitempty"`
	Site                     *SiteRef                   `json:"site,omitempty"`
	SocketMac                *string                    `json:"socketMac,omitempty"`
	SocketType               *SocketPlatform            `json:"socketType,omitempty"`
	SocketVersion            *string                    `json:"socketVersion,omitempty"`
	Status                   *SocketInventoryItemStatus `json:"status,omitempty"`
	TrackingNumber           *string                    `json:"trackingNumber,omitempty"`
	TrackingURL              *string                    `json:"trackingUrl,omitempty"`
	UpgradeStatus            *SocketUpgradeStatus       `json:"upgradeStatus,omitempty"`
	UpgradesPaused           bool                       `json:"upgradesPaused"`
}

type SocketInventoryOrderInput struct {
	AccountName      *SortOrderInput `json:"accountName,omitempty"`
	DeliverySiteName *SortOrderInput `json:"deliverySiteName,omitempty"`
	Description      *SortOrderInput `json:"description,omitempty"`
	HardwareVersion  *SortOrderInput `json:"hardwareVersion,omitempty"`
	InstalledSite    *SortOrderInput `json:"installedSite,omitempty"`
	SerialNumber     *SortOrderInput `json:"serialNumber,omitempty"`
	ShippingCompany  *SortOrderInput `json:"shippingCompany,omitempty"`
	ShippingDate     *SortOrderInput `json:"shippingDate,omitempty"`
	SocketType       *SortOrderInput `json:"socketType,omitempty"`
	Status           *SortOrderInput `json:"status,omitempty"`
}

type SocketInventoryPayload struct {
	Items    []*SocketInventoryItem `json:"items"`
	PageInfo *PageInfo              `json:"pageInfo"`
}

type SocketLanAddRuleDataInput struct {
	Description string                     `json:"description"`
	Destination *SocketLanDestinationInput `json:"destination"`
	Direction   SocketLanDirection         `json:"direction"`
	Enabled     bool                       `json:"enabled"`
	Name        string                     `json:"name"`
	Nat         *SocketLanNatSettingsInput `json:"nat"`
	Service     *SocketLanServiceInput     `json:"service"`
	Site        *SocketLanSiteInput        `json:"site"`
	Source      *SocketLanSourceInput      `json:"source"`
	Transport   SocketLanTransportType     `json:"transport"`
}

type SocketLanAddRuleInput struct {
	At   *PolicyRulePositionInput   `json:"at,omitempty"`
	Rule *SocketLanAddRuleDataInput `json:"rule"`
}

// Returns the settings for Destination of a Wan Firewall rule.
type SocketLanDestination struct {
	FloatingSubnet    []*FloatingSubnetRef    `json:"floatingSubnet"`
	GlobalIPRange     []*GlobalIPRangeRef     `json:"globalIpRange"`
	Group             []*GroupRef             `json:"group"`
	Host              []*HostRef              `json:"host"`
	IP                []string                `json:"ip"`
	IPRange           []*IPAddressRange       `json:"ipRange"`
	NetworkInterface  []*NetworkInterfaceRef  `json:"networkInterface"`
	SiteNetworkSubnet []*SiteNetworkSubnetRef `json:"siteNetworkSubnet"`
	Subnet            []string                `json:"subnet"`
	SystemGroup       []*SystemGroupRef       `json:"systemGroup"`
	Vlan              []string                `json:"vlan"`
}

// Input of the settings for Destination of a Wan Firewall rule.
type SocketLanDestinationInput struct {
	FloatingSubnet    []*FloatingSubnetRefInput    `json:"floatingSubnet"`
	GlobalIPRange     []*GlobalIPRangeRefInput     `json:"globalIpRange"`
	Group             []*GroupRefInput             `json:"group"`
	Host              []*HostRefInput              `json:"host"`
	IP                []string                     `json:"ip"`
	IPRange           []*IPAddressRangeInput       `json:"ipRange"`
	NetworkInterface  []*NetworkInterfaceRefInput  `json:"networkInterface"`
	SiteNetworkSubnet []*SiteNetworkSubnetRefInput `json:"siteNetworkSubnet"`
	Subnet            []string                     `json:"subnet"`
	SystemGroup       []*SystemGroupRefInput       `json:"systemGroup"`
	Vlan              []string                     `json:"vlan"`
}

// Input of the settings for Destination of a Wan Firewall rule.
type SocketLanDestinationUpdateInput struct {
	FloatingSubnet    []*FloatingSubnetRefInput    `json:"floatingSubnet,omitempty"`
	GlobalIPRange     []*GlobalIPRangeRefInput     `json:"globalIpRange,omitempty"`
	Group             []*GroupRefInput             `json:"group,omitempty"`
	Host              []*HostRefInput              `json:"host,omitempty"`
	IP                []string                     `json:"ip,omitempty"`
	IPRange           []*IPAddressRangeInput       `json:"ipRange,omitempty"`
	NetworkInterface  []*NetworkInterfaceRefInput  `json:"networkInterface,omitempty"`
	SiteNetworkSubnet []*SiteNetworkSubnetRefInput `json:"siteNetworkSubnet,omitempty"`
	Subnet            []string                     `json:"subnet,omitempty"`
	SystemGroup       []*SystemGroupRefInput       `json:"systemGroup,omitempty"`
	Vlan              []string                     `json:"vlan,omitempty"`
}

type SocketLanFirewallAddRuleDataInput struct {
	Action      SocketLanFirewallAction            `json:"action"`
	Application *SocketLanFirewallApplicationInput `json:"application"`
	Description string                             `json:"description"`
	Destination *SocketLanFirewallDestinationInput `json:"destination"`
	Direction   SocketLanFirewallDirection         `json:"direction"`
	Enabled     bool                               `json:"enabled"`
	Name        string                             `json:"name"`
	Service     *SocketLanFirewallServiceTypeInput `json:"service"`
	Source      *SocketLanFirewallSourceInput      `json:"source"`
	Tracking    *PolicyTrackingInput               `json:"tracking"`
}

type SocketLanFirewallAddRuleInput struct {
	At   *PolicySubRulePositionInput        `json:"at,omitempty"`
	Rule *SocketLanFirewallAddRuleDataInput `json:"rule"`
}

// Defines applications for the socket LAN firewall.
type SocketLanFirewallApplication struct {
	Application   []*ApplicationRef       `json:"application"`
	CustomApp     []*CustomApplicationRef `json:"customApp"`
	Domain        []string                `json:"domain"`
	Fqdn          []string                `json:"fqdn"`
	GlobalIPRange []*GlobalIPRangeRef     `json:"globalIpRange"`
	IP            []string                `json:"ip"`
	IPRange       []*IPAddressRange       `json:"ipRange"`
	Subnet        []string                `json:"subnet"`
}

// Defines applications for the socket LAN firewall.
type SocketLanFirewallApplicationInput struct {
	Application   []*ApplicationRefInput       `json:"application"`
	CustomApp     []*CustomApplicationRefInput `json:"customApp"`
	Domain        []string                     `json:"domain"`
	Fqdn          []string                     `json:"fqdn"`
	GlobalIPRange []*GlobalIPRangeRefInput     `json:"globalIpRange"`
	IP            []string                     `json:"ip"`
	IPRange       []*IPAddressRangeInput       `json:"ipRange"`
	Subnet        []string                     `json:"subnet"`
}

// Defines applications for the socket LAN firewall.
type SocketLanFirewallApplicationUpdateInput struct {
	Application   []*ApplicationRefInput       `json:"application,omitempty"`
	CustomApp     []*CustomApplicationRefInput `json:"customApp,omitempty"`
	Domain        []string                     `json:"domain,omitempty"`
	Fqdn          []string                     `json:"fqdn,omitempty"`
	GlobalIPRange []*GlobalIPRangeRefInput     `json:"globalIpRange,omitempty"`
	IP            []string                     `json:"ip,omitempty"`
	IPRange       []*IPAddressRangeInput       `json:"ipRange,omitempty"`
	Subnet        []string                     `json:"subnet,omitempty"`
}

// Defines destinations for the socket LAN firewall.
type SocketLanFirewallDestination struct {
	FloatingSubnet    []*FloatingSubnetRef    `json:"floatingSubnet"`
	GlobalIPRange     []*GlobalIPRangeRef     `json:"globalIpRange"`
	Group             []*GroupRef             `json:"group"`
	Host              []*HostRef              `json:"host"`
	IP                []string                `json:"ip"`
	IPRange           []*IPAddressRange       `json:"ipRange"`
	NetworkInterface  []*NetworkInterfaceRef  `json:"networkInterface"`
	Site              []*SiteRef              `json:"site"`
	SiteNetworkSubnet []*SiteNetworkSubnetRef `json:"siteNetworkSubnet"`
	Subnet            []string                `json:"subnet"`
	SystemGroup       []*SystemGroupRef       `json:"systemGroup"`
	Vlan              []string                `json:"vlan"`
}

// Defines destinations for the socket LAN firewall.
type SocketLanFirewallDestinationInput struct {
	FloatingSubnet    []*FloatingSubnetRefInput    `json:"floatingSubnet"`
	GlobalIPRange     []*GlobalIPRangeRefInput     `json:"globalIpRange"`
	Group             []*GroupRefInput             `json:"group"`
	Host              []*HostRefInput              `json:"host"`
	IP                []string                     `json:"ip"`
	IPRange           []*IPAddressRangeInput       `json:"ipRange"`
	NetworkInterface  []*NetworkInterfaceRefInput  `json:"networkInterface"`
	Site              []*SiteRefInput              `json:"site"`
	SiteNetworkSubnet []*SiteNetworkSubnetRefInput `json:"siteNetworkSubnet"`
	Subnet            []string                     `json:"subnet"`
	SystemGroup       []*SystemGroupRefInput       `json:"systemGroup"`
	Vlan              []string                     `json:"vlan"`
}

// Defines destinations for the socket LAN firewall.
type SocketLanFirewallDestinationUpdateInput struct {
	FloatingSubnet    []*FloatingSubnetRefInput    `json:"floatingSubnet,omitempty"`
	GlobalIPRange     []*GlobalIPRangeRefInput     `json:"globalIpRange,omitempty"`
	Group             []*GroupRefInput             `json:"group,omitempty"`
	Host              []*HostRefInput              `json:"host,omitempty"`
	IP                []string                     `json:"ip,omitempty"`
	IPRange           []*IPAddressRangeInput       `json:"ipRange,omitempty"`
	NetworkInterface  []*NetworkInterfaceRefInput  `json:"networkInterface,omitempty"`
	Site              []*SiteRefInput              `json:"site,omitempty"`
	SiteNetworkSubnet []*SiteNetworkSubnetRefInput `json:"siteNetworkSubnet,omitempty"`
	Subnet            []string                     `json:"subnet,omitempty"`
	SystemGroup       []*SystemGroupRefInput       `json:"systemGroup,omitempty"`
	Vlan              []string                     `json:"vlan,omitempty"`
}

type SocketLanFirewallPolicyMutations struct {
	AddRule    *SocketLanFirewallRuleMutationPayload `json:"addRule"`
	MoveRule   *SocketLanFirewallRuleMutationPayload `json:"moveRule"`
	RemoveRule *SocketLanFirewallRuleMutationPayload `json:"removeRule"`
	UpdateRule *SocketLanFirewallRuleMutationPayload `json:"updateRule"`
}

type SocketLanFirewallRemoveRuleInput struct {
	ID string `json:"id"`
}

type SocketLanFirewallRule struct {
	Action      SocketLanFirewallAction       `json:"action"`
	Application *SocketLanFirewallApplication `json:"application"`
	Description string                        `json:"description"`
	Destination *SocketLanFirewallDestination `json:"destination"`
	Direction   SocketLanFirewallDirection    `json:"direction"`
	Enabled     bool                          `json:"enabled"`
	ID          string                        `json:"id"`
	Index       int64                         `json:"index"`
	Name        string                        `json:"name"`
	Section     *PolicySectionInfo            `json:"section"`
	Service     *SocketLanFirewallServiceType `json:"service"`
	Source      *SocketLanFirewallSource      `json:"source"`
	Tracking    *PolicyTracking               `json:"tracking"`
}

func (SocketLanFirewallRule) IsIPolicyRule()                      {}
func (this SocketLanFirewallRule) GetDescription() *string        { return &this.Description }
func (this SocketLanFirewallRule) GetEnabled() bool               { return this.Enabled }
func (this SocketLanFirewallRule) GetID() string                  { return this.ID }
func (this SocketLanFirewallRule) GetIndex() int64                { return this.Index }
func (this SocketLanFirewallRule) GetName() string                { return this.Name }
func (this SocketLanFirewallRule) GetSection() *PolicySectionInfo { return this.Section }

type SocketLanFirewallRuleMutationPayload struct {
	Errors []*PolicyMutationError        `json:"errors"`
	Rule   *SocketLanFirewallRulePayload `json:"rule,omitempty"`
	Status PolicyMutationStatus          `json:"status"`
}

func (SocketLanFirewallRuleMutationPayload) IsIPolicyRuleMutationPayload() {}
func (this SocketLanFirewallRuleMutationPayload) GetErrors() []*PolicyMutationError {
	if this.Errors == nil {
		return nil
	}
	interfaceSlice := make([]*PolicyMutationError, 0, len(this.Errors))
	for _, concrete := range this.Errors {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this SocketLanFirewallRuleMutationPayload) GetRule() IPolicyRulePayload     { return *this.Rule }
func (this SocketLanFirewallRuleMutationPayload) GetStatus() PolicyMutationStatus { return this.Status }

type SocketLanFirewallRulePayload struct {
	Audit      *PolicyElementAudit           `json:"audit"`
	Properties []PolicyElementPropertiesEnum `json:"properties"`
	Rule       *SocketLanFirewallRule        `json:"rule"`
}

func (SocketLanFirewallRulePayload) IsIPolicyRulePayload()              {}
func (this SocketLanFirewallRulePayload) GetAudit() *PolicyElementAudit { return this.Audit }
func (this SocketLanFirewallRulePayload) GetProperties() []PolicyElementPropertiesEnum {
	if this.Properties == nil {
		return nil
	}
	interfaceSlice := make([]PolicyElementPropertiesEnum, 0, len(this.Properties))
	for _, concrete := range this.Properties {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this SocketLanFirewallRulePayload) GetRule() IPolicyRule { return *this.Rule }

// Defines services used in the socket LAN firewall.
type SocketLanFirewallServiceType struct {
	Custom   []*CustomService `json:"custom"`
	Simple   []*SimpleService `json:"simple"`
	Standard []*ServiceRef    `json:"standard"`
}

// Defines services used in the socket LAN firewall.
type SocketLanFirewallServiceTypeInput struct {
	Custom   []*CustomServiceInput `json:"custom"`
	Simple   []*SimpleServiceInput `json:"simple"`
	Standard []*ServiceRefInput    `json:"standard"`
}

// Defines services used in the socket LAN firewall.
type SocketLanFirewallServiceTypeUpdateInput struct {
	Custom   []*CustomServiceInput `json:"custom,omitempty"`
	Simple   []*SimpleServiceInput `json:"simple,omitempty"`
	Standard []*ServiceRefInput    `json:"standard,omitempty"`
}

// Defines sources for the socket LAN firewall.
type SocketLanFirewallSource struct {
	FloatingSubnet    []*FloatingSubnetRef    `json:"floatingSubnet"`
	GlobalIPRange     []*GlobalIPRangeRef     `json:"globalIpRange"`
	Group             []*GroupRef             `json:"group"`
	Host              []*HostRef              `json:"host"`
	IP                []string                `json:"ip"`
	IPRange           []*IPAddressRange       `json:"ipRange"`
	Mac               []string                `json:"mac"`
	NetworkInterface  []*NetworkInterfaceRef  `json:"networkInterface"`
	Site              []*SiteRef              `json:"site"`
	SiteNetworkSubnet []*SiteNetworkSubnetRef `json:"siteNetworkSubnet"`
	Subnet            []string                `json:"subnet"`
	SystemGroup       []*SystemGroupRef       `json:"systemGroup"`
	Vlan              []string                `json:"vlan"`
}

// Defines sources for the socket LAN firewall.
type SocketLanFirewallSourceInput struct {
	FloatingSubnet    []*FloatingSubnetRefInput    `json:"floatingSubnet"`
	GlobalIPRange     []*GlobalIPRangeRefInput     `json:"globalIpRange"`
	Group             []*GroupRefInput             `json:"group"`
	Host              []*HostRefInput              `json:"host"`
	IP                []string                     `json:"ip"`
	IPRange           []*IPAddressRangeInput       `json:"ipRange"`
	Mac               []string                     `json:"mac"`
	NetworkInterface  []*NetworkInterfaceRefInput  `json:"networkInterface"`
	Site              []*SiteRefInput              `json:"site"`
	SiteNetworkSubnet []*SiteNetworkSubnetRefInput `json:"siteNetworkSubnet"`
	Subnet            []string                     `json:"subnet"`
	SystemGroup       []*SystemGroupRefInput       `json:"systemGroup"`
	Vlan              []string                     `json:"vlan"`
}

// Defines sources for the socket LAN firewall.
type SocketLanFirewallSourceUpdateInput struct {
	FloatingSubnet    []*FloatingSubnetRefInput    `json:"floatingSubnet,omitempty"`
	GlobalIPRange     []*GlobalIPRangeRefInput     `json:"globalIpRange,omitempty"`
	Group             []*GroupRefInput             `json:"group,omitempty"`
	Host              []*HostRefInput              `json:"host,omitempty"`
	IP                []string                     `json:"ip,omitempty"`
	IPRange           []*IPAddressRangeInput       `json:"ipRange,omitempty"`
	Mac               []string                     `json:"mac,omitempty"`
	NetworkInterface  []*NetworkInterfaceRefInput  `json:"networkInterface,omitempty"`
	Site              []*SiteRefInput              `json:"site,omitempty"`
	SiteNetworkSubnet []*SiteNetworkSubnetRefInput `json:"siteNetworkSubnet,omitempty"`
	Subnet            []string                     `json:"subnet,omitempty"`
	SystemGroup       []*SystemGroupRefInput       `json:"systemGroup,omitempty"`
	Vlan              []string                     `json:"vlan,omitempty"`
}

type SocketLanFirewallUpdateRuleDataInput struct {
	Action      *SocketLanFirewallAction                 `json:"action,omitempty"`
	Application *SocketLanFirewallApplicationUpdateInput `json:"application,omitempty"`
	Description *string                                  `json:"description,omitempty"`
	Destination *SocketLanFirewallDestinationUpdateInput `json:"destination,omitempty"`
	Direction   *SocketLanFirewallDirection              `json:"direction,omitempty"`
	Enabled     *bool                                    `json:"enabled,omitempty"`
	Name        *string                                  `json:"name,omitempty"`
	Service     *SocketLanFirewallServiceTypeUpdateInput `json:"service,omitempty"`
	Source      *SocketLanFirewallSourceUpdateInput      `json:"source,omitempty"`
	Tracking    *PolicyTrackingUpdateInput               `json:"tracking,omitempty"`
}

type SocketLanFirewallUpdateRuleInput struct {
	ID   string                                `json:"id"`
	Rule *SocketLanFirewallUpdateRuleDataInput `json:"rule"`
}

// Defines NAT settings for the socket LAN policy.
type SocketLanNatSettings struct {
	Enabled bool             `json:"enabled"`
	NatType SocketLanNatType `json:"natType"`
}

// Defines NAT settings for the socket LAN policy.
type SocketLanNatSettingsInput struct {
	Enabled bool             `json:"enabled"`
	NatType SocketLanNatType `json:"natType"`
}

// Defines NAT settings for the socket LAN policy.
type SocketLanNatSettingsUpdateInput struct {
	Enabled *bool             `json:"enabled,omitempty"`
	NatType *SocketLanNatType `json:"natType,omitempty"`
}

type SocketLanPolicy struct {
	Audit    *PolicyAudit            `json:"audit,omitempty"`
	Enabled  bool                    `json:"enabled"`
	Revision *PolicyRevision         `json:"revision,omitempty"`
	Rules    []*SocketLanRulePayload `json:"rules"`
	Sections []*PolicySectionPayload `json:"sections"`
}

func (SocketLanPolicy) IsIPolicy()                        {}
func (this SocketLanPolicy) GetAudit() *PolicyAudit       { return this.Audit }
func (this SocketLanPolicy) GetEnabled() bool             { return this.Enabled }
func (this SocketLanPolicy) GetRevision() *PolicyRevision { return this.Revision }
func (this SocketLanPolicy) GetRules() []IPolicyRulePayload {
	if this.Rules == nil {
		return nil
	}
	interfaceSlice := make([]IPolicyRulePayload, 0, len(this.Rules))
	for _, concrete := range this.Rules {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this SocketLanPolicy) GetSections() []*PolicySectionPayload {
	if this.Sections == nil {
		return nil
	}
	interfaceSlice := make([]*PolicySectionPayload, 0, len(this.Sections))
	for _, concrete := range this.Sections {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

type SocketLanPolicyInput struct {
	Revision *PolicyRevisionInput `json:"revision,omitempty"`
}

type SocketLanPolicyMutationInput struct {
	Revision *PolicyMutationRevisionInput `json:"revision,omitempty"`
}

type SocketLanPolicyMutationPayload struct {
	Errors []*PolicyMutationError `json:"errors"`
	Policy *SocketLanPolicy       `json:"policy,omitempty"`
	Status PolicyMutationStatus   `json:"status"`
}

func (SocketLanPolicyMutationPayload) IsIPolicyMutationPayload() {}
func (this SocketLanPolicyMutationPayload) GetErrors() []*PolicyMutationError {
	if this.Errors == nil {
		return nil
	}
	interfaceSlice := make([]*PolicyMutationError, 0, len(this.Errors))
	for _, concrete := range this.Errors {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this SocketLanPolicyMutationPayload) GetPolicy() IPolicy              { return *this.Policy }
func (this SocketLanPolicyMutationPayload) GetStatus() PolicyMutationStatus { return this.Status }

type SocketLanPolicyMutations struct {
	AddRule               *SocketLanRuleMutationPayload     `json:"addRule"`
	AddSection            *PolicySectionMutationPayload     `json:"addSection"`
	CreatePolicyRevision  *SocketLanPolicyMutationPayload   `json:"createPolicyRevision"`
	DiscardPolicyRevision *SocketLanPolicyMutationPayload   `json:"discardPolicyRevision"`
	Firewall              *SocketLanFirewallPolicyMutations `json:"firewall"`
	MoveRule              *SocketLanRuleMutationPayload     `json:"moveRule"`
	MoveSection           *PolicySectionMutationPayload     `json:"moveSection"`
	PublishPolicyRevision *SocketLanPolicyMutationPayload   `json:"publishPolicyRevision"`
	RemoveRule            *SocketLanRuleMutationPayload     `json:"removeRule"`
	RemoveSection         *PolicySectionMutationPayload     `json:"removeSection"`
	UpdatePolicy          *SocketLanPolicyMutationPayload   `json:"updatePolicy"`
	UpdateRule            *SocketLanRuleMutationPayload     `json:"updateRule"`
	UpdateSection         *PolicySectionMutationPayload     `json:"updateSection"`
}

type SocketLanPolicyQueries struct {
	Policy    *SocketLanPolicy        `json:"policy"`
	Revisions *PolicyRevisionsPayload `json:"revisions,omitempty"`
}

type SocketLanPolicyUpdateInput struct {
	State *PolicyToggleState `json:"state,omitempty"`
}

type SocketLanRemoveRuleInput struct {
	ID string `json:"id"`
}

type SocketLanRule struct {
	Description string                          `json:"description"`
	Destination *SocketLanDestination           `json:"destination"`
	Direction   SocketLanDirection              `json:"direction"`
	Enabled     bool                            `json:"enabled"`
	Firewall    []*SocketLanFirewallRulePayload `json:"firewall"`
	ID          string                          `json:"id"`
	Index       int64                           `json:"index"`
	Name        string                          `json:"name"`
	Nat         *SocketLanNatSettings           `json:"nat"`
	Section     *PolicySectionInfo              `json:"section"`
	Service     *SocketLanService               `json:"service"`
	Site        *SocketLanSite                  `json:"site"`
	Source      *SocketLanSource                `json:"source"`
	Transport   SocketLanTransportType          `json:"transport"`
}

func (SocketLanRule) IsIPolicyRule()                      {}
func (this SocketLanRule) GetDescription() *string        { return &this.Description }
func (this SocketLanRule) GetEnabled() bool               { return this.Enabled }
func (this SocketLanRule) GetID() string                  { return this.ID }
func (this SocketLanRule) GetIndex() int64                { return this.Index }
func (this SocketLanRule) GetName() string                { return this.Name }
func (this SocketLanRule) GetSection() *PolicySectionInfo { return this.Section }

type SocketLanRuleMutationPayload struct {
	Errors []*PolicyMutationError `json:"errors"`
	Rule   *SocketLanRulePayload  `json:"rule,omitempty"`
	Status PolicyMutationStatus   `json:"status"`
}

func (SocketLanRuleMutationPayload) IsIPolicyRuleMutationPayload() {}
func (this SocketLanRuleMutationPayload) GetErrors() []*PolicyMutationError {
	if this.Errors == nil {
		return nil
	}
	interfaceSlice := make([]*PolicyMutationError, 0, len(this.Errors))
	for _, concrete := range this.Errors {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this SocketLanRuleMutationPayload) GetRule() IPolicyRulePayload     { return *this.Rule }
func (this SocketLanRuleMutationPayload) GetStatus() PolicyMutationStatus { return this.Status }

type SocketLanRulePayload struct {
	Audit      *PolicyElementAudit           `json:"audit"`
	Properties []PolicyElementPropertiesEnum `json:"properties"`
	Rule       *SocketLanRule                `json:"rule"`
}

func (SocketLanRulePayload) IsIPolicyRulePayload()              {}
func (this SocketLanRulePayload) GetAudit() *PolicyElementAudit { return this.Audit }
func (this SocketLanRulePayload) GetProperties() []PolicyElementPropertiesEnum {
	if this.Properties == nil {
		return nil
	}
	interfaceSlice := make([]PolicyElementPropertiesEnum, 0, len(this.Properties))
	for _, concrete := range this.Properties {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this SocketLanRulePayload) GetRule() IPolicyRule { return *this.Rule }

// Defines services used in the socket LAN policy.
type SocketLanService struct {
	Custom []*CustomService `json:"custom"`
	Simple []*SimpleService `json:"simple"`
}

// Defines services used in the socket LAN policy.
type SocketLanServiceInput struct {
	Custom []*CustomServiceInput `json:"custom"`
	Simple []*SimpleServiceInput `json:"simple"`
}

// Defines services used in the socket LAN policy.
type SocketLanServiceUpdateInput struct {
	Custom []*CustomServiceInput `json:"custom,omitempty"`
	Simple []*SimpleServiceInput `json:"simple,omitempty"`
}

// Represents the site configurations in the socket LAN policy.
type SocketLanSite struct {
	Group []*GroupRef `json:"group"`
	Site  []*SiteRef  `json:"site"`
}

// Represents the site configurations in the socket LAN policy.
type SocketLanSiteInput struct {
	Group []*GroupRefInput `json:"group"`
	Site  []*SiteRefInput  `json:"site"`
}

// Represents the site configurations in the socket LAN policy.
type SocketLanSiteUpdateInput struct {
	Group []*GroupRefInput `json:"group,omitempty"`
	Site  []*SiteRefInput  `json:"site,omitempty"`
}

// Defines sources for the socket LAN policy.
type SocketLanSource struct {
	FloatingSubnet    []*FloatingSubnetRef    `json:"floatingSubnet"`
	GlobalIPRange     []*GlobalIPRangeRef     `json:"globalIpRange"`
	Group             []*GroupRef             `json:"group"`
	Host              []*HostRef              `json:"host"`
	IP                []string                `json:"ip"`
	IPRange           []*IPAddressRange       `json:"ipRange"`
	NetworkInterface  []*NetworkInterfaceRef  `json:"networkInterface"`
	SiteNetworkSubnet []*SiteNetworkSubnetRef `json:"siteNetworkSubnet"`
	Subnet            []string                `json:"subnet"`
	SystemGroup       []*SystemGroupRef       `json:"systemGroup"`
	Vlan              []string                `json:"vlan"`
}

// Defines sources for the socket LAN policy.
type SocketLanSourceInput struct {
	FloatingSubnet    []*FloatingSubnetRefInput    `json:"floatingSubnet"`
	GlobalIPRange     []*GlobalIPRangeRefInput     `json:"globalIpRange"`
	Group             []*GroupRefInput             `json:"group"`
	Host              []*HostRefInput              `json:"host"`
	IP                []string                     `json:"ip"`
	IPRange           []*IPAddressRangeInput       `json:"ipRange"`
	NetworkInterface  []*NetworkInterfaceRefInput  `json:"networkInterface"`
	SiteNetworkSubnet []*SiteNetworkSubnetRefInput `json:"siteNetworkSubnet"`
	Subnet            []string                     `json:"subnet"`
	SystemGroup       []*SystemGroupRefInput       `json:"systemGroup"`
	Vlan              []string                     `json:"vlan"`
}

// Defines sources for the socket LAN policy.
type SocketLanSourceUpdateInput struct {
	FloatingSubnet    []*FloatingSubnetRefInput    `json:"floatingSubnet,omitempty"`
	GlobalIPRange     []*GlobalIPRangeRefInput     `json:"globalIpRange,omitempty"`
	Group             []*GroupRefInput             `json:"group,omitempty"`
	Host              []*HostRefInput              `json:"host,omitempty"`
	IP                []string                     `json:"ip,omitempty"`
	IPRange           []*IPAddressRangeInput       `json:"ipRange,omitempty"`
	NetworkInterface  []*NetworkInterfaceRefInput  `json:"networkInterface,omitempty"`
	SiteNetworkSubnet []*SiteNetworkSubnetRefInput `json:"siteNetworkSubnet,omitempty"`
	Subnet            []string                     `json:"subnet,omitempty"`
	SystemGroup       []*SystemGroupRefInput       `json:"systemGroup,omitempty"`
	Vlan              []string                     `json:"vlan,omitempty"`
}

type SocketLanUpdateRuleDataInput struct {
	Description *string                          `json:"description,omitempty"`
	Destination *SocketLanDestinationUpdateInput `json:"destination,omitempty"`
	Direction   *SocketLanDirection              `json:"direction,omitempty"`
	Enabled     *bool                            `json:"enabled,omitempty"`
	Name        *string                          `json:"name,omitempty"`
	Nat         *SocketLanNatSettingsUpdateInput `json:"nat,omitempty"`
	Service     *SocketLanServiceUpdateInput     `json:"service,omitempty"`
	Site        *SocketLanSiteUpdateInput        `json:"site,omitempty"`
	Source      *SocketLanSourceUpdateInput      `json:"source,omitempty"`
	Transport   *SocketLanTransportType          `json:"transport,omitempty"`
}

type SocketLanUpdateRuleInput struct {
	ID   string                        `json:"id"`
	Rule *SocketLanUpdateRuleDataInput `json:"rule"`
}

type SocketPortMetrics struct {
	From    *string                    `json:"from,omitempty"`
	ID      *string                    `json:"id,omitempty"`
	Records []*SocketPortMetricsRecord `json:"records,omitempty"`
	To      *string                    `json:"to,omitempty"`
	Total   *int64                     `json:"total,omitempty"`
	Totals  map[string]any             `json:"totals,omitempty"`
}

type SocketPortMetricsDimension struct {
	FieldName SocketPortMetricsFieldName `json:"fieldName"`
}

type SocketPortMetricsField struct {
	Name  SocketPortMetricsFieldName `json:"name"`
	Value Value                      `json:"value"`
}

type SocketPortMetricsFilter struct {
	FieldName SocketPortMetricsFieldName `json:"fieldName"`
	Operator  FilterOperator             `json:"operator"`
	Values    []string                   `json:"values"`
}

type SocketPortMetricsMeasure struct {
	AggType   AggregationType            `json:"aggType"`
	FieldName SocketPortMetricsFieldName `json:"fieldName"`
	Trend     *bool                      `json:"trend,omitempty"`
}

type SocketPortMetricsRecord struct {
	Fields          []*SocketPortMetricsField `json:"fields,omitempty"`
	FieldsMap       map[string]any            `json:"fieldsMap,omitempty"`
	FieldsUnitTypes []UnitType                `json:"fieldsUnitTypes,omitempty"`
	PrevTimeFrame   map[string]any            `json:"prevTimeFrame,omitempty"`
	Trends          map[string]any            `json:"trends,omitempty"`
}

type SocketPortMetricsSort struct {
	FieldName SocketPortMetricsFieldName `json:"fieldName"`
	Order     DirectionEnum              `json:"order"`
}

type SocketPortMetricsTimeSeries struct {
	From        *string       `json:"from,omitempty"`
	Granularity *int64        `json:"granularity,omitempty"`
	ID          *string       `json:"id,omitempty"`
	Timeseries  []*Timeseries `json:"timeseries,omitempty"`
	To          *string       `json:"to,omitempty"`
}

type SortInput struct {
	Field *string         `json:"field,omitempty"`
	Order *DirectionInput `json:"order,omitempty"`
}

type SortOrderInput struct {
	Direction SortOrder `json:"direction"`
	Priority  int64     `json:"priority"`
}

// Input for bulk site upgrade requests.
type StartSiteUpgradeInput struct {
	Upgrades []*SiteUpgradeRequest `json:"upgrades"`
}

// Wrapper for site upgrade response.
type StartSiteUpgradePayload struct {
	Results []*SiteUpgradeInfo `json:"results"`
}

type StoriesData struct {
	Items  []*Story `json:"items"`
	Paging *Paging  `json:"paging"`
}

type Story struct {
	AccountID    int64           `json:"accountId"`
	AccountName  *string         `json:"accountName,omitempty"`
	AnalystEmail *string         `json:"analystEmail,omitempty"`
	AnalystName  *string         `json:"analystName,omitempty"`
	CreatedAt    string          `json:"createdAt"`
	ID           string          `json:"id"`
	Incident     MergedIncident  `json:"incident"`
	Playbook     *string         `json:"playbook,omitempty"`
	Summary      *string         `json:"summary,omitempty"`
	Timeline     []*TimelineItem `json:"timeline"`
	UpdatedAt    string          `json:"updatedAt"`
}

type StoryComment struct {
	Actor     ActorRef     `json:"actor"`
	CreatedAt scalars.Time `json:"createdAt"`
	ID        string       `json:"id"`
	Text      string       `json:"text"`
}

type StoryDrillDownFilter struct {
	Name   string   `json:"name"`
	Value  string   `json:"value"`
	Values []string `json:"values"`
}

type StoryFilterInput struct {
	AccountID   *AccountIDPredicate     `json:"accountId,omitempty"`
	Criticality *IntPredicate           `json:"criticality,omitempty"`
	EngineType  *EngineTypePredicate    `json:"engineType,omitempty"`
	IncidentID  *StringPredicate        `json:"incidentId,omitempty"`
	Ioa         *StringPredicate        `json:"ioa,omitempty"`
	Muted       *BooleanPredicate       `json:"muted,omitempty"`
	Producer    *StoryProducerPredicate `json:"producer,omitempty"`
	QueryName   *StringPredicate        `json:"queryName,omitempty"`
	Severity    *StorySeverityPredicate `json:"severity,omitempty"`
	Source      *StringPredicate        `json:"source,omitempty"`
	SourceIP    *StringPredicate        `json:"sourceIp,omitempty"`
	Status      *StoryStatusPredicate   `json:"status,omitempty"`
	StoryID     *StoryIDPredicate       `json:"storyId,omitempty"`
	TimeFrame   *TimeFramePredicate     `json:"timeFrame"`
	Vendor      *VendorPredicate        `json:"vendor,omitempty"`
	Verdict     *StoryVerdictPredicate  `json:"verdict,omitempty"`
}

type StoryIDPredicate struct {
	In    []string `json:"in,omitempty"`
	NotIn []string `json:"not_in,omitempty"`
}

type StoryInput struct {
	Filter []*StoryFilterInput `json:"filter"`
	Paging *PagingInput        `json:"paging"`
	Sort   []*StorySortInput   `json:"sort,omitempty"`
}

type StoryProducerPredicate struct {
	In    []StoryProducerEnum `json:"in,omitempty"`
	NotIn []StoryProducerEnum `json:"not_in,omitempty"`
}

type StorySeverityPredicate struct {
	In    []SeverityEnum `json:"in,omitempty"`
	NotIn []SeverityEnum `json:"not_in,omitempty"`
}

type StorySortInput struct {
	FieldName StorySortFieldName `json:"fieldName"`
	Order     *SortDirectionEnum `json:"order,omitempty"`
}

type StoryStatusPredicate struct {
	In    []StoryStatusEnum `json:"in,omitempty"`
	NotIn []StoryStatusEnum `json:"not_in,omitempty"`
}

type StoryThreatType struct {
	Details           *string `json:"details,omitempty"`
	Name              string  `json:"name"`
	RecommendedAction *string `json:"recommendedAction,omitempty"`
}

type StoryVerdictPredicate struct {
	In    []StoryVerdictEnum `json:"in,omitempty"`
	NotIn []StoryVerdictEnum `json:"not_in,omitempty"`
}

type StringFilterInput struct {
	Eq  *string  `json:"eq,omitempty"`
	In  []string `json:"in,omitempty"`
	Neq *string  `json:"neq,omitempty"`
	Nin []string `json:"nin,omitempty"`
}

type StringPredicate struct {
	Contains *string   `json:"contains,omitempty"`
	In       []*string `json:"in,omitempty"`
	NotIn    []*string `json:"not_in,omitempty"`
}

type StringValue struct {
	String *string `json:"string,omitempty"`
}

func (StringValue) IsValue() {}

type StringValueSetRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (StringValueSetRef) IsObjectRef()         {}
func (this StringValueSetRef) GetID() string   { return this.ID }
func (this StringValueSetRef) GetName() string { return this.Name }

type StringValueSetRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

type SubDomain struct {
	AccountID   string `json:"accountId"`
	AccountName string `json:"accountName"`
	AccountType string `json:"accountType"`
	SubDomain   string `json:"subDomain"`
}

// A reference identifying the SubscriptionGroup object. ID: Unique SubscriptionGroup Identifier, Name: The SubscriptionGroup Name
type SubscriptionGroupRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (SubscriptionGroupRef) IsObjectRef()         {}
func (this SubscriptionGroupRef) GetID() string   { return this.ID }
func (this SubscriptionGroupRef) GetName() string { return this.Name }

type SubscriptionGroupRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

// A reference identifying the SubscriptionMailingList object. ID: Unique SubscriptionMailingList Identifier, Name: The SubscriptionMailingList Name
type SubscriptionMailingListRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (SubscriptionMailingListRef) IsObjectRef()         {}
func (this SubscriptionMailingListRef) GetID() string   { return this.ID }
func (this SubscriptionMailingListRef) GetName() string { return this.Name }

type SubscriptionMailingListRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

// A reference identifying the SubscriptionWebhook object. ID: Unique SubscriptionWebhook Identifier, Name: The SubscriptionWebhook Name
type SubscriptionWebhookRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (SubscriptionWebhookRef) IsObjectRef()         {}
func (this SubscriptionWebhookRef) GetID() string   { return this.ID }
func (this SubscriptionWebhookRef) GetName() string { return this.Name }

type SubscriptionWebhookRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

// A reference identifying the SystemGroup object. ID: Unique SystemGroup Identifier, Name: The SystemGroup Name
type SystemGroupRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (SystemGroupRef) IsObjectRef()         {}
func (this SystemGroupRef) GetID() string   { return this.ID }
func (this SystemGroupRef) GetName() string { return this.Name }

type SystemGroupRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

type TaggingMethodFilterInput struct {
	Eq  *TaggingMethod  `json:"eq,omitempty"`
	In  []TaggingMethod `json:"in,omitempty"`
	Neq *TaggingMethod  `json:"neq,omitempty"`
	Nin []TaggingMethod `json:"nin,omitempty"`
}

type TerminalServerAddRuleDataInput struct {
	AllowedHostIP  *GlobalIPRangeRefInput   `json:"allowedHostIP"`
	Description    string                   `json:"description"`
	Enabled        bool                     `json:"enabled"`
	ExcludeTraffic []*GlobalIPRangeRefInput `json:"excludeTraffic"`
	Name           string                   `json:"name"`
}

type TerminalServerAddRuleInput struct {
	At   *PolicyRulePositionInput        `json:"at,omitempty"`
	Rule *TerminalServerAddRuleDataInput `json:"rule"`
}

type TerminalServerPolicy struct {
	Audit    *PolicyAudit                 `json:"audit,omitempty"`
	Enabled  bool                         `json:"enabled"`
	Revision *PolicyRevision              `json:"revision,omitempty"`
	Rules    []*TerminalServerRulePayload `json:"rules"`
	Sections []*PolicySectionPayload      `json:"sections"`
}

func (TerminalServerPolicy) IsIPolicy()                        {}
func (this TerminalServerPolicy) GetAudit() *PolicyAudit       { return this.Audit }
func (this TerminalServerPolicy) GetEnabled() bool             { return this.Enabled }
func (this TerminalServerPolicy) GetRevision() *PolicyRevision { return this.Revision }
func (this TerminalServerPolicy) GetRules() []IPolicyRulePayload {
	if this.Rules == nil {
		return nil
	}
	interfaceSlice := make([]IPolicyRulePayload, 0, len(this.Rules))
	for _, concrete := range this.Rules {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this TerminalServerPolicy) GetSections() []*PolicySectionPayload {
	if this.Sections == nil {
		return nil
	}
	interfaceSlice := make([]*PolicySectionPayload, 0, len(this.Sections))
	for _, concrete := range this.Sections {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

type TerminalServerPolicyInput struct {
	Revision *PolicyRevisionInput `json:"revision,omitempty"`
}

type TerminalServerPolicyMutationInput struct {
	Revision *PolicyMutationRevisionInput `json:"revision,omitempty"`
}

type TerminalServerPolicyMutationPayload struct {
	Errors []*PolicyMutationError `json:"errors"`
	Policy *TerminalServerPolicy  `json:"policy,omitempty"`
	Status PolicyMutationStatus   `json:"status"`
}

func (TerminalServerPolicyMutationPayload) IsIPolicyMutationPayload() {}
func (this TerminalServerPolicyMutationPayload) GetErrors() []*PolicyMutationError {
	if this.Errors == nil {
		return nil
	}
	interfaceSlice := make([]*PolicyMutationError, 0, len(this.Errors))
	for _, concrete := range this.Errors {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this TerminalServerPolicyMutationPayload) GetPolicy() IPolicy              { return *this.Policy }
func (this TerminalServerPolicyMutationPayload) GetStatus() PolicyMutationStatus { return this.Status }

type TerminalServerPolicyMutations struct {
	AddRule               *TerminalServerRuleMutationPayload   `json:"addRule"`
	AddSection            *PolicySectionMutationPayload        `json:"addSection"`
	CreatePolicyRevision  *TerminalServerPolicyMutationPayload `json:"createPolicyRevision"`
	DiscardPolicyRevision *TerminalServerPolicyMutationPayload `json:"discardPolicyRevision"`
	MoveRule              *TerminalServerRuleMutationPayload   `json:"moveRule"`
	MoveSection           *PolicySectionMutationPayload        `json:"moveSection"`
	PublishPolicyRevision *TerminalServerPolicyMutationPayload `json:"publishPolicyRevision"`
	RemoveRule            *TerminalServerRuleMutationPayload   `json:"removeRule"`
	RemoveSection         *PolicySectionMutationPayload        `json:"removeSection"`
	UpdatePolicy          *TerminalServerPolicyMutationPayload `json:"updatePolicy"`
	UpdateRule            *TerminalServerRuleMutationPayload   `json:"updateRule"`
	UpdateSection         *PolicySectionMutationPayload        `json:"updateSection"`
}

type TerminalServerPolicyQueries struct {
	Policy    *TerminalServerPolicy   `json:"policy"`
	Revisions *PolicyRevisionsPayload `json:"revisions,omitempty"`
}

type TerminalServerPolicyUpdateInput struct {
	State *PolicyToggleState `json:"state,omitempty"`
}

type TerminalServerRemoveRuleInput struct {
	ID string `json:"id"`
}

type TerminalServerRule struct {
	AllowedHostIP  *GlobalIPRangeRef   `json:"allowedHostIP"`
	Description    string              `json:"description"`
	Enabled        bool                `json:"enabled"`
	ExcludeTraffic []*GlobalIPRangeRef `json:"excludeTraffic"`
	ID             string              `json:"id"`
	Index          int64               `json:"index"`
	Name           string              `json:"name"`
	Section        *PolicySectionInfo  `json:"section"`
}

func (TerminalServerRule) IsIPolicyRule()                      {}
func (this TerminalServerRule) GetDescription() *string        { return &this.Description }
func (this TerminalServerRule) GetEnabled() bool               { return this.Enabled }
func (this TerminalServerRule) GetID() string                  { return this.ID }
func (this TerminalServerRule) GetIndex() int64                { return this.Index }
func (this TerminalServerRule) GetName() string                { return this.Name }
func (this TerminalServerRule) GetSection() *PolicySectionInfo { return this.Section }

type TerminalServerRuleMutationPayload struct {
	Errors []*PolicyMutationError     `json:"errors"`
	Rule   *TerminalServerRulePayload `json:"rule,omitempty"`
	Status PolicyMutationStatus       `json:"status"`
}

func (TerminalServerRuleMutationPayload) IsIPolicyRuleMutationPayload() {}
func (this TerminalServerRuleMutationPayload) GetErrors() []*PolicyMutationError {
	if this.Errors == nil {
		return nil
	}
	interfaceSlice := make([]*PolicyMutationError, 0, len(this.Errors))
	for _, concrete := range this.Errors {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this TerminalServerRuleMutationPayload) GetRule() IPolicyRulePayload     { return *this.Rule }
func (this TerminalServerRuleMutationPayload) GetStatus() PolicyMutationStatus { return this.Status }

type TerminalServerRulePayload struct {
	Audit      *PolicyElementAudit           `json:"audit"`
	Properties []PolicyElementPropertiesEnum `json:"properties"`
	Rule       *TerminalServerRule           `json:"rule"`
}

func (TerminalServerRulePayload) IsIPolicyRulePayload()              {}
func (this TerminalServerRulePayload) GetAudit() *PolicyElementAudit { return this.Audit }
func (this TerminalServerRulePayload) GetProperties() []PolicyElementPropertiesEnum {
	if this.Properties == nil {
		return nil
	}
	interfaceSlice := make([]PolicyElementPropertiesEnum, 0, len(this.Properties))
	for _, concrete := range this.Properties {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this TerminalServerRulePayload) GetRule() IPolicyRule { return *this.Rule }

type TerminalServerUpdateRuleDataInput struct {
	AllowedHostIP  *GlobalIPRangeRefInput   `json:"allowedHostIP,omitempty"`
	Description    *string                  `json:"description,omitempty"`
	Enabled        *bool                    `json:"enabled,omitempty"`
	ExcludeTraffic []*GlobalIPRangeRefInput `json:"excludeTraffic,omitempty"`
	Name           *string                  `json:"name,omitempty"`
}

type TerminalServerUpdateRuleInput struct {
	ID   string                             `json:"id"`
	Rule *TerminalServerUpdateRuleDataInput `json:"rule"`
}

// The "Threat" object represents a comprehensive data structure used in GraphQL queries or mutations to encapsulate various attributes and metadata related to a threat incident, including details about the threat's origin, nature, risk assessment, and associated network traffic flows.
type Threat struct {
	AnalystFeedback     *AnalystFeedback      `json:"analystFeedback,omitempty"`
	ClientClass         []string              `json:"clientClass"`
	ConnectionType      *ConnectionTypeEnum   `json:"connectionType,omitempty"`
	Criticality         *int64                `json:"criticality,omitempty"`
	Description         *string               `json:"description,omitempty"`
	DeviceName          *string               `json:"deviceName,omitempty"`
	Direction           *string               `json:"direction,omitempty"`
	EngineType          *StoryEngineTypeEnum  `json:"engineType,omitempty"`
	Events              []*Event              `json:"events,omitempty"`
	FirstSignal         string                `json:"firstSignal"`
	Flows               []*IncidentFlow       `json:"flows,omitempty"`
	FlowsCardinality    *int64                `json:"flowsCardinality,omitempty"`
	ID                  string                `json:"id"`
	Indication          string                `json:"indication"`
	LastSignal          string                `json:"lastSignal"`
	LogonName           *string               `json:"logonName,omitempty"`
	MacAddress          *string               `json:"macAddress,omitempty"`
	Mitres              []*Mitre              `json:"mitres,omitempty"`
	Os                  *string               `json:"os,omitempty"`
	PredictedThreatType *string               `json:"predictedThreatType,omitempty"`
	PredictedVerdict    *StoryVerdictEnum     `json:"predictedVerdict,omitempty"`
	Producer            StoryProducerEnum     `json:"producer"`
	ProducerName        string                `json:"producerName"`
	QueryName           *string               `json:"queryName,omitempty"`
	Research            *bool                 `json:"research,omitempty"`
	RiskLevel           *RiskLevelEnum        `json:"riskLevel,omitempty"`
	SimilarStoriesData  []*SimilarStoryData   `json:"similarStoriesData"`
	Site                *SiteRef              `json:"site,omitempty"`
	SiteName            *string               `json:"siteName,omitempty"`
	Source              *string               `json:"source,omitempty"`
	SourceIP            *string               `json:"sourceIp,omitempty"`
	SrcSiteID           *string               `json:"srcSiteId,omitempty"`
	Status              *StoryStatusEnum      `json:"status,omitempty"`
	StoryDuration       *int64                `json:"storyDuration,omitempty"`
	Targets             []*IncidentTargetRep  `json:"targets"`
	Ticket              *string               `json:"ticket,omitempty"`
	TimeSeries          []*IncidentTimeseries `json:"timeSeries,omitempty"`
	User                *UserRef              `json:"user,omitempty"`
	Vendor              *VendorEnum           `json:"vendor,omitempty"`
}

func (Threat) IsMergedIncident()                           {}
func (this Threat) GetAnalystFeedback() *AnalystFeedback   { return this.AnalystFeedback }
func (this Threat) GetConnectionType() *ConnectionTypeEnum { return this.ConnectionType }
func (this Threat) GetCriticality() *int64                 { return this.Criticality }
func (this Threat) GetDescription() *string                { return this.Description }
func (this Threat) GetEngineType() *StoryEngineTypeEnum    { return this.EngineType }
func (this Threat) GetFirstSignal() string                 { return this.FirstSignal }
func (this Threat) GetID() string                          { return this.ID }
func (this Threat) GetIndication() string                  { return this.Indication }
func (this Threat) GetLastSignal() string                  { return this.LastSignal }
func (this Threat) GetPredictedThreatType() *string        { return this.PredictedThreatType }
func (this Threat) GetPredictedVerdict() *StoryVerdictEnum { return this.PredictedVerdict }
func (this Threat) GetProducer() StoryProducerEnum         { return this.Producer }
func (this Threat) GetProducerName() string                { return this.ProducerName }
func (this Threat) GetQueryName() *string                  { return this.QueryName }
func (this Threat) GetResearch() *bool                     { return this.Research }
func (this Threat) GetSite() *SiteRef                      { return this.Site }
func (this Threat) GetSiteName() *string                   { return this.SiteName }
func (this Threat) GetSource() *string                     { return this.Source }
func (this Threat) GetSourceIP() *string                   { return this.SourceIP }
func (this Threat) GetStatus() *StoryStatusEnum            { return this.Status }
func (this Threat) GetStoryDuration() *int64               { return this.StoryDuration }
func (this Threat) GetTicket() *string                     { return this.Ticket }
func (this Threat) GetUser() *UserRef                      { return this.User }
func (this Threat) GetVendor() *VendorEnum                 { return this.Vendor }

// The `ThreatPrevention` object is a GraphQL type that represents the details of a threat prevention incident, including fields such as analyst feedback, client class, connection type, criticality, description, device name, and various other attributes related to the incident's signals, events, and status.
type ThreatPrevention struct {
	AnalystFeedback         *AnalystFeedback          `json:"analystFeedback,omitempty"`
	ClientClass             []string                  `json:"clientClass"`
	ConnectionType          *ConnectionTypeEnum       `json:"connectionType,omitempty"`
	Criticality             *int64                    `json:"criticality,omitempty"`
	Description             *string                   `json:"description,omitempty"`
	DeviceName              *string                   `json:"deviceName,omitempty"`
	Direction               *string                   `json:"direction,omitempty"`
	EngineType              *StoryEngineTypeEnum      `json:"engineType,omitempty"`
	Events                  []*Event                  `json:"events,omitempty"`
	FirstSignal             string                    `json:"firstSignal"`
	FlowsCardinality        *int64                    `json:"flowsCardinality,omitempty"`
	ID                      string                    `json:"id"`
	Indication              string                    `json:"indication"`
	LastSignal              string                    `json:"lastSignal"`
	LogonName               *string                   `json:"logonName,omitempty"`
	MacAddress              *string                   `json:"macAddress,omitempty"`
	Mitres                  []*Mitre                  `json:"mitres,omitempty"`
	Os                      *string                   `json:"os,omitempty"`
	PredictedThreatType     *string                   `json:"predictedThreatType,omitempty"`
	PredictedVerdict        *StoryVerdictEnum         `json:"predictedVerdict,omitempty"`
	Producer                StoryProducerEnum         `json:"producer"`
	ProducerName            string                    `json:"producerName"`
	QueryName               *string                   `json:"queryName,omitempty"`
	Research                *bool                     `json:"research,omitempty"`
	RiskLevel               *RiskLevelEnum            `json:"riskLevel,omitempty"`
	SimilarStoriesData      []*SimilarStoryData       `json:"similarStoriesData"`
	Site                    *SiteRef                  `json:"site,omitempty"`
	SiteName                *string                   `json:"siteName,omitempty"`
	Source                  *string                   `json:"source,omitempty"`
	SourceIP                *string                   `json:"sourceIp,omitempty"`
	SrcSiteID               *string                   `json:"srcSiteId,omitempty"`
	Status                  *StoryStatusEnum          `json:"status,omitempty"`
	StoryDuration           *int64                    `json:"storyDuration,omitempty"`
	Targets                 []*IncidentTargetRep      `json:"targets"`
	ThreatPreventionsEvents []*ThreatPreventionEvents `json:"threatPreventionsEvents,omitempty"`
	Ticket                  *string                   `json:"ticket,omitempty"`
	TimeSeries              []*IncidentTimeseries     `json:"timeSeries,omitempty"`
	User                    *UserRef                  `json:"user,omitempty"`
	Vendor                  *VendorEnum               `json:"vendor,omitempty"`
}

func (ThreatPrevention) IsMergedIncident()                           {}
func (this ThreatPrevention) GetAnalystFeedback() *AnalystFeedback   { return this.AnalystFeedback }
func (this ThreatPrevention) GetConnectionType() *ConnectionTypeEnum { return this.ConnectionType }
func (this ThreatPrevention) GetCriticality() *int64                 { return this.Criticality }
func (this ThreatPrevention) GetDescription() *string                { return this.Description }
func (this ThreatPrevention) GetEngineType() *StoryEngineTypeEnum    { return this.EngineType }
func (this ThreatPrevention) GetFirstSignal() string                 { return this.FirstSignal }
func (this ThreatPrevention) GetID() string                          { return this.ID }
func (this ThreatPrevention) GetIndication() string                  { return this.Indication }
func (this ThreatPrevention) GetLastSignal() string                  { return this.LastSignal }
func (this ThreatPrevention) GetPredictedThreatType() *string        { return this.PredictedThreatType }
func (this ThreatPrevention) GetPredictedVerdict() *StoryVerdictEnum { return this.PredictedVerdict }
func (this ThreatPrevention) GetProducer() StoryProducerEnum         { return this.Producer }
func (this ThreatPrevention) GetProducerName() string                { return this.ProducerName }
func (this ThreatPrevention) GetQueryName() *string                  { return this.QueryName }
func (this ThreatPrevention) GetResearch() *bool                     { return this.Research }
func (this ThreatPrevention) GetSite() *SiteRef                      { return this.Site }
func (this ThreatPrevention) GetSiteName() *string                   { return this.SiteName }
func (this ThreatPrevention) GetSource() *string                     { return this.Source }
func (this ThreatPrevention) GetSourceIP() *string                   { return this.SourceIP }
func (this ThreatPrevention) GetStatus() *StoryStatusEnum            { return this.Status }
func (this ThreatPrevention) GetStoryDuration() *int64               { return this.StoryDuration }
func (this ThreatPrevention) GetTicket() *string                     { return this.Ticket }
func (this ThreatPrevention) GetUser() *UserRef                      { return this.User }
func (this ThreatPrevention) GetVendor() *VendorEnum                 { return this.Vendor }

type ThreatPreventionEvents struct {
	AppName                *string `json:"appName,omitempty"`
	ClientClass            *string `json:"clientClass,omitempty"`
	CreatedAt              *string `json:"createdAt,omitempty"`
	DestinationCountry     *string `json:"destinationCountry,omitempty"`
	DestinationGeolocation *string `json:"destinationGeolocation,omitempty"`
	DestinationIP          *string `json:"destinationIp,omitempty"`
	DestinationPort        *int64  `json:"destinationPort,omitempty"`
	Direction              *string `json:"direction,omitempty"`
	DNSResponseIP          *string `json:"dnsResponseIP,omitempty"`
	Domain                 *string `json:"domain,omitempty"`
	FileHash               *string `json:"fileHash,omitempty"`
	HTTPResponseCode       *int64  `json:"httpResponseCode,omitempty"`
	Ja3                    *string `json:"ja3,omitempty"`
	Method                 *string `json:"method,omitempty"`
	Referrer               *string `json:"referrer,omitempty"`
	SmbFileName            *string `json:"smbFileName,omitempty"`
	SourceGeolocation      *string `json:"sourceGeolocation,omitempty"`
	SourceIP               *string `json:"sourceIp,omitempty"`
	SourcePort             *int64  `json:"sourcePort,omitempty"`
	Target                 *string `json:"target,omitempty"`
	TunnelGeolocation      *string `json:"tunnelGeolocation,omitempty"`
	URL                    *string `json:"url,omitempty"`
	User                   *string `json:"user,omitempty"`
	UserAgent              *string `json:"userAgent,omitempty"`
}

// Threat Prevention (TP) license details
type ThreatPreventionLicense struct {
	Description    *string       `json:"description,omitempty"`
	ExpirationDate string        `json:"expirationDate"`
	ID             *string       `json:"id,omitempty"`
	LastUpdated    *string       `json:"lastUpdated,omitempty"`
	Plan           LicensePlan   `json:"plan"`
	Sku            LicenseSku    `json:"sku"`
	StartDate      *string       `json:"startDate,omitempty"`
	Status         LicenseStatus `json:"status"`
}

func (ThreatPreventionLicense) IsLicense()                     {}
func (this ThreatPreventionLicense) GetDescription() *string   { return this.Description }
func (this ThreatPreventionLicense) GetExpirationDate() string { return this.ExpirationDate }
func (this ThreatPreventionLicense) GetID() *string            { return this.ID }
func (this ThreatPreventionLicense) GetLastUpdated() *string   { return this.LastUpdated }
func (this ThreatPreventionLicense) GetPlan() LicensePlan      { return this.Plan }
func (this ThreatPreventionLicense) GetSku() LicenseSku        { return this.Sku }
func (this ThreatPreventionLicense) GetStartDate() *string     { return this.StartDate }
func (this ThreatPreventionLicense) GetStatus() LicenseStatus  { return this.Status }

// An object for marking specific events in time.
type TimeAnnotation struct {
	Label      string         `json:"label"`
	ShortLabel string         `json:"shortLabel"`
	Time       float64        `json:"time"`
	Type       AnnotationType `json:"type"`
}

type TimeFramePredicate struct {
	Time              string             `json:"time"`
	TimeFrameModifier *TimeFrameModifier `json:"timeFrameModifier,omitempty"`
}

// An object for marking durations!
type TimePeriod struct {
	Duration []float64  `json:"duration"`
	Title    string     `json:"title"`
	Type     PeriodType `json:"type"`
}

type TimeSeriesEvents struct {
	AccountID  string                  `json:"accountID"`
	Buckets    int64                   `json:"buckets"`
	Dimensions []*GraphEventsDimension `json:"dimensions"`
	Filters    []*GraphEventsFilter    `json:"filters"`
	Measures   []*GraphEventsMeasure   `json:"measures"`
	TimeFrame  string                  `json:"timeFrame"`
}

// For XDR stories, items that happened during the lifetime of the story
type TimelineItem struct {
	AdditionalInfo *string                   `json:"additionalInfo,omitempty"`
	AnalystInfo    *AnalystInfo              `json:"analystInfo,omitempty"`
	Category       *TimelineItemCategoryEnum `json:"category,omitempty"`
	Context        string                    `json:"context"`
	CreatedAt      string                    `json:"createdAt"`
	Description    string                    `json:"description"`
	Descriptions   []string                  `json:"descriptions"`
	Type           TimelineTypeEnum          `json:"type"`
}

type Timeseries struct {
	Data       [][]float64      `json:"data,omitempty"`
	Dimensions []*DimensionData `json:"dimensions,omitempty"`
	Info       []string         `json:"info,omitempty"`
	Key        *TimeseriesKey   `json:"key,omitempty"`
	Label      string           `json:"label"`
	Sum        *float64         `json:"sum,omitempty"`
	Units      *UnitType        `json:"units,omitempty"`
}

type TimeseriesKey struct {
	Dimensions       []*DimensionKey `json:"dimensions,omitempty"`
	MeasureFieldName string          `json:"measureFieldName"`
}

type TLSInspectAddRuleDataInput struct {
	Action                     TLSInspectAction                     `json:"action"`
	Application                *TLSInspectApplicationInput          `json:"application"`
	ConnectionOrigin           ConnectionOriginEnum                 `json:"connectionOrigin"`
	Country                    []*CountryRefInput                   `json:"country"`
	Description                string                               `json:"description"`
	DevicePostureProfile       []*DeviceProfileRefInput             `json:"devicePostureProfile"`
	Enabled                    bool                                 `json:"enabled"`
	Name                       string                               `json:"name"`
	Platform                   []OperatingSystem                    `json:"platform"`
	Source                     *TLSInspectSourceInput               `json:"source"`
	UntrustedCertificateAction TLSInspectUntrustedCertificateAction `json:"untrustedCertificateAction"`
}

type TLSInspectAddRuleInput struct {
	At   *PolicyRulePositionInput    `json:"at,omitempty"`
	Rule *TLSInspectAddRuleDataInput `json:"rule"`
}

// Application match criteria set
type TLSInspectApplication struct {
	AppCategory        []*ApplicationCategoryRef  `json:"appCategory"`
	Application        []*ApplicationRef          `json:"application"`
	Country            []*CountryRef              `json:"country"`
	CustomApp          []*CustomApplicationRef    `json:"customApp"`
	CustomCategory     []*CustomCategoryRef       `json:"customCategory"`
	CustomService      []*CustomService           `json:"customService"`
	CustomServiceIP    []*CustomServiceIP         `json:"customServiceIp"`
	Domain             []string                   `json:"domain"`
	Fqdn               []string                   `json:"fqdn"`
	GlobalIPRange      []*GlobalIPRangeRef        `json:"globalIpRange"`
	IP                 []string                   `json:"ip"`
	IPRange            []*IPAddressRange          `json:"ipRange"`
	RemoteAsn          []scalars.Asn32            `json:"remoteAsn"`
	Service            []*ServiceRef              `json:"service"`
	Subnet             []string                   `json:"subnet"`
	TLSInspectCategory []TLSInspectSystemCategory `json:"tlsInspectCategory"`
}

// Application match criteria set
type TLSInspectApplicationInput struct {
	AppCategory        []*ApplicationCategoryRefInput `json:"appCategory"`
	Application        []*ApplicationRefInput         `json:"application"`
	Country            []*CountryRefInput             `json:"country"`
	CustomApp          []*CustomApplicationRefInput   `json:"customApp"`
	CustomCategory     []*CustomCategoryRefInput      `json:"customCategory"`
	CustomService      []*CustomServiceInput          `json:"customService"`
	CustomServiceIP    []*CustomServiceIPInput        `json:"customServiceIp"`
	Domain             []string                       `json:"domain"`
	Fqdn               []string                       `json:"fqdn"`
	GlobalIPRange      []*GlobalIPRangeRefInput       `json:"globalIpRange"`
	IP                 []string                       `json:"ip"`
	IPRange            []*IPAddressRangeInput         `json:"ipRange"`
	RemoteAsn          []scalars.Asn32                `json:"remoteAsn"`
	Service            []*ServiceRefInput             `json:"service"`
	Subnet             []string                       `json:"subnet"`
	TLSInspectCategory []TLSInspectSystemCategory     `json:"tlsInspectCategory"`
}

// Application match criteria set
type TLSInspectApplicationUpdateInput struct {
	AppCategory        []*ApplicationCategoryRefInput `json:"appCategory,omitempty"`
	Application        []*ApplicationRefInput         `json:"application,omitempty"`
	Country            []*CountryRefInput             `json:"country,omitempty"`
	CustomApp          []*CustomApplicationRefInput   `json:"customApp,omitempty"`
	CustomCategory     []*CustomCategoryRefInput      `json:"customCategory,omitempty"`
	CustomService      []*CustomServiceInput          `json:"customService,omitempty"`
	CustomServiceIP    []*CustomServiceIPInput        `json:"customServiceIp,omitempty"`
	Domain             []string                       `json:"domain,omitempty"`
	Fqdn               []string                       `json:"fqdn,omitempty"`
	GlobalIPRange      []*GlobalIPRangeRefInput       `json:"globalIpRange,omitempty"`
	IP                 []string                       `json:"ip,omitempty"`
	IPRange            []*IPAddressRangeInput         `json:"ipRange,omitempty"`
	RemoteAsn          []scalars.Asn32                `json:"remoteAsn,omitempty"`
	Service            []*ServiceRefInput             `json:"service,omitempty"`
	Subnet             []string                       `json:"subnet,omitempty"`
	TLSInspectCategory []TLSInspectSystemCategory     `json:"tlsInspectCategory,omitempty"`
}

// Default rule settings for the TLS Inspection policy
type TLSInspectConfig struct {
	DefaultRuleAction                     TLSInspectAction                     `json:"defaultRuleAction"`
	DefaultRuleUntrustedCertificateAction TLSInspectUntrustedCertificateAction `json:"defaultRuleUntrustedCertificateAction"`
}

type TLSInspectConfigInput struct {
	DefaultRuleAction                     TLSInspectAction                     `json:"defaultRuleAction"`
	DefaultRuleUntrustedCertificateAction TLSInspectUntrustedCertificateAction `json:"defaultRuleUntrustedCertificateAction"`
}

type TLSInspectPolicy struct {
	AdditionalAttributes *TLSInspectConfig        `json:"additionalAttributes,omitempty"`
	Audit                *PolicyAudit             `json:"audit,omitempty"`
	Enabled              bool                     `json:"enabled"`
	Revision             *PolicyRevision          `json:"revision,omitempty"`
	Rules                []*TLSInspectRulePayload `json:"rules"`
	Sections             []*PolicySectionPayload  `json:"sections"`
}

func (TLSInspectPolicy) IsIPolicy()                        {}
func (this TLSInspectPolicy) GetAudit() *PolicyAudit       { return this.Audit }
func (this TLSInspectPolicy) GetEnabled() bool             { return this.Enabled }
func (this TLSInspectPolicy) GetRevision() *PolicyRevision { return this.Revision }
func (this TLSInspectPolicy) GetRules() []IPolicyRulePayload {
	if this.Rules == nil {
		return nil
	}
	interfaceSlice := make([]IPolicyRulePayload, 0, len(this.Rules))
	for _, concrete := range this.Rules {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this TLSInspectPolicy) GetSections() []*PolicySectionPayload {
	if this.Sections == nil {
		return nil
	}
	interfaceSlice := make([]*PolicySectionPayload, 0, len(this.Sections))
	for _, concrete := range this.Sections {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

type TLSInspectPolicyInput struct {
	Revision *PolicyRevisionInput `json:"revision,omitempty"`
}

type TLSInspectPolicyMutationInput struct {
	Revision *PolicyMutationRevisionInput `json:"revision,omitempty"`
}

type TLSInspectPolicyMutationPayload struct {
	Errors []*PolicyMutationError `json:"errors"`
	Policy *TLSInspectPolicy      `json:"policy,omitempty"`
	Status PolicyMutationStatus   `json:"status"`
}

func (TLSInspectPolicyMutationPayload) IsIPolicyMutationPayload() {}
func (this TLSInspectPolicyMutationPayload) GetErrors() []*PolicyMutationError {
	if this.Errors == nil {
		return nil
	}
	interfaceSlice := make([]*PolicyMutationError, 0, len(this.Errors))
	for _, concrete := range this.Errors {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this TLSInspectPolicyMutationPayload) GetPolicy() IPolicy              { return *this.Policy }
func (this TLSInspectPolicyMutationPayload) GetStatus() PolicyMutationStatus { return this.Status }

type TLSInspectPolicyMutations struct {
	AddRule               *TLSInspectRuleMutationPayload   `json:"addRule"`
	AddSection            *PolicySectionMutationPayload    `json:"addSection"`
	CreatePolicyRevision  *TLSInspectPolicyMutationPayload `json:"createPolicyRevision"`
	DiscardPolicyRevision *TLSInspectPolicyMutationPayload `json:"discardPolicyRevision"`
	MoveRule              *TLSInspectRuleMutationPayload   `json:"moveRule"`
	MoveSection           *PolicySectionMutationPayload    `json:"moveSection"`
	PublishPolicyRevision *TLSInspectPolicyMutationPayload `json:"publishPolicyRevision"`
	RemoveRule            *TLSInspectRuleMutationPayload   `json:"removeRule"`
	RemoveSection         *PolicySectionMutationPayload    `json:"removeSection"`
	UpdatePolicy          *TLSInspectPolicyMutationPayload `json:"updatePolicy"`
	UpdateRule            *TLSInspectRuleMutationPayload   `json:"updateRule"`
	UpdateSection         *PolicySectionMutationPayload    `json:"updateSection"`
}

type TLSInspectPolicyQueries struct {
	Policy    *TLSInspectPolicy       `json:"policy"`
	Revisions *PolicyRevisionsPayload `json:"revisions,omitempty"`
}

type TLSInspectPolicyUpdateInput struct {
	AdditionalAttributes *TLSInspectConfigInput `json:"additionalAttributes,omitempty"`
	State                *PolicyToggleState     `json:"state,omitempty"`
}

type TLSInspectRemoveRuleInput struct {
	ID string `json:"id"`
}

type TLSInspectRule struct {
	Action                     TLSInspectAction                     `json:"action"`
	Application                *TLSInspectApplication               `json:"application"`
	ConnectionOrigin           ConnectionOriginEnum                 `json:"connectionOrigin"`
	Country                    []*CountryRef                        `json:"country"`
	Description                string                               `json:"description"`
	DevicePostureProfile       []*DeviceProfileRef                  `json:"devicePostureProfile"`
	Enabled                    bool                                 `json:"enabled"`
	ID                         string                               `json:"id"`
	Index                      int64                                `json:"index"`
	Name                       string                               `json:"name"`
	Platform                   []OperatingSystem                    `json:"platform"`
	Section                    *PolicySectionInfo                   `json:"section"`
	Source                     *TLSInspectSource                    `json:"source"`
	UntrustedCertificateAction TLSInspectUntrustedCertificateAction `json:"untrustedCertificateAction"`
}

func (TLSInspectRule) IsIPolicyRule()                      {}
func (this TLSInspectRule) GetDescription() *string        { return &this.Description }
func (this TLSInspectRule) GetEnabled() bool               { return this.Enabled }
func (this TLSInspectRule) GetID() string                  { return this.ID }
func (this TLSInspectRule) GetIndex() int64                { return this.Index }
func (this TLSInspectRule) GetName() string                { return this.Name }
func (this TLSInspectRule) GetSection() *PolicySectionInfo { return this.Section }

type TLSInspectRuleMutationPayload struct {
	Errors []*PolicyMutationError `json:"errors"`
	Rule   *TLSInspectRulePayload `json:"rule,omitempty"`
	Status PolicyMutationStatus   `json:"status"`
}

func (TLSInspectRuleMutationPayload) IsIPolicyRuleMutationPayload() {}
func (this TLSInspectRuleMutationPayload) GetErrors() []*PolicyMutationError {
	if this.Errors == nil {
		return nil
	}
	interfaceSlice := make([]*PolicyMutationError, 0, len(this.Errors))
	for _, concrete := range this.Errors {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this TLSInspectRuleMutationPayload) GetRule() IPolicyRulePayload     { return *this.Rule }
func (this TLSInspectRuleMutationPayload) GetStatus() PolicyMutationStatus { return this.Status }

type TLSInspectRulePayload struct {
	Audit      *PolicyElementAudit           `json:"audit"`
	Properties []PolicyElementPropertiesEnum `json:"properties"`
	Rule       *TLSInspectRule               `json:"rule"`
}

func (TLSInspectRulePayload) IsIPolicyRulePayload()              {}
func (this TLSInspectRulePayload) GetAudit() *PolicyElementAudit { return this.Audit }
func (this TLSInspectRulePayload) GetProperties() []PolicyElementPropertiesEnum {
	if this.Properties == nil {
		return nil
	}
	interfaceSlice := make([]PolicyElementPropertiesEnum, 0, len(this.Properties))
	for _, concrete := range this.Properties {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this TLSInspectRulePayload) GetRule() IPolicyRule { return *this.Rule }

// Returns the settings for Source of an TLS inspection rule
type TLSInspectSource struct {
	FloatingSubnet    []*FloatingSubnetRef    `json:"floatingSubnet"`
	GlobalIPRange     []*GlobalIPRangeRef     `json:"globalIpRange"`
	Group             []*GroupRef             `json:"group"`
	Host              []*HostRef              `json:"host"`
	IP                []string                `json:"ip"`
	IPRange           []*IPAddressRange       `json:"ipRange"`
	NetworkInterface  []*NetworkInterfaceRef  `json:"networkInterface"`
	Site              []*SiteRef              `json:"site"`
	SiteNetworkSubnet []*SiteNetworkSubnetRef `json:"siteNetworkSubnet"`
	Subnet            []string                `json:"subnet"`
	SystemGroup       []*SystemGroupRef       `json:"systemGroup"`
	User              []*UserRef              `json:"user"`
	UsersGroup        []*UsersGroupRef        `json:"usersGroup"`
}

// Input of the settings for Source of an TLS inspection rule
type TLSInspectSourceInput struct {
	FloatingSubnet    []*FloatingSubnetRefInput    `json:"floatingSubnet"`
	GlobalIPRange     []*GlobalIPRangeRefInput     `json:"globalIpRange"`
	Group             []*GroupRefInput             `json:"group"`
	Host              []*HostRefInput              `json:"host"`
	IP                []string                     `json:"ip"`
	IPRange           []*IPAddressRangeInput       `json:"ipRange"`
	NetworkInterface  []*NetworkInterfaceRefInput  `json:"networkInterface"`
	Site              []*SiteRefInput              `json:"site"`
	SiteNetworkSubnet []*SiteNetworkSubnetRefInput `json:"siteNetworkSubnet"`
	Subnet            []string                     `json:"subnet"`
	SystemGroup       []*SystemGroupRefInput       `json:"systemGroup"`
	User              []*UserRefInput              `json:"user"`
	UsersGroup        []*UsersGroupRefInput        `json:"usersGroup"`
}

// Input of the settings for Source of an TLS inspection rule
type TLSInspectSourceUpdateInput struct {
	FloatingSubnet    []*FloatingSubnetRefInput    `json:"floatingSubnet,omitempty"`
	GlobalIPRange     []*GlobalIPRangeRefInput     `json:"globalIpRange,omitempty"`
	Group             []*GroupRefInput             `json:"group,omitempty"`
	Host              []*HostRefInput              `json:"host,omitempty"`
	IP                []string                     `json:"ip,omitempty"`
	IPRange           []*IPAddressRangeInput       `json:"ipRange,omitempty"`
	NetworkInterface  []*NetworkInterfaceRefInput  `json:"networkInterface,omitempty"`
	Site              []*SiteRefInput              `json:"site,omitempty"`
	SiteNetworkSubnet []*SiteNetworkSubnetRefInput `json:"siteNetworkSubnet,omitempty"`
	Subnet            []string                     `json:"subnet,omitempty"`
	SystemGroup       []*SystemGroupRefInput       `json:"systemGroup,omitempty"`
	User              []*UserRefInput              `json:"user,omitempty"`
	UsersGroup        []*UsersGroupRefInput        `json:"usersGroup,omitempty"`
}

type TLSInspectUpdateRuleDataInput struct {
	Action                     *TLSInspectAction                     `json:"action,omitempty"`
	Application                *TLSInspectApplicationUpdateInput     `json:"application,omitempty"`
	ConnectionOrigin           *ConnectionOriginEnum                 `json:"connectionOrigin,omitempty"`
	Country                    []*CountryRefInput                    `json:"country,omitempty"`
	Description                *string                               `json:"description,omitempty"`
	DevicePostureProfile       []*DeviceProfileRefInput              `json:"devicePostureProfile,omitempty"`
	Enabled                    *bool                                 `json:"enabled,omitempty"`
	Name                       *string                               `json:"name,omitempty"`
	Platform                   []OperatingSystem                     `json:"platform,omitempty"`
	Source                     *TLSInspectSourceUpdateInput          `json:"source,omitempty"`
	UntrustedCertificateAction *TLSInspectUntrustedCertificateAction `json:"untrustedCertificateAction,omitempty"`
}

type TLSInspectUpdateRuleInput struct {
	ID   string                         `json:"id"`
	Rule *TLSInspectUpdateRuleDataInput `json:"rule"`
}

type TunnelConfig struct {
	LocalID                *string `json:"localId,omitempty"`
	TunnelID               *string `json:"tunnelId,omitempty"`
	TunnelRemoteIdentifier *string `json:"tunnelRemoteIdentifier,omitempty"`
}

type UnassignSocketFromZtnaAppConnectorInput struct {
	ZtnaAppConnector *ZtnaAppConnectorRefInput `json:"ztnaAppConnector"`
}

type UnassignSocketFromZtnaAppConnectorPayload struct {
	ZtnaAppConnector *ZtnaAppConnector `json:"ztnaAppConnector"`
}

type UpdateAccountInput struct {
	Description *string `json:"description,omitempty"`
}

type UpdateAccountRoleInput struct {
	ID   string  `json:"id"`
	Name *string `json:"name,omitempty"`
}

type UpdateAdminInput struct {
	FirstName            *string                 `json:"firstName,omitempty"`
	LastName             *string                 `json:"lastName,omitempty"`
	ManagedRoles         []*UpdateAdminRoleInput `json:"managedRoles,omitempty"`
	MfaEnabled           *bool                   `json:"mfaEnabled,omitempty"`
	PasswordNeverExpires *bool                   `json:"passwordNeverExpires,omitempty"`
	ResellerRoles        []*UpdateAdminRoleInput `json:"resellerRoles,omitempty"`
}

type UpdateAdminPayload struct {
	AdminID string `json:"adminID"`
}

type UpdateAdminRoleInput struct {
	AllowedAccounts []string                `json:"allowedAccounts,omitempty"`
	AllowedEntities []*EntityInput          `json:"allowedEntities,omitempty"`
	Role            *UpdateAccountRoleInput `json:"role"`
}

type UpdateBgpPeerInput struct {
	AdvertiseAllRoutes     *bool                   `json:"advertiseAllRoutes,omitempty"`
	AdvertiseDefaultRoute  *bool                   `json:"advertiseDefaultRoute,omitempty"`
	AdvertiseSummaryRoutes *bool                   `json:"advertiseSummaryRoutes,omitempty"`
	BfdEnabled             *bool                   `json:"bfdEnabled,omitempty"`
	BfdSettings            *BfdSettingsInput       `json:"bfdSettings,omitempty"`
	CatoAsn                *scalars.Asn16          `json:"catoAsn,omitempty"`
	DefaultAction          *BgpDefaultAction       `json:"defaultAction,omitempty"`
	DefaultActionExclusion []*BgpFilterRuleInput   `json:"defaultActionExclusion,omitempty"`
	HoldTime               *int64                  `json:"holdTime,omitempty"`
	ID                     string                  `json:"id"`
	KeepaliveInterval      *int64                  `json:"keepaliveInterval,omitempty"`
	Md5AuthKey             *string                 `json:"md5AuthKey,omitempty"`
	Metric                 *int64                  `json:"metric,omitempty"`
	Name                   *string                 `json:"name,omitempty"`
	PeerAsn                *scalars.Asn32          `json:"peerAsn,omitempty"`
	PeerIP                 *string                 `json:"peerIp,omitempty"`
	PerformNat             *bool                   `json:"performNat,omitempty"`
	SummaryRoute           []*BgpSummaryRouteInput `json:"summaryRoute,omitempty"`
	Tracking               *BgpTrackingInput       `json:"tracking,omitempty"`
}

type UpdateBgpPeerPayload struct {
	BgpPeer *BgpPeer `json:"bgpPeer"`
}

// Input for updating an existing physical connection at a cloud interconnect site.
type UpdateCloudInterconnectPhysicalConnectionInput struct {
	DownstreamBwLimit   *string              `json:"downstreamBwLimit,omitempty"`
	EncapsulationMethod *TaggingMethod       `json:"encapsulationMethod,omitempty"`
	ID                  string               `json:"id"`
	PopLocation         *PopLocationRefInput `json:"popLocation,omitempty"`
	PrivateCatoIP       *string              `json:"privateCatoIp,omitempty"`
	PrivateSiteIP       *string              `json:"privateSiteIp,omitempty"`
	ServiceProviderName *string              `json:"serviceProviderName,omitempty"`
	Subnet              *string              `json:"subnet,omitempty"`
	UpstreamBwLimit     *string              `json:"upstreamBwLimit,omitempty"`
}

// Payload for updating an existing physical connection at a cloud interconnect site.
type UpdateCloudInterconnectPhysicalConnectionPayload struct {
	ID string `json:"id"`
}

type UpdateCommercialLicenseInput struct {
	LicenseID string  `json:"licenseId"`
	StartDate *string `json:"startDate,omitempty"`
}

type UpdateCommercialLicensePayload struct {
	License License `json:"license"`
}

// Input for updating FQDN typed container from file
type UpdateFqdnContainerFromFileInput struct {
	Description *string            `json:"description,omitempty"`
	FileType    ContainerFileType  `json:"fileType"`
	Ref         *ContainerRefInput `json:"ref"`
	UploadFile  *graphql.Upload    `json:"uploadFile,omitempty"`
}

// Payload of UpdateFromFile operation on FQDN typed container
type UpdateFqdnContainerFromFilePayload struct {
	Container *FqdnContainer `json:"container"`
}

type UpdateFqdnContainerFromListInput struct {
	Description string             `json:"description"`
	Ref         *ContainerRefInput `json:"ref"`
	Values      []string           `json:"values,omitempty"`
}

// Payload of UpdateFromList operation on FQDN typed container
type UpdateFqdnContainerFromListPayload struct {
	Container *FqdnContainer `json:"container"`
}

// Update attributes for a group. Only the provided fields are updated - the other fields are not changed
// Note: You can only update a total of 500 group members at one time, this means 'membersToAdd + membersToRemove' or 'members' must be less than 500
type UpdateGroupInput struct {
	Description     *string                     `json:"description,omitempty"`
	Group           *GroupRefInput              `json:"group"`
	Members         []*GroupMemberRefTypedInput `json:"members,omitempty"`
	MembersToAdd    []*GroupMemberRefTypedInput `json:"membersToAdd,omitempty"`
	MembersToRemove []*GroupMemberRefTypedInput `json:"membersToRemove,omitempty"`
	Name            *string                     `json:"name,omitempty"`
}

// The updated group object
type UpdateGroupPayload struct {
	Group *Group `json:"group"`
}

type UpdateHaInput struct {
	PrimaryManagementIP   *string `json:"primaryManagementIp,omitempty"`
	SecondaryManagementIP *string `json:"secondaryManagementIp,omitempty"`
	Vrid                  *int64  `json:"vrid,omitempty"`
}

type UpdateHaPayload struct {
	SiteID string `json:"siteId"`
}

type UpdateHardwareShippingInput struct {
	Details *HardwareShippingDetailsInput `json:"details"`
	Ids     []string                      `json:"ids"`
}

// Input for updating existing IPAddressRange typed container from file
type UpdateIPAddressRangeContainerFromFileInput struct {
	Description *string            `json:"description,omitempty"`
	FileType    ContainerFileType  `json:"fileType"`
	Ref         *ContainerRefInput `json:"ref"`
	UploadFile  *graphql.Upload    `json:"uploadFile,omitempty"`
}

// Payload of UpdateFromFile operation on IPAddressRange typed container
type UpdateIPAddressRangeContainerFromFilePayload struct {
	Container *IPAddressRangeContainer `json:"container"`
}

type UpdateIPAddressRangeContainerFromListInput struct {
	Description string                 `json:"description"`
	Ref         *ContainerRefInput     `json:"ref"`
	Values      []*IPAddressRangeInput `json:"values,omitempty"`
}

// Payload of UpdateFromList operation on IPAddressRange typed container
type UpdateIPAddressRangeContainerFromListPayload struct {
	Container *IPAddressRangeContainer `json:"container"`
}

type UpdateIpsecIkeV2SiteGeneralDetailsInput struct {
	AuthMessage        *IpsecIkeV2MessageInput `json:"authMessage,omitempty"`
	ConnectionMode     *ConnectionMode         `json:"connectionMode,omitempty"`
	IdentificationType *IdentificationType     `json:"identificationType,omitempty"`
	InitMessage        *IpsecIkeV2MessageInput `json:"initMessage,omitempty"`
	NetworkRanges      []*string               `json:"networkRanges,omitempty"`
}

type UpdateIpsecIkeV2SiteGeneralDetailsPayload struct {
	LocalID *string `json:"localId,omitempty"`
	SiteID  string  `json:"siteId"`
}

type UpdateIpsecIkeV2SiteMultiTunnelPayload struct {
	Fqdn    *string                              `json:"fqdn,omitempty"`
	Tunnels []*UpdateIpsecIkeV2SiteTunnelPayload `json:"tunnels"`
}

type UpdateIpsecIkeV2SiteTunnelPayload struct {
	LocalID  *string             `json:"localId,omitempty"`
	TunnelID *IPSecV2InterfaceID `json:"tunnelId,omitempty"`
}

type UpdateIpsecIkeV2SiteTunnelsInput struct {
	Primary   *UpdateIpsecIkeV2TunnelsInput `json:"primary,omitempty"`
	Secondary *UpdateIpsecIkeV2TunnelsInput `json:"secondary,omitempty"`
}

type UpdateIpsecIkeV2SiteTunnelsPayload struct {
	Primary   *UpdateIpsecIkeV2SiteMultiTunnelPayload `json:"primary,omitempty"`
	Secondary *UpdateIpsecIkeV2SiteMultiTunnelPayload `json:"secondary,omitempty"`
	SiteID    string                                  `json:"siteId"`
}

type UpdateIpsecIkeV2TunnelInput struct {
	LastMileBw    *LastMileBwInput   `json:"lastMileBw,omitempty"`
	Name          *string            `json:"name,omitempty"`
	PrivateCatoIP *string            `json:"privateCatoIp,omitempty"`
	PrivateSiteIP *string            `json:"privateSiteIp,omitempty"`
	Psk           *string            `json:"psk,omitempty"`
	PublicSiteIP  *string            `json:"publicSiteIp,omitempty"`
	Role          *IPSecV2TunnelRole `json:"role,omitempty"`
	TunnelID      IPSecV2InterfaceID `json:"tunnelId"`
}

type UpdateIpsecIkeV2TunnelsInput struct {
	DestinationType *DestinationType               `json:"destinationType,omitempty"`
	PopLocationID   *string                        `json:"popLocationId,omitempty"`
	PublicCatoIPID  *string                        `json:"publicCatoIpId,omitempty"`
	Tunnels         []*UpdateIpsecIkeV2TunnelInput `json:"tunnels"`
}

type UpdateLocationDetailsInput struct {
	CompanyName   *string              `json:"companyName,omitempty"`
	Contact       *ContactDetailsInput `json:"contact,omitempty"`
	PostalAddress *PostalAddressInput  `json:"postalAddress,omitempty"`
	VatID         *string              `json:"vatId,omitempty"`
}

type UpdateNetworkRangeInput struct {
	AzureFloatingIP  *string                   `json:"azureFloatingIp,omitempty"`
	DhcpSettings     *NetworkDhcpSettingsInput `json:"dhcpSettings,omitempty"`
	Gateway          *string                   `json:"gateway,omitempty"`
	InternetOnly     *bool                     `json:"internetOnly,omitempty"`
	LocalIP          *string                   `json:"localIp,omitempty"`
	MdnsReflector    *bool                     `json:"mdnsReflector,omitempty"`
	Name             *string                   `json:"name,omitempty"`
	RangeType        *SubnetType               `json:"rangeType,omitempty"`
	Subnet           *string                   `json:"subnet,omitempty"`
	TranslatedSubnet *string                   `json:"translatedSubnet,omitempty"`
	Vlan             *int64                    `json:"vlan,omitempty"`
}

type UpdateNetworkRangePayload struct {
	NetworkRangeID string `json:"networkRangeId"`
}

type UpdatePrivateApplicationInput struct {
	AllowICMPProtocol  *bool                    `json:"allowIcmpProtocol,omitempty"`
	Description        *string                  `json:"description,omitempty"`
	ID                 string                   `json:"id"`
	InternalAppAddress *string                  `json:"internalAppAddress,omitempty"`
	Name               *string                  `json:"name,omitempty"`
	PrivateAppProbing  *PrivateAppProbingInput  `json:"privateAppProbing,omitempty"`
	ProbingEnabled     *bool                    `json:"probingEnabled,omitempty"`
	ProtocolPorts      []*CustomServiceInput    `json:"protocolPorts,omitempty"`
	Published          *bool                    `json:"published,omitempty"`
	PublishedAppDomain *PublishedAppDomainInput `json:"publishedAppDomain,omitempty"`
}

type UpdatePrivateApplicationPayload struct {
	Application *PrivateApplication `json:"application"`
}

type UpdateSecondaryAWSVSocketInput struct {
	ID           string  `json:"id"`
	IPAddress    *string `json:"ipAddress,omitempty"`
	RouteTableID *string `json:"routeTableId,omitempty"`
	Subnet       *string `json:"subnet,omitempty"`
}

type UpdateSecondaryAWSVSocketPayload struct {
	SecondaryAWSVSocket *SecondaryAWSVSocket `json:"secondaryAwsVSocket"`
}

type UpdateSecondaryAzureVSocketInput struct {
	FloatingIP  *string `json:"floatingIp,omitempty"`
	ID          string  `json:"id"`
	InterfaceIP *string `json:"interfaceIp,omitempty"`
}

type UpdateSecondaryAzureVSocketPayload struct {
	SecondaryAzureVSocket *SecondaryAzureVSocket `json:"secondaryAzureVSocket"`
}

type UpdateServicePrincipalAdminInput struct {
	ManagedRoles  []*UpdateAdminRoleInput `json:"managedRoles,omitempty"`
	Name          *string                 `json:"name,omitempty"`
	ResellerRoles []*UpdateAdminRoleInput `json:"resellerRoles,omitempty"`
}

type UpdateServicePrincipalAdminPayload struct {
	AdminID string `json:"adminID"`
}

type UpdateSiteBwLicenseInput struct {
	Bw        int64         `json:"bw"`
	LicenseID string        `json:"licenseId"`
	Site      *SiteRefInput `json:"site"`
}

type UpdateSiteBwLicensePayload struct {
	License License `json:"license"`
}

type UpdateSiteGeneralDetailsInput struct {
	Description          *string                              `json:"description,omitempty"`
	Name                 *string                              `json:"name,omitempty"`
	PreferredPopLocation *UpdateSitePreferredPopLocationInput `json:"preferredPopLocation,omitempty"`
	SiteLocation         *UpdateSiteLocationInput             `json:"siteLocation,omitempty"`
	SiteType             *SiteType                            `json:"siteType,omitempty"`
}

type UpdateSiteGeneralDetailsPayload struct {
	SiteID string `json:"siteId"`
}

type UpdateSiteLocationInput struct {
	Address     *string `json:"address,omitempty"`
	CityName    *string `json:"cityName,omitempty"`
	CountryCode *string `json:"countryCode,omitempty"`
	StateCode   *string `json:"stateCode,omitempty"`
	Timezone    *string `json:"timezone,omitempty"`
}

type UpdateSitePreferredPopLocationInput struct {
	PreferredOnly bool                 `json:"preferredOnly"`
	Primary       *PopLocationRefInput `json:"primary,omitempty"`
	Secondary     *PopLocationRefInput `json:"secondary,omitempty"`
}

type UpdateSocketInterfaceInput struct {
	AltWan    *SocketInterfaceAltWanInput    `json:"altWan,omitempty"`
	Bandwidth *SocketInterfaceBandwidthInput `json:"bandwidth,omitempty"`
	DestType  SocketInterfaceDestType        `json:"destType"`
	Lag       *SocketInterfaceLagInput       `json:"lag,omitempty"`
	Lan       *SocketInterfaceLanInput       `json:"lan,omitempty"`
	Name      *string                        `json:"name,omitempty"`
	OffCloud  *SocketInterfaceOffCloudInput  `json:"offCloud,omitempty"`
	Vrrp      *SocketInterfaceVrrpInput      `json:"vrrp,omitempty"`
	Wan       *SocketInterfaceWanInput       `json:"wan,omitempty"`
}

type UpdateSocketInterfacePayload struct {
	SiteID            string                `json:"siteId"`
	SocketInterfaceID SocketInterfaceIDEnum `json:"socketInterfaceId"`
}

type UpdateStaticHostInput struct {
	IP         *string `json:"ip,omitempty"`
	MacAddress *string `json:"macAddress,omitempty"`
	Name       *string `json:"name,omitempty"`
}

type UpdateStaticHostPayload struct {
	HostID string `json:"hostId"`
}

type UpdateZtnaAppConnectorInput struct {
	Description          *string                                    `json:"description,omitempty"`
	GroupName            *string                                    `json:"groupName,omitempty"`
	ID                   string                                     `json:"id"`
	Location             *ZtnaAppConnectorLocationInput             `json:"location,omitempty"`
	Name                 *string                                    `json:"name,omitempty"`
	PreferredPopLocation *ZtnaAppConnectorPreferredPopLocationInput `json:"preferredPopLocation,omitempty"`
}

type UpdateZtnaAppConnectorPayload struct {
	ZtnaAppConnector *ZtnaAppConnector `json:"ztnaAppConnector"`
}

// Input for updating ZTNA App Connectors configuration.
// At least one field must be provided.
type UpdateZtnaAppConnectorsConfigurationInput struct {
	AppConnectorManagementRange *string `json:"appConnectorManagementRange,omitempty"`
	PrivateAppsServiceRange     *string `json:"privateAppsServiceRange,omitempty"`
}

// Payload returned after updating ZTNA App Connectors configuration.
type UpdateZtnaAppConnectorsConfigurationPayload struct {
	ZtnaAppConnectorsConfiguration *ZtnaAppConnectorsConfiguration `json:"ztnaAppConnectorsConfiguration"`
}

type UpgradeZtnaAppConnectorInput struct {
	Upgrades []*ZtnaAppConnectorUpgradeRequest `json:"upgrades"`
}

type UpgradeZtnaAppConnectorPayload struct {
	Upgrades []*ZtnaAppConnectorUpgradeInfo `json:"upgrades"`
}

// Upload file input
type UploadFileInput struct {
	FileName string `json:"fileName"`
}

// Upload file response
type UploadFilePayload struct {
	UploadURL *string `json:"uploadUrl,omitempty"`
}

// Basic User configuration information
type UserInfo struct {
	AuthMethod   *string                    `json:"authMethod,omitempty"`
	CreationTime *string                    `json:"creationTime,omitempty"`
	Email        *string                    `json:"email,omitempty"`
	Name         *string                    `json:"name,omitempty"`
	Origin       *string                    `json:"origin,omitempty"`
	PhoneNumber  *string                    `json:"phoneNumber,omitempty"`
	Status       *scalars.OperationalStatus `json:"status,omitempty"`
}

// A reference identifying the User object. ID: Unique User Identifier, Name: The User Name
type UserRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (UserRef) IsObjectRef()         {}
func (this UserRef) GetID() string   { return this.ID }
func (this UserRef) GetName() string { return this.Name }

type UserRefFilterInput struct {
	Eq  *UserRefInput   `json:"eq,omitempty"`
	In  []*UserRefInput `json:"in,omitempty"`
	Neq *UserRefInput   `json:"neq,omitempty"`
	Nin []*UserRefInput `json:"nin,omitempty"`
}

type UserRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

type UserSnapshot struct {
	ConnectedInOffice  *bool                      `json:"connectedInOffice,omitempty"`
	ConnectivityStatus *ConnectivityStatus        `json:"connectivityStatus,omitempty"`
	DeviceName         *string                    `json:"deviceName,omitempty"`
	Devices            []*DeviceSnapshot          `json:"devices,omitempty"`
	ID                 *string                    `json:"id,omitempty"`
	Info               *UserInfo                  `json:"info,omitempty"`
	InternalIP         *string                    `json:"internalIP,omitempty"`
	LastConnected      *string                    `json:"lastConnected,omitempty"`
	Name               *string                    `json:"name,omitempty"`
	OperationalStatus  *scalars.OperationalStatus `json:"operationalStatus,omitempty"`
	OsType             *string                    `json:"osType,omitempty"`
	OsVersion          *string                    `json:"osVersion,omitempty"`
	PopID              *int64                     `json:"popID,omitempty"`
	PopName            *string                    `json:"popName,omitempty"`
	RecentConnections  []*RecentConnection        `json:"recentConnections,omitempty"`
	RemoteIP           *string                    `json:"remoteIP,omitempty"`
	RemoteIPInfo       *IPInfo                    `json:"remoteIPInfo,omitempty"`
	Uptime             *int64                     `json:"uptime,omitempty"`
	Version            *string                    `json:"version,omitempty"`
	VersionNumber      *int64                     `json:"versionNumber,omitempty"`
}

// A reference identifying the UsersGroup object. ID: Unique UsersGroup Identifier, Name: The UsersGroup Name
type UsersGroupRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (UsersGroupRef) IsObjectRef()         {}
func (this UsersGroupRef) GetID() string   { return this.ID }
func (this UsersGroupRef) GetName() string { return this.Name }

type UsersGroupRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

type VendorPredicate struct {
	In    []VendorEnum `json:"in,omitempty"`
	NotIn []VendorEnum `json:"not_in,omitempty"`
}

type WanFirewallAddRuleDataInput struct {
	Action           WanFirewallActionEnum            `json:"action"`
	ActivePeriod     *PolicyRuleActivePeriodInput     `json:"activePeriod"`
	Application      *WanFirewallApplicationInput     `json:"application"`
	ConnectionOrigin ConnectionOriginEnum             `json:"connectionOrigin"`
	Country          []*CountryRefInput               `json:"country"`
	Description      string                           `json:"description"`
	Destination      *WanFirewallDestinationInput     `json:"destination"`
	Device           []*DeviceProfileRefInput         `json:"device"`
	DeviceAttributes *DeviceAttributesInput           `json:"deviceAttributes"`
	DeviceOs         []OperatingSystem                `json:"deviceOS"`
	Direction        WanFirewallDirectionEnum         `json:"direction"`
	Enabled          bool                             `json:"enabled"`
	Exceptions       []*WanFirewallRuleExceptionInput `json:"exceptions"`
	Name             string                           `json:"name"`
	Schedule         *PolicyScheduleInput             `json:"schedule"`
	Service          *WanFirewallServiceTypeInput     `json:"service"`
	Source           *WanFirewallSourceInput          `json:"source"`
	Tracking         *PolicyTrackingInput             `json:"tracking"`
}

// Rule parameters and relevant position
type WanFirewallAddRuleInput struct {
	At   *PolicyRulePositionInput     `json:"at,omitempty"`
	Rule *WanFirewallAddRuleDataInput `json:"rule"`
}

// Application match criteria set
type WanFirewallApplication struct {
	AppCategory            []*ApplicationCategoryRef    `json:"appCategory"`
	Application            []*ApplicationRef            `json:"application"`
	CustomApp              []*CustomApplicationRef      `json:"customApp"`
	CustomCategory         []*CustomCategoryRef         `json:"customCategory"`
	Domain                 []string                     `json:"domain"`
	Fqdn                   []string                     `json:"fqdn"`
	GlobalIPRange          []*GlobalIPRangeRef          `json:"globalIpRange"`
	IP                     []string                     `json:"ip"`
	IPRange                []*IPAddressRange            `json:"ipRange"`
	SanctionedAppsCategory []*SanctionedAppsCategoryRef `json:"sanctionedAppsCategory"`
	Subnet                 []string                     `json:"subnet"`
}

// Application match criteria set
type WanFirewallApplicationInput struct {
	AppCategory            []*ApplicationCategoryRefInput    `json:"appCategory"`
	Application            []*ApplicationRefInput            `json:"application"`
	CustomApp              []*CustomApplicationRefInput      `json:"customApp"`
	CustomCategory         []*CustomCategoryRefInput         `json:"customCategory"`
	Domain                 []string                          `json:"domain"`
	Fqdn                   []string                          `json:"fqdn"`
	GlobalIPRange          []*GlobalIPRangeRefInput          `json:"globalIpRange"`
	IP                     []string                          `json:"ip"`
	IPRange                []*IPAddressRangeInput            `json:"ipRange"`
	SanctionedAppsCategory []*SanctionedAppsCategoryRefInput `json:"sanctionedAppsCategory"`
	Subnet                 []string                          `json:"subnet"`
}

// Application match criteria set
type WanFirewallApplicationUpdateInput struct {
	AppCategory            []*ApplicationCategoryRefInput    `json:"appCategory,omitempty"`
	Application            []*ApplicationRefInput            `json:"application,omitempty"`
	CustomApp              []*CustomApplicationRefInput      `json:"customApp,omitempty"`
	CustomCategory         []*CustomCategoryRefInput         `json:"customCategory,omitempty"`
	Domain                 []string                          `json:"domain,omitempty"`
	Fqdn                   []string                          `json:"fqdn,omitempty"`
	GlobalIPRange          []*GlobalIPRangeRefInput          `json:"globalIpRange,omitempty"`
	IP                     []string                          `json:"ip,omitempty"`
	IPRange                []*IPAddressRangeInput            `json:"ipRange,omitempty"`
	SanctionedAppsCategory []*SanctionedAppsCategoryRefInput `json:"sanctionedAppsCategory,omitempty"`
	Subnet                 []string                          `json:"subnet,omitempty"`
}

// Returns the settings for Destination of a Wan Firewall rule
type WanFirewallDestination struct {
	FloatingSubnet    []*FloatingSubnetRef    `json:"floatingSubnet"`
	GlobalIPRange     []*GlobalIPRangeRef     `json:"globalIpRange"`
	Group             []*GroupRef             `json:"group"`
	Host              []*HostRef              `json:"host"`
	IP                []string                `json:"ip"`
	IPRange           []*IPAddressRange       `json:"ipRange"`
	NetworkInterface  []*NetworkInterfaceRef  `json:"networkInterface"`
	Site              []*SiteRef              `json:"site"`
	SiteNetworkSubnet []*SiteNetworkSubnetRef `json:"siteNetworkSubnet"`
	Subnet            []string                `json:"subnet"`
	SystemGroup       []*SystemGroupRef       `json:"systemGroup"`
	User              []*UserRef              `json:"user"`
	UsersGroup        []*UsersGroupRef        `json:"usersGroup"`
}

// Input of the settings for Destination of a Wan Firewall rule. To specify 'ANY' destination, an empty list must be provided for each match criteria field (e.g. ip: [], group: [], etc...)
type WanFirewallDestinationInput struct {
	FloatingSubnet    []*FloatingSubnetRefInput    `json:"floatingSubnet"`
	GlobalIPRange     []*GlobalIPRangeRefInput     `json:"globalIpRange"`
	Group             []*GroupRefInput             `json:"group"`
	Host              []*HostRefInput              `json:"host"`
	IP                []string                     `json:"ip"`
	IPRange           []*IPAddressRangeInput       `json:"ipRange"`
	NetworkInterface  []*NetworkInterfaceRefInput  `json:"networkInterface"`
	Site              []*SiteRefInput              `json:"site"`
	SiteNetworkSubnet []*SiteNetworkSubnetRefInput `json:"siteNetworkSubnet"`
	Subnet            []string                     `json:"subnet"`
	SystemGroup       []*SystemGroupRefInput       `json:"systemGroup"`
	User              []*UserRefInput              `json:"user"`
	UsersGroup        []*UsersGroupRefInput        `json:"usersGroup"`
}

// Input of the settings for Destination of a Wan Firewall rule. To specify 'ANY' destination, an empty list must be provided for each match criteria field (e.g. ip: [], group: [], etc...)
type WanFirewallDestinationUpdateInput struct {
	FloatingSubnet    []*FloatingSubnetRefInput    `json:"floatingSubnet,omitempty"`
	GlobalIPRange     []*GlobalIPRangeRefInput     `json:"globalIpRange,omitempty"`
	Group             []*GroupRefInput             `json:"group,omitempty"`
	Host              []*HostRefInput              `json:"host,omitempty"`
	IP                []string                     `json:"ip,omitempty"`
	IPRange           []*IPAddressRangeInput       `json:"ipRange,omitempty"`
	NetworkInterface  []*NetworkInterfaceRefInput  `json:"networkInterface,omitempty"`
	Site              []*SiteRefInput              `json:"site,omitempty"`
	SiteNetworkSubnet []*SiteNetworkSubnetRefInput `json:"siteNetworkSubnet,omitempty"`
	Subnet            []string                     `json:"subnet,omitempty"`
	SystemGroup       []*SystemGroupRefInput       `json:"systemGroup,omitempty"`
	User              []*UserRefInput              `json:"user,omitempty"`
	UsersGroup        []*UsersGroupRefInput        `json:"usersGroup,omitempty"`
}

type WanFirewallPolicy struct {
	Audit    *PolicyAudit              `json:"audit,omitempty"`
	Enabled  bool                      `json:"enabled"`
	Revision *PolicyRevision           `json:"revision,omitempty"`
	Rules    []*WanFirewallRulePayload `json:"rules"`
	Sections []*PolicySectionPayload   `json:"sections"`
}

func (WanFirewallPolicy) IsIPolicy()                        {}
func (this WanFirewallPolicy) GetAudit() *PolicyAudit       { return this.Audit }
func (this WanFirewallPolicy) GetEnabled() bool             { return this.Enabled }
func (this WanFirewallPolicy) GetRevision() *PolicyRevision { return this.Revision }
func (this WanFirewallPolicy) GetRules() []IPolicyRulePayload {
	if this.Rules == nil {
		return nil
	}
	interfaceSlice := make([]IPolicyRulePayload, 0, len(this.Rules))
	for _, concrete := range this.Rules {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this WanFirewallPolicy) GetSections() []*PolicySectionPayload {
	if this.Sections == nil {
		return nil
	}
	interfaceSlice := make([]*PolicySectionPayload, 0, len(this.Sections))
	for _, concrete := range this.Sections {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

type WanFirewallPolicyInput struct {
	Revision *PolicyRevisionInput `json:"revision,omitempty"`
}

type WanFirewallPolicyMutationInput struct {
	Revision *PolicyMutationRevisionInput `json:"revision,omitempty"`
}

// Wan Firewall policy information provided in the API response
type WanFirewallPolicyMutationPayload struct {
	Errors []*PolicyMutationError `json:"errors"`
	Policy *WanFirewallPolicy     `json:"policy,omitempty"`
	Status PolicyMutationStatus   `json:"status"`
}

func (WanFirewallPolicyMutationPayload) IsIPolicyMutationPayload() {}
func (this WanFirewallPolicyMutationPayload) GetErrors() []*PolicyMutationError {
	if this.Errors == nil {
		return nil
	}
	interfaceSlice := make([]*PolicyMutationError, 0, len(this.Errors))
	for _, concrete := range this.Errors {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this WanFirewallPolicyMutationPayload) GetPolicy() IPolicy              { return *this.Policy }
func (this WanFirewallPolicyMutationPayload) GetStatus() PolicyMutationStatus { return this.Status }

// The Wan Firewall Policy information returned to the caller in the API response.
type WanFirewallPolicyMutations struct {
	AddRule               *WanFirewallRuleMutationPayload   `json:"addRule"`
	AddSection            *PolicySectionMutationPayload     `json:"addSection"`
	CreatePolicyRevision  *WanFirewallPolicyMutationPayload `json:"createPolicyRevision"`
	DiscardPolicyRevision *WanFirewallPolicyMutationPayload `json:"discardPolicyRevision"`
	MoveRule              *WanFirewallRuleMutationPayload   `json:"moveRule"`
	MoveSection           *PolicySectionMutationPayload     `json:"moveSection"`
	PublishPolicyRevision *WanFirewallPolicyMutationPayload `json:"publishPolicyRevision"`
	RemoveRule            *WanFirewallRuleMutationPayload   `json:"removeRule"`
	RemoveSection         *PolicySectionMutationPayload     `json:"removeSection"`
	UpdatePolicy          *WanFirewallPolicyMutationPayload `json:"updatePolicy"`
	UpdateRule            *WanFirewallRuleMutationPayload   `json:"updateRule"`
	UpdateSection         *PolicySectionMutationPayload     `json:"updateSection"`
}

type WanFirewallPolicyQueries struct {
	Policy    *WanFirewallPolicy      `json:"policy"`
	Revisions *PolicyRevisionsPayload `json:"revisions,omitempty"`
}

type WanFirewallPolicyUpdateInput struct {
	State *PolicyToggleState `json:"state,omitempty"`
}

type WanFirewallRemoveRuleInput struct {
	ID string `json:"id"`
}

type WanFirewallRule struct {
	Action           WanFirewallActionEnum       `json:"action"`
	ActivePeriod     *PolicyRuleActivePeriod     `json:"activePeriod"`
	Application      *WanFirewallApplication     `json:"application"`
	ConnectionOrigin ConnectionOriginEnum        `json:"connectionOrigin"`
	Country          []*CountryRef               `json:"country"`
	Description      string                      `json:"description"`
	Destination      *WanFirewallDestination     `json:"destination"`
	Device           []*DeviceProfileRef         `json:"device"`
	DeviceAttributes *DeviceAttributes           `json:"deviceAttributes"`
	DeviceOs         []OperatingSystem           `json:"deviceOS"`
	Direction        WanFirewallDirectionEnum    `json:"direction"`
	Enabled          bool                        `json:"enabled"`
	Exceptions       []*WanFirewallRuleException `json:"exceptions"`
	ID               string                      `json:"id"`
	Index            int64                       `json:"index"`
	Name             string                      `json:"name"`
	Schedule         *PolicySchedule             `json:"schedule"`
	Section          *PolicySectionInfo          `json:"section"`
	Service          *WanFirewallServiceType     `json:"service"`
	Source           *WanFirewallSource          `json:"source"`
	Tracking         *PolicyTracking             `json:"tracking"`
}

func (WanFirewallRule) IsIPolicyRule()                      {}
func (this WanFirewallRule) GetDescription() *string        { return &this.Description }
func (this WanFirewallRule) GetEnabled() bool               { return this.Enabled }
func (this WanFirewallRule) GetID() string                  { return this.ID }
func (this WanFirewallRule) GetIndex() int64                { return this.Index }
func (this WanFirewallRule) GetName() string                { return this.Name }
func (this WanFirewallRule) GetSection() *PolicySectionInfo { return this.Section }

// Exceptions define when a rule is ignored, and the firewall policy evaluation continues with the lower priority rules.
type WanFirewallRuleException struct {
	Application      *WanFirewallApplication  `json:"application"`
	ConnectionOrigin ConnectionOriginEnum     `json:"connectionOrigin"`
	Country          []*CountryRef            `json:"country"`
	Destination      *WanFirewallDestination  `json:"destination"`
	Device           []*DeviceProfileRef      `json:"device"`
	DeviceAttributes *DeviceAttributes        `json:"deviceAttributes"`
	DeviceOs         []OperatingSystem        `json:"deviceOS"`
	Direction        WanFirewallDirectionEnum `json:"direction"`
	Name             string                   `json:"name"`
	Service          *WanFirewallServiceType  `json:"service"`
	Source           *WanFirewallSource       `json:"source"`
}

// Exceptions define when a rule is ignored, and the firewall policy evaluation continues with the lower priority rules.
type WanFirewallRuleExceptionInput struct {
	Application      *WanFirewallApplicationInput `json:"application"`
	ConnectionOrigin ConnectionOriginEnum         `json:"connectionOrigin"`
	Country          []*CountryRefInput           `json:"country"`
	Destination      *WanFirewallDestinationInput `json:"destination"`
	Device           []*DeviceProfileRefInput     `json:"device"`
	DeviceAttributes *DeviceAttributesInput       `json:"deviceAttributes"`
	DeviceOs         []OperatingSystem            `json:"deviceOS"`
	Direction        WanFirewallDirectionEnum     `json:"direction"`
	Name             string                       `json:"name"`
	Service          *WanFirewallServiceTypeInput `json:"service"`
	Source           *WanFirewallSourceInput      `json:"source"`
}

type WanFirewallRuleMutationPayload struct {
	Errors []*PolicyMutationError  `json:"errors"`
	Rule   *WanFirewallRulePayload `json:"rule,omitempty"`
	Status PolicyMutationStatus    `json:"status"`
}

func (WanFirewallRuleMutationPayload) IsIPolicyRuleMutationPayload() {}
func (this WanFirewallRuleMutationPayload) GetErrors() []*PolicyMutationError {
	if this.Errors == nil {
		return nil
	}
	interfaceSlice := make([]*PolicyMutationError, 0, len(this.Errors))
	for _, concrete := range this.Errors {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this WanFirewallRuleMutationPayload) GetRule() IPolicyRulePayload     { return *this.Rule }
func (this WanFirewallRuleMutationPayload) GetStatus() PolicyMutationStatus { return this.Status }

// Wan Firewall policy information for a specific revision
type WanFirewallRulePayload struct {
	Audit      *PolicyElementAudit           `json:"audit"`
	Properties []PolicyElementPropertiesEnum `json:"properties"`
	Rule       *WanFirewallRule              `json:"rule"`
}

func (WanFirewallRulePayload) IsIPolicyRulePayload()              {}
func (this WanFirewallRulePayload) GetAudit() *PolicyElementAudit { return this.Audit }
func (this WanFirewallRulePayload) GetProperties() []PolicyElementPropertiesEnum {
	if this.Properties == nil {
		return nil
	}
	interfaceSlice := make([]PolicyElementPropertiesEnum, 0, len(this.Properties))
	for _, concrete := range this.Properties {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this WanFirewallRulePayload) GetRule() IPolicyRule { return *this.Rule }

// Returns the Service Type to which this Wan Firewall rule applies
type WanFirewallServiceType struct {
	Custom   []*CustomService `json:"custom"`
	Standard []*ServiceRef    `json:"standard"`
}

// Input of the Service Type to which this Wan Firewall rule applies. To specify 'ANY' source, an empty list must be provided for each match criteria field (e.g. standard: [], custom: [], etc...)
type WanFirewallServiceTypeInput struct {
	Custom   []*CustomServiceInput `json:"custom"`
	Standard []*ServiceRefInput    `json:"standard"`
}

// Input of the Service Type to which this Wan Firewall rule applies. To specify 'ANY' source, an empty list must be provided for each match criteria field (e.g. standard: [], custom: [], etc...)
type WanFirewallServiceTypeUpdateInput struct {
	Custom   []*CustomServiceInput `json:"custom,omitempty"`
	Standard []*ServiceRefInput    `json:"standard,omitempty"`
}

// Returns the settings for Source of an Wan Firewall rule
type WanFirewallSource struct {
	FloatingSubnet    []*FloatingSubnetRef    `json:"floatingSubnet"`
	GlobalIPRange     []*GlobalIPRangeRef     `json:"globalIpRange"`
	Group             []*GroupRef             `json:"group"`
	Host              []*HostRef              `json:"host"`
	IP                []string                `json:"ip"`
	IPRange           []*IPAddressRange       `json:"ipRange"`
	NetworkInterface  []*NetworkInterfaceRef  `json:"networkInterface"`
	Site              []*SiteRef              `json:"site"`
	SiteNetworkSubnet []*SiteNetworkSubnetRef `json:"siteNetworkSubnet"`
	Subnet            []string                `json:"subnet"`
	SystemGroup       []*SystemGroupRef       `json:"systemGroup"`
	User              []*UserRef              `json:"user"`
	UsersGroup        []*UsersGroupRef        `json:"usersGroup"`
}

// Input of the settings for Source of an Wan Firewall rule. To specify 'ANY' source, an empty list must be provided for each match criteria field (e.g. ip: [], group: [], etc...)
type WanFirewallSourceInput struct {
	FloatingSubnet    []*FloatingSubnetRefInput    `json:"floatingSubnet"`
	GlobalIPRange     []*GlobalIPRangeRefInput     `json:"globalIpRange"`
	Group             []*GroupRefInput             `json:"group"`
	Host              []*HostRefInput              `json:"host"`
	IP                []string                     `json:"ip"`
	IPRange           []*IPAddressRangeInput       `json:"ipRange"`
	NetworkInterface  []*NetworkInterfaceRefInput  `json:"networkInterface"`
	Site              []*SiteRefInput              `json:"site"`
	SiteNetworkSubnet []*SiteNetworkSubnetRefInput `json:"siteNetworkSubnet"`
	Subnet            []string                     `json:"subnet"`
	SystemGroup       []*SystemGroupRefInput       `json:"systemGroup"`
	User              []*UserRefInput              `json:"user"`
	UsersGroup        []*UsersGroupRefInput        `json:"usersGroup"`
}

// Input of the settings for Source of an Wan Firewall rule. To specify 'ANY' source, an empty list must be provided for each match criteria field (e.g. ip: [], group: [], etc...)
type WanFirewallSourceUpdateInput struct {
	FloatingSubnet    []*FloatingSubnetRefInput    `json:"floatingSubnet,omitempty"`
	GlobalIPRange     []*GlobalIPRangeRefInput     `json:"globalIpRange,omitempty"`
	Group             []*GroupRefInput             `json:"group,omitempty"`
	Host              []*HostRefInput              `json:"host,omitempty"`
	IP                []string                     `json:"ip,omitempty"`
	IPRange           []*IPAddressRangeInput       `json:"ipRange,omitempty"`
	NetworkInterface  []*NetworkInterfaceRefInput  `json:"networkInterface,omitempty"`
	Site              []*SiteRefInput              `json:"site,omitempty"`
	SiteNetworkSubnet []*SiteNetworkSubnetRefInput `json:"siteNetworkSubnet,omitempty"`
	Subnet            []string                     `json:"subnet,omitempty"`
	SystemGroup       []*SystemGroupRefInput       `json:"systemGroup,omitempty"`
	User              []*UserRefInput              `json:"user,omitempty"`
	UsersGroup        []*UsersGroupRefInput        `json:"usersGroup,omitempty"`
}

type WanFirewallUpdateRuleDataInput struct {
	Action           *WanFirewallActionEnum             `json:"action,omitempty"`
	ActivePeriod     *PolicyRuleActivePeriodUpdateInput `json:"activePeriod,omitempty"`
	Application      *WanFirewallApplicationUpdateInput `json:"application,omitempty"`
	ConnectionOrigin *ConnectionOriginEnum              `json:"connectionOrigin,omitempty"`
	Country          []*CountryRefInput                 `json:"country,omitempty"`
	Description      *string                            `json:"description,omitempty"`
	Destination      *WanFirewallDestinationUpdateInput `json:"destination,omitempty"`
	Device           []*DeviceProfileRefInput           `json:"device,omitempty"`
	DeviceAttributes *DeviceAttributesUpdateInput       `json:"deviceAttributes,omitempty"`
	DeviceOs         []OperatingSystem                  `json:"deviceOS,omitempty"`
	Direction        *WanFirewallDirectionEnum          `json:"direction,omitempty"`
	Enabled          *bool                              `json:"enabled,omitempty"`
	Exceptions       []*WanFirewallRuleExceptionInput   `json:"exceptions,omitempty"`
	Name             *string                            `json:"name,omitempty"`
	Schedule         *PolicyScheduleUpdateInput         `json:"schedule,omitempty"`
	Service          *WanFirewallServiceTypeUpdateInput `json:"service,omitempty"`
	Source           *WanFirewallSourceUpdateInput      `json:"source,omitempty"`
	Tracking         *PolicyTrackingUpdateInput         `json:"tracking,omitempty"`
}

type WanFirewallUpdateRuleInput struct {
	ID   string                          `json:"id"`
	Rule *WanFirewallUpdateRuleDataInput `json:"rule"`
}

type WanNetworkAddRuleDataInput struct {
	Application       *WanNetworkRuleApplicationInput   `json:"application"`
	BandwidthPriority *BandwidthManagementRefInput      `json:"bandwidthPriority"`
	Configuration     *WanNetworkRuleConfigurationInput `json:"configuration"`
	Description       string                            `json:"description"`
	Destination       *WanNetworkRuleDestinationInput   `json:"destination"`
	Enabled           bool                              `json:"enabled"`
	Exceptions        []*WanNetworkRuleExceptionInput   `json:"exceptions"`
	Name              string                            `json:"name"`
	RouteType         WanNetworkRuleRouteType           `json:"routeType"`
	RuleType          WanNetworkRuleType                `json:"ruleType"`
	Source            *WanNetworkRuleSourceInput        `json:"source"`
}

type WanNetworkAddRuleInput struct {
	At   *PolicyRulePositionInput    `json:"at,omitempty"`
	Rule *WanNetworkAddRuleDataInput `json:"rule"`
}

type WanNetworkPolicy struct {
	Audit    *PolicyAudit             `json:"audit,omitempty"`
	Enabled  bool                     `json:"enabled"`
	Revision *PolicyRevision          `json:"revision,omitempty"`
	Rules    []*WanNetworkRulePayload `json:"rules"`
	Sections []*PolicySectionPayload  `json:"sections"`
}

func (WanNetworkPolicy) IsIPolicy()                        {}
func (this WanNetworkPolicy) GetAudit() *PolicyAudit       { return this.Audit }
func (this WanNetworkPolicy) GetEnabled() bool             { return this.Enabled }
func (this WanNetworkPolicy) GetRevision() *PolicyRevision { return this.Revision }
func (this WanNetworkPolicy) GetRules() []IPolicyRulePayload {
	if this.Rules == nil {
		return nil
	}
	interfaceSlice := make([]IPolicyRulePayload, 0, len(this.Rules))
	for _, concrete := range this.Rules {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this WanNetworkPolicy) GetSections() []*PolicySectionPayload {
	if this.Sections == nil {
		return nil
	}
	interfaceSlice := make([]*PolicySectionPayload, 0, len(this.Sections))
	for _, concrete := range this.Sections {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

type WanNetworkPolicyInput struct {
	Revision *PolicyRevisionInput `json:"revision,omitempty"`
}

type WanNetworkPolicyMutationInput struct {
	Revision *PolicyMutationRevisionInput `json:"revision,omitempty"`
}

type WanNetworkPolicyMutationPayload struct {
	Errors []*PolicyMutationError `json:"errors"`
	Policy *WanNetworkPolicy      `json:"policy,omitempty"`
	Status PolicyMutationStatus   `json:"status"`
}

func (WanNetworkPolicyMutationPayload) IsIPolicyMutationPayload() {}
func (this WanNetworkPolicyMutationPayload) GetErrors() []*PolicyMutationError {
	if this.Errors == nil {
		return nil
	}
	interfaceSlice := make([]*PolicyMutationError, 0, len(this.Errors))
	for _, concrete := range this.Errors {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this WanNetworkPolicyMutationPayload) GetPolicy() IPolicy              { return *this.Policy }
func (this WanNetworkPolicyMutationPayload) GetStatus() PolicyMutationStatus { return this.Status }

type WanNetworkPolicyMutations struct {
	AddRule               *WanNetworkRuleMutationPayload   `json:"addRule"`
	AddSection            *PolicySectionMutationPayload    `json:"addSection"`
	CreatePolicyRevision  *WanNetworkPolicyMutationPayload `json:"createPolicyRevision"`
	DiscardPolicyRevision *WanNetworkPolicyMutationPayload `json:"discardPolicyRevision"`
	MoveRule              *WanNetworkRuleMutationPayload   `json:"moveRule"`
	MoveSection           *PolicySectionMutationPayload    `json:"moveSection"`
	PublishPolicyRevision *WanNetworkPolicyMutationPayload `json:"publishPolicyRevision"`
	RemoveRule            *WanNetworkRuleMutationPayload   `json:"removeRule"`
	RemoveSection         *PolicySectionMutationPayload    `json:"removeSection"`
	UpdatePolicy          *WanNetworkPolicyMutationPayload `json:"updatePolicy"`
	UpdateRule            *WanNetworkRuleMutationPayload   `json:"updateRule"`
	UpdateSection         *PolicySectionMutationPayload    `json:"updateSection"`
}

type WanNetworkPolicyQueries struct {
	Policy    *WanNetworkPolicy       `json:"policy"`
	Revisions *PolicyRevisionsPayload `json:"revisions,omitempty"`
}

type WanNetworkPolicyUpdateInput struct {
	State *PolicyToggleState `json:"state,omitempty"`
}

type WanNetworkRemoveRuleInput struct {
	ID string `json:"id"`
}

type WanNetworkRule struct {
	Application       *WanNetworkRuleApplication   `json:"application"`
	BandwidthPriority *BandwidthManagementRef      `json:"bandwidthPriority"`
	Configuration     *WanNetworkRuleConfiguration `json:"configuration"`
	Description       string                       `json:"description"`
	Destination       *WanNetworkRuleDestination   `json:"destination"`
	Enabled           bool                         `json:"enabled"`
	Exceptions        []*WanNetworkRuleException   `json:"exceptions"`
	ID                string                       `json:"id"`
	Index             int64                        `json:"index"`
	Name              string                       `json:"name"`
	RouteType         WanNetworkRuleRouteType      `json:"routeType"`
	RuleType          WanNetworkRuleType           `json:"ruleType"`
	Section           *PolicySectionInfo           `json:"section"`
	Source            *WanNetworkRuleSource        `json:"source"`
}

func (WanNetworkRule) IsIPolicyRule()                      {}
func (this WanNetworkRule) GetDescription() *string        { return &this.Description }
func (this WanNetworkRule) GetEnabled() bool               { return this.Enabled }
func (this WanNetworkRule) GetID() string                  { return this.ID }
func (this WanNetworkRule) GetIndex() int64                { return this.Index }
func (this WanNetworkRule) GetName() string                { return this.Name }
func (this WanNetworkRule) GetSection() *PolicySectionInfo { return this.Section }

type WanNetworkRuleApplication struct {
	AppCategory     []*ApplicationCategoryRef `json:"appCategory"`
	Application     []*ApplicationRef         `json:"application"`
	CustomApp       []*CustomApplicationRef   `json:"customApp"`
	CustomCategory  []*CustomCategoryRef      `json:"customCategory"`
	CustomService   []*CustomService          `json:"customService"`
	CustomServiceIP []*CustomServiceIP        `json:"customServiceIp"`
	Domain          []string                  `json:"domain"`
	Fqdn            []string                  `json:"fqdn"`
	Service         []*ServiceRef             `json:"service"`
}

type WanNetworkRuleApplicationInput struct {
	AppCategory     []*ApplicationCategoryRefInput `json:"appCategory"`
	Application     []*ApplicationRefInput         `json:"application"`
	CustomApp       []*CustomApplicationRefInput   `json:"customApp"`
	CustomCategory  []*CustomCategoryRefInput      `json:"customCategory"`
	CustomService   []*CustomServiceInput          `json:"customService"`
	CustomServiceIP []*CustomServiceIPInput        `json:"customServiceIp"`
	Domain          []string                       `json:"domain"`
	Fqdn            []string                       `json:"fqdn"`
	Service         []*ServiceRefInput             `json:"service"`
}

type WanNetworkRuleApplicationUpdateInput struct {
	AppCategory     []*ApplicationCategoryRefInput `json:"appCategory,omitempty"`
	Application     []*ApplicationRefInput         `json:"application,omitempty"`
	CustomApp       []*CustomApplicationRefInput   `json:"customApp,omitempty"`
	CustomCategory  []*CustomCategoryRefInput      `json:"customCategory,omitempty"`
	CustomService   []*CustomServiceInput          `json:"customService,omitempty"`
	CustomServiceIP []*CustomServiceIPInput        `json:"customServiceIp,omitempty"`
	Domain          []string                       `json:"domain,omitempty"`
	Fqdn            []string                       `json:"fqdn,omitempty"`
	Service         []*ServiceRefInput             `json:"service,omitempty"`
}

type WanNetworkRuleConfiguration struct {
	ActiveTCPAcceleration bool                     `json:"activeTcpAcceleration"`
	AllocationIP          []*AllocatedIPRef        `json:"allocationIp"`
	BackhaulingSite       []*SiteRef               `json:"backhaulingSite"`
	PacketLossMitigation  bool                     `json:"packetLossMitigation"`
	PopLocation           []*PopLocationRef        `json:"popLocation"`
	PreserveSourcePort    bool                     `json:"preserveSourcePort"`
	PrimaryTransport      *WanNetworkRuleTransport `json:"primaryTransport"`
	SecondaryTransport    *WanNetworkRuleTransport `json:"secondaryTransport"`
}

type WanNetworkRuleConfigurationInput struct {
	ActiveTCPAcceleration bool                          `json:"activeTcpAcceleration"`
	AllocationIP          []*AllocatedIPRefInput        `json:"allocationIp"`
	BackhaulingSite       []*SiteRefInput               `json:"backhaulingSite"`
	PacketLossMitigation  bool                          `json:"packetLossMitigation"`
	PopLocation           []*PopLocationRefInput        `json:"popLocation"`
	PreserveSourcePort    bool                          `json:"preserveSourcePort"`
	PrimaryTransport      *WanNetworkRuleTransportInput `json:"primaryTransport"`
	SecondaryTransport    *WanNetworkRuleTransportInput `json:"secondaryTransport"`
}

type WanNetworkRuleConfigurationUpdateInput struct {
	ActiveTCPAcceleration *bool                               `json:"activeTcpAcceleration,omitempty"`
	AllocationIP          []*AllocatedIPRefInput              `json:"allocationIp,omitempty"`
	BackhaulingSite       []*SiteRefInput                     `json:"backhaulingSite,omitempty"`
	PacketLossMitigation  *bool                               `json:"packetLossMitigation,omitempty"`
	PopLocation           []*PopLocationRefInput              `json:"popLocation,omitempty"`
	PreserveSourcePort    *bool                               `json:"preserveSourcePort,omitempty"`
	PrimaryTransport      *WanNetworkRuleTransportUpdateInput `json:"primaryTransport,omitempty"`
	SecondaryTransport    *WanNetworkRuleTransportUpdateInput `json:"secondaryTransport,omitempty"`
}

type WanNetworkRuleDestination struct {
	FloatingSubnet    []*FloatingSubnetRef    `json:"floatingSubnet"`
	GlobalIPRange     []*GlobalIPRangeRef     `json:"globalIpRange"`
	Group             []*GroupRef             `json:"group"`
	Host              []*HostRef              `json:"host"`
	IP                []string                `json:"ip"`
	IPRange           []*IPAddressRange       `json:"ipRange"`
	NetworkInterface  []*NetworkInterfaceRef  `json:"networkInterface"`
	Site              []*SiteRef              `json:"site"`
	SiteNetworkSubnet []*SiteNetworkSubnetRef `json:"siteNetworkSubnet"`
	Subnet            []string                `json:"subnet"`
	SystemGroup       []*SystemGroupRef       `json:"systemGroup"`
	User              []*UserRef              `json:"user"`
	UsersGroup        []*UsersGroupRef        `json:"usersGroup"`
}

type WanNetworkRuleDestinationInput struct {
	FloatingSubnet    []*FloatingSubnetRefInput    `json:"floatingSubnet"`
	GlobalIPRange     []*GlobalIPRangeRefInput     `json:"globalIpRange"`
	Group             []*GroupRefInput             `json:"group"`
	Host              []*HostRefInput              `json:"host"`
	IP                []string                     `json:"ip"`
	IPRange           []*IPAddressRangeInput       `json:"ipRange"`
	NetworkInterface  []*NetworkInterfaceRefInput  `json:"networkInterface"`
	Site              []*SiteRefInput              `json:"site"`
	SiteNetworkSubnet []*SiteNetworkSubnetRefInput `json:"siteNetworkSubnet"`
	Subnet            []string                     `json:"subnet"`
	SystemGroup       []*SystemGroupRefInput       `json:"systemGroup"`
	User              []*UserRefInput              `json:"user"`
	UsersGroup        []*UsersGroupRefInput        `json:"usersGroup"`
}

type WanNetworkRuleDestinationUpdateInput struct {
	FloatingSubnet    []*FloatingSubnetRefInput    `json:"floatingSubnet,omitempty"`
	GlobalIPRange     []*GlobalIPRangeRefInput     `json:"globalIpRange,omitempty"`
	Group             []*GroupRefInput             `json:"group,omitempty"`
	Host              []*HostRefInput              `json:"host,omitempty"`
	IP                []string                     `json:"ip,omitempty"`
	IPRange           []*IPAddressRangeInput       `json:"ipRange,omitempty"`
	NetworkInterface  []*NetworkInterfaceRefInput  `json:"networkInterface,omitempty"`
	Site              []*SiteRefInput              `json:"site,omitempty"`
	SiteNetworkSubnet []*SiteNetworkSubnetRefInput `json:"siteNetworkSubnet,omitempty"`
	Subnet            []string                     `json:"subnet,omitempty"`
	SystemGroup       []*SystemGroupRefInput       `json:"systemGroup,omitempty"`
	User              []*UserRefInput              `json:"user,omitempty"`
	UsersGroup        []*UsersGroupRefInput        `json:"usersGroup,omitempty"`
}

type WanNetworkRuleException struct {
	Application *WanNetworkRuleApplication `json:"application"`
	Destination *WanNetworkRuleDestination `json:"destination"`
	Name        string                     `json:"name"`
	Source      *WanNetworkRuleSource      `json:"source"`
}

type WanNetworkRuleExceptionInput struct {
	Application *WanNetworkRuleApplicationInput `json:"application"`
	Destination *WanNetworkRuleDestinationInput `json:"destination"`
	Name        string                          `json:"name"`
	Source      *WanNetworkRuleSourceInput      `json:"source"`
}

type WanNetworkRuleMutationPayload struct {
	Errors []*PolicyMutationError `json:"errors"`
	Rule   *WanNetworkRulePayload `json:"rule,omitempty"`
	Status PolicyMutationStatus   `json:"status"`
}

func (WanNetworkRuleMutationPayload) IsIPolicyRuleMutationPayload() {}
func (this WanNetworkRuleMutationPayload) GetErrors() []*PolicyMutationError {
	if this.Errors == nil {
		return nil
	}
	interfaceSlice := make([]*PolicyMutationError, 0, len(this.Errors))
	for _, concrete := range this.Errors {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this WanNetworkRuleMutationPayload) GetRule() IPolicyRulePayload     { return *this.Rule }
func (this WanNetworkRuleMutationPayload) GetStatus() PolicyMutationStatus { return this.Status }

type WanNetworkRulePayload struct {
	Audit      *PolicyElementAudit           `json:"audit"`
	Properties []PolicyElementPropertiesEnum `json:"properties"`
	Rule       *WanNetworkRule               `json:"rule"`
}

func (WanNetworkRulePayload) IsIPolicyRulePayload()              {}
func (this WanNetworkRulePayload) GetAudit() *PolicyElementAudit { return this.Audit }
func (this WanNetworkRulePayload) GetProperties() []PolicyElementPropertiesEnum {
	if this.Properties == nil {
		return nil
	}
	interfaceSlice := make([]PolicyElementPropertiesEnum, 0, len(this.Properties))
	for _, concrete := range this.Properties {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this WanNetworkRulePayload) GetRule() IPolicyRule { return *this.Rule }

type WanNetworkRuleSource struct {
	FloatingSubnet    []*FloatingSubnetRef    `json:"floatingSubnet"`
	GlobalIPRange     []*GlobalIPRangeRef     `json:"globalIpRange"`
	Group             []*GroupRef             `json:"group"`
	Host              []*HostRef              `json:"host"`
	IP                []string                `json:"ip"`
	IPRange           []*IPAddressRange       `json:"ipRange"`
	NetworkInterface  []*NetworkInterfaceRef  `json:"networkInterface"`
	Site              []*SiteRef              `json:"site"`
	SiteNetworkSubnet []*SiteNetworkSubnetRef `json:"siteNetworkSubnet"`
	Subnet            []string                `json:"subnet"`
	SystemGroup       []*SystemGroupRef       `json:"systemGroup"`
	User              []*UserRef              `json:"user"`
	UsersGroup        []*UsersGroupRef        `json:"usersGroup"`
}

type WanNetworkRuleSourceInput struct {
	FloatingSubnet    []*FloatingSubnetRefInput    `json:"floatingSubnet"`
	GlobalIPRange     []*GlobalIPRangeRefInput     `json:"globalIpRange"`
	Group             []*GroupRefInput             `json:"group"`
	Host              []*HostRefInput              `json:"host"`
	IP                []string                     `json:"ip"`
	IPRange           []*IPAddressRangeInput       `json:"ipRange"`
	NetworkInterface  []*NetworkInterfaceRefInput  `json:"networkInterface"`
	Site              []*SiteRefInput              `json:"site"`
	SiteNetworkSubnet []*SiteNetworkSubnetRefInput `json:"siteNetworkSubnet"`
	Subnet            []string                     `json:"subnet"`
	SystemGroup       []*SystemGroupRefInput       `json:"systemGroup"`
	User              []*UserRefInput              `json:"user"`
	UsersGroup        []*UsersGroupRefInput        `json:"usersGroup"`
}

type WanNetworkRuleSourceUpdateInput struct {
	FloatingSubnet    []*FloatingSubnetRefInput    `json:"floatingSubnet,omitempty"`
	GlobalIPRange     []*GlobalIPRangeRefInput     `json:"globalIpRange,omitempty"`
	Group             []*GroupRefInput             `json:"group,omitempty"`
	Host              []*HostRefInput              `json:"host,omitempty"`
	IP                []string                     `json:"ip,omitempty"`
	IPRange           []*IPAddressRangeInput       `json:"ipRange,omitempty"`
	NetworkInterface  []*NetworkInterfaceRefInput  `json:"networkInterface,omitempty"`
	Site              []*SiteRefInput              `json:"site,omitempty"`
	SiteNetworkSubnet []*SiteNetworkSubnetRefInput `json:"siteNetworkSubnet,omitempty"`
	Subnet            []string                     `json:"subnet,omitempty"`
	SystemGroup       []*SystemGroupRefInput       `json:"systemGroup,omitempty"`
	User              []*UserRefInput              `json:"user,omitempty"`
	UsersGroup        []*UsersGroupRefInput        `json:"usersGroup,omitempty"`
}

type WanNetworkRuleTransport struct {
	PrimaryInterfaceRole   WanNetworkRuleInterfaceRole `json:"primaryInterfaceRole"`
	SecondaryInterfaceRole WanNetworkRuleInterfaceRole `json:"secondaryInterfaceRole"`
	TransportType          WanNetworkRuleTransportType `json:"transportType"`
}

type WanNetworkRuleTransportInput struct {
	PrimaryInterfaceRole   WanNetworkRuleInterfaceRole `json:"primaryInterfaceRole"`
	SecondaryInterfaceRole WanNetworkRuleInterfaceRole `json:"secondaryInterfaceRole"`
	TransportType          WanNetworkRuleTransportType `json:"transportType"`
}

type WanNetworkRuleTransportUpdateInput struct {
	PrimaryInterfaceRole   *WanNetworkRuleInterfaceRole `json:"primaryInterfaceRole,omitempty"`
	SecondaryInterfaceRole *WanNetworkRuleInterfaceRole `json:"secondaryInterfaceRole,omitempty"`
	TransportType          *WanNetworkRuleTransportType `json:"transportType,omitempty"`
}

type WanNetworkUpdateRuleDataInput struct {
	Application       *WanNetworkRuleApplicationUpdateInput   `json:"application,omitempty"`
	BandwidthPriority *BandwidthManagementRefInput            `json:"bandwidthPriority,omitempty"`
	Configuration     *WanNetworkRuleConfigurationUpdateInput `json:"configuration,omitempty"`
	Description       *string                                 `json:"description,omitempty"`
	Destination       *WanNetworkRuleDestinationUpdateInput   `json:"destination,omitempty"`
	Enabled           *bool                                   `json:"enabled,omitempty"`
	Exceptions        []*WanNetworkRuleExceptionInput         `json:"exceptions,omitempty"`
	Name              *string                                 `json:"name,omitempty"`
	RouteType         *WanNetworkRuleRouteType                `json:"routeType,omitempty"`
	RuleType          *WanNetworkRuleType                     `json:"ruleType,omitempty"`
	Source            *WanNetworkRuleSourceUpdateInput        `json:"source,omitempty"`
}

type WanNetworkUpdateRuleInput struct {
	ID   string                         `json:"id"`
	Rule *WanNetworkUpdateRuleDataInput `json:"rule"`
}

type Xdr struct {
	Stories *StoriesData `json:"stories,omitempty"`
	Story   *Story       `json:"story,omitempty"`
}

// XOps service license details
type XOpsLicense struct {
	Description    *string       `json:"description,omitempty"`
	ExpirationDate string        `json:"expirationDate"`
	ID             *string       `json:"id,omitempty"`
	LastUpdated    *string       `json:"lastUpdated,omitempty"`
	Plan           LicensePlan   `json:"plan"`
	Sku            LicenseSku    `json:"sku"`
	StartDate      *string       `json:"startDate,omitempty"`
	Status         LicenseStatus `json:"status"`
}

func (XOpsLicense) IsLicense()                     {}
func (this XOpsLicense) GetDescription() *string   { return this.Description }
func (this XOpsLicense) GetExpirationDate() string { return this.ExpirationDate }
func (this XOpsLicense) GetID() *string            { return this.ID }
func (this XOpsLicense) GetLastUpdated() *string   { return this.LastUpdated }
func (this XOpsLicense) GetPlan() LicensePlan      { return this.Plan }
func (this XOpsLicense) GetSku() LicenseSku        { return this.Sku }
func (this XOpsLicense) GetStartDate() *string     { return this.StartDate }
func (this XOpsLicense) GetStatus() LicenseStatus  { return this.Status }

type XdrMutations struct {
	AddStoryComment    *AddStoryCommentPayload    `json:"addStoryComment,omitempty"`
	AnalystFeedback    *AnalystFeedbackPayload    `json:"analystFeedback,omitempty"`
	DeleteStoryComment *DeleteStoryCommentPayload `json:"deleteStoryComment,omitempty"`
}

// XDR Pro (extended detection and response) service license details
type XdrProLicense struct {
	Description    *string       `json:"description,omitempty"`
	ExpirationDate string        `json:"expirationDate"`
	ID             *string       `json:"id,omitempty"`
	LastUpdated    *string       `json:"lastUpdated,omitempty"`
	Plan           LicensePlan   `json:"plan"`
	Sku            LicenseSku    `json:"sku"`
	StartDate      *string       `json:"startDate,omitempty"`
	Status         LicenseStatus `json:"status"`
	Total          int64         `json:"total"`
}

func (XdrProLicense) IsLicense()                     {}
func (this XdrProLicense) GetDescription() *string   { return this.Description }
func (this XdrProLicense) GetExpirationDate() string { return this.ExpirationDate }
func (this XdrProLicense) GetID() *string            { return this.ID }
func (this XdrProLicense) GetLastUpdated() *string   { return this.LastUpdated }
func (this XdrProLicense) GetPlan() LicensePlan      { return this.Plan }
func (this XdrProLicense) GetSku() LicenseSku        { return this.Sku }
func (this XdrProLicense) GetStartDate() *string     { return this.StartDate }
func (this XdrProLicense) GetStatus() LicenseStatus  { return this.Status }

func (XdrProLicense) IsQuantifiableLicense() {}

func (this XdrProLicense) GetTotal() int64 { return this.Total }

type ZtnaAppConnector struct {
	Description          *string                               `json:"description,omitempty"`
	GroupName            string                                `json:"groupName"`
	ID                   string                                `json:"id"`
	Location             *ZtnaAppConnectorLocation             `json:"location"`
	Name                 string                                `json:"name"`
	PreferredPopLocation *ZtnaAppConnectorPreferredPopLocation `json:"preferredPopLocation,omitempty"`
	PrivateAppRef        []*PrivateApplicationRef              `json:"privateAppRef"`
	SerialNumber         *string                               `json:"serialNumber,omitempty"`
	SocketID             *string                               `json:"socketId,omitempty"`
	SocketModel          *SocketModel                          `json:"socketModel,omitempty"`
	Type                 ZtnaAppConnectorType                  `json:"type"`
}

type ZtnaAppConnectorConnectivityInfo struct {
	FirstConnected *string                            `json:"firstConnected,omitempty"`
	LastConnected  *string                            `json:"lastConnected,omitempty"`
	PopLocation    *PopLocationRef                    `json:"popLocation,omitempty"`
	Status         ZtnaAppConnectorConnectivityStatus `json:"status"`
}

type ZtnaAppConnectorConnectivityStatusFilterInput struct {
	Eq  *ZtnaAppConnectorConnectivityStatus  `json:"eq,omitempty"`
	In  []ZtnaAppConnectorConnectivityStatus `json:"in,omitempty"`
	Neq *ZtnaAppConnectorConnectivityStatus  `json:"neq,omitempty"`
	Nin []ZtnaAppConnectorConnectivityStatus `json:"nin,omitempty"`
}

type ZtnaAppConnectorDeviceConnectivityInfo struct {
	Platform     SocketPlatform `json:"platform"`
	SerialNumber string         `json:"serialNumber"`
	Version      string         `json:"version"`
}

type ZtnaAppConnectorDeviceInfo struct {
	Model        *SocketModel `json:"model,omitempty"`
	SerialNumber *string      `json:"serialNumber,omitempty"`
	SocketID     *string      `json:"socketId,omitempty"`
	Version      *string      `json:"version,omitempty"`
}

type ZtnaAppConnectorDeviceSnapshot struct {
	Connectivity *ZtnaAppConnectorDeviceConnectivityInfo `json:"connectivity,omitempty"`
	ID           string                                  `json:"id"`
	Info         *ZtnaAppConnectorDeviceInfo             `json:"info"`
	Interface    []*ZtnaAppConnectorInterfaceSnapshot    `json:"interface"`
}

// Filter object for connector group listing
type ZtnaAppConnectorGroupListFilterInput struct {
	Search *FreeTextFilterInput `json:"search,omitempty"`
}

type ZtnaAppConnectorGroupListInput struct {
	Filter *ZtnaAppConnectorGroupListFilterInput `json:"filter,omitempty"`
	Paging *PagingInput                          `json:"paging,omitempty"`
}

type ZtnaAppConnectorGroupListPayload struct {
	Items    []string  `json:"items"`
	PageInfo *PageInfo `json:"pageInfo"`
}

type ZtnaAppConnectorGroupSnapshot struct {
	ConnectivityStatus []*ZtnaAppConnectorSnapshotConnectivityStatusSummaryItem `json:"connectivityStatus"`
	Connectors         []*ZtnaAppConnectorSnapshot                              `json:"connectors"`
	GroupName          string                                                   `json:"groupName"`
	PrivateApps        []*PrivateApplicationRef                                 `json:"privateApps"`
	TotalConnectors    int64                                                    `json:"totalConnectors"`
}

type ZtnaAppConnectorGroupSnapshotFilterInput struct {
	ConnectedPop       []*StringFilterInput                             `json:"connectedPop,omitempty"`
	ConnectivityStatus []*ZtnaAppConnectorConnectivityStatusFilterInput `json:"connectivityStatus,omitempty"`
	ConnectorName      []*StringFilterInput                             `json:"connectorName,omitempty"`
	Country            []*StringFilterInput                             `json:"country,omitempty"`
	DeviceVersion      []*StringFilterInput                             `json:"deviceVersion,omitempty"`
	DNSServer          []*StringFilterInput                             `json:"dnsServer,omitempty"`
	FreeText           []*FreeTextFilterInput                           `json:"freeText,omitempty"`
	GroupName          []*StringFilterInput                             `json:"groupName,omitempty"`
	ID                 []*IDFilterInput                                 `json:"id,omitempty"`
	LanIP              []*StringFilterInput                             `json:"lanIp,omitempty"`
	Model              []*ZtnaAppConnectorModelFilterInput              `json:"model,omitempty"`
	PrivateApp         []*StringFilterInput                             `json:"privateApp,omitempty"`
	SerialNumber       []*StringFilterInput                             `json:"serialNumber,omitempty"`
}

type ZtnaAppConnectorGroupSnapshotInput struct {
	Filter *ZtnaAppConnectorGroupSnapshotFilterInput `json:"filter,omitempty"`
	Paging *PagingInput                              `json:"paging,omitempty"`
}

type ZtnaAppConnectorGroupSnapshotPayload struct {
	Items    []*ZtnaAppConnectorGroupSnapshot `json:"items"`
	PageInfo *PageInfo                        `json:"pageInfo"`
}

type ZtnaAppConnectorInfo struct {
	GroupName string                            `json:"groupName"`
	Location  *ZtnaAppConnectorLocationSnapshot `json:"location"`
	Type      ZtnaAppConnectorType              `json:"type"`
}

type ZtnaAppConnectorInterfaceConnectivityInfo struct {
	DNSServer []string            `json:"dnsServer"`
	LanIP     *string             `json:"lanIp,omitempty"`
	Status    *ConnectivityStatus `json:"status,omitempty"`
}

type ZtnaAppConnectorInterfaceSnapshot struct {
	Connectivity  *ZtnaAppConnectorInterfaceConnectivityInfo `json:"connectivity,omitempty"`
	ID            string                                     `json:"id"`
	InterfaceType ZtnaAppConnectorInterfaceType              `json:"interfaceType"`
}

type ZtnaAppConnectorListFilterInput struct {
	GroupName       []*StringFilterInput             `json:"groupName,omitempty"`
	IsAssigned      *BooleanFilterInput              `json:"isAssigned,omitempty"`
	Name            []*StringFilterInput             `json:"name,omitempty"`
	SearchGroupName *FreeTextFilterInput             `json:"searchGroupName,omitempty"`
	SearchName      *FreeTextFilterInput             `json:"searchName,omitempty"`
	Type            *ZtnaAppConnectorTypeFilterInput `json:"type,omitempty"`
}

type ZtnaAppConnectorListInput struct {
	Filter *ZtnaAppConnectorListFilterInput `json:"filter,omitempty"`
	Paging *PagingInput                     `json:"paging,omitempty"`
}

type ZtnaAppConnectorListPayload struct {
	PageInfo         *PageInfo           `json:"pageInfo"`
	ZtnaAppConnector []*ZtnaAppConnector `json:"ztnaAppConnector"`
}

type ZtnaAppConnectorLocation struct {
	Address     *string `json:"address,omitempty"`
	CityName    string  `json:"cityName"`
	CountryCode string  `json:"countryCode"`
	StateCode   *string `json:"stateCode,omitempty"`
	Timezone    string  `json:"timezone"`
}

type ZtnaAppConnectorLocationInput struct {
	Address     *string `json:"address,omitempty"`
	City        string  `json:"city"`
	CountryCode string  `json:"countryCode"`
	StateCode   *string `json:"stateCode,omitempty"`
	Timezone    string  `json:"timezone"`
}

type ZtnaAppConnectorLocationSnapshot struct {
	CityName    string `json:"cityName"`
	CountryCode string `json:"countryCode"`
}

type ZtnaAppConnectorModelFilterInput struct {
	Eq  *SocketModel  `json:"eq,omitempty"`
	In  []SocketModel `json:"in,omitempty"`
	Neq *SocketModel  `json:"neq,omitempty"`
	Nin []SocketModel `json:"nin,omitempty"`
}

type ZtnaAppConnectorMutations struct {
	AddZtnaAppConnector                  *AddZtnaAppConnectorPayload                  `json:"addZtnaAppConnector"`
	AddZtnaAppConnectorsConfiguration    *AddZtnaAppConnectorsConfigurationPayload    `json:"addZtnaAppConnectorsConfiguration"`
	AssignSocketToZtnaAppConnector       *AssignSocketToZtnaAppConnectorPayload       `json:"assignSocketToZtnaAppConnector"`
	RemoveZtnaAppConnector               *RemoveZtnaAppConnectorPayload               `json:"removeZtnaAppConnector"`
	RemoveZtnaAppConnectorsConfiguration *RemoveZtnaAppConnectorsConfigurationPayload `json:"removeZtnaAppConnectorsConfiguration"`
	UnassignSocketFromZtnaAppConnector   *UnassignSocketFromZtnaAppConnectorPayload   `json:"unassignSocketFromZtnaAppConnector"`
	UpdateZtnaAppConnector               *UpdateZtnaAppConnectorPayload               `json:"updateZtnaAppConnector"`
	UpdateZtnaAppConnectorsConfiguration *UpdateZtnaAppConnectorsConfigurationPayload `json:"updateZtnaAppConnectorsConfiguration"`
	UpgradeZtnaAppConnector              *UpgradeZtnaAppConnectorPayload              `json:"upgradeZtnaAppConnector"`
}

type ZtnaAppConnectorPreferredPopLocation struct {
	Automatic     bool            `json:"automatic"`
	PreferredOnly bool            `json:"preferredOnly"`
	Primary       *PopLocationRef `json:"primary,omitempty"`
	Secondary     *PopLocationRef `json:"secondary,omitempty"`
}

type ZtnaAppConnectorPreferredPopLocationInput struct {
	Automatic     bool                 `json:"automatic"`
	PreferredOnly bool                 `json:"preferredOnly"`
	Primary       *PopLocationRefInput `json:"primary,omitempty"`
	Secondary     *PopLocationRefInput `json:"secondary,omitempty"`
}

type ZtnaAppConnectorPrivateAppConnectivityInfo struct {
	ProbingStatus ZtnaAppConnectorSnapshotProbingStatus `json:"probingStatus"`
	RoutingStatus ZtnaAppConnectorSnapshotRoutingStatus `json:"routingStatus"`
}

type ZtnaAppConnectorPrivateAppSnapshot struct {
	Connectivity *ZtnaAppConnectorPrivateAppConnectivityInfo `json:"connectivity,omitempty"`
	ID           string                                      `json:"id"`
	Name         string                                      `json:"name"`
}

type ZtnaAppConnectorQueries struct {
	ZtnaAppConnector               *ZtnaAppConnector                 `json:"ztnaAppConnector,omitempty"`
	ZtnaAppConnectorGroupList      *ZtnaAppConnectorGroupListPayload `json:"ztnaAppConnectorGroupList,omitempty"`
	ZtnaAppConnectorList           *ZtnaAppConnectorListPayload      `json:"ztnaAppConnectorList,omitempty"`
	ZtnaAppConnectorsConfiguration *ZtnaAppConnectorsConfiguration   `json:"ztnaAppConnectorsConfiguration,omitempty"`
}

type ZtnaAppConnectorRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (ZtnaAppConnectorRef) IsObjectRef()         {}
func (this ZtnaAppConnectorRef) GetID() string   { return this.ID }
func (this ZtnaAppConnectorRef) GetName() string { return this.Name }

type ZtnaAppConnectorRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

type ZtnaAppConnectorSnapshot struct {
	Connectivity *ZtnaAppConnectorConnectivityInfo     `json:"connectivity,omitempty"`
	Device       *ZtnaAppConnectorDeviceSnapshot       `json:"device,omitempty"`
	ID           string                                `json:"id"`
	Info         *ZtnaAppConnectorInfo                 `json:"info"`
	Name         string                                `json:"name"`
	PrivateApp   []*ZtnaAppConnectorPrivateAppSnapshot `json:"privateApp"`
}

type ZtnaAppConnectorSnapshotAssignmentSummary struct {
	Assigned int64 `json:"assigned"`
	Total    int64 `json:"total"`
}

type ZtnaAppConnectorSnapshotConnectivityStatusSummaryItem struct {
	ConnectivityStatus ZtnaAppConnectorConnectivityStatus `json:"connectivityStatus"`
	Total              int64                              `json:"total"`
}

type ZtnaAppConnectorSnapshotFilterInput struct {
	ConnectedPop       []*StringFilterInput                             `json:"connectedPop,omitempty"`
	ConnectivityStatus []*ZtnaAppConnectorConnectivityStatusFilterInput `json:"connectivityStatus,omitempty"`
	ConnectorName      []*StringFilterInput                             `json:"connectorName,omitempty"`
	Country            []*StringFilterInput                             `json:"country,omitempty"`
	DeviceVersion      []*StringFilterInput                             `json:"deviceVersion,omitempty"`
	DNSServer          []*StringFilterInput                             `json:"dnsServer,omitempty"`
	FreeText           []*FreeTextFilterInput                           `json:"freeText,omitempty"`
	GroupName          []*StringFilterInput                             `json:"groupName,omitempty"`
	ID                 []*IDFilterInput                                 `json:"id,omitempty"`
	LanIP              []*StringFilterInput                             `json:"lanIp,omitempty"`
	Model              []*ZtnaAppConnectorModelFilterInput              `json:"model,omitempty"`
	PrivateApp         []*StringFilterInput                             `json:"privateApp,omitempty"`
	SerialNumber       []*StringFilterInput                             `json:"serialNumber,omitempty"`
}

type ZtnaAppConnectorSnapshotInput struct {
	Filter *ZtnaAppConnectorSnapshotFilterInput `json:"filter,omitempty"`
	Paging *PagingInput                         `json:"paging,omitempty"`
	Sort   *ZtnaAppConnectorSnapshotSortInput   `json:"sort,omitempty"`
}

type ZtnaAppConnectorSnapshotPayload struct {
	Items    []*ZtnaAppConnectorSnapshot `json:"items"`
	PageInfo *PageInfo                   `json:"pageInfo"`
}

type ZtnaAppConnectorSnapshotSocketModelSummaryItem struct {
	Model SocketModel `json:"model"`
	Total int64       `json:"total"`
}

type ZtnaAppConnectorSnapshotSocketPlatformSummaryItem struct {
	Platform SocketPlatform `json:"platform"`
	Total    int64          `json:"total"`
}

type ZtnaAppConnectorSnapshotSortInput struct {
	Connectivity *SortOrderInput `json:"connectivity,omitempty"`
	Name         *SortOrderInput `json:"name,omitempty"`
}

type ZtnaAppConnectorSnapshotSummaryFilterInput struct {
	ConnectivityStatus []*ZtnaAppConnectorConnectivityStatusFilterInput `json:"connectivityStatus,omitempty"`
}

type ZtnaAppConnectorSnapshotSummaryInput struct {
	Filter *ZtnaAppConnectorSnapshotSummaryFilterInput `json:"filter,omitempty"`
}

type ZtnaAppConnectorSnapshotSummaryPayload struct {
	Assignment         *ZtnaAppConnectorSnapshotAssignmentSummary               `json:"assignment,omitempty"`
	ConnectivityStatus []*ZtnaAppConnectorSnapshotConnectivityStatusSummaryItem `json:"connectivityStatus"`
	SocketModel        []*ZtnaAppConnectorSnapshotSocketModelSummaryItem        `json:"socketModel"`
	SocketPlatform     []*ZtnaAppConnectorSnapshotSocketPlatformSummaryItem     `json:"socketPlatform"`
	Total              int64                                                    `json:"total"`
	Version            []*ZtnaAppConnectorSnapshotVersionSummaryItem            `json:"version"`
}

type ZtnaAppConnectorSnapshotVersionSummaryItem struct {
	Total   int64  `json:"total"`
	Version string `json:"version"`
}

// Filter input for ZTNA App Connector type
type ZtnaAppConnectorTypeFilterInput struct {
	Eq  *ZtnaAppConnectorType  `json:"eq,omitempty"`
	In  []ZtnaAppConnectorType `json:"in,omitempty"`
	Neq *ZtnaAppConnectorType  `json:"neq,omitempty"`
	Nin []ZtnaAppConnectorType `json:"nin,omitempty"`
}

type ZtnaAppConnectorUpgradeInfo struct {
	TargetVersion    string               `json:"targetVersion"`
	ZtnaAppConnector *ZtnaAppConnectorRef `json:"ztnaAppConnector"`
}

type ZtnaAppConnectorUpgradeRequest struct {
	TargetVersion    string                    `json:"targetVersion"`
	ZtnaAppConnector *ZtnaAppConnectorRefInput `json:"ztnaAppConnector"`
}

// ZTNA App Connectors configuration for an account.
type ZtnaAppConnectorsConfiguration struct {
	AppConnectorManagementRange string `json:"appConnectorManagementRange"`
	PrivateAppsServiceRange     string `json:"privateAppsServiceRange"`
}

// ZTNA remote users license
type ZtnaUsersLicense struct {
	Description           *string               `json:"description,omitempty"`
	ExpirationDate        string                `json:"expirationDate"`
	ID                    *string               `json:"id,omitempty"`
	LastUpdated           *string               `json:"lastUpdated,omitempty"`
	Plan                  LicensePlan           `json:"plan"`
	Sku                   LicenseSku            `json:"sku"`
	StartDate             *string               `json:"startDate,omitempty"`
	Status                LicenseStatus         `json:"status"`
	Total                 int64                 `json:"total"`
	ZtnaUsersLicenseGroup ZtnaUsersLicenseGroup `json:"ztnaUsersLicenseGroup"`
}

func (ZtnaUsersLicense) IsLicense()                     {}
func (this ZtnaUsersLicense) GetDescription() *string   { return this.Description }
func (this ZtnaUsersLicense) GetExpirationDate() string { return this.ExpirationDate }
func (this ZtnaUsersLicense) GetID() *string            { return this.ID }
func (this ZtnaUsersLicense) GetLastUpdated() *string   { return this.LastUpdated }
func (this ZtnaUsersLicense) GetPlan() LicensePlan      { return this.Plan }
func (this ZtnaUsersLicense) GetSku() LicenseSku        { return this.Sku }
func (this ZtnaUsersLicense) GetStartDate() *string     { return this.StartDate }
func (this ZtnaUsersLicense) GetStatus() LicenseStatus  { return this.Status }

func (ZtnaUsersLicense) IsQuantifiableLicense() {}

func (this ZtnaUsersLicense) GetTotal() int64 { return this.Total }

// Global ZTNA license usage and allocation across all accounts
type ZtnaUsersLicenseAllocations struct {
	Allocated int64 `json:"allocated"`
	Available int64 `json:"available"`
	Total     int64 `json:"total"`
}

type AccountInclusion string

const (
	AccountInclusionAllAccounts         AccountInclusion = "ALL_ACCOUNTS"
	AccountInclusionManagedAccountsOnly AccountInclusion = "MANAGED_ACCOUNTS_ONLY"
)

var AllAccountInclusion = []AccountInclusion{
	AccountInclusionAllAccounts,
	AccountInclusionManagedAccountsOnly,
}

func (e AccountInclusion) IsValid() bool {
	switch e {
	case AccountInclusionAllAccounts, AccountInclusionManagedAccountsOnly:
		return true
	}
	return false
}

func (e AccountInclusion) String() string {
	return string(e)
}

func (e *AccountInclusion) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AccountInclusion(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AccountInclusion", str)
	}
	return nil
}

func (e AccountInclusion) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type AccountOperationsTimelineType string

const (
	AccountOperationsTimelineTypeAction AccountOperationsTimelineType = "Action"
	AccountOperationsTimelineTypeEvent  AccountOperationsTimelineType = "Event"
)

var AllAccountOperationsTimelineType = []AccountOperationsTimelineType{
	AccountOperationsTimelineTypeAction,
	AccountOperationsTimelineTypeEvent,
}

func (e AccountOperationsTimelineType) IsValid() bool {
	switch e {
	case AccountOperationsTimelineTypeAction, AccountOperationsTimelineTypeEvent:
		return true
	}
	return false
}

func (e AccountOperationsTimelineType) String() string {
	return string(e)
}

func (e *AccountOperationsTimelineType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AccountOperationsTimelineType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AccountOperationsTimelineType", str)
	}
	return nil
}

func (e AccountOperationsTimelineType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// enum that shows account license status
type AccountPlan string

const (
	AccountPlanCommercial AccountPlan = "COMMERCIAL"
	AccountPlanTrial      AccountPlan = "TRIAL"
)

var AllAccountPlan = []AccountPlan{
	AccountPlanCommercial,
	AccountPlanTrial,
}

func (e AccountPlan) IsValid() bool {
	switch e {
	case AccountPlanCommercial, AccountPlanTrial:
		return true
	}
	return false
}

func (e AccountPlan) String() string {
	return string(e)
}

func (e *AccountPlan) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AccountPlan(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AccountPlan", str)
	}
	return nil
}

func (e AccountPlan) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// enum for account type
type AccountProfileType string

const (
	//  A customer account
	AccountProfileTypeCustomer AccountProfileType = "CUSTOMER"
	//  A partner account
	AccountProfileTypePartner AccountProfileType = "PARTNER"
)

var AllAccountProfileType = []AccountProfileType{
	AccountProfileTypeCustomer,
	AccountProfileTypePartner,
}

func (e AccountProfileType) IsValid() bool {
	switch e {
	case AccountProfileTypeCustomer, AccountProfileTypePartner:
		return true
	}
	return false
}

func (e AccountProfileType) String() string {
	return string(e)
}

func (e *AccountProfileType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AccountProfileType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AccountProfileType", str)
	}
	return nil
}

func (e AccountProfileType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// enum that shows account license status
type AccountStatus string

const (
	AccountStatusActive   AccountStatus = "ACTIVE"
	AccountStatusDisabled AccountStatus = "DISABLED"
	AccountStatusLocked   AccountStatus = "LOCKED"
)

var AllAccountStatus = []AccountStatus{
	AccountStatusActive,
	AccountStatusDisabled,
	AccountStatusLocked,
}

func (e AccountStatus) IsValid() bool {
	switch e {
	case AccountStatusActive, AccountStatusDisabled, AccountStatusLocked:
		return true
	}
	return false
}

func (e AccountStatus) String() string {
	return string(e)
}

func (e *AccountStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AccountStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AccountStatus", str)
	}
	return nil
}

func (e AccountStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// enum for account tenancy
type AccountTenancy string

const (
	//  Multi tenant account - default for partner accounts
	AccountTenancyMultiTenant AccountTenancy = "MULTI_TENANT"
	//  Single tenant account - default for customer accounts
	AccountTenancySingleTenant AccountTenancy = "SINGLE_TENANT"
)

var AllAccountTenancy = []AccountTenancy{
	AccountTenancyMultiTenant,
	AccountTenancySingleTenant,
}

func (e AccountTenancy) IsValid() bool {
	switch e {
	case AccountTenancyMultiTenant, AccountTenancySingleTenant:
		return true
	}
	return false
}

func (e AccountTenancy) String() string {
	return string(e)
}

func (e *AccountTenancy) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AccountTenancy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AccountTenancy", str)
	}
	return nil
}

func (e AccountTenancy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type AccountType string

const (
	AccountTypeAll      AccountType = "ALL"
	AccountTypeRegular  AccountType = "REGULAR"
	AccountTypeReseller AccountType = "RESELLER"
	AccountTypeSystem   AccountType = "SYSTEM"
)

var AllAccountType = []AccountType{
	AccountTypeAll,
	AccountTypeRegular,
	AccountTypeReseller,
	AccountTypeSystem,
}

func (e AccountType) IsValid() bool {
	switch e {
	case AccountTypeAll, AccountTypeRegular, AccountTypeReseller, AccountTypeSystem:
		return true
	}
	return false
}

func (e AccountType) String() string {
	return string(e)
}

func (e *AccountType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AccountType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AccountType", str)
	}
	return nil
}

func (e AccountType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type AddressValidationStatus string

const (
	AddressValidationStatusInvalid AddressValidationStatus = "INVALID"
	AddressValidationStatusNa      AddressValidationStatus = "NA"
	AddressValidationStatusValid   AddressValidationStatus = "VALID"
)

var AllAddressValidationStatus = []AddressValidationStatus{
	AddressValidationStatusInvalid,
	AddressValidationStatusNa,
	AddressValidationStatusValid,
}

func (e AddressValidationStatus) IsValid() bool {
	switch e {
	case AddressValidationStatusInvalid, AddressValidationStatusNa, AddressValidationStatusValid:
		return true
	}
	return false
}

func (e AddressValidationStatus) String() string {
	return string(e)
}

func (e *AddressValidationStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AddressValidationStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AddressValidationStatus", str)
	}
	return nil
}

func (e AddressValidationStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type AdminType string

const (
	AdminTypeLogin            AdminType = "LOGIN"
	AdminTypeServicePrinciple AdminType = "SERVICE_PRINCIPLE"
)

var AllAdminType = []AdminType{
	AdminTypeLogin,
	AdminTypeServicePrinciple,
}

func (e AdminType) IsValid() bool {
	switch e {
	case AdminTypeLogin, AdminTypeServicePrinciple:
		return true
	}
	return false
}

func (e AdminType) String() string {
	return string(e)
}

func (e *AdminType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AdminType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AdminType", str)
	}
	return nil
}

func (e AdminType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type AggregationType string

const (
	AggregationTypeAny           AggregationType = "any"
	AggregationTypeAvg           AggregationType = "avg"
	AggregationTypeChanges       AggregationType = "changes"
	AggregationTypeCount         AggregationType = "count"
	AggregationTypeCountDistinct AggregationType = "count_distinct"
	AggregationTypeDistinct      AggregationType = "distinct"
	AggregationTypeMax           AggregationType = "max"
	AggregationTypeMin           AggregationType = "min"
	AggregationTypeSum           AggregationType = "sum"
	AggregationTypeUniqSet       AggregationType = "uniq_set"
)

var AllAggregationType = []AggregationType{
	AggregationTypeAny,
	AggregationTypeAvg,
	AggregationTypeChanges,
	AggregationTypeCount,
	AggregationTypeCountDistinct,
	AggregationTypeDistinct,
	AggregationTypeMax,
	AggregationTypeMin,
	AggregationTypeSum,
	AggregationTypeUniqSet,
}

func (e AggregationType) IsValid() bool {
	switch e {
	case AggregationTypeAny, AggregationTypeAvg, AggregationTypeChanges, AggregationTypeCount, AggregationTypeCountDistinct, AggregationTypeDistinct, AggregationTypeMax, AggregationTypeMin, AggregationTypeSum, AggregationTypeUniqSet:
		return true
	}
	return false
}

func (e AggregationType) String() string {
	return string(e)
}

func (e *AggregationType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AggregationType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AggregationType", str)
	}
	return nil
}

func (e AggregationType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type AiOperationsIncidentTypeEnum string

const (
	AiOperationsIncidentTypeEnumAccount AiOperationsIncidentTypeEnum = "Account"
)

var AllAiOperationsIncidentTypeEnum = []AiOperationsIncidentTypeEnum{
	AiOperationsIncidentTypeEnumAccount,
}

func (e AiOperationsIncidentTypeEnum) IsValid() bool {
	switch e {
	case AiOperationsIncidentTypeEnumAccount:
		return true
	}
	return false
}

func (e AiOperationsIncidentTypeEnum) String() string {
	return string(e)
}

func (e *AiOperationsIncidentTypeEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AiOperationsIncidentTypeEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AiOperationsIncidentTypeEnum", str)
	}
	return nil
}

func (e AiOperationsIncidentTypeEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type AlertClassificationEnum string

const (
	AlertClassificationEnumFalsePositive                 AlertClassificationEnum = "FALSE_POSITIVE"
	AlertClassificationEnumInformationalExpectedActivity AlertClassificationEnum = "INFORMATIONAL_EXPECTED_ACTIVITY"
	AlertClassificationEnumTruePositive                  AlertClassificationEnum = "TRUE_POSITIVE"
)

var AllAlertClassificationEnum = []AlertClassificationEnum{
	AlertClassificationEnumFalsePositive,
	AlertClassificationEnumInformationalExpectedActivity,
	AlertClassificationEnumTruePositive,
}

func (e AlertClassificationEnum) IsValid() bool {
	switch e {
	case AlertClassificationEnumFalsePositive, AlertClassificationEnumInformationalExpectedActivity, AlertClassificationEnumTruePositive:
		return true
	}
	return false
}

func (e AlertClassificationEnum) String() string {
	return string(e)
}

func (e *AlertClassificationEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AlertClassificationEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AlertClassificationEnum", str)
	}
	return nil
}

func (e AlertClassificationEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type AlertDeterminationEnum string

const (
	AlertDeterminationEnumApt                       AlertDeterminationEnum = "APT"
	AlertDeterminationEnumCompromisedAccount        AlertDeterminationEnum = "COMPROMISED_ACCOUNT"
	AlertDeterminationEnumConfirmedActivity         AlertDeterminationEnum = "CONFIRMED_ACTIVITY"
	AlertDeterminationEnumLineOfBusinessApplication AlertDeterminationEnum = "LINE_OF_BUSINESS_APPLICATION"
	AlertDeterminationEnumMaliciousUserActivity     AlertDeterminationEnum = "MALICIOUS_USER_ACTIVITY"
	AlertDeterminationEnumMalware                   AlertDeterminationEnum = "MALWARE"
	AlertDeterminationEnumMultiStagedAttack         AlertDeterminationEnum = "MULTI_STAGED_ATTACK"
	AlertDeterminationEnumNotEnoughDataToValidate   AlertDeterminationEnum = "NOT_ENOUGH_DATA_TO_VALIDATE"
	AlertDeterminationEnumNotMalicious              AlertDeterminationEnum = "NOT_MALICIOUS"
	AlertDeterminationEnumOther                     AlertDeterminationEnum = "OTHER"
	AlertDeterminationEnumPhishing                  AlertDeterminationEnum = "PHISHING"
	AlertDeterminationEnumSecurityPersonnel         AlertDeterminationEnum = "SECURITY_PERSONNEL"
	AlertDeterminationEnumSecurityTesting           AlertDeterminationEnum = "SECURITY_TESTING"
	AlertDeterminationEnumUnwantedSoftware          AlertDeterminationEnum = "UNWANTED_SOFTWARE"
)

var AllAlertDeterminationEnum = []AlertDeterminationEnum{
	AlertDeterminationEnumApt,
	AlertDeterminationEnumCompromisedAccount,
	AlertDeterminationEnumConfirmedActivity,
	AlertDeterminationEnumLineOfBusinessApplication,
	AlertDeterminationEnumMaliciousUserActivity,
	AlertDeterminationEnumMalware,
	AlertDeterminationEnumMultiStagedAttack,
	AlertDeterminationEnumNotEnoughDataToValidate,
	AlertDeterminationEnumNotMalicious,
	AlertDeterminationEnumOther,
	AlertDeterminationEnumPhishing,
	AlertDeterminationEnumSecurityPersonnel,
	AlertDeterminationEnumSecurityTesting,
	AlertDeterminationEnumUnwantedSoftware,
}

func (e AlertDeterminationEnum) IsValid() bool {
	switch e {
	case AlertDeterminationEnumApt, AlertDeterminationEnumCompromisedAccount, AlertDeterminationEnumConfirmedActivity, AlertDeterminationEnumLineOfBusinessApplication, AlertDeterminationEnumMaliciousUserActivity, AlertDeterminationEnumMalware, AlertDeterminationEnumMultiStagedAttack, AlertDeterminationEnumNotEnoughDataToValidate, AlertDeterminationEnumNotMalicious, AlertDeterminationEnumOther, AlertDeterminationEnumPhishing, AlertDeterminationEnumSecurityPersonnel, AlertDeterminationEnumSecurityTesting, AlertDeterminationEnumUnwantedSoftware:
		return true
	}
	return false
}

func (e AlertDeterminationEnum) String() string {
	return string(e)
}

func (e *AlertDeterminationEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AlertDeterminationEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AlertDeterminationEnum", str)
	}
	return nil
}

func (e AlertDeterminationEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type AnnotationType string

const (
	//  Other events that are included in annotations
	AnnotationTypeGeneric AnnotationType = "generic"
	//  The site connects to a different PoP
	AnnotationTypePopChange AnnotationType = "popChange"
	//  The ISP IP address (remote IP) changed
	AnnotationTypeRemoteIPChange AnnotationType = "remoteIPChange"
	//  Change for HA status role
	AnnotationTypeRoleChange AnnotationType = "roleChange"
)

var AllAnnotationType = []AnnotationType{
	AnnotationTypeGeneric,
	AnnotationTypePopChange,
	AnnotationTypeRemoteIPChange,
	AnnotationTypeRoleChange,
}

func (e AnnotationType) IsValid() bool {
	switch e {
	case AnnotationTypeGeneric, AnnotationTypePopChange, AnnotationTypeRemoteIPChange, AnnotationTypeRoleChange:
		return true
	}
	return false
}

func (e AnnotationType) String() string {
	return string(e)
}

func (e *AnnotationType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AnnotationType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AnnotationType", str)
	}
	return nil
}

func (e AnnotationType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type AntiMalwareFileHashAction string

const (
	//  Block file download by filehash action
	AntiMalwareFileHashActionBlock AntiMalwareFileHashAction = "BLOCK"
	//  Bypass file download by filehash action
	AntiMalwareFileHashActionBypass AntiMalwareFileHashAction = "BYPASS"
)

var AllAntiMalwareFileHashAction = []AntiMalwareFileHashAction{
	AntiMalwareFileHashActionBlock,
	AntiMalwareFileHashActionBypass,
}

func (e AntiMalwareFileHashAction) IsValid() bool {
	switch e {
	case AntiMalwareFileHashActionBlock, AntiMalwareFileHashActionBypass:
		return true
	}
	return false
}

func (e AntiMalwareFileHashAction) String() string {
	return string(e)
}

func (e *AntiMalwareFileHashAction) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AntiMalwareFileHashAction(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AntiMalwareFileHashAction", str)
	}
	return nil
}

func (e AntiMalwareFileHashAction) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ApnMethod string

const (
	ApnMethodMethodAuto    ApnMethod = "METHOD_AUTO"
	ApnMethodMethodManual  ApnMethod = "METHOD_MANUAL"
	ApnMethodMethodUnknown ApnMethod = "METHOD_UNKNOWN"
)

var AllApnMethod = []ApnMethod{
	ApnMethodMethodAuto,
	ApnMethodMethodManual,
	ApnMethodMethodUnknown,
}

func (e ApnMethod) IsValid() bool {
	switch e {
	case ApnMethodMethodAuto, ApnMethodMethodManual, ApnMethodMethodUnknown:
		return true
	}
	return false
}

func (e ApnMethod) String() string {
	return string(e)
}

func (e *ApnMethod) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ApnMethod(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ApnMethod", str)
	}
	return nil
}

func (e ApnMethod) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type AppStatsFieldName string

const (
	//  The ISP related to this event (when the IP address isn't provided by the ISP, then the event message is IP Addresses are assigned statically)
	AppStatsFieldNameIspName AppStatsFieldName = "ISP_name"
	//  Active Directory name
	AppStatsFieldNameAdName AppStatsFieldName = "ad_name"
	//  The application identifier
	AppStatsFieldNameApp AppStatsFieldName = "app"
	//  The application name
	AppStatsFieldNameApplication AppStatsFieldName = "application"
	//  Application description
	AppStatsFieldNameApplicationDescription AppStatsFieldName = "application_description"
	//  The application identifier
	AppStatsFieldNameApplicationID AppStatsFieldName = "application_id"
	//  The application name
	AppStatsFieldNameApplicationName      AppStatsFieldName = "application_name"
	AppStatsFieldNameApplicationRiskLevel AppStatsFieldName = "application_risk_level"
	//  The application risk score assigned by Cato
	AppStatsFieldNameApplicationRiskScore AppStatsFieldName = "application_risk_score"
	//  Cato system categories of the application
	AppStatsFieldNameCategories AppStatsFieldName = "categories"
	//  Cato system category of the application
	AppStatsFieldNameCategory AppStatsFieldName = "category"
	//  For hosts configured with a static IP in the Cato Management Application, the host name
	AppStatsFieldNameConfiguredHostName AppStatsFieldName = "configured_host_name"
	//  Application description
	AppStatsFieldNameDescription AppStatsFieldName = "description"
	//  IP for destination host or Cato Client
	AppStatsFieldNameDestIP AppStatsFieldName = "dest_ip"
	//  Destination is site or remote user
	AppStatsFieldNameDestIsSiteOrVpn AppStatsFieldName = "dest_is_site_or_vpn"
	//  Destination site or remote user identifier
	AppStatsFieldNameDestSite AppStatsFieldName = "dest_site"
	//  Destination Site or remote user identifier
	AppStatsFieldNameDestSiteID AppStatsFieldName = "dest_site_id"
	//  Destination Site or remote user name
	AppStatsFieldNameDestSiteName AppStatsFieldName = "dest_site_name"
	//  Name for device related to the traffic
	AppStatsFieldNameDeviceName    AppStatsFieldName = "device_name"
	AppStatsFieldNameDiscoveredApp AppStatsFieldName = "discovered_app"
	AppStatsFieldNameDomain        AppStatsFieldName = "domain"
	//  data downloaded from cloud applications
	AppStatsFieldNameDownstream   AppStatsFieldName = "downstream"
	AppStatsFieldNameFlowsCreated AppStatsFieldName = "flows_created"
	//  the country in which the registered application headquarteres is located
	AppStatsFieldNameHqLocation AppStatsFieldName = "hq_location"
	AppStatsFieldNameIP         AppStatsFieldName = "ip"
	//  indicates whether the application is considered cloud app/SaaS app
	AppStatsFieldNameIsCloudApp AppStatsFieldName = "is_cloud_app"
	//  Is the application defined as sanctioned?
	AppStatsFieldNameIsSanctionedApp AppStatsFieldName = "is_sanctioned_app"
	//  new cloud application identifier
	AppStatsFieldNameNewApp    AppStatsFieldName = "new_app"
	AppStatsFieldNameRiskLevel AppStatsFieldName = "risk_level"
	//  the application risk score assigned by Cato
	AppStatsFieldNameRiskScore AppStatsFieldName = "risk_score"
	//  Is the application defined as sanctioned?
	AppStatsFieldNameSanctioned AppStatsFieldName = "sanctioned"
	//  Country in which the source host is located
	AppStatsFieldNameSiteCountry AppStatsFieldName = "site_country"
	//  State in which the source host is located
	AppStatsFieldNameSiteState AppStatsFieldName = "site_state"
	//  Name for Socket interface
	AppStatsFieldNameSocketInterface AppStatsFieldName = "socket_interface"
	//  Country in which the source host is located (detected via public IP address)
	AppStatsFieldNameSrcCountry AppStatsFieldName = "src_country"
	//  Country Code of country in which the source host is located (detected via public IP address)
	AppStatsFieldNameSrcCountryCode AppStatsFieldName = "src_country_code"
	//  IP for source host or Cato Client
	AppStatsFieldNameSrcIP AppStatsFieldName = "src_ip"
	//  Source is site or remote user
	AppStatsFieldNameSrcIsSiteOrVpn AppStatsFieldName = "src_is_site_or_vpn"
	//  IP address provided by ISP to site or Client
	AppStatsFieldNameSrcIspIP AppStatsFieldName = "src_isp_ip"
	//  Site country code alpha2
	AppStatsFieldNameSrcSiteCountryCode AppStatsFieldName = "src_site_country_code"
	//  Source site or remote user identifier
	AppStatsFieldNameSrcSiteID AppStatsFieldName = "src_site_id"
	//  Source site or remote user name
	AppStatsFieldNameSrcSiteName AppStatsFieldName = "src_site_name"
	//  Site state code
	AppStatsFieldNameSrcSiteState AppStatsFieldName = "src_site_state"
	//  Name of subnet as defined in Cato Management Application
	AppStatsFieldNameSubnet AppStatsFieldName = "subnet"
	//  Name of subnet as defined in Cato Management Application
	AppStatsFieldNameSubnetName AppStatsFieldName = "subnet_name"
	//  Top level domain
	AppStatsFieldNameTld AppStatsFieldName = "tld"
	//  the total sum of upstream and downstream data in bytes
	AppStatsFieldNameTraffic AppStatsFieldName = "traffic"
	//  Traffic direction
	AppStatsFieldNameTrafficDirection AppStatsFieldName = "traffic_direction"
	//  data uploaded to cloud applications
	AppStatsFieldNameUpstream AppStatsFieldName = "upstream"
	//  User identifier
	AppStatsFieldNameUserID AppStatsFieldName = "user_id"
	//  User name
	AppStatsFieldNameUserName  AppStatsFieldName = "user_name"
	AppStatsFieldNameVpnUserID AppStatsFieldName = "vpn_user_id"
)

var AllAppStatsFieldName = []AppStatsFieldName{
	AppStatsFieldNameIspName,
	AppStatsFieldNameAdName,
	AppStatsFieldNameApp,
	AppStatsFieldNameApplication,
	AppStatsFieldNameApplicationDescription,
	AppStatsFieldNameApplicationID,
	AppStatsFieldNameApplicationName,
	AppStatsFieldNameApplicationRiskLevel,
	AppStatsFieldNameApplicationRiskScore,
	AppStatsFieldNameCategories,
	AppStatsFieldNameCategory,
	AppStatsFieldNameConfiguredHostName,
	AppStatsFieldNameDescription,
	AppStatsFieldNameDestIP,
	AppStatsFieldNameDestIsSiteOrVpn,
	AppStatsFieldNameDestSite,
	AppStatsFieldNameDestSiteID,
	AppStatsFieldNameDestSiteName,
	AppStatsFieldNameDeviceName,
	AppStatsFieldNameDiscoveredApp,
	AppStatsFieldNameDomain,
	AppStatsFieldNameDownstream,
	AppStatsFieldNameFlowsCreated,
	AppStatsFieldNameHqLocation,
	AppStatsFieldNameIP,
	AppStatsFieldNameIsCloudApp,
	AppStatsFieldNameIsSanctionedApp,
	AppStatsFieldNameNewApp,
	AppStatsFieldNameRiskLevel,
	AppStatsFieldNameRiskScore,
	AppStatsFieldNameSanctioned,
	AppStatsFieldNameSiteCountry,
	AppStatsFieldNameSiteState,
	AppStatsFieldNameSocketInterface,
	AppStatsFieldNameSrcCountry,
	AppStatsFieldNameSrcCountryCode,
	AppStatsFieldNameSrcIP,
	AppStatsFieldNameSrcIsSiteOrVpn,
	AppStatsFieldNameSrcIspIP,
	AppStatsFieldNameSrcSiteCountryCode,
	AppStatsFieldNameSrcSiteID,
	AppStatsFieldNameSrcSiteName,
	AppStatsFieldNameSrcSiteState,
	AppStatsFieldNameSubnet,
	AppStatsFieldNameSubnetName,
	AppStatsFieldNameTld,
	AppStatsFieldNameTraffic,
	AppStatsFieldNameTrafficDirection,
	AppStatsFieldNameUpstream,
	AppStatsFieldNameUserID,
	AppStatsFieldNameUserName,
	AppStatsFieldNameVpnUserID,
}

func (e AppStatsFieldName) IsValid() bool {
	switch e {
	case AppStatsFieldNameIspName, AppStatsFieldNameAdName, AppStatsFieldNameApp, AppStatsFieldNameApplication, AppStatsFieldNameApplicationDescription, AppStatsFieldNameApplicationID, AppStatsFieldNameApplicationName, AppStatsFieldNameApplicationRiskLevel, AppStatsFieldNameApplicationRiskScore, AppStatsFieldNameCategories, AppStatsFieldNameCategory, AppStatsFieldNameConfiguredHostName, AppStatsFieldNameDescription, AppStatsFieldNameDestIP, AppStatsFieldNameDestIsSiteOrVpn, AppStatsFieldNameDestSite, AppStatsFieldNameDestSiteID, AppStatsFieldNameDestSiteName, AppStatsFieldNameDeviceName, AppStatsFieldNameDiscoveredApp, AppStatsFieldNameDomain, AppStatsFieldNameDownstream, AppStatsFieldNameFlowsCreated, AppStatsFieldNameHqLocation, AppStatsFieldNameIP, AppStatsFieldNameIsCloudApp, AppStatsFieldNameIsSanctionedApp, AppStatsFieldNameNewApp, AppStatsFieldNameRiskLevel, AppStatsFieldNameRiskScore, AppStatsFieldNameSanctioned, AppStatsFieldNameSiteCountry, AppStatsFieldNameSiteState, AppStatsFieldNameSocketInterface, AppStatsFieldNameSrcCountry, AppStatsFieldNameSrcCountryCode, AppStatsFieldNameSrcIP, AppStatsFieldNameSrcIsSiteOrVpn, AppStatsFieldNameSrcIspIP, AppStatsFieldNameSrcSiteCountryCode, AppStatsFieldNameSrcSiteID, AppStatsFieldNameSrcSiteName, AppStatsFieldNameSrcSiteState, AppStatsFieldNameSubnet, AppStatsFieldNameSubnetName, AppStatsFieldNameTld, AppStatsFieldNameTraffic, AppStatsFieldNameTrafficDirection, AppStatsFieldNameUpstream, AppStatsFieldNameUserID, AppStatsFieldNameUserName, AppStatsFieldNameVpnUserID:
		return true
	}
	return false
}

func (e AppStatsFieldName) String() string {
	return string(e)
}

func (e *AppStatsFieldName) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AppStatsFieldName(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AppStatsFieldName", str)
	}
	return nil
}

func (e AppStatsFieldName) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Allowed actions
type AppTenantRestrictionActionEnum string

const (
	//  Do not inject any Headers nor Values for outgoing traffic
	AppTenantRestrictionActionEnumBypass AppTenantRestrictionActionEnum = "BYPASS"
	//  Inject Headers and Values for outgoing traffic
	AppTenantRestrictionActionEnumInjectHeaders AppTenantRestrictionActionEnum = "INJECT_HEADERS"
)

var AllAppTenantRestrictionActionEnum = []AppTenantRestrictionActionEnum{
	AppTenantRestrictionActionEnumBypass,
	AppTenantRestrictionActionEnumInjectHeaders,
}

func (e AppTenantRestrictionActionEnum) IsValid() bool {
	switch e {
	case AppTenantRestrictionActionEnumBypass, AppTenantRestrictionActionEnumInjectHeaders:
		return true
	}
	return false
}

func (e AppTenantRestrictionActionEnum) String() string {
	return string(e)
}

func (e *AppTenantRestrictionActionEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AppTenantRestrictionActionEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AppTenantRestrictionActionEnum", str)
	}
	return nil
}

func (e AppTenantRestrictionActionEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Severity options
type AppTenantRestrictionSeverityEnum string

const (
	//  High severity
	AppTenantRestrictionSeverityEnumHigh AppTenantRestrictionSeverityEnum = "HIGH"
	//  Low severity
	AppTenantRestrictionSeverityEnumLow AppTenantRestrictionSeverityEnum = "LOW"
	//  Medium severity
	AppTenantRestrictionSeverityEnumMedium AppTenantRestrictionSeverityEnum = "MEDIUM"
)

var AllAppTenantRestrictionSeverityEnum = []AppTenantRestrictionSeverityEnum{
	AppTenantRestrictionSeverityEnumHigh,
	AppTenantRestrictionSeverityEnumLow,
	AppTenantRestrictionSeverityEnumMedium,
}

func (e AppTenantRestrictionSeverityEnum) IsValid() bool {
	switch e {
	case AppTenantRestrictionSeverityEnumHigh, AppTenantRestrictionSeverityEnumLow, AppTenantRestrictionSeverityEnumMedium:
		return true
	}
	return false
}

func (e AppTenantRestrictionSeverityEnum) String() string {
	return string(e)
}

func (e *AppTenantRestrictionSeverityEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AppTenantRestrictionSeverityEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AppTenantRestrictionSeverityEnum", str)
	}
	return nil
}

func (e AppTenantRestrictionSeverityEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Application Control Access Method Type
type ApplicationControlAccessMethodType string

const (
	//  User agent identification method
	ApplicationControlAccessMethodTypeUserAgent ApplicationControlAccessMethodType = "USER_AGENT"
)

var AllApplicationControlAccessMethodType = []ApplicationControlAccessMethodType{
	ApplicationControlAccessMethodTypeUserAgent,
}

func (e ApplicationControlAccessMethodType) IsValid() bool {
	switch e {
	case ApplicationControlAccessMethodTypeUserAgent:
		return true
	}
	return false
}

func (e ApplicationControlAccessMethodType) String() string {
	return string(e)
}

func (e *ApplicationControlAccessMethodType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ApplicationControlAccessMethodType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ApplicationControlAccessMethodType", str)
	}
	return nil
}

func (e ApplicationControlAccessMethodType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Application Control Action
type ApplicationControlAction string

const (
	//  Permit the action
	ApplicationControlActionAllow ApplicationControlAction = "ALLOW"
	//  Prevent the action
	ApplicationControlActionBlock ApplicationControlAction = "BLOCK"
	//  Log the action without enforcement
	ApplicationControlActionMonitor ApplicationControlAction = "MONITOR"
)

var AllApplicationControlAction = []ApplicationControlAction{
	ApplicationControlActionAllow,
	ApplicationControlActionBlock,
	ApplicationControlActionMonitor,
}

func (e ApplicationControlAction) IsValid() bool {
	switch e {
	case ApplicationControlActionAllow, ApplicationControlActionBlock, ApplicationControlActionMonitor:
		return true
	}
	return false
}

func (e ApplicationControlAction) String() string {
	return string(e)
}

func (e *ApplicationControlAction) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ApplicationControlAction(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ApplicationControlAction", str)
	}
	return nil
}

func (e ApplicationControlAction) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Attribute Value
type ApplicationControlAttributeValue string

const (
	//  Any Value
	ApplicationControlAttributeValueAny ApplicationControlAttributeValue = "ANY"
	//  Not Supported
	ApplicationControlAttributeValueNotSupported ApplicationControlAttributeValue = "NOT_SUPPORTED"
	//  Supported
	ApplicationControlAttributeValueSupported ApplicationControlAttributeValue = "SUPPORTED"
)

var AllApplicationControlAttributeValue = []ApplicationControlAttributeValue{
	ApplicationControlAttributeValueAny,
	ApplicationControlAttributeValueNotSupported,
	ApplicationControlAttributeValueSupported,
}

func (e ApplicationControlAttributeValue) IsValid() bool {
	switch e {
	case ApplicationControlAttributeValueAny, ApplicationControlAttributeValueNotSupported, ApplicationControlAttributeValueSupported:
		return true
	}
	return false
}

func (e ApplicationControlAttributeValue) String() string {
	return string(e)
}

func (e *ApplicationControlAttributeValue) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ApplicationControlAttributeValue(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ApplicationControlAttributeValue", str)
	}
	return nil
}

func (e ApplicationControlAttributeValue) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Application Control File Attribute Type
type ApplicationControlFileAttributeType string

const (
	//  File encryption status
	ApplicationControlFileAttributeTypeContentIsEncrypted ApplicationControlFileAttributeType = "CONTENT_IS_ENCRYPTED"
	//  File Size
	ApplicationControlFileAttributeTypeContentSize ApplicationControlFileAttributeType = "CONTENT_SIZE"
	//  File type classification
	ApplicationControlFileAttributeTypeContentType ApplicationControlFileAttributeType = "CONTENT_TYPE"
)

var AllApplicationControlFileAttributeType = []ApplicationControlFileAttributeType{
	ApplicationControlFileAttributeTypeContentIsEncrypted,
	ApplicationControlFileAttributeTypeContentSize,
	ApplicationControlFileAttributeTypeContentType,
}

func (e ApplicationControlFileAttributeType) IsValid() bool {
	switch e {
	case ApplicationControlFileAttributeTypeContentIsEncrypted, ApplicationControlFileAttributeTypeContentSize, ApplicationControlFileAttributeTypeContentType:
		return true
	}
	return false
}

func (e ApplicationControlFileAttributeType) String() string {
	return string(e)
}

func (e *ApplicationControlFileAttributeType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ApplicationControlFileAttributeType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ApplicationControlFileAttributeType", str)
	}
	return nil
}

func (e ApplicationControlFileAttributeType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Application Control Operator
type ApplicationControlOperator string

const (
	//  Substring match comparison
	ApplicationControlOperatorContains ApplicationControlOperator = "CONTAINS"
	//  Numerical greater than comparison
	ApplicationControlOperatorGreaterThan ApplicationControlOperator = "GREATER_THAN"
	//  Set membership comparison
	ApplicationControlOperatorIn ApplicationControlOperator = "IN"
	//  Exact match comparison
	ApplicationControlOperatorIs ApplicationControlOperator = "IS"
	//  Numerical less than or equal comparison
	ApplicationControlOperatorLessThanOrEqual ApplicationControlOperator = "LESS_THAN_OR_EQUAL"
)

var AllApplicationControlOperator = []ApplicationControlOperator{
	ApplicationControlOperatorContains,
	ApplicationControlOperatorGreaterThan,
	ApplicationControlOperatorIn,
	ApplicationControlOperatorIs,
	ApplicationControlOperatorLessThanOrEqual,
}

func (e ApplicationControlOperator) IsValid() bool {
	switch e {
	case ApplicationControlOperatorContains, ApplicationControlOperatorGreaterThan, ApplicationControlOperatorIn, ApplicationControlOperatorIs, ApplicationControlOperatorLessThanOrEqual:
		return true
	}
	return false
}

func (e ApplicationControlOperator) String() string {
	return string(e)
}

func (e *ApplicationControlOperator) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ApplicationControlOperator(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ApplicationControlOperator", str)
	}
	return nil
}

func (e ApplicationControlOperator) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Application Control Rule Type
type ApplicationControlRuleType string

const (
	//  Specifies an application control rule
	ApplicationControlRuleTypeApplication ApplicationControlRuleType = "APPLICATION"
	//  Specifies an data control rule
	ApplicationControlRuleTypeData ApplicationControlRuleType = "DATA"
	//  Specifies an file control rule
	ApplicationControlRuleTypeFile ApplicationControlRuleType = "FILE"
)

var AllApplicationControlRuleType = []ApplicationControlRuleType{
	ApplicationControlRuleTypeApplication,
	ApplicationControlRuleTypeData,
	ApplicationControlRuleTypeFile,
}

func (e ApplicationControlRuleType) IsValid() bool {
	switch e {
	case ApplicationControlRuleTypeApplication, ApplicationControlRuleTypeData, ApplicationControlRuleTypeFile:
		return true
	}
	return false
}

func (e ApplicationControlRuleType) String() string {
	return string(e)
}

func (e *ApplicationControlRuleType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ApplicationControlRuleType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ApplicationControlRuleType", str)
	}
	return nil
}

func (e ApplicationControlRuleType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Application Control Satisfy
type ApplicationControlSatisfy string

const (
	//  Match only if all criteria are met
	ApplicationControlSatisfyAll ApplicationControlSatisfy = "ALL"
	//  Match if any criteria are met
	ApplicationControlSatisfyAny ApplicationControlSatisfy = "ANY"
)

var AllApplicationControlSatisfy = []ApplicationControlSatisfy{
	ApplicationControlSatisfyAll,
	ApplicationControlSatisfyAny,
}

func (e ApplicationControlSatisfy) IsValid() bool {
	switch e {
	case ApplicationControlSatisfyAll, ApplicationControlSatisfyAny:
		return true
	}
	return false
}

func (e ApplicationControlSatisfy) String() string {
	return string(e)
}

func (e *ApplicationControlSatisfy) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ApplicationControlSatisfy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ApplicationControlSatisfy", str)
	}
	return nil
}

func (e ApplicationControlSatisfy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Severity level
type ApplicationControlSeverity string

const (
	//  Indicates a high severity level
	ApplicationControlSeverityHigh ApplicationControlSeverity = "HIGH"
	//  Indicates a low severity level
	ApplicationControlSeverityLow ApplicationControlSeverity = "LOW"
	//  Indicates a medium severity level
	ApplicationControlSeverityMedium ApplicationControlSeverity = "MEDIUM"
)

var AllApplicationControlSeverity = []ApplicationControlSeverity{
	ApplicationControlSeverityHigh,
	ApplicationControlSeverityLow,
	ApplicationControlSeverityMedium,
}

func (e ApplicationControlSeverity) IsValid() bool {
	switch e {
	case ApplicationControlSeverityHigh, ApplicationControlSeverityLow, ApplicationControlSeverityMedium:
		return true
	}
	return false
}

func (e ApplicationControlSeverity) String() string {
	return string(e)
}

func (e *ApplicationControlSeverity) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ApplicationControlSeverity(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ApplicationControlSeverity", str)
	}
	return nil
}

func (e ApplicationControlSeverity) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Application Type
type ApplicationType string

const (
	//  Application
	ApplicationTypeApplication ApplicationType = "APPLICATION"
	//  Cloud Application type
	ApplicationTypeCloudApplication ApplicationType = "CLOUD_APPLICATION"
	//  Service
	ApplicationTypeService ApplicationType = "SERVICE"
)

var AllApplicationType = []ApplicationType{
	ApplicationTypeApplication,
	ApplicationTypeCloudApplication,
	ApplicationTypeService,
}

func (e ApplicationType) IsValid() bool {
	switch e {
	case ApplicationTypeApplication, ApplicationTypeCloudApplication, ApplicationTypeService:
		return true
	}
	return false
}

func (e ApplicationType) String() string {
	return string(e)
}

func (e *ApplicationType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ApplicationType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ApplicationType", str)
	}
	return nil
}

func (e ApplicationType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type AuditFieldName string

const (
	//  The name of the account on which the record was created
	AuditFieldNameAccount AuditFieldName = "account"
	//  The id of the account on which the record was created
	AuditFieldNameAccountID AuditFieldName = "account_id"
	//  The admin whose action generated the record
	AuditFieldNameAdmin AuditFieldName = "admin"
	//  The ID of the admin whose action generated the record
	AuditFieldNameAdminID AuditFieldName = "admin_id"
	//  The api key whose action generated the record
	AuditFieldNameAPIKey            AuditFieldName = "apiKey"
	AuditFieldNameAuditCreationType AuditFieldName = "audit_creation_type"
	//  the nature of the change: `CREATED, DELETED, MODIFIED, ENABLED, DISABLED, SKIPPED`
	AuditFieldNameChangeType AuditFieldName = "change_type"
	//  Time the record was created
	AuditFieldNameCreationDate AuditFieldName = "creation_date"
	//  Time the record was committed to storage
	AuditFieldNameInsertionDate AuditFieldName = "insertion_date"
	//  The name of the object that was affected, e.g. 'My Site'
	AuditFieldNameModelName AuditFieldName = "model_name"
	//  The type of object that was affected. e.g. Site, Socket, SocketInterface
	AuditFieldNameModelType AuditFieldName = "model_type"
	//  Less granular than model_name, a general marker of the modified area: administration, configuration, security
	AuditFieldNameModule AuditFieldName = "module"
)

var AllAuditFieldName = []AuditFieldName{
	AuditFieldNameAccount,
	AuditFieldNameAccountID,
	AuditFieldNameAdmin,
	AuditFieldNameAdminID,
	AuditFieldNameAPIKey,
	AuditFieldNameAuditCreationType,
	AuditFieldNameChangeType,
	AuditFieldNameCreationDate,
	AuditFieldNameInsertionDate,
	AuditFieldNameModelName,
	AuditFieldNameModelType,
	AuditFieldNameModule,
}

func (e AuditFieldName) IsValid() bool {
	switch e {
	case AuditFieldNameAccount, AuditFieldNameAccountID, AuditFieldNameAdmin, AuditFieldNameAdminID, AuditFieldNameAPIKey, AuditFieldNameAuditCreationType, AuditFieldNameChangeType, AuditFieldNameCreationDate, AuditFieldNameInsertionDate, AuditFieldNameModelName, AuditFieldNameModelType, AuditFieldNameModule:
		return true
	}
	return false
}

func (e AuditFieldName) String() string {
	return string(e)
}

func (e *AuditFieldName) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AuditFieldName(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AuditFieldName", str)
	}
	return nil
}

func (e AuditFieldName) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type BgpCommunityFilterPredicate string

const (
	//  Matches exactly the specified community value.
	BgpCommunityFilterPredicateEqual BgpCommunityFilterPredicate = "EQUAL"
	//  Matches any community value except the specified one.
	BgpCommunityFilterPredicateNotEqual BgpCommunityFilterPredicate = "NOT_EQUAL"
)

var AllBgpCommunityFilterPredicate = []BgpCommunityFilterPredicate{
	BgpCommunityFilterPredicateEqual,
	BgpCommunityFilterPredicateNotEqual,
}

func (e BgpCommunityFilterPredicate) IsValid() bool {
	switch e {
	case BgpCommunityFilterPredicateEqual, BgpCommunityFilterPredicateNotEqual:
		return true
	}
	return false
}

func (e BgpCommunityFilterPredicate) String() string {
	return string(e)
}

func (e *BgpCommunityFilterPredicate) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BgpCommunityFilterPredicate(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BgpCommunityFilterPredicate", str)
	}
	return nil
}

func (e BgpCommunityFilterPredicate) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type BgpDefaultAction string

const (
	//  Default action to accept all unmatched routes.
	BgpDefaultActionAccept BgpDefaultAction = "ACCEPT"
	//  Default action to drop all unmatched routes.
	BgpDefaultActionDrop BgpDefaultAction = "DROP"
)

var AllBgpDefaultAction = []BgpDefaultAction{
	BgpDefaultActionAccept,
	BgpDefaultActionDrop,
}

func (e BgpDefaultAction) IsValid() bool {
	switch e {
	case BgpDefaultActionAccept, BgpDefaultActionDrop:
		return true
	}
	return false
}

func (e BgpDefaultAction) String() string {
	return string(e)
}

func (e *BgpDefaultAction) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BgpDefaultAction(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BgpDefaultAction", str)
	}
	return nil
}

func (e BgpDefaultAction) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type BgpState string

const (
	BgpStateActive      BgpState = "Active"
	BgpStateConnect     BgpState = "Connect"
	BgpStateEstablished BgpState = "Established"
	BgpStateIdle        BgpState = "Idle"
	BgpStateOpenConfirm BgpState = "OpenConfirm"
	BgpStateOpenSent    BgpState = "OpenSent"
	BgpStateStateMax    BgpState = "StateMAX"
)

var AllBgpState = []BgpState{
	BgpStateActive,
	BgpStateConnect,
	BgpStateEstablished,
	BgpStateIdle,
	BgpStateOpenConfirm,
	BgpStateOpenSent,
	BgpStateStateMax,
}

func (e BgpState) IsValid() bool {
	switch e {
	case BgpStateActive, BgpStateConnect, BgpStateEstablished, BgpStateIdle, BgpStateOpenConfirm, BgpStateOpenSent, BgpStateStateMax:
		return true
	}
	return false
}

func (e BgpState) String() string {
	return string(e)
}

func (e *BgpState) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BgpState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BgpState", str)
	}
	return nil
}

func (e BgpState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type CatalogApplicationActivityFieldOperator string

const (
	CatalogApplicationActivityFieldOperatorContains    CatalogApplicationActivityFieldOperator = "CONTAINS"
	CatalogApplicationActivityFieldOperatorGreaterThan CatalogApplicationActivityFieldOperator = "GREATER_THAN"
	CatalogApplicationActivityFieldOperatorIn          CatalogApplicationActivityFieldOperator = "IN"
	CatalogApplicationActivityFieldOperatorIs          CatalogApplicationActivityFieldOperator = "IS"
	CatalogApplicationActivityFieldOperatorLessEquals  CatalogApplicationActivityFieldOperator = "LESS_EQUALS"
)

var AllCatalogApplicationActivityFieldOperator = []CatalogApplicationActivityFieldOperator{
	CatalogApplicationActivityFieldOperatorContains,
	CatalogApplicationActivityFieldOperatorGreaterThan,
	CatalogApplicationActivityFieldOperatorIn,
	CatalogApplicationActivityFieldOperatorIs,
	CatalogApplicationActivityFieldOperatorLessEquals,
}

func (e CatalogApplicationActivityFieldOperator) IsValid() bool {
	switch e {
	case CatalogApplicationActivityFieldOperatorContains, CatalogApplicationActivityFieldOperatorGreaterThan, CatalogApplicationActivityFieldOperatorIn, CatalogApplicationActivityFieldOperatorIs, CatalogApplicationActivityFieldOperatorLessEquals:
		return true
	}
	return false
}

func (e CatalogApplicationActivityFieldOperator) String() string {
	return string(e)
}

func (e *CatalogApplicationActivityFieldOperator) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CatalogApplicationActivityFieldOperator(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CatalogApplicationActivityFieldOperator", str)
	}
	return nil
}

func (e CatalogApplicationActivityFieldOperator) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type CatalogApplicationAttribute string

const (
	CatalogApplicationAttributeSupported   CatalogApplicationAttribute = "SUPPORTED"
	CatalogApplicationAttributeUnknown     CatalogApplicationAttribute = "UNKNOWN"
	CatalogApplicationAttributeUnsupported CatalogApplicationAttribute = "UNSUPPORTED"
)

var AllCatalogApplicationAttribute = []CatalogApplicationAttribute{
	CatalogApplicationAttributeSupported,
	CatalogApplicationAttributeUnknown,
	CatalogApplicationAttributeUnsupported,
}

func (e CatalogApplicationAttribute) IsValid() bool {
	switch e {
	case CatalogApplicationAttributeSupported, CatalogApplicationAttributeUnknown, CatalogApplicationAttributeUnsupported:
		return true
	}
	return false
}

func (e CatalogApplicationAttribute) String() string {
	return string(e)
}

func (e *CatalogApplicationAttribute) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CatalogApplicationAttribute(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CatalogApplicationAttribute", str)
	}
	return nil
}

func (e CatalogApplicationAttribute) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type CatalogApplicationCapability string

const (
	CatalogApplicationCapabilityAntiMalwareInline    CatalogApplicationCapability = "ANTI_MALWARE_INLINE"
	CatalogApplicationCapabilityAppControlAPI        CatalogApplicationCapability = "APP_CONTROL_API"
	CatalogApplicationCapabilityAppControlInline     CatalogApplicationCapability = "APP_CONTROL_INLINE"
	CatalogApplicationCapabilityDataProtectionAPI    CatalogApplicationCapability = "DATA_PROTECTION_API"
	CatalogApplicationCapabilityDataProtectionInline CatalogApplicationCapability = "DATA_PROTECTION_INLINE"
	CatalogApplicationCapabilityFileControlInline    CatalogApplicationCapability = "FILE_CONTROL_INLINE"
	CatalogApplicationCapabilityFirewallIntline      CatalogApplicationCapability = "FIREWALL_INTLINE"
	CatalogApplicationCapabilityLanFirewall          CatalogApplicationCapability = "LAN_FIREWALL"
)

var AllCatalogApplicationCapability = []CatalogApplicationCapability{
	CatalogApplicationCapabilityAntiMalwareInline,
	CatalogApplicationCapabilityAppControlAPI,
	CatalogApplicationCapabilityAppControlInline,
	CatalogApplicationCapabilityDataProtectionAPI,
	CatalogApplicationCapabilityDataProtectionInline,
	CatalogApplicationCapabilityFileControlInline,
	CatalogApplicationCapabilityFirewallIntline,
	CatalogApplicationCapabilityLanFirewall,
}

func (e CatalogApplicationCapability) IsValid() bool {
	switch e {
	case CatalogApplicationCapabilityAntiMalwareInline, CatalogApplicationCapabilityAppControlAPI, CatalogApplicationCapabilityAppControlInline, CatalogApplicationCapabilityDataProtectionAPI, CatalogApplicationCapabilityDataProtectionInline, CatalogApplicationCapabilityFileControlInline, CatalogApplicationCapabilityFirewallIntline, CatalogApplicationCapabilityLanFirewall:
		return true
	}
	return false
}

func (e CatalogApplicationCapability) String() string {
	return string(e)
}

func (e *CatalogApplicationCapability) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CatalogApplicationCapability(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CatalogApplicationCapability", str)
	}
	return nil
}

func (e CatalogApplicationCapability) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type CatalogApplicationType string

const (
	CatalogApplicationTypeApplication      CatalogApplicationType = "APPLICATION"
	CatalogApplicationTypeCloudApplication CatalogApplicationType = "CLOUD_APPLICATION"
	CatalogApplicationTypeService          CatalogApplicationType = "SERVICE"
)

var AllCatalogApplicationType = []CatalogApplicationType{
	CatalogApplicationTypeApplication,
	CatalogApplicationTypeCloudApplication,
	CatalogApplicationTypeService,
}

func (e CatalogApplicationType) IsValid() bool {
	switch e {
	case CatalogApplicationTypeApplication, CatalogApplicationTypeCloudApplication, CatalogApplicationTypeService:
		return true
	}
	return false
}

func (e CatalogApplicationType) String() string {
	return string(e)
}

func (e *CatalogApplicationType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CatalogApplicationType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CatalogApplicationType", str)
	}
	return nil
}

func (e CatalogApplicationType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type CatoEndpointEngineType string

const (
	CatoEndpointEngineTypeAntiMalware CatoEndpointEngineType = "AntiMalware"
	CatoEndpointEngineTypeBehavioral  CatoEndpointEngineType = "Behavioral"
)

var AllCatoEndpointEngineType = []CatoEndpointEngineType{
	CatoEndpointEngineTypeAntiMalware,
	CatoEndpointEngineTypeBehavioral,
}

func (e CatoEndpointEngineType) IsValid() bool {
	switch e {
	case CatoEndpointEngineTypeAntiMalware, CatoEndpointEngineTypeBehavioral:
		return true
	}
	return false
}

func (e CatoEndpointEngineType) String() string {
	return string(e)
}

func (e *CatoEndpointEngineType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CatoEndpointEngineType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CatoEndpointEngineType", str)
	}
	return nil
}

func (e CatoEndpointEngineType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type CellularDisconnectionReason string

const (
	CellularDisconnectionReasonReasonNone    CellularDisconnectionReason = "REASON_NONE"
	CellularDisconnectionReasonReasonTimeout CellularDisconnectionReason = "REASON_TIMEOUT"
)

var AllCellularDisconnectionReason = []CellularDisconnectionReason{
	CellularDisconnectionReasonReasonNone,
	CellularDisconnectionReasonReasonTimeout,
}

func (e CellularDisconnectionReason) IsValid() bool {
	switch e {
	case CellularDisconnectionReasonReasonNone, CellularDisconnectionReasonReasonTimeout:
		return true
	}
	return false
}

func (e CellularDisconnectionReason) String() string {
	return string(e)
}

func (e *CellularDisconnectionReason) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CellularDisconnectionReason(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CellularDisconnectionReason", str)
	}
	return nil
}

func (e CellularDisconnectionReason) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type CellularModemStatus string

const (
	CellularModemStatusStatusError   CellularModemStatus = "STATUS_ERROR"
	CellularModemStatusStatusOk      CellularModemStatus = "STATUS_OK"
	CellularModemStatusStatusUnknown CellularModemStatus = "STATUS_UNKNOWN"
)

var AllCellularModemStatus = []CellularModemStatus{
	CellularModemStatusStatusError,
	CellularModemStatusStatusOk,
	CellularModemStatusStatusUnknown,
}

func (e CellularModemStatus) IsValid() bool {
	switch e {
	case CellularModemStatusStatusError, CellularModemStatusStatusOk, CellularModemStatusStatusUnknown:
		return true
	}
	return false
}

func (e CellularModemStatus) String() string {
	return string(e)
}

func (e *CellularModemStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CellularModemStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CellularModemStatus", str)
	}
	return nil
}

func (e CellularModemStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type CellularNetworkType string

const (
	CellularNetworkTypeType2g      CellularNetworkType = "TYPE_2G"
	CellularNetworkTypeType3g      CellularNetworkType = "TYPE_3G"
	CellularNetworkTypeType4g      CellularNetworkType = "TYPE_4G"
	CellularNetworkTypeTypeUnknown CellularNetworkType = "TYPE_UNKNOWN"
)

var AllCellularNetworkType = []CellularNetworkType{
	CellularNetworkTypeType2g,
	CellularNetworkTypeType3g,
	CellularNetworkTypeType4g,
	CellularNetworkTypeTypeUnknown,
}

func (e CellularNetworkType) IsValid() bool {
	switch e {
	case CellularNetworkTypeType2g, CellularNetworkTypeType3g, CellularNetworkTypeType4g, CellularNetworkTypeTypeUnknown:
		return true
	}
	return false
}

func (e CellularNetworkType) String() string {
	return string(e)
}

func (e *CellularNetworkType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CellularNetworkType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CellularNetworkType", str)
	}
	return nil
}

func (e CellularNetworkType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ConnectionMode string

const (
	ConnectionModeBidirectional ConnectionMode = "BIDIRECTIONAL"
	ConnectionModeResponderOnly ConnectionMode = "RESPONDER_ONLY"
)

var AllConnectionMode = []ConnectionMode{
	ConnectionModeBidirectional,
	ConnectionModeResponderOnly,
}

func (e ConnectionMode) IsValid() bool {
	switch e {
	case ConnectionModeBidirectional, ConnectionModeResponderOnly:
		return true
	}
	return false
}

func (e ConnectionMode) String() string {
	return string(e)
}

func (e *ConnectionMode) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ConnectionMode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ConnectionMode", str)
	}
	return nil
}

func (e ConnectionMode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ConnectionOriginEnum string

const (
	ConnectionOriginEnumAny    ConnectionOriginEnum = "ANY"
	ConnectionOriginEnumRemote ConnectionOriginEnum = "REMOTE"
	ConnectionOriginEnumSite   ConnectionOriginEnum = "SITE"
)

var AllConnectionOriginEnum = []ConnectionOriginEnum{
	ConnectionOriginEnumAny,
	ConnectionOriginEnumRemote,
	ConnectionOriginEnumSite,
}

func (e ConnectionOriginEnum) IsValid() bool {
	switch e {
	case ConnectionOriginEnumAny, ConnectionOriginEnumRemote, ConnectionOriginEnumSite:
		return true
	}
	return false
}

func (e ConnectionOriginEnum) String() string {
	return string(e)
}

func (e *ConnectionOriginEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ConnectionOriginEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ConnectionOriginEnum", str)
	}
	return nil
}

func (e ConnectionOriginEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ConnectionTypeEnum string

const (
	ConnectionTypeEnumHost ConnectionTypeEnum = "Host"
	ConnectionTypeEnumSite ConnectionTypeEnum = "Site"
	ConnectionTypeEnumUser ConnectionTypeEnum = "User"
)

var AllConnectionTypeEnum = []ConnectionTypeEnum{
	ConnectionTypeEnumHost,
	ConnectionTypeEnumSite,
	ConnectionTypeEnumUser,
}

func (e ConnectionTypeEnum) IsValid() bool {
	switch e {
	case ConnectionTypeEnumHost, ConnectionTypeEnumSite, ConnectionTypeEnumUser:
		return true
	}
	return false
}

func (e ConnectionTypeEnum) String() string {
	return string(e)
}

func (e *ConnectionTypeEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ConnectionTypeEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ConnectionTypeEnum", str)
	}
	return nil
}

func (e ConnectionTypeEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ConnectivityStatus string

const (
	//  Connected to the Cato Cloud
	ConnectivityStatusConnected ConnectivityStatus = "connected"
	//  Disconnected from the Cato Cloud
	ConnectivityStatusDisconnected ConnectivityStatus = "disconnected"
)

var AllConnectivityStatus = []ConnectivityStatus{
	ConnectivityStatusConnected,
	ConnectivityStatusDisconnected,
}

func (e ConnectivityStatus) IsValid() bool {
	switch e {
	case ConnectivityStatusConnected, ConnectivityStatusDisconnected:
		return true
	}
	return false
}

func (e ConnectivityStatus) String() string {
	return string(e)
}

func (e *ConnectivityStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ConnectivityStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ConnectivityStatus", str)
	}
	return nil
}

func (e ConnectivityStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ContainerFileType string

const (
	ContainerFileTypeCSV  ContainerFileType = "CSV"
	ContainerFileTypeStix ContainerFileType = "STIX"
)

var AllContainerFileType = []ContainerFileType{
	ContainerFileTypeCSV,
	ContainerFileTypeStix,
}

func (e ContainerFileType) IsValid() bool {
	switch e {
	case ContainerFileTypeCSV, ContainerFileTypeStix:
		return true
	}
	return false
}

func (e ContainerFileType) String() string {
	return string(e)
}

func (e *ContainerFileType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ContainerFileType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ContainerFileType", str)
	}
	return nil
}

func (e ContainerFileType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ContainerType string

const (
	ContainerTypeFqdn    ContainerType = "FQDN"
	ContainerTypeIPRange ContainerType = "IP_RANGE"
)

var AllContainerType = []ContainerType{
	ContainerTypeFqdn,
	ContainerTypeIPRange,
}

func (e ContainerType) IsValid() bool {
	switch e {
	case ContainerTypeFqdn, ContainerTypeIPRange:
		return true
	}
	return false
}

func (e ContainerType) String() string {
	return string(e)
}

func (e *ContainerType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ContainerType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ContainerType", str)
	}
	return nil
}

func (e ContainerType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type DayOfWeek string

const (
	DayOfWeekFriday    DayOfWeek = "FRIDAY"
	DayOfWeekMonday    DayOfWeek = "MONDAY"
	DayOfWeekSaturday  DayOfWeek = "SATURDAY"
	DayOfWeekSunday    DayOfWeek = "SUNDAY"
	DayOfWeekThursday  DayOfWeek = "THURSDAY"
	DayOfWeekTuesday   DayOfWeek = "TUESDAY"
	DayOfWeekWednesday DayOfWeek = "WEDNESDAY"
)

var AllDayOfWeek = []DayOfWeek{
	DayOfWeekFriday,
	DayOfWeekMonday,
	DayOfWeekSaturday,
	DayOfWeekSunday,
	DayOfWeekThursday,
	DayOfWeekTuesday,
	DayOfWeekWednesday,
}

func (e DayOfWeek) IsValid() bool {
	switch e {
	case DayOfWeekFriday, DayOfWeekMonday, DayOfWeekSaturday, DayOfWeekSunday, DayOfWeekThursday, DayOfWeekTuesday, DayOfWeekWednesday:
		return true
	}
	return false
}

func (e DayOfWeek) String() string {
	return string(e)
}

func (e *DayOfWeek) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DayOfWeek(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DayOfWeek", str)
	}
	return nil
}

func (e DayOfWeek) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type DegradedStatusReason string

const (
	DegradedStatusReasonAltWanDisconnected                        DegradedStatusReason = "ALT_WAN_DISCONNECTED"
	DegradedStatusReasonCrossConnectCircuitDisconnected           DegradedStatusReason = "CROSS_CONNECT_CIRCUIT_DISCONNECTED"
	DegradedStatusReasonHaNotReadyIncompatibleMajorSocketVersions DegradedStatusReason = "HA_NOT_READY_INCOMPATIBLE_MAJOR_SOCKET_VERSIONS"
	DegradedStatusReasonHaNotReadyNoKeepalive                     DegradedStatusReason = "HA_NOT_READY_NO_KEEPALIVE"
	DegradedStatusReasonHaNotReadySocketDisconnected              DegradedStatusReason = "HA_NOT_READY_SOCKET_DISCONNECTED"
	DegradedStatusReasonIpsecMultiTunnelTunnelDisconnected        DegradedStatusReason = "IPSEC_MULTI_TUNNEL_TUNNEL_DISCONNECTED"
	DegradedStatusReasonIpsecTunnelDisconnected                   DegradedStatusReason = "IPSEC_TUNNEL_DISCONNECTED"
	DegradedStatusReasonLanDisconnected                           DegradedStatusReason = "LAN_DISCONNECTED"
	DegradedStatusReasonLanLagDisconnected                        DegradedStatusReason = "LAN_LAG_DISCONNECTED"
	DegradedStatusReasonLanLagMemberDisconnected                  DegradedStatusReason = "LAN_LAG_MEMBER_DISCONNECTED"
	DegradedStatusReasonWanDisconnected                           DegradedStatusReason = "WAN_DISCONNECTED"
	DegradedStatusReasonWanTunnelDisconnected                     DegradedStatusReason = "WAN_TUNNEL_DISCONNECTED"
)

var AllDegradedStatusReason = []DegradedStatusReason{
	DegradedStatusReasonAltWanDisconnected,
	DegradedStatusReasonCrossConnectCircuitDisconnected,
	DegradedStatusReasonHaNotReadyIncompatibleMajorSocketVersions,
	DegradedStatusReasonHaNotReadyNoKeepalive,
	DegradedStatusReasonHaNotReadySocketDisconnected,
	DegradedStatusReasonIpsecMultiTunnelTunnelDisconnected,
	DegradedStatusReasonIpsecTunnelDisconnected,
	DegradedStatusReasonLanDisconnected,
	DegradedStatusReasonLanLagDisconnected,
	DegradedStatusReasonLanLagMemberDisconnected,
	DegradedStatusReasonWanDisconnected,
	DegradedStatusReasonWanTunnelDisconnected,
}

func (e DegradedStatusReason) IsValid() bool {
	switch e {
	case DegradedStatusReasonAltWanDisconnected, DegradedStatusReasonCrossConnectCircuitDisconnected, DegradedStatusReasonHaNotReadyIncompatibleMajorSocketVersions, DegradedStatusReasonHaNotReadyNoKeepalive, DegradedStatusReasonHaNotReadySocketDisconnected, DegradedStatusReasonIpsecMultiTunnelTunnelDisconnected, DegradedStatusReasonIpsecTunnelDisconnected, DegradedStatusReasonLanDisconnected, DegradedStatusReasonLanLagDisconnected, DegradedStatusReasonLanLagMemberDisconnected, DegradedStatusReasonWanDisconnected, DegradedStatusReasonWanTunnelDisconnected:
		return true
	}
	return false
}

func (e DegradedStatusReason) String() string {
	return string(e)
}

func (e *DegradedStatusReason) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DegradedStatusReason(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DegradedStatusReason", str)
	}
	return nil
}

func (e DegradedStatusReason) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type DestinationType string

const (
	DestinationTypeFqdn DestinationType = "FQDN"
	DestinationTypeIPv4 DestinationType = "IPv4"
)

var AllDestinationType = []DestinationType{
	DestinationTypeFqdn,
	DestinationTypeIPv4,
}

func (e DestinationType) IsValid() bool {
	switch e {
	case DestinationTypeFqdn, DestinationTypeIPv4:
		return true
	}
	return false
}

func (e DestinationType) String() string {
	return string(e)
}

func (e *DestinationType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DestinationType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DestinationType", str)
	}
	return nil
}

func (e DestinationType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type DetectionSourceEnum string

const (
	DetectionSourceEnumAntivirus                     DetectionSourceEnum = "ANTIVIRUS"
	DetectionSourceEnumAppGovernanceDetection        DetectionSourceEnum = "APP_GOVERNANCE_DETECTION"
	DetectionSourceEnumAppGovernancePolicy           DetectionSourceEnum = "APP_GOVERNANCE_POLICY"
	DetectionSourceEnumAutomatedInvestigation        DetectionSourceEnum = "AUTOMATED_INVESTIGATION"
	DetectionSourceEnumAzureAdIdentityProtection     DetectionSourceEnum = "AZURE_AD_IDENTITY_PROTECTION"
	DetectionSourceEnumCloudAppSecurity              DetectionSourceEnum = "CLOUD_APP_SECURITY"
	DetectionSourceEnumCustomDetection               DetectionSourceEnum = "CUSTOM_DETECTION"
	DetectionSourceEnumCustomTi                      DetectionSourceEnum = "CUSTOM_TI"
	DetectionSourceEnumManual                        DetectionSourceEnum = "MANUAL"
	DetectionSourceEnumMicrosoft365Defender          DetectionSourceEnum = "MICROSOFT365_DEFENDER"
	DetectionSourceEnumMicrosoftDataLossPrevention   DetectionSourceEnum = "MICROSOFT_DATA_LOSS_PREVENTION"
	DetectionSourceEnumMicrosoftDefenderForEndpoint  DetectionSourceEnum = "MICROSOFT_DEFENDER_FOR_ENDPOINT"
	DetectionSourceEnumMicrosoftDefenderForIdentity  DetectionSourceEnum = "MICROSOFT_DEFENDER_FOR_IDENTITY"
	DetectionSourceEnumMicrosoftDefenderForOffice365 DetectionSourceEnum = "MICROSOFT_DEFENDER_FOR_OFFICE365"
	DetectionSourceEnumMicrosoftThreatExperts        DetectionSourceEnum = "MICROSOFT_THREAT_EXPERTS"
	DetectionSourceEnumSmartScreen                   DetectionSourceEnum = "SMART_SCREEN"
)

var AllDetectionSourceEnum = []DetectionSourceEnum{
	DetectionSourceEnumAntivirus,
	DetectionSourceEnumAppGovernanceDetection,
	DetectionSourceEnumAppGovernancePolicy,
	DetectionSourceEnumAutomatedInvestigation,
	DetectionSourceEnumAzureAdIdentityProtection,
	DetectionSourceEnumCloudAppSecurity,
	DetectionSourceEnumCustomDetection,
	DetectionSourceEnumCustomTi,
	DetectionSourceEnumManual,
	DetectionSourceEnumMicrosoft365Defender,
	DetectionSourceEnumMicrosoftDataLossPrevention,
	DetectionSourceEnumMicrosoftDefenderForEndpoint,
	DetectionSourceEnumMicrosoftDefenderForIdentity,
	DetectionSourceEnumMicrosoftDefenderForOffice365,
	DetectionSourceEnumMicrosoftThreatExperts,
	DetectionSourceEnumSmartScreen,
}

func (e DetectionSourceEnum) IsValid() bool {
	switch e {
	case DetectionSourceEnumAntivirus, DetectionSourceEnumAppGovernanceDetection, DetectionSourceEnumAppGovernancePolicy, DetectionSourceEnumAutomatedInvestigation, DetectionSourceEnumAzureAdIdentityProtection, DetectionSourceEnumCloudAppSecurity, DetectionSourceEnumCustomDetection, DetectionSourceEnumCustomTi, DetectionSourceEnumManual, DetectionSourceEnumMicrosoft365Defender, DetectionSourceEnumMicrosoftDataLossPrevention, DetectionSourceEnumMicrosoftDefenderForEndpoint, DetectionSourceEnumMicrosoftDefenderForIdentity, DetectionSourceEnumMicrosoftDefenderForOffice365, DetectionSourceEnumMicrosoftThreatExperts, DetectionSourceEnumSmartScreen:
		return true
	}
	return false
}

func (e DetectionSourceEnum) String() string {
	return string(e)
}

func (e *DetectionSourceEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DetectionSourceEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DetectionSourceEnum", str)
	}
	return nil
}

func (e DetectionSourceEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type DetectionStatusEnum string

const (
	DetectionStatusEnumBlocked   DetectionStatusEnum = "BLOCKED"
	DetectionStatusEnumDetected  DetectionStatusEnum = "DETECTED"
	DetectionStatusEnumPrevented DetectionStatusEnum = "PREVENTED"
)

var AllDetectionStatusEnum = []DetectionStatusEnum{
	DetectionStatusEnumBlocked,
	DetectionStatusEnumDetected,
	DetectionStatusEnumPrevented,
}

func (e DetectionStatusEnum) IsValid() bool {
	switch e {
	case DetectionStatusEnumBlocked, DetectionStatusEnumDetected, DetectionStatusEnumPrevented:
		return true
	}
	return false
}

func (e DetectionStatusEnum) String() string {
	return string(e)
}

func (e *DetectionStatusEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DetectionStatusEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DetectionStatusEnum", str)
	}
	return nil
}

func (e DetectionStatusEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type DeviceAvStatusEnum string

const (
	DeviceAvStatusEnumDisabled     DeviceAvStatusEnum = "DISABLED"
	DeviceAvStatusEnumNotReporting DeviceAvStatusEnum = "NOT_REPORTING"
	DeviceAvStatusEnumNotUpdated   DeviceAvStatusEnum = "NOT_UPDATED"
	DeviceAvStatusEnumUpdated      DeviceAvStatusEnum = "UPDATED"
)

var AllDeviceAvStatusEnum = []DeviceAvStatusEnum{
	DeviceAvStatusEnumDisabled,
	DeviceAvStatusEnumNotReporting,
	DeviceAvStatusEnumNotUpdated,
	DeviceAvStatusEnumUpdated,
}

func (e DeviceAvStatusEnum) IsValid() bool {
	switch e {
	case DeviceAvStatusEnumDisabled, DeviceAvStatusEnumNotReporting, DeviceAvStatusEnumNotUpdated, DeviceAvStatusEnumUpdated:
		return true
	}
	return false
}

func (e DeviceAvStatusEnum) String() string {
	return string(e)
}

func (e *DeviceAvStatusEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DeviceAvStatusEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DeviceAvStatusEnum", str)
	}
	return nil
}

func (e DeviceAvStatusEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type DeviceCategory string

const (
	DeviceCategoryIoT        DeviceCategory = "IoT"
	DeviceCategoryMobile     DeviceCategory = "Mobile"
	DeviceCategoryNetworking DeviceCategory = "Networking"
	DeviceCategoryOt         DeviceCategory = "OT"
	DeviceCategoryPc         DeviceCategory = "PC"
	DeviceCategoryServer     DeviceCategory = "Server"
)

var AllDeviceCategory = []DeviceCategory{
	DeviceCategoryIoT,
	DeviceCategoryMobile,
	DeviceCategoryNetworking,
	DeviceCategoryOt,
	DeviceCategoryPc,
	DeviceCategoryServer,
}

func (e DeviceCategory) IsValid() bool {
	switch e {
	case DeviceCategoryIoT, DeviceCategoryMobile, DeviceCategoryNetworking, DeviceCategoryOt, DeviceCategoryPc, DeviceCategoryServer:
		return true
	}
	return false
}

func (e DeviceCategory) String() string {
	return string(e)
}

func (e *DeviceCategory) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DeviceCategory(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DeviceCategory", str)
	}
	return nil
}

func (e DeviceCategory) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type DeviceConfidenceLevel string

const (
	//  Device classification is strongly validated by multiple signals
	DeviceConfidenceLevelHigh DeviceConfidenceLevel = "HIGH"
	//  Device classification has minimal supporting evidence
	DeviceConfidenceLevelLow DeviceConfidenceLevel = "LOW"
	//  Device classification has moderate supporting signals
	DeviceConfidenceLevelMedium DeviceConfidenceLevel = "MEDIUM"
)

var AllDeviceConfidenceLevel = []DeviceConfidenceLevel{
	DeviceConfidenceLevelHigh,
	DeviceConfidenceLevelLow,
	DeviceConfidenceLevelMedium,
}

func (e DeviceConfidenceLevel) IsValid() bool {
	switch e {
	case DeviceConfidenceLevelHigh, DeviceConfidenceLevelLow, DeviceConfidenceLevelMedium:
		return true
	}
	return false
}

func (e DeviceConfidenceLevel) String() string {
	return string(e)
}

func (e *DeviceConfidenceLevel) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DeviceConfidenceLevel(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DeviceConfidenceLevel", str)
	}
	return nil
}

func (e DeviceConfidenceLevel) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type DeviceConfigHaRoleEnum string

const (
	DeviceConfigHaRoleEnumPrimary   DeviceConfigHaRoleEnum = "PRIMARY"
	DeviceConfigHaRoleEnumSecondary DeviceConfigHaRoleEnum = "SECONDARY"
)

var AllDeviceConfigHaRoleEnum = []DeviceConfigHaRoleEnum{
	DeviceConfigHaRoleEnumPrimary,
	DeviceConfigHaRoleEnumSecondary,
}

func (e DeviceConfigHaRoleEnum) IsValid() bool {
	switch e {
	case DeviceConfigHaRoleEnumPrimary, DeviceConfigHaRoleEnumSecondary:
		return true
	}
	return false
}

func (e DeviceConfigHaRoleEnum) String() string {
	return string(e)
}

func (e *DeviceConfigHaRoleEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DeviceConfigHaRoleEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DeviceConfigHaRoleEnum", str)
	}
	return nil
}

func (e DeviceConfigHaRoleEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type DeviceHaRoleStateEnum string

const (
	DeviceHaRoleStateEnumBackup DeviceHaRoleStateEnum = "BACKUP"
	DeviceHaRoleStateEnumMaster DeviceHaRoleStateEnum = "MASTER"
)

var AllDeviceHaRoleStateEnum = []DeviceHaRoleStateEnum{
	DeviceHaRoleStateEnumBackup,
	DeviceHaRoleStateEnumMaster,
}

func (e DeviceHaRoleStateEnum) IsValid() bool {
	switch e {
	case DeviceHaRoleStateEnumBackup, DeviceHaRoleStateEnumMaster:
		return true
	}
	return false
}

func (e DeviceHaRoleStateEnum) String() string {
	return string(e)
}

func (e *DeviceHaRoleStateEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DeviceHaRoleStateEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DeviceHaRoleStateEnum", str)
	}
	return nil
}

func (e DeviceHaRoleStateEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type DeviceHealthStatusEnum string

const (
	DeviceHealthStatusEnumActive                            DeviceHealthStatusEnum = "ACTIVE"
	DeviceHealthStatusEnumImpairedCommunication             DeviceHealthStatusEnum = "IMPAIRED_COMMUNICATION"
	DeviceHealthStatusEnumInactive                          DeviceHealthStatusEnum = "INACTIVE"
	DeviceHealthStatusEnumNoSensorData                      DeviceHealthStatusEnum = "NO_SENSOR_DATA"
	DeviceHealthStatusEnumNoSensorDataImpairedCommunication DeviceHealthStatusEnum = "NO_SENSOR_DATA_IMPAIRED_COMMUNICATION"
)

var AllDeviceHealthStatusEnum = []DeviceHealthStatusEnum{
	DeviceHealthStatusEnumActive,
	DeviceHealthStatusEnumImpairedCommunication,
	DeviceHealthStatusEnumInactive,
	DeviceHealthStatusEnumNoSensorData,
	DeviceHealthStatusEnumNoSensorDataImpairedCommunication,
}

func (e DeviceHealthStatusEnum) IsValid() bool {
	switch e {
	case DeviceHealthStatusEnumActive, DeviceHealthStatusEnumImpairedCommunication, DeviceHealthStatusEnumInactive, DeviceHealthStatusEnumNoSensorData, DeviceHealthStatusEnumNoSensorDataImpairedCommunication:
		return true
	}
	return false
}

func (e DeviceHealthStatusEnum) String() string {
	return string(e)
}

func (e *DeviceHealthStatusEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DeviceHealthStatusEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DeviceHealthStatusEnum", str)
	}
	return nil
}

func (e DeviceHealthStatusEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type DeviceV2Category string

const (
	DeviceV2CategoryIot        DeviceV2Category = "IOT"
	DeviceV2CategoryMobile     DeviceV2Category = "MOBILE"
	DeviceV2CategoryNetworking DeviceV2Category = "NETWORKING"
	DeviceV2CategoryOt         DeviceV2Category = "OT"
	DeviceV2CategoryPc         DeviceV2Category = "PC"
	DeviceV2CategoryServer     DeviceV2Category = "SERVER"
)

var AllDeviceV2Category = []DeviceV2Category{
	DeviceV2CategoryIot,
	DeviceV2CategoryMobile,
	DeviceV2CategoryNetworking,
	DeviceV2CategoryOt,
	DeviceV2CategoryPc,
	DeviceV2CategoryServer,
}

func (e DeviceV2Category) IsValid() bool {
	switch e {
	case DeviceV2CategoryIot, DeviceV2CategoryMobile, DeviceV2CategoryNetworking, DeviceV2CategoryOt, DeviceV2CategoryPc, DeviceV2CategoryServer:
		return true
	}
	return false
}

func (e DeviceV2Category) String() string {
	return string(e)
}

func (e *DeviceV2Category) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DeviceV2Category(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DeviceV2Category", str)
	}
	return nil
}

func (e DeviceV2Category) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type DhcpType string

const (
	DhcpTypeAccountDefault DhcpType = "ACCOUNT_DEFAULT"
	DhcpTypeDhcpDisabled   DhcpType = "DHCP_DISABLED"
	DhcpTypeDhcpRange      DhcpType = "DHCP_RANGE"
	DhcpTypeDhcpRelay      DhcpType = "DHCP_RELAY"
)

var AllDhcpType = []DhcpType{
	DhcpTypeAccountDefault,
	DhcpTypeDhcpDisabled,
	DhcpTypeDhcpRange,
	DhcpTypeDhcpRelay,
}

func (e DhcpType) IsValid() bool {
	switch e {
	case DhcpTypeAccountDefault, DhcpTypeDhcpDisabled, DhcpTypeDhcpRange, DhcpTypeDhcpRelay:
		return true
	}
	return false
}

func (e DhcpType) String() string {
	return string(e)
}

func (e *DhcpType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DhcpType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DhcpType", str)
	}
	return nil
}

func (e DhcpType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type DirectionEnum string

const (
	DirectionEnumAsc  DirectionEnum = "asc"
	DirectionEnumDesc DirectionEnum = "desc"
)

var AllDirectionEnum = []DirectionEnum{
	DirectionEnumAsc,
	DirectionEnumDesc,
}

func (e DirectionEnum) IsValid() bool {
	switch e {
	case DirectionEnumAsc, DirectionEnumDesc:
		return true
	}
	return false
}

func (e DirectionEnum) String() string {
	return string(e)
}

func (e *DirectionEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DirectionEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DirectionEnum", str)
	}
	return nil
}

func (e DirectionEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type DirectionInput string

const (
	DirectionInputAsc  DirectionInput = "asc"
	DirectionInputDesc DirectionInput = "desc"
)

var AllDirectionInput = []DirectionInput{
	DirectionInputAsc,
	DirectionInputDesc,
}

func (e DirectionInput) IsValid() bool {
	switch e {
	case DirectionInputAsc, DirectionInputDesc:
		return true
	}
	return false
}

func (e DirectionInput) String() string {
	return string(e)
}

func (e *DirectionInput) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DirectionInput(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DirectionInput", str)
	}
	return nil
}

func (e DirectionInput) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The DPA agreement, based on your contract with Cato
type DpaVersion string

const (
	DpaVersionDpa2019_01 DpaVersion = "DPA_2019_01"
	DpaVersionDpa2021_01 DpaVersion = "DPA_2021_01"
	DpaVersionDpa2023_01 DpaVersion = "DPA_2023_01"
)

var AllDpaVersion = []DpaVersion{
	DpaVersionDpa2019_01,
	DpaVersionDpa2021_01,
	DpaVersionDpa2023_01,
}

func (e DpaVersion) IsValid() bool {
	switch e {
	case DpaVersionDpa2019_01, DpaVersionDpa2021_01, DpaVersionDpa2023_01:
		return true
	}
	return false
}

func (e DpaVersion) String() string {
	return string(e)
}

func (e *DpaVersion) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DpaVersion(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DpaVersion", str)
	}
	return nil
}

func (e DpaVersion) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Search operators on ElasticSearch. Between operators are applicable only to numeric fields
// Note that not operators are slower
type ElasticOperator string

const (
	ElasticOperatorBetween    ElasticOperator = "between"
	ElasticOperatorExists     ElasticOperator = "exists"
	ElasticOperatorIn         ElasticOperator = "in"
	ElasticOperatorIs         ElasticOperator = "is"
	ElasticOperatorIsNot      ElasticOperator = "is_not"
	ElasticOperatorNotBetween ElasticOperator = "not_between"
	ElasticOperatorNotExists  ElasticOperator = "not_exists"
	ElasticOperatorNotIn      ElasticOperator = "not_in"
)

var AllElasticOperator = []ElasticOperator{
	ElasticOperatorBetween,
	ElasticOperatorExists,
	ElasticOperatorIn,
	ElasticOperatorIs,
	ElasticOperatorIsNot,
	ElasticOperatorNotBetween,
	ElasticOperatorNotExists,
	ElasticOperatorNotIn,
}

func (e ElasticOperator) IsValid() bool {
	switch e {
	case ElasticOperatorBetween, ElasticOperatorExists, ElasticOperatorIn, ElasticOperatorIs, ElasticOperatorIsNot, ElasticOperatorNotBetween, ElasticOperatorNotExists, ElasticOperatorNotIn:
		return true
	}
	return false
}

func (e ElasticOperator) String() string {
	return string(e)
}

func (e *ElasticOperator) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ElasticOperator(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ElasticOperator", str)
	}
	return nil
}

func (e ElasticOperator) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type EmployeeRange string

const (
	//  1-10 employees
	EmployeeRangeBetween00001_00010 EmployeeRange = "BETWEEN_00001_00010"
	//  11-50 employees
	EmployeeRangeBetween00011_00050 EmployeeRange = "BETWEEN_00011_00050"
	//  51-100 employees
	EmployeeRangeBetween00051_00100 EmployeeRange = "BETWEEN_00051_00100"
	//  101-250 employees
	EmployeeRangeBetween00101_00250 EmployeeRange = "BETWEEN_00101_00250"
	//  251-500 employees
	EmployeeRangeBetween00251_00500 EmployeeRange = "BETWEEN_00251_00500"
	//  501-1,000 employees
	EmployeeRangeBetween00501_01000 EmployeeRange = "BETWEEN_00501_01000"
	//  1,001-5,000 employees
	EmployeeRangeBetween01001_05000 EmployeeRange = "BETWEEN_01001_05000"
	//  5,001-10,000 employees
	EmployeeRangeBetween05001_10000 EmployeeRange = "BETWEEN_05001_10000"
	//  10,000+ employees
	EmployeeRangeBetween10001Max EmployeeRange = "BETWEEN_10001_MAX"
)

var AllEmployeeRange = []EmployeeRange{
	EmployeeRangeBetween00001_00010,
	EmployeeRangeBetween00011_00050,
	EmployeeRangeBetween00051_00100,
	EmployeeRangeBetween00101_00250,
	EmployeeRangeBetween00251_00500,
	EmployeeRangeBetween00501_01000,
	EmployeeRangeBetween01001_05000,
	EmployeeRangeBetween05001_10000,
	EmployeeRangeBetween10001Max,
}

func (e EmployeeRange) IsValid() bool {
	switch e {
	case EmployeeRangeBetween00001_00010, EmployeeRangeBetween00011_00050, EmployeeRangeBetween00051_00100, EmployeeRangeBetween00101_00250, EmployeeRangeBetween00251_00500, EmployeeRangeBetween00501_01000, EmployeeRangeBetween01001_05000, EmployeeRangeBetween05001_10000, EmployeeRangeBetween10001Max:
		return true
	}
	return false
}

func (e EmployeeRange) String() string {
	return string(e)
}

func (e *EmployeeRange) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EmployeeRange(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EmployeeRange", str)
	}
	return nil
}

func (e EmployeeRange) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type EntityType string

const (
	//  A reference to a configured Account under reseller
	EntityTypeAccount EntityType = "account"
	//  An account administrator (user in Cato Console)
	EntityTypeAdmin EntityType = "admin"
	//  An external IP address in a specific PoP reserved for the account
	EntityTypeAllocatedIP EntityType = "allocatedIP"
	//  Any entity (matches everything)
	EntityTypeAny EntityType = "any"
	//  Pooled licenses available for use
	EntityTypeAPIKey EntityType = "apiKey"
	//  added by joe
	EntityTypeAvailablePooledUsage EntityType = "availablePooledUsage"
	//  Site licenses available for use
	EntityTypeAvailableSiteUsage EntityType = "availableSiteUsage"
	//  added by joe
	EntityTypeCasbRule EntityType = "casbRule"
	//  A settlement with over 1K population
	EntityTypeCity EntityType = "city"
	//  Geographical and political entity recognized internationally
	EntityTypeCountry EntityType = "country"
	//  Represents a state or territory within a country. It is a sub-division of the country
	EntityTypeCountryState EntityType = "countryState"
	//  A reference to DHCP Relay Group within account
	EntityTypeDhcpRelayGroup EntityType = "dhcpRelayGroup"
	//  added by joe
	EntityTypeGroup             EntityType = "group"
	EntityTypeGroupSubscription EntityType = "groupSubscription"
	//  A reference to the configured Host within Site
	EntityTypeHost EntityType = "host"
	//  added by joe
	EntityTypeInterfaceSubnet EntityType = "interfaceSubnet"
	//  added by joe
	EntityTypeIP EntityType = "ip"
	//  A reference to LAN Firewall Rule within Site
	EntityTypeLanFirewall EntityType = "lanFirewall"
	//  A reference to Local Routing Rule within Site
	EntityTypeLocalRouting            EntityType = "localRouting"
	EntityTypeLocation                EntityType = "location"
	EntityTypeMailingListSubscription EntityType = "mailingListSubscription"
	//  A reference to the configured Network Interface within Site
	EntityTypeNetworkInterface EntityType = "networkInterface"
	//  added by joe
	EntityTypeNetworkRule EntityType = "networkRule"
	//  Combination of protocol (TCP, UDP, TCP/UDP, ICMP) and port number
	EntityTypePortProtocol EntityType = "portProtocol"
	//  l4 services for LAN firewall rules
	EntityTypeSimpleService EntityType = "simpleService"
	//  A reference to a configured Site within Account
	EntityTypeSite EntityType = "site"
	//  union of the globalRange and a Subnet
	EntityTypeSiteRange EntityType = "siteRange"
	//  added by joe
	EntityTypeSocketInterface EntityType = "socketInterface"
	//  added by joe
	EntityTypeSubnet EntityType = "subnet"
	//  Time zone, which is a geographical region where clocks are set to the same time
	EntityTypeTimezone EntityType = "timezone"
	//  added by joe
	EntityTypeUsersGroup EntityType = "usersGroup"
	//  A reference to the configured VPN User within Account
	EntityTypeVpnUser             EntityType = "vpnUser"
	EntityTypeWebhookSubscription EntityType = "webhookSubscription"
)

var AllEntityType = []EntityType{
	EntityTypeAccount,
	EntityTypeAdmin,
	EntityTypeAllocatedIP,
	EntityTypeAny,
	EntityTypeAPIKey,
	EntityTypeAvailablePooledUsage,
	EntityTypeAvailableSiteUsage,
	EntityTypeCasbRule,
	EntityTypeCity,
	EntityTypeCountry,
	EntityTypeCountryState,
	EntityTypeDhcpRelayGroup,
	EntityTypeGroup,
	EntityTypeGroupSubscription,
	EntityTypeHost,
	EntityTypeInterfaceSubnet,
	EntityTypeIP,
	EntityTypeLanFirewall,
	EntityTypeLocalRouting,
	EntityTypeLocation,
	EntityTypeMailingListSubscription,
	EntityTypeNetworkInterface,
	EntityTypeNetworkRule,
	EntityTypePortProtocol,
	EntityTypeSimpleService,
	EntityTypeSite,
	EntityTypeSiteRange,
	EntityTypeSocketInterface,
	EntityTypeSubnet,
	EntityTypeTimezone,
	EntityTypeUsersGroup,
	EntityTypeVpnUser,
	EntityTypeWebhookSubscription,
}

func (e EntityType) IsValid() bool {
	switch e {
	case EntityTypeAccount, EntityTypeAdmin, EntityTypeAllocatedIP, EntityTypeAny, EntityTypeAPIKey, EntityTypeAvailablePooledUsage, EntityTypeAvailableSiteUsage, EntityTypeCasbRule, EntityTypeCity, EntityTypeCountry, EntityTypeCountryState, EntityTypeDhcpRelayGroup, EntityTypeGroup, EntityTypeGroupSubscription, EntityTypeHost, EntityTypeInterfaceSubnet, EntityTypeIP, EntityTypeLanFirewall, EntityTypeLocalRouting, EntityTypeLocation, EntityTypeMailingListSubscription, EntityTypeNetworkInterface, EntityTypeNetworkRule, EntityTypePortProtocol, EntityTypeSimpleService, EntityTypeSite, EntityTypeSiteRange, EntityTypeSocketInterface, EntityTypeSubnet, EntityTypeTimezone, EntityTypeUsersGroup, EntityTypeVpnUser, EntityTypeWebhookSubscription:
		return true
	}
	return false
}

func (e EntityType) String() string {
	return string(e)
}

func (e *EntityType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EntityType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EntityType", str)
	}
	return nil
}

func (e EntityType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type EventFeedFilterFieldName string

const (
	//  Sub-type for Routing, Security, Connectivity, System or Sockets Management event
	EventFeedFilterFieldNameEventSubType EventFeedFilterFieldName = "event_sub_type"
	//  Routing, Security, Connectivity, System or Sockets Management event
	EventFeedFilterFieldNameEventType EventFeedFilterFieldName = "event_type"
)

var AllEventFeedFilterFieldName = []EventFeedFilterFieldName{
	EventFeedFilterFieldNameEventSubType,
	EventFeedFilterFieldNameEventType,
}

func (e EventFeedFilterFieldName) IsValid() bool {
	switch e {
	case EventFeedFilterFieldNameEventSubType, EventFeedFilterFieldNameEventType:
		return true
	}
	return false
}

func (e EventFeedFilterFieldName) String() string {
	return string(e)
}

func (e *EventFeedFilterFieldName) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EventFeedFilterFieldName(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EventFeedFilterFieldName", str)
	}
	return nil
}

func (e EventFeedFilterFieldName) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Search operators on Event Feed
type EventFeedFilterOperator string

const (
	EventFeedFilterOperatorIn    EventFeedFilterOperator = "in"
	EventFeedFilterOperatorIs    EventFeedFilterOperator = "is"
	EventFeedFilterOperatorIsNot EventFeedFilterOperator = "is_not"
	EventFeedFilterOperatorNotIn EventFeedFilterOperator = "not_in"
)

var AllEventFeedFilterOperator = []EventFeedFilterOperator{
	EventFeedFilterOperatorIn,
	EventFeedFilterOperatorIs,
	EventFeedFilterOperatorIsNot,
	EventFeedFilterOperatorNotIn,
}

func (e EventFeedFilterOperator) IsValid() bool {
	switch e {
	case EventFeedFilterOperatorIn, EventFeedFilterOperatorIs, EventFeedFilterOperatorIsNot, EventFeedFilterOperatorNotIn:
		return true
	}
	return false
}

func (e EventFeedFilterOperator) String() string {
	return string(e)
}

func (e *EventFeedFilterOperator) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EventFeedFilterOperator(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EventFeedFilterOperator", str)
	}
	return nil
}

func (e EventFeedFilterOperator) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type EventFieldName string

const (
	//  The ISP related to this event (when the IP address isn't provided by the ISP, then the event message is IP Addresses are assigned statically)
	EventFieldNameIspName EventFieldName = "ISP_name"
	//  Identifies system access software or device
	EventFieldNameAccessMethod EventFieldName = "access_method"
	//  Account ID
	EventFieldNameAccountID EventFieldName = "account_id"
	//  Firewall, QoS or LAG action
	EventFieldNameAction EventFieldName = "action"
	//  A list of actions taken, if more than one action was taken as defined by a policy
	EventFieldNameActionsTaken EventFieldName = "actions_taken"
	//  The activity resource ID being referenced with resource type.
	EventFieldNameActivityResourceID EventFieldName = "activity_resource_id"
	//  Defines the type of entity performing the action, helping to distinguish between different categories of users.
	EventFieldNameActorType EventFieldName = "actor_type"
	//  Active Directory name
	EventFieldNameAdName EventFieldName = "ad_name"
	//  A unique identifier of the alert notification
	EventFieldNameAlertID EventFieldName = "alert_id"
	//  Always-on Configuration
	EventFieldNameAlwaysOnConfiguration EventFieldName = "always_on_configuration"
	//  Analyst Verdict
	EventFieldNameAnalystVerdict EventFieldName = "analyst_verdict"
	//  The name of the API, e.g. eventsFeed
	EventFieldNameAPIName EventFieldName = "api_name"
	//  Specifies whether the API is a query (read) or a mutation (create/update/delete)
	EventFieldNameAPIType EventFieldName = "api_type"
	//  Name of application activity
	EventFieldNameAppActivity EventFieldName = "app_activity"
	//  SaaS user activities into categories.
	EventFieldNameAppActivityCategory EventFieldName = "app_activity_category"
	//  Activity type
	EventFieldNameAppActivityType EventFieldName = "app_activity_type"
	//  Related Apps
	EventFieldNameAppStack EventFieldName = "app_stack"
	//  Application ID of the flow
	EventFieldNameApplicationID EventFieldName = "application_id"
	//  The name of the application associated with the flow
	EventFieldNameApplicationName EventFieldName = "application_name"
	//  Application risk score
	EventFieldNameApplicationRisk EventFieldName = "application_risk"
	//  Connectivity authentication method: unauthenticated, OATH2, LDAP or VPN
	EventFieldNameAuthMethod EventFieldName = "auth_method"
	//  Examples: MFA or password
	EventFieldNameAuthenticationType EventFieldName = "authentication_type"
	//  BGP ASN for Cato peer
	EventFieldNameBgpCatoAsn EventFieldName = "bgp_cato_asn"
	//  BGP IP for Cato peer
	EventFieldNameBgpCatoIP EventFieldName = "bgp_cato_ip"
	//  BGP disconnect error code
	EventFieldNameBgpErrorCode EventFieldName = "bgp_error_code"
	//  BGP ASN for remote peer
	EventFieldNameBgpPeerAsn EventFieldName = "bgp_peer_asn"
	//  BGP IP for remote peer
	EventFieldNameBgpPeerIP EventFieldName = "bgp_peer_ip"
	//  CIDR for BGP route
	EventFieldNameBgpRouteCidr EventFieldName = "bgp_route_cidr"
	//  BGP disconnect error message
	EventFieldNameBgpSuberrorCode EventFieldName = "bgp_suberror_code"
	//  Always-On Bypass Duration In Seconds
	EventFieldNameBypassDurationSec EventFieldName = "bypass_duration_sec"
	//  Always-On Bypass Method
	EventFieldNameBypassMethod EventFieldName = "bypass_method"
	//  Always-On Bypass Reason
	EventFieldNameBypassReason EventFieldName = "bypass_reason"
	//  Cato system category
	EventFieldNameCategories EventFieldName = "categories"
	//  Cato application name
	EventFieldNameCatoApp EventFieldName = "cato_app"
	//  Activity classification, e.g. FALSE_POSITIVE
	EventFieldNameClassification EventFieldName = "classification"
	//  Expiration date for Client certificate
	EventFieldNameClientCertExpires EventFieldName = "client_cert_expires"
	//  Name of Client certificate
	EventFieldNameClientCertName EventFieldName = "client_cert_name"
	//  Type of process generating this traffic
	EventFieldNameClientClass EventFieldName = "client_class"
	// Admins can configure the Client connection mode to control which types of traffic are routed and protected by Cato. The available options are:
	// All Ports and Protocols  Secures all application traffic across any port or protocol.
	// Web-only (HTTPS)  Secures only browser-based traffic over HTTPS.
	EventFieldNameClientConnectionMode EventFieldName = "client_connection_mode"
	//  Socket or SDP Client version
	EventFieldNameClientVersion EventFieldName = "client_version"
	//  Shows the display name of the target user involved in an activity
	EventFieldNameCollaboratorName EventFieldName = "collaborator_name"
	//  For SaaS Security API, email addresses of the users that received the file
	EventFieldNameCollaborators EventFieldName = "collaborators"
	//  Confidence Level
	EventFieldNameConfidenceLevel EventFieldName = "confidence_level"
	//  For hosts configured with a static IP in the Cato Management Application, the host name
	EventFieldNameConfiguredHostName EventFieldName = "configured_host_name"
	//  The algorithm that is used (CUBIC /NewReno / BBR)
	EventFieldNameCongestionAlgorithm EventFieldName = "congestion_algorithm"
	//  Connect on boot Enabled/Disabled
	EventFieldNameConnectOnBoot EventFieldName = "connect_on_boot"
	//  Connection Origin
	EventFieldNameConnectionOrigin EventFieldName = "connection_origin"
	//  For SaaS Security API, name of the connector
	EventFieldNameConnectorName EventFieldName = "connector_name"
	//  For SaaS Security API, status of the connector
	EventFieldNameConnectorStatus EventFieldName = "connector_status"
	//  For SaaS Security API, SaaS app for the connector
	EventFieldNameConnectorType EventFieldName = "connector_type"
	//  IoC Container Name
	EventFieldNameContainerName EventFieldName = "container_name"
	//  An external system identifier used for correlation between related Cato entities. Example: external ticket id that correlates Cato XDR stories.
	EventFieldNameCorrelationID EventFieldName = "correlation_id"
	//  Criticality
	EventFieldNameCriticality EventFieldName = "criticality"
	//  Custom category ID
	EventFieldNameCustomCategoryID EventFieldName = "custom_category_id"
	//  Custom category name
	EventFieldNameCustomCategoryName EventFieldName = "custom_category_name"
	//  For Internet traffic, country where the destination host is located
	EventFieldNameDestCountry EventFieldName = "dest_country"
	//  For Internet traffic, the two letter country code where the destination host is located (based on ISO 3166-1 alpha-2)
	EventFieldNameDestCountryCode EventFieldName = "dest_country_code"
	//  The unique identifier by the SaaS vendor for the target group in an activity.
	EventFieldNameDestGroupID EventFieldName = "dest_group_id"
	//  Identifies the target group involved in an activity
	EventFieldNameDestGroupName EventFieldName = "dest_group_name"
	//  Destination IP address
	EventFieldNameDestIP EventFieldName = "dest_ip"
	//  For WAN traffic, destination is site or SDP user
	EventFieldNameDestIsSiteOrVpn EventFieldName = "dest_is_site_or_vpn"
	//  The destination process ID
	EventFieldNameDestPid EventFieldName = "dest_pid"
	//  Destination port
	EventFieldNameDestPort EventFieldName = "dest_port"
	//  Destination process command line
	EventFieldNameDestProcessCmdline EventFieldName = "dest_process_cmdline"
	//  Destination process parent file path
	EventFieldNameDestProcessParentPath EventFieldName = "dest_process_parent_path"
	//  Destination process parent process ID
	EventFieldNameDestProcessParentPid EventFieldName = "dest_process_parent_pid"
	//  Destination process file path
	EventFieldNameDestProcessPath EventFieldName = "dest_process_path"
	//  Unique internal Cato ID for the destination site or remote user
	EventFieldNameDestSiteID EventFieldName = "dest_site_id"
	//  The name of the destination site
	EventFieldNameDestSiteName EventFieldName = "dest_site_name"
	//  Short description of the detection
	EventFieldNameDetectionName EventFieldName = "detection_name"
	// Triggered when malware has been detected EPP Behavioral engines and has been dealt with:
	//  on_detection: the event is triggered upon malware detection;
	//  on_end_disinfect: the event is triggered upon detection and followed disinfection;
	//  on_inject: the event is triggered upon code injection.
	EventFieldNameDetectionStage EventFieldName = "detection_stage"
	//  Device Categories
	EventFieldNameDeviceCategories EventFieldName = "device_categories"
	//  Device Certificate Validated/Not Validated
	EventFieldNameDeviceCertificate EventFieldName = "device_certificate"
	//  Unique Cato ID for devices
	EventFieldNameDeviceID EventFieldName = "device_id"
	//  Device Manufacturer
	EventFieldNameDeviceManufacturer EventFieldName = "device_manufacturer"
	//  Device Model
	EventFieldNameDeviceModel EventFieldName = "device_model"
	//  Name for device related to the event
	EventFieldNameDeviceName EventFieldName = "device_name"
	//  Device OS Type
	EventFieldNameDeviceOsType EventFieldName = "device_os_type"
	//  Device posture profiles
	EventFieldNameDevicePostureProfile EventFieldName = "device_posture_profile"
	//  Device Type
	EventFieldNameDeviceType EventFieldName = "device_type"
	//  Host name of Domain Controller that created LDAP event
	EventFieldNameDirectoryHostName EventFieldName = "directory_host_name"
	//  IP address of Domain Controller that created LDAP event
	EventFieldNameDirectoryIP EventFieldName = "directory_ip"
	//  Result of LDAP Domain Controller sync event
	EventFieldNameDirectorySyncResult EventFieldName = "directory_sync_result"
	//  Type of LDAP Domain Controller sync event
	EventFieldNameDirectorySyncType EventFieldName = "directory_sync_type"
	//  If policy is set to disinfect, return the result of this action
	EventFieldNameDisinfectResult EventFieldName = "disinfect_result"
	//  Describes the behavior when the DLP system encounters a failure
	EventFieldNameDlpFailMode EventFieldName = "dlp_fail_mode"
	//  DLP profiles related to the event
	EventFieldNameDlpProfiles EventFieldName = "dlp_profiles"
	//  Defines the scanning methods used by the DLP system
	EventFieldNameDlpScanTypes EventFieldName = "dlp_scan_types"
	//  Catos DNS Protection type that matched the DNS request
	EventFieldNameDNSProtectionCategory EventFieldName = "dns_protection_category"
	//  Domain queried in the DNS request
	EventFieldNameDNSQuery EventFieldName = "dns_query"
	//  Domain name based on the SSL SNI, HTTP host name, or DNS name
	EventFieldNameDomainName EventFieldName = "domain_name"
	//  Egress PoP Name
	EventFieldNameEgressPopName EventFieldName = "egress_pop_name"
	//  Egress Site Name for backhauling traffic
	EventFieldNameEgressSiteName EventFieldName = "egress_site_name"
	//  Email Subject
	EventFieldNameEmailSubject EventFieldName = "email_subject"
	//  The ID for the endpoint
	EventFieldNameEndpointID EventFieldName = "endpoint_id"
	//  The engine type associated with the event
	EventFieldNameEngineType EventFieldName = "engine_type"
	//  The Endpoint Protection Engine that detected the malware
	EventFieldNameEppEngineType EventFieldName = "epp_engine_type"
	//  The profile assigned to the endpoint upon detection of the malware
	EventFieldNameEppProfile EventFieldName = "epp_profile"
	//  Count for events that are repeated multiple times during one minute
	EventFieldNameEventCount EventFieldName = "event_count"
	//  Event Id
	EventFieldNameEventID EventFieldName = "event_id"
	//  Cato's description of the event
	EventFieldNameEventMessage EventFieldName = "event_message"
	//  Sub-type for Routing, Security, Connectivity, System or Sockets Management event
	EventFieldNameEventSubType EventFieldName = "event_sub_type"
	//  Routing, Security, Connectivity, System or Sockets Management event
	EventFieldNameEventType EventFieldName = "event_type"
	//  Provides details about why a specific action or process failed
	EventFieldNameFailureReason EventFieldName = "failure_reason"
	//  File hash
	EventFieldNameFileHash EventFieldName = "file_hash"
	//  File name
	EventFieldNameFileName EventFieldName = "file_name"
	//  The file operation when this event occurred
	EventFieldNameFileOperation EventFieldName = "file_operation"
	//  File size
	EventFieldNameFileSize EventFieldName = "file_size"
	//  File type
	EventFieldNameFileType EventFieldName = "file_type"
	//  The final status for this object after performing actions as defined by the policy
	EventFieldNameFinalObjectStatus EventFieldName = "final_object_status"
	//  Amount of flows for a given incident
	EventFieldNameFlowsCardinality EventFieldName = "flows_cardinality"
	//  Full path URL application activity
	EventFieldNameFullPathURL EventFieldName = "full_path_url"
	//  An identifier for a guest user using Cato through a Captive Portal
	EventFieldNameGuestUser EventFieldName = "guest_user"
	//  IP address of host related to event
	EventFieldNameHostIP EventFieldName = "host_ip"
	//  MAC address of host related to event
	EventFieldNameHostMac EventFieldName = "host_mac"
	//  HTTP request method (ie. Get, Post)
	EventFieldNameHTTPRequestMethod EventFieldName = "http_request_method"
	//  For MDR service, a true/false value that indicates if this event is: A summary that aggregates many events (true) Raw network flows for a single event (false)
	EventFieldNameIncidentAggregation EventFieldName = "incident_aggregation"
	//  Unique Cato ID that identifies this security incident
	EventFieldNameIncidentID EventFieldName = "incident_id"
	//  Indication
	EventFieldNameIndication EventFieldName = "indication"
	//  Indicator
	EventFieldNameIndicator EventFieldName = "indicator"
	//  The initial status of the object, before any policy was applied
	EventFieldNameInitialObjectStatus EventFieldName = "initial_object_status"
	//  Cato Internal-use only
	EventFieldNameInternalID EventFieldName = "internalId"
	//  Network protocol for this event
	EventFieldNameIPProtocol EventFieldName = "ip_protocol"
	//  Classifies users based on their permissions.
	EventFieldNameIsAdmin EventFieldName = "is_admin"
	//  Indicates whether an activity requires administrative permissions.
	EventFieldNameIsAdminActivity EventFieldName = "is_admin_activity"
	//  Is Compliant
	EventFieldNameIsCompliant EventFieldName = "is_compliant"
	//  Is Managed
	EventFieldNameIsManaged EventFieldName = "is_managed"
	//  Is the app for this event defined as a sanctioned app? (True/False)
	EventFieldNameIsSanctionedApp EventFieldName = "is_sanctioned_app"
	//  If the events was part of the sinkhole flow
	EventFieldNameIsSinkhole EventFieldName = "is_sinkhole"
	//  Name defined for the public API Key in the Cato Management Application
	EventFieldNameKeyName EventFieldName = "key_name"
	//  A list of labels providing additional context for the event
	EventFieldNameLabels EventFieldName = "labels"
	//  Data that measures the congestion for a specific link
	EventFieldNameLinkHealthIsCongested EventFieldName = "link_health_is_congested"
	//  Data that measures the jitter for a specific link
	EventFieldNameLinkHealthJitter EventFieldName = "link_health_jitter"
	//  Round Trip Delay in Milliseconds that it takes a packet to travel between the source and the PoP
	EventFieldNameLinkHealthLatency EventFieldName = "link_health_latency"
	//  Data that measures the packet loss for a specific link
	EventFieldNameLinkHealthPktLoss EventFieldName = "link_health_pkt_loss"
	//  Link type  Cato, Alt. WAN or LAG
	EventFieldNameLinkType EventFieldName = "link_type"
	//  The user logged into this endpoint during this event
	EventFieldNameLoggedInUser EventFieldName = "logged_in_user"
	//  Login action, values are: User portal (myvpn.catonetworks.com) or VPN client (Client or site traffic)
	EventFieldNameLoginType EventFieldName = "login_type"
	//  Matched DLP data types related to the event
	EventFieldNameMatchedDataTypes EventFieldName = "matched_data_types"
	//  Mitre attack subtechniques
	EventFieldNameMitreAttackSubtechniques EventFieldName = "mitre_attack_subtechniques"
	//  Mitre attack tactics
	EventFieldNameMitreAttackTactics EventFieldName = "mitre_attack_tactics"
	//  Mitre attack techniques
	EventFieldNameMitreAttackTechniques EventFieldName = "mitre_attack_techniques"
	//  Network Access
	EventFieldNameNetworkAccess EventFieldName = "network_access"
	//  Matched network rule
	EventFieldNameNetworkRule EventFieldName = "network_rule"
	//  For SaaS Security API, API Error of Apps Security Notification
	EventFieldNameNotificationAPIError EventFieldName = "notification_api_error"
	//  For SaaS Security API, description of Apps Security Notification
	EventFieldNameNotificationDescription EventFieldName = "notification_description"
	//  Unique identifier by the 3rd party App of the object being referenced
	EventFieldNameObjectID EventFieldName = "object_id"
	//  The name of the object for this event (for example: file name)
	EventFieldNameObjectName EventFieldName = "object_name"
	//  Specifies the type of object being acted upon (e.g., file, folder)
	EventFieldNameObjectType EventFieldName = "object_type"
	//  Office mode Enabled/Disabled
	EventFieldNameOfficeMode EventFieldName = "office_mode"
	//  Host OS or tunnel device
	EventFieldNameOsType EventFieldName = "os_type"
	//  OS version for the device (such as 14.3.0)
	EventFieldNameOsVersion EventFieldName = "os_version"
	//  Indicate if the Access to the 3rd Party SaaS App occurs without passing through Cato Cloud (direct access to saas App)
	EventFieldNameOutOfBandAccess EventFieldName = "out_of_band_access"
	//  For SaaS Security API, email address of the file owner
	EventFieldNameOwner EventFieldName = "owner"
	//  Pac File Enabled/Disabled
	EventFieldNamePacFile EventFieldName = "pac_file"
	//  For SaaS Security API, parent Microsoft 365 connector
	EventFieldNameParentConnectorName EventFieldName = "parent_connector_name"
	//  Name of PoP location
	EventFieldNamePopName EventFieldName = "pop_name"
	//  Precedence
	EventFieldNamePrecedence EventFieldName = "precedence"
	//  Indicate how many processes are part of this event
	EventFieldNameProcessesCount EventFieldName = "processes_count"
	//  Producer
	EventFieldNameProducer EventFieldName = "producer"
	//  Related project name(s)
	EventFieldNameProjects EventFieldName = "projects"
	//  Prompt Page Selected Action
	EventFieldNamePromptAction EventFieldName = "prompt_action"
	//  The name of the provider, for example cloud provider - AWS
	EventFieldNameProviderName EventFieldName = "provider_name"
	//  Public source IP
	EventFieldNamePublicIP EventFieldName = "public_ip"
	//  QoS Priority value
	EventFieldNameQosPriority EventFieldName = "qos_priority"
	//  For QoS, the time that this QoS event started. The event is generated when the QoS event finishes
	EventFieldNameQosReportedTime EventFieldName = "qos_reported_time"
	//  Specifies the path to a quarantine folder for isolated files
	EventFieldNameQuarantineFolderPath EventFieldName = "quarantine_folder_path"
	//  A Unique ID for the quarantined file
	EventFieldNameQuarantineUUID EventFieldName = "quarantine_uuid"
	//  Raw Data
	EventFieldNameRawData EventFieldName = "raw_data"
	//  Textual recommendation of the steps to take
	EventFieldNameRecommendedActions EventFieldName = "recommended_actions"
	//  The URL that links directly to the object involved in the activity
	EventFieldNameReferenceURL EventFieldName = "reference_url"
	//  Referer URL from the HTTP request header indicating the source of the request.
	EventFieldNameRefererURL EventFieldName = "referer_url"
	//  The region of the object
	EventFieldNameRegionName EventFieldName = "region_name"
	//  Registration code used the first time that a SDP user authenticates (the code is partially obfuscated)
	EventFieldNameRegistrationCode EventFieldName = "registration_code"
	//  The ID of the resource in the cloud provider
	EventFieldNameResourceID EventFieldName = "resource_id"
	//  The specific name or identifier of the resource.
	EventFieldNameResourceName EventFieldName = "resource_name"
	//  The type of resource being referenced.
	EventFieldNameResourceType EventFieldName = "resource_type"
	//  (IPS or SAM event) Indicates the overall impact of a threat for the host or network: Low  ie. adware Medium  ie. network scans High  ie. spyware or worms
	EventFieldNameRiskLevel EventFieldName = "risk_level"
	//  Unique Cato ID for the security rule related to the event
	EventFieldNameRuleID EventFieldName = "rule_id"
	//  Rule name
	EventFieldNameRuleName EventFieldName = "rule_name"
	//  Indicates the internal vendor service or module that produced the data reported in this event
	EventFieldNameServiceName EventFieldName = "service_name"
	//  Severity defined for the rule
	EventFieldNameSeverity EventFieldName = "severity"
	//  Sharing Options for the file (such as SharePoint)
	EventFieldNameSharingScope EventFieldName = "sharing_scope"
	//  Sign In Types
	EventFieldNameSignInEventTypes EventFieldName = "sign_in_event_types"
	//  For IPS and SAM, ID of the IPS signature
	EventFieldNameSignatureID EventFieldName = "signature_id"
	//  Name for Socket interface
	EventFieldNameSocketInterface EventFieldName = "socket_interface"
	//  Socket interface ID
	EventFieldNameSocketInterfaceID EventFieldName = "socket_interface_id"
	//  For Socket upgrades, new version number
	EventFieldNameSocketNewVersion EventFieldName = "socket_new_version"
	//  For Socket upgrade, previous version number
	EventFieldNameSocketOldVersion EventFieldName = "socket_old_version"
	//  Type of Socket reset (Hardware/Software)
	EventFieldNameSocketReset EventFieldName = "socket_reset"
	//  For Socket HA events, indicates if the Socket is primary or secondary
	EventFieldNameSocketRole EventFieldName = "socket_role"
	//  Socket serial number
	EventFieldNameSocketSerial EventFieldName = "socket_serial"
	//  Socket version number
	EventFieldNameSocketVersion EventFieldName = "socket_version"
	//  Split Tunnel Configuration
	EventFieldNameSplitTunnelConfiguration EventFieldName = "split_tunnel_configuration"
	//  Country in which the source host is located (detected via public IP address)
	EventFieldNameSrcCountry EventFieldName = "src_country"
	//  Country Code of country in which the source host is located (detected via public IP address)
	EventFieldNameSrcCountryCode EventFieldName = "src_country_code"
	//  IP for host or Cato Client
	EventFieldNameSrcIP EventFieldName = "src_ip"
	//  Source type: site or remote user
	EventFieldNameSrcIsSiteOrVpn EventFieldName = "src_is_site_or_vpn"
	//  IP address provided by ISP to site or Client
	EventFieldNameSrcIspIP EventFieldName = "src_isp_ip"
	//  Source process ID
	EventFieldNameSrcPid EventFieldName = "src_pid"
	//  Internal port number
	EventFieldNameSrcPort EventFieldName = "src_port"
	//  Source process command line
	EventFieldNameSrcProcessCmdline EventFieldName = "src_process_cmdline"
	//  Source process parent file path
	EventFieldNameSrcProcessParentPath EventFieldName = "src_process_parent_path"
	//  Source process parent process ID
	EventFieldNameSrcProcessParentPid EventFieldName = "src_process_parent_pid"
	//  Source process file path
	EventFieldNameSrcProcessPath EventFieldName = "src_process_path"
	//  Unique internal Cato ID for the site or remote user
	EventFieldNameSrcSiteID EventFieldName = "src_site_id"
	//  Source site or remote user
	EventFieldNameSrcSiteName EventFieldName = "src_site_name"
	//  Static host
	EventFieldNameStaticHost EventFieldName = "static_host"
	// The story status.
	// Possible values: Open, Pending Analysis, Pending more info, Closed, Reopened, Monitoring
	EventFieldNameStatus EventFieldName = "status"
	//  Story Id
	EventFieldNameStoryID EventFieldName = "story_id"
	//  Name of subnet as defined in Cato Management Application
	EventFieldNameSubnetName EventFieldName = "subnet_name"
	//  The name of the subscription
	EventFieldNameSubscriptionName EventFieldName = "subscription_name"
	//  Number of targets (servers) associated with this event
	EventFieldNameTargetsCardinality EventFieldName = "targets_cardinality"
	//  Shows if traffic was TCP accelerated or not
	EventFieldNameTCPAcceleration EventFieldName = "tcp_acceleration"
	//  Unique identifier for the tenant within a multi-tenant environment
	EventFieldNameTenantID EventFieldName = "tenant_id"
	//  Tenant Name
	EventFieldNameTenantName EventFieldName = "tenant_name"
	//  Tenant Restriction Rule Name
	EventFieldNameTenantRestrictionRuleName EventFieldName = "tenant_restriction_rule_name"
	// Contains the detection risk level. Could be one of the following:
	//  Info - this is information-only event, the activity is not malicious;
	//  Suspicious - the event is suspicious. It may be malicious, but there is not enough information
	//  Malware - the event is malicious activity
	EventFieldNameThreatConfidence EventFieldName = "threat_confidence"
	//  For anti-malware events, malware name For IPS events, explains the reason why the traffic was blocked
	EventFieldNameThreatName EventFieldName = "threat_name"
	//  Link to external malware reference
	EventFieldNameThreatReference EventFieldName = "threat_reference"
	//  The higher the score, the more dangerous the event. In range between 1 - 100 inclusive
	EventFieldNameThreatScore EventFieldName = "threat_score"
	//  Type of malware event
	EventFieldNameThreatType EventFieldName = "threat_type"
	//  Result of malware event (clean indicates a safe file)
	EventFieldNameThreatVerdict EventFieldName = "threat_verdict"
	//  Time stamp of the event (Linux epoch format)
	EventFieldNameTime EventFieldName = "time"
	//  Time stamp of the event (Human-readable format)
	EventFieldNameTimeStr EventFieldName = "time_str"
	//  A short summary of the activity
	EventFieldNameTitle EventFieldName = "title"
	//  TLS Certificate Error
	EventFieldNameTLSCertificateError EventFieldName = "tls_certificate_error"
	//  TLS Error Description
	EventFieldNameTLSErrorDescription EventFieldName = "tls_error_description"
	//  TLS Error Type
	EventFieldNameTLSErrorType EventFieldName = "tls_error_type"
	//  Shows if traffic was TLS inspected or not
	EventFieldNameTLSInspection EventFieldName = "tls_inspection"
	//  TLS Inspection rule name
	EventFieldNameTLSRuleName EventFieldName = "tls_rule_name"
	//  TLS Version
	EventFieldNameTLSVersion EventFieldName = "tls_version"
	//  Direction of network traffic for this event, values are inbound or outbound
	EventFieldNameTrafficDirection EventFieldName = "traffic_direction"
	//  Translated Client IP
	EventFieldNameTranslatedClientIP EventFieldName = "translated_client_ip"
	//  Translated Server IP
	EventFieldNameTranslatedServerIP EventFieldName = "translated_server_ip"
	//  Trigger
	EventFieldNameTrigger EventFieldName = "trigger"
	//  Trust Type
	EventFieldNameTrustType EventFieldName = "trust_type"
	//  Trusted networks Enabled/Disabled
	EventFieldNameTrustedNetworks EventFieldName = "trusted_networks"
	//  Tunnel Protocol TCP/UDP
	EventFieldNameTunnelIPProtocol EventFieldName = "tunnel_ip_protocol"
	//  Protocol for the tunnel
	EventFieldNameTunnelProtocol EventFieldName = "tunnel_protocol"
	//  Socket upgrade end time (Linux epoch format):
	EventFieldNameUpgradeEndTime EventFieldName = "upgrade_end_time"
	//  Indicates if the Socket upgrade occurred during the maintenance window or initiated by Support (Cato Admin)
	EventFieldNameUpgradeInitiatedBy EventFieldName = "upgrade_initiated_by"
	//  Socket upgrade start time (Linux epoch format)
	EventFieldNameUpgradeStartTime EventFieldName = "upgrade_start_time"
	//  URL associated with the event
	EventFieldNameURL EventFieldName = "url"
	//  User Agent
	EventFieldNameUserAgent EventFieldName = "user_agent"
	//  Method used to get identity with User Awareness (such as Identity Agent)
	EventFieldNameUserAwarenessMethod EventFieldName = "user_awareness_method"
	//  User ID
	EventFieldNameUserID EventFieldName = "user_id"
	//  User that generated the event
	EventFieldNameUserName EventFieldName = "user_name"
	//  Identifies the origin of the users connection.
	EventFieldNameUserOrigin EventFieldName = "user_origin"
	//  For Block/Prompt page, reference ID to report incorrect category
	EventFieldNameUserReferenceID EventFieldName = "user_reference_id"
	//  User risk level category
	EventFieldNameUserRiskLevel EventFieldName = "user_risk_level"
	//  The vendor that identified the incident, such as Cato or Microsoft
	EventFieldNameVendor EventFieldName = "vendor"
	//  Shows the id of the target user involved in an activity
	EventFieldNameVendorCollaboratorID EventFieldName = "vendor_collaborator_id"
	//  Vendor Device Id
	EventFieldNameVendorDeviceID EventFieldName = "vendor_device_id"
	//  Vendor Device Name
	EventFieldNameVendorDeviceName EventFieldName = "vendor_device_name"
	//  Vendor Event Id
	EventFieldNameVendorEventID EventFieldName = "vendor_event_id"
	//  Third party vendor policy description
	EventFieldNameVendorPolicyDescription EventFieldName = "vendor_policy_description"
	//  Third party vendor policy ID
	EventFieldNameVendorPolicyID EventFieldName = "vendor_policy_id"
	//  Third party vendor policy name
	EventFieldNameVendorPolicyName EventFieldName = "vendor_policy_name"
	//  Identifies the user in the vendors system
	EventFieldNameVendorUserID EventFieldName = "vendor_user_id"
	//  Unique Cato Visible ID for devices
	EventFieldNameVisibleDeviceID EventFieldName = "visible_device_id"
	//  Lan access Allowed / Blocked
	EventFieldNameVpnLanAccess EventFieldName = "vpn_lan_access"
	//  Users email address
	EventFieldNameVpnUserEmail EventFieldName = "vpn_user_email"
	//  For LDAP sync events, name of the AD domain
	EventFieldNameWindowsDomainName EventFieldName = "windows_domain_name"
	//  XFF HTTP header indicates the original IP address for the connections
	EventFieldNameXff EventFieldName = "xff"
)

var AllEventFieldName = []EventFieldName{
	EventFieldNameIspName,
	EventFieldNameAccessMethod,
	EventFieldNameAccountID,
	EventFieldNameAction,
	EventFieldNameActionsTaken,
	EventFieldNameActivityResourceID,
	EventFieldNameActorType,
	EventFieldNameAdName,
	EventFieldNameAlertID,
	EventFieldNameAlwaysOnConfiguration,
	EventFieldNameAnalystVerdict,
	EventFieldNameAPIName,
	EventFieldNameAPIType,
	EventFieldNameAppActivity,
	EventFieldNameAppActivityCategory,
	EventFieldNameAppActivityType,
	EventFieldNameAppStack,
	EventFieldNameApplicationID,
	EventFieldNameApplicationName,
	EventFieldNameApplicationRisk,
	EventFieldNameAuthMethod,
	EventFieldNameAuthenticationType,
	EventFieldNameBgpCatoAsn,
	EventFieldNameBgpCatoIP,
	EventFieldNameBgpErrorCode,
	EventFieldNameBgpPeerAsn,
	EventFieldNameBgpPeerIP,
	EventFieldNameBgpRouteCidr,
	EventFieldNameBgpSuberrorCode,
	EventFieldNameBypassDurationSec,
	EventFieldNameBypassMethod,
	EventFieldNameBypassReason,
	EventFieldNameCategories,
	EventFieldNameCatoApp,
	EventFieldNameClassification,
	EventFieldNameClientCertExpires,
	EventFieldNameClientCertName,
	EventFieldNameClientClass,
	EventFieldNameClientConnectionMode,
	EventFieldNameClientVersion,
	EventFieldNameCollaboratorName,
	EventFieldNameCollaborators,
	EventFieldNameConfidenceLevel,
	EventFieldNameConfiguredHostName,
	EventFieldNameCongestionAlgorithm,
	EventFieldNameConnectOnBoot,
	EventFieldNameConnectionOrigin,
	EventFieldNameConnectorName,
	EventFieldNameConnectorStatus,
	EventFieldNameConnectorType,
	EventFieldNameContainerName,
	EventFieldNameCorrelationID,
	EventFieldNameCriticality,
	EventFieldNameCustomCategoryID,
	EventFieldNameCustomCategoryName,
	EventFieldNameDestCountry,
	EventFieldNameDestCountryCode,
	EventFieldNameDestGroupID,
	EventFieldNameDestGroupName,
	EventFieldNameDestIP,
	EventFieldNameDestIsSiteOrVpn,
	EventFieldNameDestPid,
	EventFieldNameDestPort,
	EventFieldNameDestProcessCmdline,
	EventFieldNameDestProcessParentPath,
	EventFieldNameDestProcessParentPid,
	EventFieldNameDestProcessPath,
	EventFieldNameDestSiteID,
	EventFieldNameDestSiteName,
	EventFieldNameDetectionName,
	EventFieldNameDetectionStage,
	EventFieldNameDeviceCategories,
	EventFieldNameDeviceCertificate,
	EventFieldNameDeviceID,
	EventFieldNameDeviceManufacturer,
	EventFieldNameDeviceModel,
	EventFieldNameDeviceName,
	EventFieldNameDeviceOsType,
	EventFieldNameDevicePostureProfile,
	EventFieldNameDeviceType,
	EventFieldNameDirectoryHostName,
	EventFieldNameDirectoryIP,
	EventFieldNameDirectorySyncResult,
	EventFieldNameDirectorySyncType,
	EventFieldNameDisinfectResult,
	EventFieldNameDlpFailMode,
	EventFieldNameDlpProfiles,
	EventFieldNameDlpScanTypes,
	EventFieldNameDNSProtectionCategory,
	EventFieldNameDNSQuery,
	EventFieldNameDomainName,
	EventFieldNameEgressPopName,
	EventFieldNameEgressSiteName,
	EventFieldNameEmailSubject,
	EventFieldNameEndpointID,
	EventFieldNameEngineType,
	EventFieldNameEppEngineType,
	EventFieldNameEppProfile,
	EventFieldNameEventCount,
	EventFieldNameEventID,
	EventFieldNameEventMessage,
	EventFieldNameEventSubType,
	EventFieldNameEventType,
	EventFieldNameFailureReason,
	EventFieldNameFileHash,
	EventFieldNameFileName,
	EventFieldNameFileOperation,
	EventFieldNameFileSize,
	EventFieldNameFileType,
	EventFieldNameFinalObjectStatus,
	EventFieldNameFlowsCardinality,
	EventFieldNameFullPathURL,
	EventFieldNameGuestUser,
	EventFieldNameHostIP,
	EventFieldNameHostMac,
	EventFieldNameHTTPRequestMethod,
	EventFieldNameIncidentAggregation,
	EventFieldNameIncidentID,
	EventFieldNameIndication,
	EventFieldNameIndicator,
	EventFieldNameInitialObjectStatus,
	EventFieldNameInternalID,
	EventFieldNameIPProtocol,
	EventFieldNameIsAdmin,
	EventFieldNameIsAdminActivity,
	EventFieldNameIsCompliant,
	EventFieldNameIsManaged,
	EventFieldNameIsSanctionedApp,
	EventFieldNameIsSinkhole,
	EventFieldNameKeyName,
	EventFieldNameLabels,
	EventFieldNameLinkHealthIsCongested,
	EventFieldNameLinkHealthJitter,
	EventFieldNameLinkHealthLatency,
	EventFieldNameLinkHealthPktLoss,
	EventFieldNameLinkType,
	EventFieldNameLoggedInUser,
	EventFieldNameLoginType,
	EventFieldNameMatchedDataTypes,
	EventFieldNameMitreAttackSubtechniques,
	EventFieldNameMitreAttackTactics,
	EventFieldNameMitreAttackTechniques,
	EventFieldNameNetworkAccess,
	EventFieldNameNetworkRule,
	EventFieldNameNotificationAPIError,
	EventFieldNameNotificationDescription,
	EventFieldNameObjectID,
	EventFieldNameObjectName,
	EventFieldNameObjectType,
	EventFieldNameOfficeMode,
	EventFieldNameOsType,
	EventFieldNameOsVersion,
	EventFieldNameOutOfBandAccess,
	EventFieldNameOwner,
	EventFieldNamePacFile,
	EventFieldNameParentConnectorName,
	EventFieldNamePopName,
	EventFieldNamePrecedence,
	EventFieldNameProcessesCount,
	EventFieldNameProducer,
	EventFieldNameProjects,
	EventFieldNamePromptAction,
	EventFieldNameProviderName,
	EventFieldNamePublicIP,
	EventFieldNameQosPriority,
	EventFieldNameQosReportedTime,
	EventFieldNameQuarantineFolderPath,
	EventFieldNameQuarantineUUID,
	EventFieldNameRawData,
	EventFieldNameRecommendedActions,
	EventFieldNameReferenceURL,
	EventFieldNameRefererURL,
	EventFieldNameRegionName,
	EventFieldNameRegistrationCode,
	EventFieldNameResourceID,
	EventFieldNameResourceName,
	EventFieldNameResourceType,
	EventFieldNameRiskLevel,
	EventFieldNameRuleID,
	EventFieldNameRuleName,
	EventFieldNameServiceName,
	EventFieldNameSeverity,
	EventFieldNameSharingScope,
	EventFieldNameSignInEventTypes,
	EventFieldNameSignatureID,
	EventFieldNameSocketInterface,
	EventFieldNameSocketInterfaceID,
	EventFieldNameSocketNewVersion,
	EventFieldNameSocketOldVersion,
	EventFieldNameSocketReset,
	EventFieldNameSocketRole,
	EventFieldNameSocketSerial,
	EventFieldNameSocketVersion,
	EventFieldNameSplitTunnelConfiguration,
	EventFieldNameSrcCountry,
	EventFieldNameSrcCountryCode,
	EventFieldNameSrcIP,
	EventFieldNameSrcIsSiteOrVpn,
	EventFieldNameSrcIspIP,
	EventFieldNameSrcPid,
	EventFieldNameSrcPort,
	EventFieldNameSrcProcessCmdline,
	EventFieldNameSrcProcessParentPath,
	EventFieldNameSrcProcessParentPid,
	EventFieldNameSrcProcessPath,
	EventFieldNameSrcSiteID,
	EventFieldNameSrcSiteName,
	EventFieldNameStaticHost,
	EventFieldNameStatus,
	EventFieldNameStoryID,
	EventFieldNameSubnetName,
	EventFieldNameSubscriptionName,
	EventFieldNameTargetsCardinality,
	EventFieldNameTCPAcceleration,
	EventFieldNameTenantID,
	EventFieldNameTenantName,
	EventFieldNameTenantRestrictionRuleName,
	EventFieldNameThreatConfidence,
	EventFieldNameThreatName,
	EventFieldNameThreatReference,
	EventFieldNameThreatScore,
	EventFieldNameThreatType,
	EventFieldNameThreatVerdict,
	EventFieldNameTime,
	EventFieldNameTimeStr,
	EventFieldNameTitle,
	EventFieldNameTLSCertificateError,
	EventFieldNameTLSErrorDescription,
	EventFieldNameTLSErrorType,
	EventFieldNameTLSInspection,
	EventFieldNameTLSRuleName,
	EventFieldNameTLSVersion,
	EventFieldNameTrafficDirection,
	EventFieldNameTranslatedClientIP,
	EventFieldNameTranslatedServerIP,
	EventFieldNameTrigger,
	EventFieldNameTrustType,
	EventFieldNameTrustedNetworks,
	EventFieldNameTunnelIPProtocol,
	EventFieldNameTunnelProtocol,
	EventFieldNameUpgradeEndTime,
	EventFieldNameUpgradeInitiatedBy,
	EventFieldNameUpgradeStartTime,
	EventFieldNameURL,
	EventFieldNameUserAgent,
	EventFieldNameUserAwarenessMethod,
	EventFieldNameUserID,
	EventFieldNameUserName,
	EventFieldNameUserOrigin,
	EventFieldNameUserReferenceID,
	EventFieldNameUserRiskLevel,
	EventFieldNameVendor,
	EventFieldNameVendorCollaboratorID,
	EventFieldNameVendorDeviceID,
	EventFieldNameVendorDeviceName,
	EventFieldNameVendorEventID,
	EventFieldNameVendorPolicyDescription,
	EventFieldNameVendorPolicyID,
	EventFieldNameVendorPolicyName,
	EventFieldNameVendorUserID,
	EventFieldNameVisibleDeviceID,
	EventFieldNameVpnLanAccess,
	EventFieldNameVpnUserEmail,
	EventFieldNameWindowsDomainName,
	EventFieldNameXff,
}

func (e EventFieldName) IsValid() bool {
	switch e {
	case EventFieldNameIspName, EventFieldNameAccessMethod, EventFieldNameAccountID, EventFieldNameAction, EventFieldNameActionsTaken, EventFieldNameActivityResourceID, EventFieldNameActorType, EventFieldNameAdName, EventFieldNameAlertID, EventFieldNameAlwaysOnConfiguration, EventFieldNameAnalystVerdict, EventFieldNameAPIName, EventFieldNameAPIType, EventFieldNameAppActivity, EventFieldNameAppActivityCategory, EventFieldNameAppActivityType, EventFieldNameAppStack, EventFieldNameApplicationID, EventFieldNameApplicationName, EventFieldNameApplicationRisk, EventFieldNameAuthMethod, EventFieldNameAuthenticationType, EventFieldNameBgpCatoAsn, EventFieldNameBgpCatoIP, EventFieldNameBgpErrorCode, EventFieldNameBgpPeerAsn, EventFieldNameBgpPeerIP, EventFieldNameBgpRouteCidr, EventFieldNameBgpSuberrorCode, EventFieldNameBypassDurationSec, EventFieldNameBypassMethod, EventFieldNameBypassReason, EventFieldNameCategories, EventFieldNameCatoApp, EventFieldNameClassification, EventFieldNameClientCertExpires, EventFieldNameClientCertName, EventFieldNameClientClass, EventFieldNameClientConnectionMode, EventFieldNameClientVersion, EventFieldNameCollaboratorName, EventFieldNameCollaborators, EventFieldNameConfidenceLevel, EventFieldNameConfiguredHostName, EventFieldNameCongestionAlgorithm, EventFieldNameConnectOnBoot, EventFieldNameConnectionOrigin, EventFieldNameConnectorName, EventFieldNameConnectorStatus, EventFieldNameConnectorType, EventFieldNameContainerName, EventFieldNameCorrelationID, EventFieldNameCriticality, EventFieldNameCustomCategoryID, EventFieldNameCustomCategoryName, EventFieldNameDestCountry, EventFieldNameDestCountryCode, EventFieldNameDestGroupID, EventFieldNameDestGroupName, EventFieldNameDestIP, EventFieldNameDestIsSiteOrVpn, EventFieldNameDestPid, EventFieldNameDestPort, EventFieldNameDestProcessCmdline, EventFieldNameDestProcessParentPath, EventFieldNameDestProcessParentPid, EventFieldNameDestProcessPath, EventFieldNameDestSiteID, EventFieldNameDestSiteName, EventFieldNameDetectionName, EventFieldNameDetectionStage, EventFieldNameDeviceCategories, EventFieldNameDeviceCertificate, EventFieldNameDeviceID, EventFieldNameDeviceManufacturer, EventFieldNameDeviceModel, EventFieldNameDeviceName, EventFieldNameDeviceOsType, EventFieldNameDevicePostureProfile, EventFieldNameDeviceType, EventFieldNameDirectoryHostName, EventFieldNameDirectoryIP, EventFieldNameDirectorySyncResult, EventFieldNameDirectorySyncType, EventFieldNameDisinfectResult, EventFieldNameDlpFailMode, EventFieldNameDlpProfiles, EventFieldNameDlpScanTypes, EventFieldNameDNSProtectionCategory, EventFieldNameDNSQuery, EventFieldNameDomainName, EventFieldNameEgressPopName, EventFieldNameEgressSiteName, EventFieldNameEmailSubject, EventFieldNameEndpointID, EventFieldNameEngineType, EventFieldNameEppEngineType, EventFieldNameEppProfile, EventFieldNameEventCount, EventFieldNameEventID, EventFieldNameEventMessage, EventFieldNameEventSubType, EventFieldNameEventType, EventFieldNameFailureReason, EventFieldNameFileHash, EventFieldNameFileName, EventFieldNameFileOperation, EventFieldNameFileSize, EventFieldNameFileType, EventFieldNameFinalObjectStatus, EventFieldNameFlowsCardinality, EventFieldNameFullPathURL, EventFieldNameGuestUser, EventFieldNameHostIP, EventFieldNameHostMac, EventFieldNameHTTPRequestMethod, EventFieldNameIncidentAggregation, EventFieldNameIncidentID, EventFieldNameIndication, EventFieldNameIndicator, EventFieldNameInitialObjectStatus, EventFieldNameInternalID, EventFieldNameIPProtocol, EventFieldNameIsAdmin, EventFieldNameIsAdminActivity, EventFieldNameIsCompliant, EventFieldNameIsManaged, EventFieldNameIsSanctionedApp, EventFieldNameIsSinkhole, EventFieldNameKeyName, EventFieldNameLabels, EventFieldNameLinkHealthIsCongested, EventFieldNameLinkHealthJitter, EventFieldNameLinkHealthLatency, EventFieldNameLinkHealthPktLoss, EventFieldNameLinkType, EventFieldNameLoggedInUser, EventFieldNameLoginType, EventFieldNameMatchedDataTypes, EventFieldNameMitreAttackSubtechniques, EventFieldNameMitreAttackTactics, EventFieldNameMitreAttackTechniques, EventFieldNameNetworkAccess, EventFieldNameNetworkRule, EventFieldNameNotificationAPIError, EventFieldNameNotificationDescription, EventFieldNameObjectID, EventFieldNameObjectName, EventFieldNameObjectType, EventFieldNameOfficeMode, EventFieldNameOsType, EventFieldNameOsVersion, EventFieldNameOutOfBandAccess, EventFieldNameOwner, EventFieldNamePacFile, EventFieldNameParentConnectorName, EventFieldNamePopName, EventFieldNamePrecedence, EventFieldNameProcessesCount, EventFieldNameProducer, EventFieldNameProjects, EventFieldNamePromptAction, EventFieldNameProviderName, EventFieldNamePublicIP, EventFieldNameQosPriority, EventFieldNameQosReportedTime, EventFieldNameQuarantineFolderPath, EventFieldNameQuarantineUUID, EventFieldNameRawData, EventFieldNameRecommendedActions, EventFieldNameReferenceURL, EventFieldNameRefererURL, EventFieldNameRegionName, EventFieldNameRegistrationCode, EventFieldNameResourceID, EventFieldNameResourceName, EventFieldNameResourceType, EventFieldNameRiskLevel, EventFieldNameRuleID, EventFieldNameRuleName, EventFieldNameServiceName, EventFieldNameSeverity, EventFieldNameSharingScope, EventFieldNameSignInEventTypes, EventFieldNameSignatureID, EventFieldNameSocketInterface, EventFieldNameSocketInterfaceID, EventFieldNameSocketNewVersion, EventFieldNameSocketOldVersion, EventFieldNameSocketReset, EventFieldNameSocketRole, EventFieldNameSocketSerial, EventFieldNameSocketVersion, EventFieldNameSplitTunnelConfiguration, EventFieldNameSrcCountry, EventFieldNameSrcCountryCode, EventFieldNameSrcIP, EventFieldNameSrcIsSiteOrVpn, EventFieldNameSrcIspIP, EventFieldNameSrcPid, EventFieldNameSrcPort, EventFieldNameSrcProcessCmdline, EventFieldNameSrcProcessParentPath, EventFieldNameSrcProcessParentPid, EventFieldNameSrcProcessPath, EventFieldNameSrcSiteID, EventFieldNameSrcSiteName, EventFieldNameStaticHost, EventFieldNameStatus, EventFieldNameStoryID, EventFieldNameSubnetName, EventFieldNameSubscriptionName, EventFieldNameTargetsCardinality, EventFieldNameTCPAcceleration, EventFieldNameTenantID, EventFieldNameTenantName, EventFieldNameTenantRestrictionRuleName, EventFieldNameThreatConfidence, EventFieldNameThreatName, EventFieldNameThreatReference, EventFieldNameThreatScore, EventFieldNameThreatType, EventFieldNameThreatVerdict, EventFieldNameTime, EventFieldNameTimeStr, EventFieldNameTitle, EventFieldNameTLSCertificateError, EventFieldNameTLSErrorDescription, EventFieldNameTLSErrorType, EventFieldNameTLSInspection, EventFieldNameTLSRuleName, EventFieldNameTLSVersion, EventFieldNameTrafficDirection, EventFieldNameTranslatedClientIP, EventFieldNameTranslatedServerIP, EventFieldNameTrigger, EventFieldNameTrustType, EventFieldNameTrustedNetworks, EventFieldNameTunnelIPProtocol, EventFieldNameTunnelProtocol, EventFieldNameUpgradeEndTime, EventFieldNameUpgradeInitiatedBy, EventFieldNameUpgradeStartTime, EventFieldNameURL, EventFieldNameUserAgent, EventFieldNameUserAwarenessMethod, EventFieldNameUserID, EventFieldNameUserName, EventFieldNameUserOrigin, EventFieldNameUserReferenceID, EventFieldNameUserRiskLevel, EventFieldNameVendor, EventFieldNameVendorCollaboratorID, EventFieldNameVendorDeviceID, EventFieldNameVendorDeviceName, EventFieldNameVendorEventID, EventFieldNameVendorPolicyDescription, EventFieldNameVendorPolicyID, EventFieldNameVendorPolicyName, EventFieldNameVendorUserID, EventFieldNameVisibleDeviceID, EventFieldNameVpnLanAccess, EventFieldNameVpnUserEmail, EventFieldNameWindowsDomainName, EventFieldNameXff:
		return true
	}
	return false
}

func (e EventFieldName) String() string {
	return string(e)
}

func (e *EventFieldName) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EventFieldName(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EventFieldName", str)
	}
	return nil
}

func (e EventFieldName) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Status values for export job lifecycle
type ExportJobStatus string

const (
	//  Export job finished successfully and file is ready for download
	ExportJobStatusCompleted ExportJobStatus = "COMPLETED"
	//  Export job encountered an error and could not complete
	ExportJobStatusFailed ExportJobStatus = "FAILED"
	//  Export job is currently being processed
	ExportJobStatusInProgress ExportJobStatus = "IN_PROGRESS"
	//  Export job has been queued but not yet started
	ExportJobStatusPending ExportJobStatus = "PENDING"
)

var AllExportJobStatus = []ExportJobStatus{
	ExportJobStatusCompleted,
	ExportJobStatusFailed,
	ExportJobStatusInProgress,
	ExportJobStatusPending,
}

func (e ExportJobStatus) IsValid() bool {
	switch e {
	case ExportJobStatusCompleted, ExportJobStatusFailed, ExportJobStatusInProgress, ExportJobStatusPending:
		return true
	}
	return false
}

func (e ExportJobStatus) String() string {
	return string(e)
}

func (e *ExportJobStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ExportJobStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ExportJobStatus", str)
	}
	return nil
}

func (e ExportJobStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type FilterOperator string

const (
	FilterOperatorBetween    FilterOperator = "between"
	FilterOperatorExists     FilterOperator = "exists"
	FilterOperatorGt         FilterOperator = "gt"
	FilterOperatorGte        FilterOperator = "gte"
	FilterOperatorIn         FilterOperator = "in"
	FilterOperatorIs         FilterOperator = "is"
	FilterOperatorIsNot      FilterOperator = "is_not"
	FilterOperatorLt         FilterOperator = "lt"
	FilterOperatorLte        FilterOperator = "lte"
	FilterOperatorNotBetween FilterOperator = "not_between"
	FilterOperatorNotExists  FilterOperator = "not_exists"
	FilterOperatorNotIn      FilterOperator = "not_in"
)

var AllFilterOperator = []FilterOperator{
	FilterOperatorBetween,
	FilterOperatorExists,
	FilterOperatorGt,
	FilterOperatorGte,
	FilterOperatorIn,
	FilterOperatorIs,
	FilterOperatorIsNot,
	FilterOperatorLt,
	FilterOperatorLte,
	FilterOperatorNotBetween,
	FilterOperatorNotExists,
	FilterOperatorNotIn,
}

func (e FilterOperator) IsValid() bool {
	switch e {
	case FilterOperatorBetween, FilterOperatorExists, FilterOperatorGt, FilterOperatorGte, FilterOperatorIn, FilterOperatorIs, FilterOperatorIsNot, FilterOperatorLt, FilterOperatorLte, FilterOperatorNotBetween, FilterOperatorNotExists, FilterOperatorNotIn:
		return true
	}
	return false
}

func (e FilterOperator) String() string {
	return string(e)
}

func (e *FilterOperator) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FilterOperator(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FilterOperator", str)
	}
	return nil
}

func (e FilterOperator) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type GraphType string

const (
	GraphTypeAnalytics GraphType = "ANALYTICS"
)

var AllGraphType = []GraphType{
	GraphTypeAnalytics,
}

func (e GraphType) IsValid() bool {
	switch e {
	case GraphTypeAnalytics:
		return true
	}
	return false
}

func (e GraphType) String() string {
	return string(e)
}

func (e *GraphType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GraphType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GraphType", str)
	}
	return nil
}

func (e GraphType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Member types that can be referenced in a group.
type GroupMemberRefType string

const (
	GroupMemberRefTypeFloatingSubnet    GroupMemberRefType = "FLOATING_SUBNET"
	GroupMemberRefTypeGlobalIPRange     GroupMemberRefType = "GLOBAL_IP_RANGE"
	GroupMemberRefTypeHost              GroupMemberRefType = "HOST"
	GroupMemberRefTypeNetworkInterface  GroupMemberRefType = "NETWORK_INTERFACE"
	GroupMemberRefTypeSite              GroupMemberRefType = "SITE"
	GroupMemberRefTypeSiteNetworkSubnet GroupMemberRefType = "SITE_NETWORK_SUBNET"
)

var AllGroupMemberRefType = []GroupMemberRefType{
	GroupMemberRefTypeFloatingSubnet,
	GroupMemberRefTypeGlobalIPRange,
	GroupMemberRefTypeHost,
	GroupMemberRefTypeNetworkInterface,
	GroupMemberRefTypeSite,
	GroupMemberRefTypeSiteNetworkSubnet,
}

func (e GroupMemberRefType) IsValid() bool {
	switch e {
	case GroupMemberRefTypeFloatingSubnet, GroupMemberRefTypeGlobalIPRange, GroupMemberRefTypeHost, GroupMemberRefTypeNetworkInterface, GroupMemberRefTypeSite, GroupMemberRefTypeSiteNetworkSubnet:
		return true
	}
	return false
}

func (e GroupMemberRefType) String() string {
	return string(e)
}

func (e *GroupMemberRefType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GroupMemberRefType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GroupMemberRefType", str)
	}
	return nil
}

func (e GroupMemberRefType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type HaReadiness string

const (
	HaReadinessNotReady HaReadiness = "not_ready"
	HaReadinessReady    HaReadiness = "ready"
)

var AllHaReadiness = []HaReadiness{
	HaReadinessNotReady,
	HaReadinessReady,
}

func (e HaReadiness) IsValid() bool {
	switch e {
	case HaReadinessNotReady, HaReadinessReady:
		return true
	}
	return false
}

func (e HaReadiness) String() string {
	return string(e)
}

func (e *HaReadiness) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HaReadiness(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HaReadiness", str)
	}
	return nil
}

func (e HaReadiness) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type HaRole string

const (
	HaRolePrimary   HaRole = "PRIMARY"
	HaRoleSecondary HaRole = "SECONDARY"
)

var AllHaRole = []HaRole{
	HaRolePrimary,
	HaRoleSecondary,
}

func (e HaRole) IsValid() bool {
	switch e {
	case HaRolePrimary, HaRoleSecondary:
		return true
	}
	return false
}

func (e HaRole) String() string {
	return string(e)
}

func (e *HaRole) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HaRole(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HaRole", str)
	}
	return nil
}

func (e HaRole) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type HaSubStatus string

const (
	HaSubStatusFail HaSubStatus = "fail"
	HaSubStatusOk   HaSubStatus = "ok"
)

var AllHaSubStatus = []HaSubStatus{
	HaSubStatusFail,
	HaSubStatusOk,
}

func (e HaSubStatus) IsValid() bool {
	switch e {
	case HaSubStatusFail, HaSubStatusOk:
		return true
	}
	return false
}

func (e HaSubStatus) String() string {
	return string(e)
}

func (e *HaSubStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HaSubStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HaSubStatus", str)
	}
	return nil
}

func (e HaSubStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type IPSecV2InterfaceID string

const (
	IPSecV2InterfaceIDPrimary1   IPSecV2InterfaceID = "PRIMARY1"
	IPSecV2InterfaceIDPrimary2   IPSecV2InterfaceID = "PRIMARY2"
	IPSecV2InterfaceIDPrimary3   IPSecV2InterfaceID = "PRIMARY3"
	IPSecV2InterfaceIDSecondary1 IPSecV2InterfaceID = "SECONDARY1"
	IPSecV2InterfaceIDSecondary2 IPSecV2InterfaceID = "SECONDARY2"
	IPSecV2InterfaceIDSecondary3 IPSecV2InterfaceID = "SECONDARY3"
)

var AllIPSecV2InterfaceID = []IPSecV2InterfaceID{
	IPSecV2InterfaceIDPrimary1,
	IPSecV2InterfaceIDPrimary2,
	IPSecV2InterfaceIDPrimary3,
	IPSecV2InterfaceIDSecondary1,
	IPSecV2InterfaceIDSecondary2,
	IPSecV2InterfaceIDSecondary3,
}

func (e IPSecV2InterfaceID) IsValid() bool {
	switch e {
	case IPSecV2InterfaceIDPrimary1, IPSecV2InterfaceIDPrimary2, IPSecV2InterfaceIDPrimary3, IPSecV2InterfaceIDSecondary1, IPSecV2InterfaceIDSecondary2, IPSecV2InterfaceIDSecondary3:
		return true
	}
	return false
}

func (e IPSecV2InterfaceID) String() string {
	return string(e)
}

func (e *IPSecV2InterfaceID) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = IPSecV2InterfaceID(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid IPSecV2InterfaceId", str)
	}
	return nil
}

func (e IPSecV2InterfaceID) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type IPSecV2TunnelRole string

const (
	IPSecV2TunnelRoleWan1 IPSecV2TunnelRole = "WAN1"
	IPSecV2TunnelRoleWan2 IPSecV2TunnelRole = "WAN2"
	IPSecV2TunnelRoleWan3 IPSecV2TunnelRole = "WAN3"
)

var AllIPSecV2TunnelRole = []IPSecV2TunnelRole{
	IPSecV2TunnelRoleWan1,
	IPSecV2TunnelRoleWan2,
	IPSecV2TunnelRoleWan3,
}

func (e IPSecV2TunnelRole) IsValid() bool {
	switch e {
	case IPSecV2TunnelRoleWan1, IPSecV2TunnelRoleWan2, IPSecV2TunnelRoleWan3:
		return true
	}
	return false
}

func (e IPSecV2TunnelRole) String() string {
	return string(e)
}

func (e *IPSecV2TunnelRole) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = IPSecV2TunnelRole(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid IPSecV2TunnelRole", str)
	}
	return nil
}

func (e IPSecV2TunnelRole) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type IdentificationType string

const (
	IdentificationTypeEmail IdentificationType = "EMAIL"
	IdentificationTypeFqdn  IdentificationType = "FQDN"
	IdentificationTypeIPV4  IdentificationType = "IPV4"
	IdentificationTypeKeyID IdentificationType = "KEY_ID"
)

var AllIdentificationType = []IdentificationType{
	IdentificationTypeEmail,
	IdentificationTypeFqdn,
	IdentificationTypeIPV4,
	IdentificationTypeKeyID,
}

func (e IdentificationType) IsValid() bool {
	switch e {
	case IdentificationTypeEmail, IdentificationTypeFqdn, IdentificationTypeIPV4, IdentificationTypeKeyID:
		return true
	}
	return false
}

func (e IdentificationType) String() string {
	return string(e)
}

func (e *IdentificationType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = IdentificationType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid IdentificationType", str)
	}
	return nil
}

func (e IdentificationType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type IlmmOnboardingStatus string

const (
	IlmmOnboardingStatusComplete IlmmOnboardingStatus = "COMPLETE"
	IlmmOnboardingStatusFailed   IlmmOnboardingStatus = "FAILED"
	IlmmOnboardingStatusMissing  IlmmOnboardingStatus = "MISSING"
	IlmmOnboardingStatusPending  IlmmOnboardingStatus = "PENDING"
)

var AllIlmmOnboardingStatus = []IlmmOnboardingStatus{
	IlmmOnboardingStatusComplete,
	IlmmOnboardingStatusFailed,
	IlmmOnboardingStatusMissing,
	IlmmOnboardingStatusPending,
}

func (e IlmmOnboardingStatus) IsValid() bool {
	switch e {
	case IlmmOnboardingStatusComplete, IlmmOnboardingStatusFailed, IlmmOnboardingStatusMissing, IlmmOnboardingStatusPending:
		return true
	}
	return false
}

func (e IlmmOnboardingStatus) String() string {
	return string(e)
}

func (e *IlmmOnboardingStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = IlmmOnboardingStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid IlmmOnboardingStatus", str)
	}
	return nil
}

func (e IlmmOnboardingStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The action applied by the Internet Firewall if the rule is matched
type InternetFirewallActionEnum string

const (
	//  Allow the network traffic to pass through the firewall.
	InternetFirewallActionEnumAllow InternetFirewallActionEnum = "ALLOW"
	//  Deny the network traffic from passing through the firewall.
	InternetFirewallActionEnumBlock InternetFirewallActionEnum = "BLOCK"
	//  Requests user confirmation to allow or block network traffic.
	InternetFirewallActionEnumPrompt InternetFirewallActionEnum = "PROMPT"
	//  Apply Remote Browser Isolation (RBI) to the network traffic
	InternetFirewallActionEnumRbi InternetFirewallActionEnum = "RBI"
)

var AllInternetFirewallActionEnum = []InternetFirewallActionEnum{
	InternetFirewallActionEnumAllow,
	InternetFirewallActionEnumBlock,
	InternetFirewallActionEnumPrompt,
	InternetFirewallActionEnumRbi,
}

func (e InternetFirewallActionEnum) IsValid() bool {
	switch e {
	case InternetFirewallActionEnumAllow, InternetFirewallActionEnumBlock, InternetFirewallActionEnumPrompt, InternetFirewallActionEnumRbi:
		return true
	}
	return false
}

func (e InternetFirewallActionEnum) String() string {
	return string(e)
}

func (e *InternetFirewallActionEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = InternetFirewallActionEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid InternetFirewallActionEnum", str)
	}
	return nil
}

func (e InternetFirewallActionEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type IPProtocol string

const (
	IPProtocolAny  IPProtocol = "ANY"
	IPProtocolICMP IPProtocol = "ICMP"
	IPProtocolTCP  IPProtocol = "TCP"
	//  TCP or UDP
	IPProtocolTCPUDP IPProtocol = "TCP_UDP"
	IPProtocolUDP    IPProtocol = "UDP"
)

var AllIPProtocol = []IPProtocol{
	IPProtocolAny,
	IPProtocolICMP,
	IPProtocolTCP,
	IPProtocolTCPUDP,
	IPProtocolUDP,
}

func (e IPProtocol) IsValid() bool {
	switch e {
	case IPProtocolAny, IPProtocolICMP, IPProtocolTCP, IPProtocolTCPUDP, IPProtocolUDP:
		return true
	}
	return false
}

func (e IPProtocol) String() string {
	return string(e)
}

func (e *IPProtocol) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = IPProtocol(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid IpProtocol", str)
	}
	return nil
}

func (e IPProtocol) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type IPSecCipher string

const (
	IPSecCipherAesCbc128 IPSecCipher = "AES_CBC_128"
	IPSecCipherAesCbc256 IPSecCipher = "AES_CBC_256"
	IPSecCipherAesGcm128 IPSecCipher = "AES_GCM_128"
	IPSecCipherAesGcm256 IPSecCipher = "AES_GCM_256"
	IPSecCipherAutomatic IPSecCipher = "AUTOMATIC"
	IPSecCipherDes3Cbc   IPSecCipher = "DES3_CBC"
	IPSecCipherNone      IPSecCipher = "NONE"
)

var AllIPSecCipher = []IPSecCipher{
	IPSecCipherAesCbc128,
	IPSecCipherAesCbc256,
	IPSecCipherAesGcm128,
	IPSecCipherAesGcm256,
	IPSecCipherAutomatic,
	IPSecCipherDes3Cbc,
	IPSecCipherNone,
}

func (e IPSecCipher) IsValid() bool {
	switch e {
	case IPSecCipherAesCbc128, IPSecCipherAesCbc256, IPSecCipherAesGcm128, IPSecCipherAesGcm256, IPSecCipherAutomatic, IPSecCipherDes3Cbc, IPSecCipherNone:
		return true
	}
	return false
}

func (e IPSecCipher) String() string {
	return string(e)
}

func (e *IPSecCipher) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = IPSecCipher(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid IpSecCipher", str)
	}
	return nil
}

func (e IPSecCipher) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type IPSecDHGroup string

const (
	IPSecDHGroupAutomatic    IPSecDHGroup = "AUTOMATIC"
	IPSecDHGroupDh14Modp2048 IPSecDHGroup = "DH_14_MODP2048"
	IPSecDHGroupDh15Modp3072 IPSecDHGroup = "DH_15_MODP3072"
	IPSecDHGroupDh16Modp4096 IPSecDHGroup = "DH_16_MODP4096"
	IPSecDHGroupDh19Ecp256   IPSecDHGroup = "DH_19_ECP256"
	IPSecDHGroupDh20Ecp384   IPSecDHGroup = "DH_20_ECP384"
	IPSecDHGroupDh21Ecp521   IPSecDHGroup = "DH_21_ECP521"
	IPSecDHGroupDh2Modp1024  IPSecDHGroup = "DH_2_MODP1024"
	IPSecDHGroupDh5Modp1536  IPSecDHGroup = "DH_5_MODP1536"
	IPSecDHGroupNone         IPSecDHGroup = "NONE"
)

var AllIPSecDHGroup = []IPSecDHGroup{
	IPSecDHGroupAutomatic,
	IPSecDHGroupDh14Modp2048,
	IPSecDHGroupDh15Modp3072,
	IPSecDHGroupDh16Modp4096,
	IPSecDHGroupDh19Ecp256,
	IPSecDHGroupDh20Ecp384,
	IPSecDHGroupDh21Ecp521,
	IPSecDHGroupDh2Modp1024,
	IPSecDHGroupDh5Modp1536,
	IPSecDHGroupNone,
}

func (e IPSecDHGroup) IsValid() bool {
	switch e {
	case IPSecDHGroupAutomatic, IPSecDHGroupDh14Modp2048, IPSecDHGroupDh15Modp3072, IPSecDHGroupDh16Modp4096, IPSecDHGroupDh19Ecp256, IPSecDHGroupDh20Ecp384, IPSecDHGroupDh21Ecp521, IPSecDHGroupDh2Modp1024, IPSecDHGroupDh5Modp1536, IPSecDHGroupNone:
		return true
	}
	return false
}

func (e IPSecDHGroup) String() string {
	return string(e)
}

func (e *IPSecDHGroup) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = IPSecDHGroup(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid IpSecDHGroup", str)
	}
	return nil
}

func (e IPSecDHGroup) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type IPSecHash string

const (
	IPSecHashAutomatic IPSecHash = "AUTOMATIC"
	IPSecHashMd5       IPSecHash = "MD5"
	IPSecHashNone      IPSecHash = "NONE"
	IPSecHashSha1      IPSecHash = "SHA1"
	IPSecHashSha256    IPSecHash = "SHA256"
	IPSecHashSha384    IPSecHash = "SHA384"
	IPSecHashSha512    IPSecHash = "SHA512"
)

var AllIPSecHash = []IPSecHash{
	IPSecHashAutomatic,
	IPSecHashMd5,
	IPSecHashNone,
	IPSecHashSha1,
	IPSecHashSha256,
	IPSecHashSha384,
	IPSecHashSha512,
}

func (e IPSecHash) IsValid() bool {
	switch e {
	case IPSecHashAutomatic, IPSecHashMd5, IPSecHashNone, IPSecHashSha1, IPSecHashSha256, IPSecHashSha384, IPSecHashSha512:
		return true
	}
	return false
}

func (e IPSecHash) String() string {
	return string(e)
}

func (e *IPSecHash) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = IPSecHash(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid IpSecHash", str)
	}
	return nil
}

func (e IPSecHash) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// enum for license plan type (site license, service license, etc...)
type LicensePlan string

const (
	LicensePlanCommercial LicensePlan = "COMMERCIAL"
	LicensePlanTrial      LicensePlan = "TRIAL"
)

var AllLicensePlan = []LicensePlan{
	LicensePlanCommercial,
	LicensePlanTrial,
}

func (e LicensePlan) IsValid() bool {
	switch e {
	case LicensePlanCommercial, LicensePlanTrial:
		return true
	}
	return false
}

func (e LicensePlan) String() string {
	return string(e)
}

func (e *LicensePlan) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LicensePlan(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid LicensePlan", str)
	}
	return nil
}

func (e LicensePlan) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type LicenseSku string

const (
	//  Cato Anti Malware (legacy) service SKU
	LicenseSkuCatoAntiMalware LicenseSku = "CATO_ANTI_MALWARE"
	//  Cato Anti Malware Next Generation (legacy) service SKU
	LicenseSkuCatoAntiMalwareNg LicenseSku = "CATO_ANTI_MALWARE_NG"
	//  Cato CASB service SKU
	LicenseSkuCatoCasb LicenseSku = "CATO_CASB"
	//  Cato datalake Group SKU
	LicenseSkuCatoDatalake LicenseSku = "CATO_DATALAKE"
	//  12 months data retention SKU
	LicenseSkuCatoDatalake12m LicenseSku = "CATO_DATALAKE_12M"
	//  3 months data retention SKU
	LicenseSkuCatoDatalake3m LicenseSku = "CATO_DATALAKE_3M"
	//  6 months data retention SKU
	LicenseSkuCatoDatalake6m LicenseSku = "CATO_DATALAKE_6M"
	//  Cato DEM service SKU
	LicenseSkuCatoDem LicenseSku = "CATO_DEM"
	//  Cato DLP service SKU
	LicenseSkuCatoDlp LicenseSku = "CATO_DLP"
	//  Cato EPP service SKU
	LicenseSkuCatoEpp LicenseSku = "CATO_EPP"
	//  Cato ILMM service SKU
	LicenseSkuCatoIlmm LicenseSku = "CATO_ILMM"
	//  Cato IoT/OT Security service SKU
	LicenseSkuCatoIotOt LicenseSku = "CATO_IOT_OT"
	//  Cato IPS (legacy) service SKU
	LicenseSkuCatoIPS LicenseSku = "CATO_IPS"
	//  Public IPs SKU
	LicenseSkuCatoIPAdd LicenseSku = "CATO_IP_ADD"
	//  Cato Managed XDR service SKU
	LicenseSkuCatoManagedXdr LicenseSku = "CATO_MANAGED_XDR"
	//  Cato MDR service SKU
	LicenseSkuCatoMdr LicenseSku = "CATO_MDR"
	//  Cato NOCaaS service SKU
	LicenseSkuCatoNocaasHf LicenseSku = "CATO_NOCAAS_HF"
	//  Site pooled bandwidth SASE SKU
	LicenseSkuCatoPb LicenseSku = "CATO_PB"
	//  Site pooled bandwidth SSE SKU
	LicenseSkuCatoPbSse LicenseSku = "CATO_PB_SSE"
	//  Cato Remote Browser Isolation (RBI) service SKU
	LicenseSkuCatoRbi LicenseSku = "CATO_RBI"
	//  Cato SAAS Group SKU
	LicenseSkuCatoSaas            LicenseSku = "CATO_SAAS"
	LicenseSkuCatoSaasSecurityAPI LicenseSku = "CATO_SAAS_SECURITY_API"
	//  Cato SAAS Security API with more than two Applications integration (legacy) service SKU
	LicenseSkuCatoSaasSecurityAPIAllApps LicenseSku = "CATO_SAAS_SECURITY_API_ALL_APPS"
	//  Cato SAAS Security API with one application integration (legacy) service SKU
	LicenseSkuCatoSaasSecurityAPIOneApp LicenseSku = "CATO_SAAS_SECURITY_API_ONE_APP"
	//  Cato SAAS Security API with two applications integration (legacy) service SKU
	LicenseSkuCatoSaasSecurityAPITwoApps LicenseSku = "CATO_SAAS_SECURITY_API_TWO_APPS"
	//  Site bandwidth SASE SKU
	LicenseSkuCatoSite LicenseSku = "CATO_SITE"
	//  Site bandwidth SSE SKU
	LicenseSkuCatoSseSite LicenseSku = "CATO_SSE_SITE"
	//  Cato Threat Prevention (legacy) service SKU
	LicenseSkuCatoThreatPrevention LicenseSku = "CATO_THREAT_PREVENTION"
	//  Cato Advanced Threat Prevention service SKU
	LicenseSkuCatoThreatPreventionAdv LicenseSku = "CATO_THREAT_PREVENTION_ADV"
	//  Cato XDR service SKU
	LicenseSkuCatoXdrPro LicenseSku = "CATO_XDR_PRO"
	//  Cato XOps service SKU
	LicenseSkuCatoXops LicenseSku = "CATO_XOPS"
	//  ZTNA remote users SKU
	LicenseSkuCatoZtnaUsers LicenseSku = "CATO_ZTNA_USERS"
	//  ZTNA remote users SKU
	LicenseSkuMobileUsers LicenseSku = "MOBILE_USERS"
)

var AllLicenseSku = []LicenseSku{
	LicenseSkuCatoAntiMalware,
	LicenseSkuCatoAntiMalwareNg,
	LicenseSkuCatoCasb,
	LicenseSkuCatoDatalake,
	LicenseSkuCatoDatalake12m,
	LicenseSkuCatoDatalake3m,
	LicenseSkuCatoDatalake6m,
	LicenseSkuCatoDem,
	LicenseSkuCatoDlp,
	LicenseSkuCatoEpp,
	LicenseSkuCatoIlmm,
	LicenseSkuCatoIotOt,
	LicenseSkuCatoIPS,
	LicenseSkuCatoIPAdd,
	LicenseSkuCatoManagedXdr,
	LicenseSkuCatoMdr,
	LicenseSkuCatoNocaasHf,
	LicenseSkuCatoPb,
	LicenseSkuCatoPbSse,
	LicenseSkuCatoRbi,
	LicenseSkuCatoSaas,
	LicenseSkuCatoSaasSecurityAPI,
	LicenseSkuCatoSaasSecurityAPIAllApps,
	LicenseSkuCatoSaasSecurityAPIOneApp,
	LicenseSkuCatoSaasSecurityAPITwoApps,
	LicenseSkuCatoSite,
	LicenseSkuCatoSseSite,
	LicenseSkuCatoThreatPrevention,
	LicenseSkuCatoThreatPreventionAdv,
	LicenseSkuCatoXdrPro,
	LicenseSkuCatoXops,
	LicenseSkuCatoZtnaUsers,
	LicenseSkuMobileUsers,
}

func (e LicenseSku) IsValid() bool {
	switch e {
	case LicenseSkuCatoAntiMalware, LicenseSkuCatoAntiMalwareNg, LicenseSkuCatoCasb, LicenseSkuCatoDatalake, LicenseSkuCatoDatalake12m, LicenseSkuCatoDatalake3m, LicenseSkuCatoDatalake6m, LicenseSkuCatoDem, LicenseSkuCatoDlp, LicenseSkuCatoEpp, LicenseSkuCatoIlmm, LicenseSkuCatoIotOt, LicenseSkuCatoIPS, LicenseSkuCatoIPAdd, LicenseSkuCatoManagedXdr, LicenseSkuCatoMdr, LicenseSkuCatoNocaasHf, LicenseSkuCatoPb, LicenseSkuCatoPbSse, LicenseSkuCatoRbi, LicenseSkuCatoSaas, LicenseSkuCatoSaasSecurityAPI, LicenseSkuCatoSaasSecurityAPIAllApps, LicenseSkuCatoSaasSecurityAPIOneApp, LicenseSkuCatoSaasSecurityAPITwoApps, LicenseSkuCatoSite, LicenseSkuCatoSseSite, LicenseSkuCatoThreatPrevention, LicenseSkuCatoThreatPreventionAdv, LicenseSkuCatoXdrPro, LicenseSkuCatoXops, LicenseSkuCatoZtnaUsers, LicenseSkuMobileUsers:
		return true
	}
	return false
}

func (e LicenseSku) String() string {
	return string(e)
}

func (e *LicenseSku) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LicenseSku(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid LicenseSku", str)
	}
	return nil
}

func (e LicenseSku) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// enum for account plan status  the current license status within the license lifecycle
type LicenseStatus string

const (
	//  A license that is currently active
	LicenseStatusActive LicenseStatus = "ACTIVE"
	//  An expired license is no longer active
	LicenseStatusDisabled LicenseStatus = "DISABLED"
	//  A license in a grace period
	LicenseStatusLocked LicenseStatus = "LOCKED"
	//  The license is pending customer activation by setting a start date
	LicenseStatusPending LicenseStatus = "PENDING"
	//  An existing license with a future start date that is not currently active
	LicenseStatusScheduled LicenseStatus = "SCHEDULED"
	//  A license that is active before its start date, for partners and customers to verify the relevant configurations
	LicenseStatusStaging LicenseStatus = "STAGING"
)

var AllLicenseStatus = []LicenseStatus{
	LicenseStatusActive,
	LicenseStatusDisabled,
	LicenseStatusLocked,
	LicenseStatusPending,
	LicenseStatusScheduled,
	LicenseStatusStaging,
}

func (e LicenseStatus) IsValid() bool {
	switch e {
	case LicenseStatusActive, LicenseStatusDisabled, LicenseStatusLocked, LicenseStatusPending, LicenseStatusScheduled, LicenseStatusStaging:
		return true
	}
	return false
}

func (e LicenseStatus) String() string {
	return string(e)
}

func (e *LicenseStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LicenseStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid LicenseStatus", str)
	}
	return nil
}

func (e LicenseStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type LinkConfigPrecedenceEnum string

const (
	LinkConfigPrecedenceEnumActive     LinkConfigPrecedenceEnum = "ACTIVE"
	LinkConfigPrecedenceEnumLastResort LinkConfigPrecedenceEnum = "LAST_RESORT"
	LinkConfigPrecedenceEnumPassive    LinkConfigPrecedenceEnum = "PASSIVE"
)

var AllLinkConfigPrecedenceEnum = []LinkConfigPrecedenceEnum{
	LinkConfigPrecedenceEnumActive,
	LinkConfigPrecedenceEnumLastResort,
	LinkConfigPrecedenceEnumPassive,
}

func (e LinkConfigPrecedenceEnum) IsValid() bool {
	switch e {
	case LinkConfigPrecedenceEnumActive, LinkConfigPrecedenceEnumLastResort, LinkConfigPrecedenceEnumPassive:
		return true
	}
	return false
}

func (e LinkConfigPrecedenceEnum) String() string {
	return string(e)
}

func (e *LinkConfigPrecedenceEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LinkConfigPrecedenceEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid LinkConfigPrecedenceEnum", str)
	}
	return nil
}

func (e LinkConfigPrecedenceEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type LinkQualityIssueTypeEnum string

const (
	LinkQualityIssueTypeEnumCongestion LinkQualityIssueTypeEnum = "CONGESTION"
	LinkQualityIssueTypeEnumDistance   LinkQualityIssueTypeEnum = "DISTANCE"
	LinkQualityIssueTypeEnumJitter     LinkQualityIssueTypeEnum = "JITTER"
	LinkQualityIssueTypeEnumPacketLoss LinkQualityIssueTypeEnum = "PACKET_LOSS"
)

var AllLinkQualityIssueTypeEnum = []LinkQualityIssueTypeEnum{
	LinkQualityIssueTypeEnumCongestion,
	LinkQualityIssueTypeEnumDistance,
	LinkQualityIssueTypeEnumJitter,
	LinkQualityIssueTypeEnumPacketLoss,
}

func (e LinkQualityIssueTypeEnum) IsValid() bool {
	switch e {
	case LinkQualityIssueTypeEnumCongestion, LinkQualityIssueTypeEnumDistance, LinkQualityIssueTypeEnumJitter, LinkQualityIssueTypeEnumPacketLoss:
		return true
	}
	return false
}

func (e LinkQualityIssueTypeEnum) String() string {
	return string(e)
}

func (e *LinkQualityIssueTypeEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LinkQualityIssueTypeEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid LinkQualityIssueTypeEnum", str)
	}
	return nil
}

func (e LinkQualityIssueTypeEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type LinkStatusEnum string

const (
	LinkStatusEnumActive  LinkStatusEnum = "ACTIVE"
	LinkStatusEnumPassive LinkStatusEnum = "PASSIVE"
)

var AllLinkStatusEnum = []LinkStatusEnum{
	LinkStatusEnumActive,
	LinkStatusEnumPassive,
}

func (e LinkStatusEnum) IsValid() bool {
	switch e {
	case LinkStatusEnumActive, LinkStatusEnumPassive:
		return true
	}
	return false
}

func (e LinkStatusEnum) String() string {
	return string(e)
}

func (e *LinkStatusEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LinkStatusEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid LinkStatusEnum", str)
	}
	return nil
}

func (e LinkStatusEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type LocationType string

const (
	LocationTypeBranch          LocationType = "BRANCH"
	LocationTypeCloudDataCenter LocationType = "CLOUD_DATA_CENTER"
	LocationTypeDataCenter      LocationType = "DATA_CENTER"
	LocationTypeHeadquarters    LocationType = "HEADQUARTERS"
	LocationTypeOther           LocationType = "OTHER"
	LocationTypeWarehouse       LocationType = "WAREHOUSE"
)

var AllLocationType = []LocationType{
	LocationTypeBranch,
	LocationTypeCloudDataCenter,
	LocationTypeDataCenter,
	LocationTypeHeadquarters,
	LocationTypeOther,
	LocationTypeWarehouse,
}

func (e LocationType) IsValid() bool {
	switch e {
	case LocationTypeBranch, LocationTypeCloudDataCenter, LocationTypeDataCenter, LocationTypeHeadquarters, LocationTypeOther, LocationTypeWarehouse:
		return true
	}
	return false
}

func (e LocationType) String() string {
	return string(e)
}

func (e *LocationType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LocationType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid LocationType", str)
	}
	return nil
}

func (e LocationType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type LookupFilterType string

const (
	//  Custom filter for country, used by city and state entityLookup
	LookupFilterTypeCountry LookupFilterType = "country"
	// Custom filter to be used with Site entityLookup, to get only sites with Alt WAN, possible values:
	// "true",
	// "false",
	LookupFilterTypeFilterByAltWan LookupFilterType = "filterByAltWan"
	// Custom filter to be used with Site entityLookup, to get only sites that are configured as backhauling gateways, possible values:
	// "true",
	// "false",
	LookupFilterTypeFilterByBackhaulingGw LookupFilterType = "filterByBackhaulingGW"
	// Custom filter to be used with Site entityLookup, to get only sites with one connection type, possible values (there are more values that can supported):
	// "SOCKET_X1500",
	// "SOCKET_X1600",
	// "SOCKET_X1700",
	// "VSOCKET_VGX_ESX",
	// "VSOCKET_VGX_AWS"
	// "VSOCKET_VGX_AZURE"
	// "SOCKET_X1600_LTE",
	LookupFilterTypeFilterByConnectionType LookupFilterType = "filterByConnectionType"
	// Custom filter to be used with Site entityLookup, to get only sites with one connection type, possible values:
	// "SOCKET",
	// "IPSEC",
	// "vSOCKET",
	// "PHYSICAL_SOCKET"
	LookupFilterTypeFilterByConnectionTypeFamily LookupFilterType = "filterByConnectionTypeFamily"
	// Custom filter to be used with Site entityLookup, to get only sites that are configured as OffCloudTransportEnabled, possible values:
	// "true",
	// "false",
	LookupFilterTypeFilterByOffCloudTransportEnabled LookupFilterType = "filterByOffCloudTransportEnabled"
	//  Custom filter for state used by city entityLookup
	LookupFilterTypeState LookupFilterType = "state"
)

var AllLookupFilterType = []LookupFilterType{
	LookupFilterTypeCountry,
	LookupFilterTypeFilterByAltWan,
	LookupFilterTypeFilterByBackhaulingGw,
	LookupFilterTypeFilterByConnectionType,
	LookupFilterTypeFilterByConnectionTypeFamily,
	LookupFilterTypeFilterByOffCloudTransportEnabled,
	LookupFilterTypeState,
}

func (e LookupFilterType) IsValid() bool {
	switch e {
	case LookupFilterTypeCountry, LookupFilterTypeFilterByAltWan, LookupFilterTypeFilterByBackhaulingGw, LookupFilterTypeFilterByConnectionType, LookupFilterTypeFilterByConnectionTypeFamily, LookupFilterTypeFilterByOffCloudTransportEnabled, LookupFilterTypeState:
		return true
	}
	return false
}

func (e LookupFilterType) String() string {
	return string(e)
}

func (e *LookupFilterType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LookupFilterType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid LookupFilterType", str)
	}
	return nil
}

func (e LookupFilterType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type MetadataType string

const (
	MetadataTypeTxt MetadataType = "TXT"
)

var AllMetadataType = []MetadataType{
	MetadataTypeTxt,
}

func (e MetadataType) IsValid() bool {
	switch e {
	case MetadataTypeTxt:
		return true
	}
	return false
}

func (e MetadataType) String() string {
	return string(e)
}

func (e *MetadataType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MetadataType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MetadataType", str)
	}
	return nil
}

func (e MetadataType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type MsAlertStatus string

const (
	MsAlertStatusInProgress MsAlertStatus = "IN_PROGRESS"
	MsAlertStatusNew        MsAlertStatus = "NEW"
	MsAlertStatusResolved   MsAlertStatus = "RESOLVED"
)

var AllMsAlertStatus = []MsAlertStatus{
	MsAlertStatusInProgress,
	MsAlertStatusNew,
	MsAlertStatusResolved,
}

func (e MsAlertStatus) IsValid() bool {
	switch e {
	case MsAlertStatusInProgress, MsAlertStatusNew, MsAlertStatusResolved:
		return true
	}
	return false
}

func (e MsAlertStatus) String() string {
	return string(e)
}

func (e *MsAlertStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MsAlertStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MsAlertStatus", str)
	}
	return nil
}

func (e MsAlertStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type MsResourceVerdictEnum string

const (
	MsResourceVerdictEnumBenign        MsResourceVerdictEnum = "Benign"
	MsResourceVerdictEnumInformational MsResourceVerdictEnum = "Informational"
	MsResourceVerdictEnumMalicious     MsResourceVerdictEnum = "Malicious"
	MsResourceVerdictEnumSuspicious    MsResourceVerdictEnum = "Suspicious"
)

var AllMsResourceVerdictEnum = []MsResourceVerdictEnum{
	MsResourceVerdictEnumBenign,
	MsResourceVerdictEnumInformational,
	MsResourceVerdictEnumMalicious,
	MsResourceVerdictEnumSuspicious,
}

func (e MsResourceVerdictEnum) IsValid() bool {
	switch e {
	case MsResourceVerdictEnumBenign, MsResourceVerdictEnumInformational, MsResourceVerdictEnumMalicious, MsResourceVerdictEnumSuspicious:
		return true
	}
	return false
}

func (e MsResourceVerdictEnum) String() string {
	return string(e)
}

func (e *MsResourceVerdictEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MsResourceVerdictEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MsResourceVerdictEnum", str)
	}
	return nil
}

func (e MsResourceVerdictEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type NetworkEventSourceEnum string

const (
	NetworkEventSourceEnumBgpSession NetworkEventSourceEnum = "BGP_SESSION"
	NetworkEventSourceEnumDevice     NetworkEventSourceEnum = "DEVICE"
	NetworkEventSourceEnumHost       NetworkEventSourceEnum = "HOST"
	NetworkEventSourceEnumIsp        NetworkEventSourceEnum = "ISP"
	NetworkEventSourceEnumLink       NetworkEventSourceEnum = "LINK"
	NetworkEventSourceEnumPop        NetworkEventSourceEnum = "POP"
	NetworkEventSourceEnumSite       NetworkEventSourceEnum = "SITE"
)

var AllNetworkEventSourceEnum = []NetworkEventSourceEnum{
	NetworkEventSourceEnumBgpSession,
	NetworkEventSourceEnumDevice,
	NetworkEventSourceEnumHost,
	NetworkEventSourceEnumIsp,
	NetworkEventSourceEnumLink,
	NetworkEventSourceEnumPop,
	NetworkEventSourceEnumSite,
}

func (e NetworkEventSourceEnum) IsValid() bool {
	switch e {
	case NetworkEventSourceEnumBgpSession, NetworkEventSourceEnumDevice, NetworkEventSourceEnumHost, NetworkEventSourceEnumIsp, NetworkEventSourceEnumLink, NetworkEventSourceEnumPop, NetworkEventSourceEnumSite:
		return true
	}
	return false
}

func (e NetworkEventSourceEnum) String() string {
	return string(e)
}

func (e *NetworkEventSourceEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NetworkEventSourceEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NetworkEventSourceEnum", str)
	}
	return nil
}

func (e NetworkEventSourceEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type NetworkXDREventTypeEnum string

const (
	NetworkXDREventTypeEnumDegraded NetworkXDREventTypeEnum = "DEGRADED"
	NetworkXDREventTypeEnumInsight  NetworkXDREventTypeEnum = "INSIGHT"
	NetworkXDREventTypeEnumResolved NetworkXDREventTypeEnum = "RESOLVED"
)

var AllNetworkXDREventTypeEnum = []NetworkXDREventTypeEnum{
	NetworkXDREventTypeEnumDegraded,
	NetworkXDREventTypeEnumInsight,
	NetworkXDREventTypeEnumResolved,
}

func (e NetworkXDREventTypeEnum) IsValid() bool {
	switch e {
	case NetworkXDREventTypeEnumDegraded, NetworkXDREventTypeEnumInsight, NetworkXDREventTypeEnumResolved:
		return true
	}
	return false
}

func (e NetworkXDREventTypeEnum) String() string {
	return string(e)
}

func (e *NetworkXDREventTypeEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NetworkXDREventTypeEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NetworkXDREventTypeEnum", str)
	}
	return nil
}

func (e NetworkXDREventTypeEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ObjectRefBy string

const (
	ObjectRefByID   ObjectRefBy = "ID"
	ObjectRefByName ObjectRefBy = "NAME"
)

var AllObjectRefBy = []ObjectRefBy{
	ObjectRefByID,
	ObjectRefByName,
}

func (e ObjectRefBy) IsValid() bool {
	switch e {
	case ObjectRefByID, ObjectRefByName:
		return true
	}
	return false
}

func (e ObjectRefBy) String() string {
	return string(e)
}

func (e *ObjectRefBy) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ObjectRefBy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ObjectRefBy", str)
	}
	return nil
}

func (e ObjectRefBy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type OnboardingStatusEnum string

const (
	OnboardingStatusEnumCanBeOnboarded   OnboardingStatusEnum = "CAN_BE_ONBOARDED"
	OnboardingStatusEnumInsufficientInfo OnboardingStatusEnum = "INSUFFICIENT_INFO"
	OnboardingStatusEnumOnboarded        OnboardingStatusEnum = "ONBOARDED"
)

var AllOnboardingStatusEnum = []OnboardingStatusEnum{
	OnboardingStatusEnumCanBeOnboarded,
	OnboardingStatusEnumInsufficientInfo,
	OnboardingStatusEnumOnboarded,
}

func (e OnboardingStatusEnum) IsValid() bool {
	switch e {
	case OnboardingStatusEnumCanBeOnboarded, OnboardingStatusEnumInsufficientInfo, OnboardingStatusEnumOnboarded:
		return true
	}
	return false
}

func (e OnboardingStatusEnum) String() string {
	return string(e)
}

func (e *OnboardingStatusEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OnboardingStatusEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OnboardingStatusEnum", str)
	}
	return nil
}

func (e OnboardingStatusEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type OperatingSystem string

const (
	OperatingSystemAndroid  OperatingSystem = "ANDROID"
	OperatingSystemEmbedded OperatingSystem = "EMBEDDED"
	OperatingSystemIos      OperatingSystem = "IOS"
	OperatingSystemLinux    OperatingSystem = "LINUX"
	OperatingSystemMacos    OperatingSystem = "MACOS"
	OperatingSystemWindows  OperatingSystem = "WINDOWS"
)

var AllOperatingSystem = []OperatingSystem{
	OperatingSystemAndroid,
	OperatingSystemEmbedded,
	OperatingSystemIos,
	OperatingSystemLinux,
	OperatingSystemMacos,
	OperatingSystemWindows,
}

func (e OperatingSystem) IsValid() bool {
	switch e {
	case OperatingSystemAndroid, OperatingSystemEmbedded, OperatingSystemIos, OperatingSystemLinux, OperatingSystemMacos, OperatingSystemWindows:
		return true
	}
	return false
}

func (e OperatingSystem) String() string {
	return string(e)
}

func (e *OperatingSystem) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OperatingSystem(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OperatingSystem", str)
	}
	return nil
}

func (e OperatingSystem) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The origins (e.g., integrations, data feeds) that detected the device
type OriginType string

const (
	//  Device details reported by the Armis security platform
	OriginTypeArmis OriginType = "Armis"
	//  Device information provided by the Cato Networks platform
	OriginTypeCatoNetworks OriginType = "CatoNetworks"
	//  Device data gathered from Claroty's security platform
	OriginTypeClaroty OriginType = "Claroty"
	//  Device details provided by CrowdStrike endpoint security
	OriginTypeCrowdstrike OriginType = "Crowdstrike"
	//  Device data collected from Microsoft Intune MDM
	OriginTypeMicrosoftIntune OriginType = "MicrosoftIntune"
	//  Device information from SentinelOne endpoint platform
	OriginTypeSentinelOne OriginType = "SentinelOne"
	//  Origin of the device data could not be determined
	OriginTypeUnknown OriginType = "Unknown"
	//  Device information identified through Zoom integration
	OriginTypeZoom OriginType = "Zoom"
)

var AllOriginType = []OriginType{
	OriginTypeArmis,
	OriginTypeCatoNetworks,
	OriginTypeClaroty,
	OriginTypeCrowdstrike,
	OriginTypeMicrosoftIntune,
	OriginTypeSentinelOne,
	OriginTypeUnknown,
	OriginTypeZoom,
}

func (e OriginType) IsValid() bool {
	switch e {
	case OriginTypeArmis, OriginTypeCatoNetworks, OriginTypeClaroty, OriginTypeCrowdstrike, OriginTypeMicrosoftIntune, OriginTypeSentinelOne, OriginTypeUnknown, OriginTypeZoom:
		return true
	}
	return false
}

func (e OriginType) String() string {
	return string(e)
}

func (e *OriginType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OriginType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OriginType", str)
	}
	return nil
}

func (e OriginType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type PeriodType string

const (
	//  traffic was seen
	PeriodTypeActive PeriodType = "active"
	//  some packets were discarded after queue timeout
	PeriodTypeCongested PeriodType = "congested"
	//  unspecified period type
	PeriodTypeGeneric PeriodType = "generic"
	//  multiple last mile destinations measured large latency (greater than 500ms)
	PeriodTypeLastmileLatency PeriodType = "lastmileLatency"
	//  multiple last mile destinations measured packet loss
	PeriodTypeLastmilePacketLoss PeriodType = "lastmilePacketLoss"
	//  missing data
	PeriodTypeMissingData PeriodType = "missingData"
	//  some packets were queued
	PeriodTypeOverlowed PeriodType = "overlowed"
	//  packet loss connectivity issue
	PeriodTypePacketLoss PeriodType = "packetLoss"
	//  interface in standby mode
	PeriodTypePassiveLink PeriodType = "passiveLink"
	//  period connected to specific pop instance
	PeriodTypePop PeriodType = "pop"
)

var AllPeriodType = []PeriodType{
	PeriodTypeActive,
	PeriodTypeCongested,
	PeriodTypeGeneric,
	PeriodTypeLastmileLatency,
	PeriodTypeLastmilePacketLoss,
	PeriodTypeMissingData,
	PeriodTypeOverlowed,
	PeriodTypePacketLoss,
	PeriodTypePassiveLink,
	PeriodTypePop,
}

func (e PeriodType) IsValid() bool {
	switch e {
	case PeriodTypeActive, PeriodTypeCongested, PeriodTypeGeneric, PeriodTypeLastmileLatency, PeriodTypeLastmilePacketLoss, PeriodTypeMissingData, PeriodTypeOverlowed, PeriodTypePacketLoss, PeriodTypePassiveLink, PeriodTypePop:
		return true
	}
	return false
}

func (e PeriodType) String() string {
	return string(e)
}

func (e *PeriodType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PeriodType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PeriodType", str)
	}
	return nil
}

func (e PeriodType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Enum for the type of time range a rule is active
type PolicyActiveOnEnum string

const (
	PolicyActiveOnEnumAlways          PolicyActiveOnEnum = "ALWAYS"
	PolicyActiveOnEnumCustomRecurring PolicyActiveOnEnum = "CUSTOM_RECURRING"
	PolicyActiveOnEnumCustomTimeframe PolicyActiveOnEnum = "CUSTOM_TIMEFRAME"
	PolicyActiveOnEnumWorkingHours    PolicyActiveOnEnum = "WORKING_HOURS"
)

var AllPolicyActiveOnEnum = []PolicyActiveOnEnum{
	PolicyActiveOnEnumAlways,
	PolicyActiveOnEnumCustomRecurring,
	PolicyActiveOnEnumCustomTimeframe,
	PolicyActiveOnEnumWorkingHours,
}

func (e PolicyActiveOnEnum) IsValid() bool {
	switch e {
	case PolicyActiveOnEnumAlways, PolicyActiveOnEnumCustomRecurring, PolicyActiveOnEnumCustomTimeframe, PolicyActiveOnEnumWorkingHours:
		return true
	}
	return false
}

func (e PolicyActiveOnEnum) String() string {
	return string(e)
}

func (e *PolicyActiveOnEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PolicyActiveOnEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PolicyActiveOnEnum", str)
	}
	return nil
}

func (e PolicyActiveOnEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Attributes describing the rule state or type
type PolicyElementPropertiesEnum string

const (
	//  New (added) rule
	PolicyElementPropertiesEnumAdded PolicyElementPropertiesEnum = "ADDED"
	// An object can not be moved, or referenced when moving other objects.
	// However its properties and content can be modified.
	PolicyElementPropertiesEnumAnchored PolicyElementPropertiesEnum = "ANCHORED"
	//  A rule locked for changes by other admins
	PolicyElementPropertiesEnumLocked PolicyElementPropertiesEnum = "LOCKED"
	//  A rule moved to a different position
	PolicyElementPropertiesEnumMoved PolicyElementPropertiesEnum = "MOVED"
	//  Removed (deleted) rule
	PolicyElementPropertiesEnumRemoved PolicyElementPropertiesEnum = "REMOVED"
	//  A pre-defined (system) rule that cannot be modified or removed
	PolicyElementPropertiesEnumSystem PolicyElementPropertiesEnum = "SYSTEM"
	//  Updated (modified) existing rule
	PolicyElementPropertiesEnumUpdated PolicyElementPropertiesEnum = "UPDATED"
)

var AllPolicyElementPropertiesEnum = []PolicyElementPropertiesEnum{
	PolicyElementPropertiesEnumAdded,
	PolicyElementPropertiesEnumAnchored,
	PolicyElementPropertiesEnumLocked,
	PolicyElementPropertiesEnumMoved,
	PolicyElementPropertiesEnumRemoved,
	PolicyElementPropertiesEnumSystem,
	PolicyElementPropertiesEnumUpdated,
}

func (e PolicyElementPropertiesEnum) IsValid() bool {
	switch e {
	case PolicyElementPropertiesEnumAdded, PolicyElementPropertiesEnumAnchored, PolicyElementPropertiesEnumLocked, PolicyElementPropertiesEnumMoved, PolicyElementPropertiesEnumRemoved, PolicyElementPropertiesEnumSystem, PolicyElementPropertiesEnumUpdated:
		return true
	}
	return false
}

func (e PolicyElementPropertiesEnum) String() string {
	return string(e)
}

func (e *PolicyElementPropertiesEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PolicyElementPropertiesEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PolicyElementPropertiesEnum", str)
	}
	return nil
}

func (e PolicyElementPropertiesEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Enum for the status of a policy mutation
type PolicyMutationStatus string

const (
	PolicyMutationStatusFailure PolicyMutationStatus = "FAILURE"
	PolicyMutationStatusSuccess PolicyMutationStatus = "SUCCESS"
)

var AllPolicyMutationStatus = []PolicyMutationStatus{
	PolicyMutationStatusFailure,
	PolicyMutationStatusSuccess,
}

func (e PolicyMutationStatus) IsValid() bool {
	switch e {
	case PolicyMutationStatusFailure, PolicyMutationStatusSuccess:
		return true
	}
	return false
}

func (e PolicyMutationStatus) String() string {
	return string(e)
}

func (e *PolicyMutationStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PolicyMutationStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PolicyMutationStatus", str)
	}
	return nil
}

func (e PolicyMutationStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Enum for the type of a policy revision
type PolicyRevisionType string

const (
	PolicyRevisionTypePrivate PolicyRevisionType = "PRIVATE"
	PolicyRevisionTypePublic  PolicyRevisionType = "PUBLIC"
)

var AllPolicyRevisionType = []PolicyRevisionType{
	PolicyRevisionTypePrivate,
	PolicyRevisionTypePublic,
}

func (e PolicyRevisionType) IsValid() bool {
	switch e {
	case PolicyRevisionTypePrivate, PolicyRevisionTypePublic:
		return true
	}
	return false
}

func (e PolicyRevisionType) String() string {
	return string(e)
}

func (e *PolicyRevisionType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PolicyRevisionType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PolicyRevisionType", str)
	}
	return nil
}

func (e PolicyRevisionType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Enum for the position of a rule within a policy
type PolicyRulePositionEnum string

const (
	//  The rule position is after the pre-existing specified rule
	PolicyRulePositionEnumAfterRule PolicyRulePositionEnum = "AFTER_RULE"
	//  The rule position is before the pre-existing specified rule
	PolicyRulePositionEnumBeforeRule PolicyRulePositionEnum = "BEFORE_RULE"
	//  The rule position is immediately after the system rules (first non-system rule)
	PolicyRulePositionEnumFirstInPolicy PolicyRulePositionEnum = "FIRST_IN_POLICY"
	//  The rule position is first in the specified section
	PolicyRulePositionEnumFirstInSection PolicyRulePositionEnum = "FIRST_IN_SECTION"
	//  The rule position is last in the policy
	PolicyRulePositionEnumLastInPolicy PolicyRulePositionEnum = "LAST_IN_POLICY"
	//  The rule position is last in the specified section
	PolicyRulePositionEnumLastInSection PolicyRulePositionEnum = "LAST_IN_SECTION"
)

var AllPolicyRulePositionEnum = []PolicyRulePositionEnum{
	PolicyRulePositionEnumAfterRule,
	PolicyRulePositionEnumBeforeRule,
	PolicyRulePositionEnumFirstInPolicy,
	PolicyRulePositionEnumFirstInSection,
	PolicyRulePositionEnumLastInPolicy,
	PolicyRulePositionEnumLastInSection,
}

func (e PolicyRulePositionEnum) IsValid() bool {
	switch e {
	case PolicyRulePositionEnumAfterRule, PolicyRulePositionEnumBeforeRule, PolicyRulePositionEnumFirstInPolicy, PolicyRulePositionEnumFirstInSection, PolicyRulePositionEnumLastInPolicy, PolicyRulePositionEnumLastInSection:
		return true
	}
	return false
}

func (e PolicyRulePositionEnum) String() string {
	return string(e)
}

func (e *PolicyRulePositionEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PolicyRulePositionEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PolicyRulePositionEnum", str)
	}
	return nil
}

func (e PolicyRulePositionEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Enum for the frequency of an alert event for a rule
type PolicyRuleTrackingFrequencyEnum string

const (
	PolicyRuleTrackingFrequencyEnumDaily     PolicyRuleTrackingFrequencyEnum = "DAILY"
	PolicyRuleTrackingFrequencyEnumHourly    PolicyRuleTrackingFrequencyEnum = "HOURLY"
	PolicyRuleTrackingFrequencyEnumImmediate PolicyRuleTrackingFrequencyEnum = "IMMEDIATE"
	PolicyRuleTrackingFrequencyEnumWeekly    PolicyRuleTrackingFrequencyEnum = "WEEKLY"
)

var AllPolicyRuleTrackingFrequencyEnum = []PolicyRuleTrackingFrequencyEnum{
	PolicyRuleTrackingFrequencyEnumDaily,
	PolicyRuleTrackingFrequencyEnumHourly,
	PolicyRuleTrackingFrequencyEnumImmediate,
	PolicyRuleTrackingFrequencyEnumWeekly,
}

func (e PolicyRuleTrackingFrequencyEnum) IsValid() bool {
	switch e {
	case PolicyRuleTrackingFrequencyEnumDaily, PolicyRuleTrackingFrequencyEnumHourly, PolicyRuleTrackingFrequencyEnumImmediate, PolicyRuleTrackingFrequencyEnumWeekly:
		return true
	}
	return false
}

func (e PolicyRuleTrackingFrequencyEnum) String() string {
	return string(e)
}

func (e *PolicyRuleTrackingFrequencyEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PolicyRuleTrackingFrequencyEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PolicyRuleTrackingFrequencyEnum", str)
	}
	return nil
}

func (e PolicyRuleTrackingFrequencyEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type PolicySectionPositionEnum string

const (
	PolicySectionPositionEnumAfterSection  PolicySectionPositionEnum = "AFTER_SECTION"
	PolicySectionPositionEnumBeforeSection PolicySectionPositionEnum = "BEFORE_SECTION"
	PolicySectionPositionEnumLastInPolicy  PolicySectionPositionEnum = "LAST_IN_POLICY"
)

var AllPolicySectionPositionEnum = []PolicySectionPositionEnum{
	PolicySectionPositionEnumAfterSection,
	PolicySectionPositionEnumBeforeSection,
	PolicySectionPositionEnumLastInPolicy,
}

func (e PolicySectionPositionEnum) IsValid() bool {
	switch e {
	case PolicySectionPositionEnumAfterSection, PolicySectionPositionEnumBeforeSection, PolicySectionPositionEnumLastInPolicy:
		return true
	}
	return false
}

func (e PolicySectionPositionEnum) String() string {
	return string(e)
}

func (e *PolicySectionPositionEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PolicySectionPositionEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PolicySectionPositionEnum", str)
	}
	return nil
}

func (e PolicySectionPositionEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Enum for the position of a rule within a policy
type PolicySubRulePositionEnum string

const (
	//  The rule position is after the pre-existing specified rule
	PolicySubRulePositionEnumAfterSubRule PolicySubRulePositionEnum = "AFTER_SUB_RULE"
	//  The rule position is before the pre-existing specified rule
	PolicySubRulePositionEnumBeforeSubRule PolicySubRulePositionEnum = "BEFORE_SUB_RULE"
	//  The rule position is first in the specified rule
	PolicySubRulePositionEnumFirstInRule PolicySubRulePositionEnum = "FIRST_IN_RULE"
	//  The rule position is last in the specified rule
	PolicySubRulePositionEnumLastInRule PolicySubRulePositionEnum = "LAST_IN_RULE"
)

var AllPolicySubRulePositionEnum = []PolicySubRulePositionEnum{
	PolicySubRulePositionEnumAfterSubRule,
	PolicySubRulePositionEnumBeforeSubRule,
	PolicySubRulePositionEnumFirstInRule,
	PolicySubRulePositionEnumLastInRule,
}

func (e PolicySubRulePositionEnum) IsValid() bool {
	switch e {
	case PolicySubRulePositionEnumAfterSubRule, PolicySubRulePositionEnumBeforeSubRule, PolicySubRulePositionEnumFirstInRule, PolicySubRulePositionEnumLastInRule:
		return true
	}
	return false
}

func (e PolicySubRulePositionEnum) String() string {
	return string(e)
}

func (e *PolicySubRulePositionEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PolicySubRulePositionEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PolicySubRulePositionEnum", str)
	}
	return nil
}

func (e PolicySubRulePositionEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Enum for the state of a policy
type PolicyToggleState string

const (
	PolicyToggleStateDisabled PolicyToggleState = "DISABLED"
	PolicyToggleStateEnabled  PolicyToggleState = "ENABLED"
)

var AllPolicyToggleState = []PolicyToggleState{
	PolicyToggleStateDisabled,
	PolicyToggleStateEnabled,
}

func (e PolicyToggleState) IsValid() bool {
	switch e {
	case PolicyToggleStateDisabled, PolicyToggleStateEnabled:
		return true
	}
	return false
}

func (e PolicyToggleState) String() string {
	return string(e)
}

func (e *PolicyToggleState) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PolicyToggleState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PolicyToggleState", str)
	}
	return nil
}

func (e PolicyToggleState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type PrivateAccessPolicyActionEnum string

const (
	PrivateAccessPolicyActionEnumAllow PrivateAccessPolicyActionEnum = "ALLOW"
	PrivateAccessPolicyActionEnumBlock PrivateAccessPolicyActionEnum = "BLOCK"
)

var AllPrivateAccessPolicyActionEnum = []PrivateAccessPolicyActionEnum{
	PrivateAccessPolicyActionEnumAllow,
	PrivateAccessPolicyActionEnumBlock,
}

func (e PrivateAccessPolicyActionEnum) IsValid() bool {
	switch e {
	case PrivateAccessPolicyActionEnumAllow, PrivateAccessPolicyActionEnumBlock:
		return true
	}
	return false
}

func (e PrivateAccessPolicyActionEnum) String() string {
	return string(e)
}

func (e *PrivateAccessPolicyActionEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PrivateAccessPolicyActionEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PrivateAccessPolicyActionEnum", str)
	}
	return nil
}

func (e PrivateAccessPolicyActionEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Defines Origin of the connection
type PrivateAccessPolicyOriginEnum string

const (
	PrivateAccessPolicyOriginEnumAny PrivateAccessPolicyOriginEnum = "ANY"
	//  Any Remote option
	PrivateAccessPolicyOriginEnumRemote PrivateAccessPolicyOriginEnum = "REMOTE"
	//  User is connecting from the Enterprise Browser
	PrivateAccessPolicyOriginEnumRemoteBrowser PrivateAccessPolicyOriginEnum = "REMOTE_BROWSER"
	//  User is connecting from the SDP client
	PrivateAccessPolicyOriginEnumRemoteClient PrivateAccessPolicyOriginEnum = "REMOTE_CLIENT"
	//  User is connecting from the Browser Extension
	PrivateAccessPolicyOriginEnumRemoteExtension PrivateAccessPolicyOriginEnum = "REMOTE_EXTENSION"
	//  User is connecting from the Application Portal
	PrivateAccessPolicyOriginEnumRemotePortal PrivateAccessPolicyOriginEnum = "REMOTE_PORTAL"
	//  User is connecting from Site
	PrivateAccessPolicyOriginEnumSite PrivateAccessPolicyOriginEnum = "SITE"
)

var AllPrivateAccessPolicyOriginEnum = []PrivateAccessPolicyOriginEnum{
	PrivateAccessPolicyOriginEnumAny,
	PrivateAccessPolicyOriginEnumRemote,
	PrivateAccessPolicyOriginEnumRemoteBrowser,
	PrivateAccessPolicyOriginEnumRemoteClient,
	PrivateAccessPolicyOriginEnumRemoteExtension,
	PrivateAccessPolicyOriginEnumRemotePortal,
	PrivateAccessPolicyOriginEnumSite,
}

func (e PrivateAccessPolicyOriginEnum) IsValid() bool {
	switch e {
	case PrivateAccessPolicyOriginEnumAny, PrivateAccessPolicyOriginEnumRemote, PrivateAccessPolicyOriginEnumRemoteBrowser, PrivateAccessPolicyOriginEnumRemoteClient, PrivateAccessPolicyOriginEnumRemoteExtension, PrivateAccessPolicyOriginEnumRemotePortal, PrivateAccessPolicyOriginEnumSite:
		return true
	}
	return false
}

func (e PrivateAccessPolicyOriginEnum) String() string {
	return string(e)
}

func (e *PrivateAccessPolicyOriginEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PrivateAccessPolicyOriginEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PrivateAccessPolicyOriginEnum", str)
	}
	return nil
}

func (e PrivateAccessPolicyOriginEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ProtoType string

const (
	ProtoTypeCrossConnect    ProtoType = "CROSS_CONNECT"
	ProtoTypeCrossConnectL2  ProtoType = "CROSS_CONNECT_L2"
	ProtoTypeCrossConnectVrf ProtoType = "CROSS_CONNECT_VRF"
	ProtoTypeGreTunnel       ProtoType = "GRE_TUNNEL"
	ProtoTypeIpsecClient     ProtoType = "IPSEC_CLIENT"
	ProtoTypeIpsecHost       ProtoType = "IPSEC_HOST"
	ProtoTypeIpsecV2         ProtoType = "IPSEC_V2"
	ProtoTypeNotDefined      ProtoType = "NOT_DEFINED"
	ProtoTypePortalListener  ProtoType = "PORTAL_LISTENER"
	ProtoTypeSocketAWS1500   ProtoType = "SOCKET_AWS1500"
	ProtoTypeSocketAz1500    ProtoType = "SOCKET_AZ1500"
	ProtoTypeSocketEsx1500   ProtoType = "SOCKET_ESX1500"
	ProtoTypeSocketGCP1500   ProtoType = "SOCKET_GCP1500"
	ProtoTypeSocketRpi64     ProtoType = "SOCKET_RPI64"
	ProtoTypeSocketX1        ProtoType = "SOCKET_X1"
	ProtoTypeSocketX1500     ProtoType = "SOCKET_X1500"
	ProtoTypeSocketX1600     ProtoType = "SOCKET_X1600"
	ProtoTypeSocketX1600Lte  ProtoType = "SOCKET_X1600_LTE"
	ProtoTypeSocketX1700     ProtoType = "SOCKET_X1700"
	ProtoTypeVsocketVgs      ProtoType = "VSOCKET_VGS"
	ProtoTypeVsocketVgx      ProtoType = "VSOCKET_VGX"
	ProtoTypeVsocketVgxAWS   ProtoType = "VSOCKET_VGX_AWS"
	ProtoTypeVsocketVgxAzure ProtoType = "VSOCKET_VGX_AZURE"
	ProtoTypeVsocketVgxEsx   ProtoType = "VSOCKET_VGX_ESX"
	ProtoTypeVsocketVsh      ProtoType = "VSOCKET_VSH"
)

var AllProtoType = []ProtoType{
	ProtoTypeCrossConnect,
	ProtoTypeCrossConnectL2,
	ProtoTypeCrossConnectVrf,
	ProtoTypeGreTunnel,
	ProtoTypeIpsecClient,
	ProtoTypeIpsecHost,
	ProtoTypeIpsecV2,
	ProtoTypeNotDefined,
	ProtoTypePortalListener,
	ProtoTypeSocketAWS1500,
	ProtoTypeSocketAz1500,
	ProtoTypeSocketEsx1500,
	ProtoTypeSocketGCP1500,
	ProtoTypeSocketRpi64,
	ProtoTypeSocketX1,
	ProtoTypeSocketX1500,
	ProtoTypeSocketX1600,
	ProtoTypeSocketX1600Lte,
	ProtoTypeSocketX1700,
	ProtoTypeVsocketVgs,
	ProtoTypeVsocketVgx,
	ProtoTypeVsocketVgxAWS,
	ProtoTypeVsocketVgxAzure,
	ProtoTypeVsocketVgxEsx,
	ProtoTypeVsocketVsh,
}

func (e ProtoType) IsValid() bool {
	switch e {
	case ProtoTypeCrossConnect, ProtoTypeCrossConnectL2, ProtoTypeCrossConnectVrf, ProtoTypeGreTunnel, ProtoTypeIpsecClient, ProtoTypeIpsecHost, ProtoTypeIpsecV2, ProtoTypeNotDefined, ProtoTypePortalListener, ProtoTypeSocketAWS1500, ProtoTypeSocketAz1500, ProtoTypeSocketEsx1500, ProtoTypeSocketGCP1500, ProtoTypeSocketRpi64, ProtoTypeSocketX1, ProtoTypeSocketX1500, ProtoTypeSocketX1600, ProtoTypeSocketX1600Lte, ProtoTypeSocketX1700, ProtoTypeVsocketVgs, ProtoTypeVsocketVgx, ProtoTypeVsocketVgxAWS, ProtoTypeVsocketVgxAzure, ProtoTypeVsocketVgxEsx, ProtoTypeVsocketVsh:
		return true
	}
	return false
}

func (e ProtoType) String() string {
	return string(e)
}

func (e *ProtoType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProtoType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProtoType", str)
	}
	return nil
}

func (e ProtoType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type RBACAction string

const (
	RBACActionEdit RBACAction = "EDIT"
	RBACActionNone RBACAction = "NONE"
	RBACActionView RBACAction = "VIEW"
)

var AllRBACAction = []RBACAction{
	RBACActionEdit,
	RBACActionNone,
	RBACActionView,
}

func (e RBACAction) IsValid() bool {
	switch e {
	case RBACActionEdit, RBACActionNone, RBACActionView:
		return true
	}
	return false
}

func (e RBACAction) String() string {
	return string(e)
}

func (e *RBACAction) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RBACAction(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RBACAction", str)
	}
	return nil
}

func (e RBACAction) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// REGIONAL and GLOBAL licenses for MOROCCO, CHINA, and VIETNAM group values
type Regionality string

const (
	//  Global traffic going outside of the region
	RegionalityGlobal Regionality = "GLOBAL"
	//  Site traffic within the region
	RegionalityRegional Regionality = "REGIONAL"
)

var AllRegionality = []Regionality{
	RegionalityGlobal,
	RegionalityRegional,
}

func (e Regionality) IsValid() bool {
	switch e {
	case RegionalityGlobal, RegionalityRegional:
		return true
	}
	return false
}

func (e Regionality) String() string {
	return string(e)
}

func (e *Regionality) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Regionality(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Regionality", str)
	}
	return nil
}

func (e Regionality) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type RemediationStatusEnum string

const (
	RemediationStatusEnumBlocked           RemediationStatusEnum = "BLOCKED"
	RemediationStatusEnumClean             RemediationStatusEnum = "CLEAN"
	RemediationStatusEnumDeleted           RemediationStatusEnum = "DELETED"
	RemediationStatusEnumDeletedReboot     RemediationStatusEnum = "DELETED_REBOOT"
	RemediationStatusEnumDisabled          RemediationStatusEnum = "DISABLED"
	RemediationStatusEnumDisinfected       RemediationStatusEnum = "DISINFECTED"
	RemediationStatusEnumDisinfectFailed   RemediationStatusEnum = "DISINFECT_FAILED"
	RemediationStatusEnumInfected          RemediationStatusEnum = "INFECTED"
	RemediationStatusEnumMoved             RemediationStatusEnum = "MOVED"
	RemediationStatusEnumMovedReboot       RemediationStatusEnum = "MOVED_REBOOT"
	RemediationStatusEnumNotFound          RemediationStatusEnum = "NOT_FOUND"
	RemediationStatusEnumNotStarted        RemediationStatusEnum = "NOT_STARTED"
	RemediationStatusEnumPasswordProtected RemediationStatusEnum = "PASSWORD_PROTECTED"
	RemediationStatusEnumPrevented         RemediationStatusEnum = "PREVENTED"
	RemediationStatusEnumRebootRequired    RemediationStatusEnum = "REBOOT_REQUIRED"
	RemediationStatusEnumRemediated        RemediationStatusEnum = "REMEDIATED"
	RemediationStatusEnumScanFailed        RemediationStatusEnum = "SCAN_FAILED"
	RemediationStatusEnumSuccess           RemediationStatusEnum = "SUCCESS"
	RemediationStatusEnumSuspicious        RemediationStatusEnum = "SUSPICIOUS"
	RemediationStatusEnumUnknown           RemediationStatusEnum = "UNKNOWN"
)

var AllRemediationStatusEnum = []RemediationStatusEnum{
	RemediationStatusEnumBlocked,
	RemediationStatusEnumClean,
	RemediationStatusEnumDeleted,
	RemediationStatusEnumDeletedReboot,
	RemediationStatusEnumDisabled,
	RemediationStatusEnumDisinfected,
	RemediationStatusEnumDisinfectFailed,
	RemediationStatusEnumInfected,
	RemediationStatusEnumMoved,
	RemediationStatusEnumMovedReboot,
	RemediationStatusEnumNotFound,
	RemediationStatusEnumNotStarted,
	RemediationStatusEnumPasswordProtected,
	RemediationStatusEnumPrevented,
	RemediationStatusEnumRebootRequired,
	RemediationStatusEnumRemediated,
	RemediationStatusEnumScanFailed,
	RemediationStatusEnumSuccess,
	RemediationStatusEnumSuspicious,
	RemediationStatusEnumUnknown,
}

func (e RemediationStatusEnum) IsValid() bool {
	switch e {
	case RemediationStatusEnumBlocked, RemediationStatusEnumClean, RemediationStatusEnumDeleted, RemediationStatusEnumDeletedReboot, RemediationStatusEnumDisabled, RemediationStatusEnumDisinfected, RemediationStatusEnumDisinfectFailed, RemediationStatusEnumInfected, RemediationStatusEnumMoved, RemediationStatusEnumMovedReboot, RemediationStatusEnumNotFound, RemediationStatusEnumNotStarted, RemediationStatusEnumPasswordProtected, RemediationStatusEnumPrevented, RemediationStatusEnumRebootRequired, RemediationStatusEnumRemediated, RemediationStatusEnumScanFailed, RemediationStatusEnumSuccess, RemediationStatusEnumSuspicious, RemediationStatusEnumUnknown:
		return true
	}
	return false
}

func (e RemediationStatusEnum) String() string {
	return string(e)
}

func (e *RemediationStatusEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RemediationStatusEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RemediationStatusEnum", str)
	}
	return nil
}

func (e RemediationStatusEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type RemotePortFwdRestrictionType string

const (
	RemotePortFwdRestrictionTypeAllowList RemotePortFwdRestrictionType = "ALLOW_LIST"
	RemotePortFwdRestrictionTypeBlockList RemotePortFwdRestrictionType = "BLOCK_LIST"
)

var AllRemotePortFwdRestrictionType = []RemotePortFwdRestrictionType{
	RemotePortFwdRestrictionTypeAllowList,
	RemotePortFwdRestrictionTypeBlockList,
}

func (e RemotePortFwdRestrictionType) IsValid() bool {
	switch e {
	case RemotePortFwdRestrictionTypeAllowList, RemotePortFwdRestrictionTypeBlockList:
		return true
	}
	return false
}

func (e RemotePortFwdRestrictionType) String() string {
	return string(e)
}

func (e *RemotePortFwdRestrictionType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RemotePortFwdRestrictionType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RemotePortFwdRestrictionType", str)
	}
	return nil
}

func (e RemotePortFwdRestrictionType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ResourceRoleEnum string

const (
	ResourceRoleEnumAdded             ResourceRoleEnum = "ADDED"
	ResourceRoleEnumAttacked          ResourceRoleEnum = "ATTACKED"
	ResourceRoleEnumAttacker          ResourceRoleEnum = "ATTACKER"
	ResourceRoleEnumCommandAndControl ResourceRoleEnum = "COMMAND_AND_CONTROL"
	ResourceRoleEnumCompromised       ResourceRoleEnum = "COMPROMISED"
	ResourceRoleEnumContextual        ResourceRoleEnum = "CONTEXTUAL"
	ResourceRoleEnumCreated           ResourceRoleEnum = "CREATED"
	ResourceRoleEnumDestination       ResourceRoleEnum = "DESTINATION"
	ResourceRoleEnumEdited            ResourceRoleEnum = "EDITED"
	ResourceRoleEnumLoaded            ResourceRoleEnum = "LOADED"
	ResourceRoleEnumPolicyViolator    ResourceRoleEnum = "POLICY_VIOLATOR"
	ResourceRoleEnumScanned           ResourceRoleEnum = "SCANNED"
	ResourceRoleEnumSource            ResourceRoleEnum = "SOURCE"
	ResourceRoleEnumSuspicious        ResourceRoleEnum = "SUSPICIOUS"
)

var AllResourceRoleEnum = []ResourceRoleEnum{
	ResourceRoleEnumAdded,
	ResourceRoleEnumAttacked,
	ResourceRoleEnumAttacker,
	ResourceRoleEnumCommandAndControl,
	ResourceRoleEnumCompromised,
	ResourceRoleEnumContextual,
	ResourceRoleEnumCreated,
	ResourceRoleEnumDestination,
	ResourceRoleEnumEdited,
	ResourceRoleEnumLoaded,
	ResourceRoleEnumPolicyViolator,
	ResourceRoleEnumScanned,
	ResourceRoleEnumSource,
	ResourceRoleEnumSuspicious,
}

func (e ResourceRoleEnum) IsValid() bool {
	switch e {
	case ResourceRoleEnumAdded, ResourceRoleEnumAttacked, ResourceRoleEnumAttacker, ResourceRoleEnumCommandAndControl, ResourceRoleEnumCompromised, ResourceRoleEnumContextual, ResourceRoleEnumCreated, ResourceRoleEnumDestination, ResourceRoleEnumEdited, ResourceRoleEnumLoaded, ResourceRoleEnumPolicyViolator, ResourceRoleEnumScanned, ResourceRoleEnumSource, ResourceRoleEnumSuspicious:
		return true
	}
	return false
}

func (e ResourceRoleEnum) String() string {
	return string(e)
}

func (e *ResourceRoleEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ResourceRoleEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ResourceRoleEnum", str)
	}
	return nil
}

func (e ResourceRoleEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type RiskLevelEnum string

const (
	RiskLevelEnumBenign       RiskLevelEnum = "Benign"
	RiskLevelEnumHigh         RiskLevelEnum = "High"
	RiskLevelEnumInconclusive RiskLevelEnum = "Inconclusive"
	RiskLevelEnumLow          RiskLevelEnum = "Low"
	RiskLevelEnumMalicious    RiskLevelEnum = "Malicious"
	RiskLevelEnumMedium       RiskLevelEnum = "Medium"
	RiskLevelEnumNan          RiskLevelEnum = "nan"
)

var AllRiskLevelEnum = []RiskLevelEnum{
	RiskLevelEnumBenign,
	RiskLevelEnumHigh,
	RiskLevelEnumInconclusive,
	RiskLevelEnumLow,
	RiskLevelEnumMalicious,
	RiskLevelEnumMedium,
	RiskLevelEnumNan,
}

func (e RiskLevelEnum) IsValid() bool {
	switch e {
	case RiskLevelEnumBenign, RiskLevelEnumHigh, RiskLevelEnumInconclusive, RiskLevelEnumLow, RiskLevelEnumMalicious, RiskLevelEnumMedium, RiskLevelEnumNan:
		return true
	}
	return false
}

func (e RiskLevelEnum) String() string {
	return string(e)
}

func (e *RiskLevelEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RiskLevelEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RiskLevelEnum", str)
	}
	return nil
}

func (e RiskLevelEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type RiskScoreCategory string

const (
	RiskScoreCategoryAny      RiskScoreCategory = "ANY"
	RiskScoreCategoryCritical RiskScoreCategory = "CRITICAL"
	RiskScoreCategoryHigh     RiskScoreCategory = "HIGH"
	RiskScoreCategoryLow      RiskScoreCategory = "LOW"
	RiskScoreCategoryMedium   RiskScoreCategory = "MEDIUM"
)

var AllRiskScoreCategory = []RiskScoreCategory{
	RiskScoreCategoryAny,
	RiskScoreCategoryCritical,
	RiskScoreCategoryHigh,
	RiskScoreCategoryLow,
	RiskScoreCategoryMedium,
}

func (e RiskScoreCategory) IsValid() bool {
	switch e {
	case RiskScoreCategoryAny, RiskScoreCategoryCritical, RiskScoreCategoryHigh, RiskScoreCategoryLow, RiskScoreCategoryMedium:
		return true
	}
	return false
}

func (e RiskScoreCategory) String() string {
	return string(e)
}

func (e *RiskScoreCategory) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RiskScoreCategory(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RiskScoreCategory", str)
	}
	return nil
}

func (e RiskScoreCategory) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type RiskScoreOperator string

const (
	RiskScoreOperatorGte RiskScoreOperator = "GTE"
	RiskScoreOperatorLte RiskScoreOperator = "LTE"
)

var AllRiskScoreOperator = []RiskScoreOperator{
	RiskScoreOperatorGte,
	RiskScoreOperatorLte,
}

func (e RiskScoreOperator) IsValid() bool {
	switch e {
	case RiskScoreOperatorGte, RiskScoreOperatorLte:
		return true
	}
	return false
}

func (e RiskScoreOperator) String() string {
	return string(e)
}

func (e *RiskScoreOperator) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RiskScoreOperator(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RiskScoreOperator", str)
	}
	return nil
}

func (e RiskScoreOperator) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Sandbox analysis failure reason
type SandboxFailureReason string

const (
	//  Failed to fetch report from sandbox service after 10 minutes
	SandboxFailureReasonAnalysisTimeout SandboxFailureReason = "ANALYSIS_TIMEOUT"
	//  Reached configured queued limit for account
	SandboxFailureReasonExceedRateLimit SandboxFailureReason = "EXCEED_RATE_LIMIT"
	//  Internal server error
	SandboxFailureReasonInternalError SandboxFailureReason = "INTERNAL_ERROR"
	//  Invalid file size (0 or too large)
	SandboxFailureReasonInvalidFileSize SandboxFailureReason = "INVALID_FILE_SIZE"
	//  Failed to submit file for sandbox analysis
	SandboxFailureReasonSubmissionError SandboxFailureReason = "SUBMISSION_ERROR"
	//  Unsupported file type
	SandboxFailureReasonUnsupportedFileType SandboxFailureReason = "UNSUPPORTED_FILE_TYPE"
)

var AllSandboxFailureReason = []SandboxFailureReason{
	SandboxFailureReasonAnalysisTimeout,
	SandboxFailureReasonExceedRateLimit,
	SandboxFailureReasonInternalError,
	SandboxFailureReasonInvalidFileSize,
	SandboxFailureReasonSubmissionError,
	SandboxFailureReasonUnsupportedFileType,
}

func (e SandboxFailureReason) IsValid() bool {
	switch e {
	case SandboxFailureReasonAnalysisTimeout, SandboxFailureReasonExceedRateLimit, SandboxFailureReasonInternalError, SandboxFailureReasonInvalidFileSize, SandboxFailureReasonSubmissionError, SandboxFailureReasonUnsupportedFileType:
		return true
	}
	return false
}

func (e SandboxFailureReason) String() string {
	return string(e)
}

func (e *SandboxFailureReason) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SandboxFailureReason(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SandboxFailureReason", str)
	}
	return nil
}

func (e SandboxFailureReason) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Sandbox analysis status
type SandboxStatus string

const (
	//  Report has expired
	SandboxStatusExpired SandboxStatus = "EXPIRED"
	//  Analysis has failed
	SandboxStatusFailed SandboxStatus = "FAILED"
	//  File is being analyzed
	SandboxStatusInProgress SandboxStatus = "IN_PROGRESS"
	//  File is pending analysis
	SandboxStatusPending SandboxStatus = "PENDING"
	//  File is queued for retry after throttling
	SandboxStatusQueued SandboxStatus = "QUEUED"
	//  Analysis is complete - report is ready
	SandboxStatusReady SandboxStatus = "READY"
)

var AllSandboxStatus = []SandboxStatus{
	SandboxStatusExpired,
	SandboxStatusFailed,
	SandboxStatusInProgress,
	SandboxStatusPending,
	SandboxStatusQueued,
	SandboxStatusReady,
}

func (e SandboxStatus) IsValid() bool {
	switch e {
	case SandboxStatusExpired, SandboxStatusFailed, SandboxStatusInProgress, SandboxStatusPending, SandboxStatusQueued, SandboxStatusReady:
		return true
	}
	return false
}

func (e SandboxStatus) String() string {
	return string(e)
}

func (e *SandboxStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SandboxStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SandboxStatus", str)
	}
	return nil
}

func (e SandboxStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Sandbox analysis verdict
type SandboxVerdict string

const (
	//  File is clean
	SandboxVerdictBenign SandboxVerdict = "BENIGN"
	//  File is malicious
	SandboxVerdictMalicious SandboxVerdict = "MALICIOUS"
	//  File is suspicious
	SandboxVerdictSuspicious SandboxVerdict = "SUSPICIOUS"
)

var AllSandboxVerdict = []SandboxVerdict{
	SandboxVerdictBenign,
	SandboxVerdictMalicious,
	SandboxVerdictSuspicious,
}

func (e SandboxVerdict) IsValid() bool {
	switch e {
	case SandboxVerdictBenign, SandboxVerdictMalicious, SandboxVerdictSuspicious:
		return true
	}
	return false
}

func (e SandboxVerdict) String() string {
	return string(e)
}

func (e *SandboxVerdict) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SandboxVerdict(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SandboxVerdict", str)
	}
	return nil
}

func (e SandboxVerdict) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ScanResult string

const (
	ScanResultBypassByContentRule ScanResult = "BYPASS_BY_CONTENT_RULE"
	ScanResultBypassByOther       ScanResult = "BYPASS_BY_OTHER"
	ScanResultBypassByType        ScanResult = "BYPASS_BY_TYPE"
	ScanResultCancelled           ScanResult = "CANCELLED"
	ScanResultClean               ScanResult = "CLEAN"
	ScanResultEncrypted           ScanResult = "ENCRYPTED"
	ScanResultVirusFound          ScanResult = "VIRUS_FOUND"
)

var AllScanResult = []ScanResult{
	ScanResultBypassByContentRule,
	ScanResultBypassByOther,
	ScanResultBypassByType,
	ScanResultCancelled,
	ScanResultClean,
	ScanResultEncrypted,
	ScanResultVirusFound,
}

func (e ScanResult) IsValid() bool {
	switch e {
	case ScanResultBypassByContentRule, ScanResultBypassByOther, ScanResultBypassByType, ScanResultCancelled, ScanResultClean, ScanResultEncrypted, ScanResultVirusFound:
		return true
	}
	return false
}

func (e ScanResult) String() string {
	return string(e)
}

func (e *ScanResult) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ScanResult(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ScanResult", str)
	}
	return nil
}

func (e ScanResult) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SeverityEnum string

const (
	SeverityEnumHigh   SeverityEnum = "High"
	SeverityEnumLow    SeverityEnum = "Low"
	SeverityEnumMedium SeverityEnum = "Medium"
)

var AllSeverityEnum = []SeverityEnum{
	SeverityEnumHigh,
	SeverityEnumLow,
	SeverityEnumMedium,
}

func (e SeverityEnum) IsValid() bool {
	switch e {
	case SeverityEnumHigh, SeverityEnumLow, SeverityEnumMedium:
		return true
	}
	return false
}

func (e SeverityEnum) String() string {
	return string(e)
}

func (e *SeverityEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SeverityEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SeverityEnum", str)
	}
	return nil
}

func (e SeverityEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ShippingStatus string

const (
	ShippingStatusConfirmShipping ShippingStatus = "CONFIRM_SHIPPING"
	ShippingStatusDelivered       ShippingStatus = "DELIVERED"
	ShippingStatusInTransit       ShippingStatus = "IN_TRANSIT"
	ShippingStatusPendingInfo     ShippingStatus = "PENDING_INFO"
)

var AllShippingStatus = []ShippingStatus{
	ShippingStatusConfirmShipping,
	ShippingStatusDelivered,
	ShippingStatusInTransit,
	ShippingStatusPendingInfo,
}

func (e ShippingStatus) IsValid() bool {
	switch e {
	case ShippingStatusConfirmShipping, ShippingStatusDelivered, ShippingStatusInTransit, ShippingStatusPendingInfo:
		return true
	}
	return false
}

func (e ShippingStatus) String() string {
	return string(e)
}

func (e *ShippingStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ShippingStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ShippingStatus", str)
	}
	return nil
}

func (e ShippingStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SimpleServiceType string

const (
	SimpleServiceTypeDNSTCP SimpleServiceType = "DNS_TCP"
	SimpleServiceTypeDNSUDP SimpleServiceType = "DNS_UDP"
	SimpleServiceTypeFtp    SimpleServiceType = "FTP"
	SimpleServiceTypeHTTP   SimpleServiceType = "HTTP"
	SimpleServiceTypeHTTPS  SimpleServiceType = "HTTPS"
	SimpleServiceTypeMysql  SimpleServiceType = "MYSQL"
	SimpleServiceTypeRdp    SimpleServiceType = "RDP"
	SimpleServiceTypeSMTP   SimpleServiceType = "SMTP"
	SimpleServiceTypeSSH    SimpleServiceType = "SSH"
)

var AllSimpleServiceType = []SimpleServiceType{
	SimpleServiceTypeDNSTCP,
	SimpleServiceTypeDNSUDP,
	SimpleServiceTypeFtp,
	SimpleServiceTypeHTTP,
	SimpleServiceTypeHTTPS,
	SimpleServiceTypeMysql,
	SimpleServiceTypeRdp,
	SimpleServiceTypeSMTP,
	SimpleServiceTypeSSH,
}

func (e SimpleServiceType) IsValid() bool {
	switch e {
	case SimpleServiceTypeDNSTCP, SimpleServiceTypeDNSUDP, SimpleServiceTypeFtp, SimpleServiceTypeHTTP, SimpleServiceTypeHTTPS, SimpleServiceTypeMysql, SimpleServiceTypeRdp, SimpleServiceTypeSMTP, SimpleServiceTypeSSH:
		return true
	}
	return false
}

func (e SimpleServiceType) String() string {
	return string(e)
}

func (e *SimpleServiceType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SimpleServiceType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SimpleServiceType", str)
	}
	return nil
}

func (e SimpleServiceType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SiteConnectionTypeEnum string

const (
	SiteConnectionTypeEnumSocketAWS1500  SiteConnectionTypeEnum = "SOCKET_AWS1500"
	SiteConnectionTypeEnumSocketAz1500   SiteConnectionTypeEnum = "SOCKET_AZ1500"
	SiteConnectionTypeEnumSocketEsx1500  SiteConnectionTypeEnum = "SOCKET_ESX1500"
	SiteConnectionTypeEnumSocketGCP1500  SiteConnectionTypeEnum = "SOCKET_GCP1500"
	SiteConnectionTypeEnumSocketX1500    SiteConnectionTypeEnum = "SOCKET_X1500"
	SiteConnectionTypeEnumSocketX1600    SiteConnectionTypeEnum = "SOCKET_X1600"
	SiteConnectionTypeEnumSocketX1600Lte SiteConnectionTypeEnum = "SOCKET_X1600_LTE"
	SiteConnectionTypeEnumSocketX1700    SiteConnectionTypeEnum = "SOCKET_X1700"
)

var AllSiteConnectionTypeEnum = []SiteConnectionTypeEnum{
	SiteConnectionTypeEnumSocketAWS1500,
	SiteConnectionTypeEnumSocketAz1500,
	SiteConnectionTypeEnumSocketEsx1500,
	SiteConnectionTypeEnumSocketGCP1500,
	SiteConnectionTypeEnumSocketX1500,
	SiteConnectionTypeEnumSocketX1600,
	SiteConnectionTypeEnumSocketX1600Lte,
	SiteConnectionTypeEnumSocketX1700,
}

func (e SiteConnectionTypeEnum) IsValid() bool {
	switch e {
	case SiteConnectionTypeEnumSocketAWS1500, SiteConnectionTypeEnumSocketAz1500, SiteConnectionTypeEnumSocketEsx1500, SiteConnectionTypeEnumSocketGCP1500, SiteConnectionTypeEnumSocketX1500, SiteConnectionTypeEnumSocketX1600, SiteConnectionTypeEnumSocketX1600Lte, SiteConnectionTypeEnumSocketX1700:
		return true
	}
	return false
}

func (e SiteConnectionTypeEnum) String() string {
	return string(e)
}

func (e *SiteConnectionTypeEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SiteConnectionTypeEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SiteConnectionTypeEnum", str)
	}
	return nil
}

func (e SiteConnectionTypeEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SiteLicenseGroup string

const (
	//  legacy license group
	SiteLicenseGroupAfrica SiteLicenseGroup = "AFRICA"
	//  legacy license group
	SiteLicenseGroupAnz SiteLicenseGroup = "ANZ"
	//  legacy license group
	SiteLicenseGroupApj SiteLicenseGroup = "APJ"
	//  Country with stand-alone licenses (not part of a group)
	SiteLicenseGroupChina SiteLicenseGroup = "CHINA"
	//  legacy license group
	SiteLicenseGroupDubai SiteLicenseGroup = "DUBAI"
	//  legacy license group
	SiteLicenseGroupEurope SiteLicenseGroup = "EUROPE"
	SiteLicenseGroupGroup1 SiteLicenseGroup = "GROUP_1"
	SiteLicenseGroupGroup2 SiteLicenseGroup = "GROUP_2"
	//  legacy license group
	SiteLicenseGroupLatam SiteLicenseGroup = "LATAM"
	//  legacy license group
	SiteLicenseGroupMiddleEast SiteLicenseGroup = "MIDDLE_EAST"
	//  Country with stand-alone licenses (not part of a group)
	SiteLicenseGroupMorocco SiteLicenseGroup = "MOROCCO"
	//  legacy license group
	SiteLicenseGroupNam SiteLicenseGroup = "NAM"
	//  Country with stand-alone licenses (not part of a group)
	SiteLicenseGroupVietnam SiteLicenseGroup = "VIETNAM"
)

var AllSiteLicenseGroup = []SiteLicenseGroup{
	SiteLicenseGroupAfrica,
	SiteLicenseGroupAnz,
	SiteLicenseGroupApj,
	SiteLicenseGroupChina,
	SiteLicenseGroupDubai,
	SiteLicenseGroupEurope,
	SiteLicenseGroupGroup1,
	SiteLicenseGroupGroup2,
	SiteLicenseGroupLatam,
	SiteLicenseGroupMiddleEast,
	SiteLicenseGroupMorocco,
	SiteLicenseGroupNam,
	SiteLicenseGroupVietnam,
}

func (e SiteLicenseGroup) IsValid() bool {
	switch e {
	case SiteLicenseGroupAfrica, SiteLicenseGroupAnz, SiteLicenseGroupApj, SiteLicenseGroupChina, SiteLicenseGroupDubai, SiteLicenseGroupEurope, SiteLicenseGroupGroup1, SiteLicenseGroupGroup2, SiteLicenseGroupLatam, SiteLicenseGroupMiddleEast, SiteLicenseGroupMorocco, SiteLicenseGroupNam, SiteLicenseGroupVietnam:
		return true
	}
	return false
}

func (e SiteLicenseGroup) String() string {
	return string(e)
}

func (e *SiteLicenseGroup) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SiteLicenseGroup(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SiteLicenseGroup", str)
	}
	return nil
}

func (e SiteLicenseGroup) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SiteLicenseType string

const (
	SiteLicenseTypeSase SiteLicenseType = "SASE"
	SiteLicenseTypeSse  SiteLicenseType = "SSE"
)

var AllSiteLicenseType = []SiteLicenseType{
	SiteLicenseTypeSase,
	SiteLicenseTypeSse,
}

func (e SiteLicenseType) IsValid() bool {
	switch e {
	case SiteLicenseTypeSase, SiteLicenseTypeSse:
		return true
	}
	return false
}

func (e SiteLicenseType) String() string {
	return string(e)
}

func (e *SiteLicenseType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SiteLicenseType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SiteLicenseType", str)
	}
	return nil
}

func (e SiteLicenseType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SiteType string

const (
	SiteTypeBranch       SiteType = "BRANCH"
	SiteTypeCloudDc      SiteType = "CLOUD_DC"
	SiteTypeDatacenter   SiteType = "DATACENTER"
	SiteTypeHeadquarters SiteType = "HEADQUARTERS"
)

var AllSiteType = []SiteType{
	SiteTypeBranch,
	SiteTypeCloudDc,
	SiteTypeDatacenter,
	SiteTypeHeadquarters,
}

func (e SiteType) IsValid() bool {
	switch e {
	case SiteTypeBranch, SiteTypeCloudDc, SiteTypeDatacenter, SiteTypeHeadquarters:
		return true
	}
	return false
}

func (e SiteType) String() string {
	return string(e)
}

func (e *SiteType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SiteType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SiteType", str)
	}
	return nil
}

func (e SiteType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SocketAddOnExpansionSlotNumber string

const (
	SocketAddOnExpansionSlotNumberSlot1 SocketAddOnExpansionSlotNumber = "SLOT_1"
	SocketAddOnExpansionSlotNumberSlot2 SocketAddOnExpansionSlotNumber = "SLOT_2"
)

var AllSocketAddOnExpansionSlotNumber = []SocketAddOnExpansionSlotNumber{
	SocketAddOnExpansionSlotNumberSlot1,
	SocketAddOnExpansionSlotNumberSlot2,
}

func (e SocketAddOnExpansionSlotNumber) IsValid() bool {
	switch e {
	case SocketAddOnExpansionSlotNumberSlot1, SocketAddOnExpansionSlotNumberSlot2:
		return true
	}
	return false
}

func (e SocketAddOnExpansionSlotNumber) String() string {
	return string(e)
}

func (e *SocketAddOnExpansionSlotNumber) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SocketAddOnExpansionSlotNumber(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SocketAddOnExpansionSlotNumber", str)
	}
	return nil
}

func (e SocketAddOnExpansionSlotNumber) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SocketAddOnType string

const (
	SocketAddOnTypeFour10gFiber SocketAddOnType = "FOUR_10G_FIBER"
	SocketAddOnTypeFour1gCopper SocketAddOnType = "FOUR_1G_COPPER"
	SocketAddOnTypeTwo10gFiber  SocketAddOnType = "TWO_10G_FIBER"
	SocketAddOnTypeTwo1gFiber   SocketAddOnType = "TWO_1G_FIBER"
)

var AllSocketAddOnType = []SocketAddOnType{
	SocketAddOnTypeFour10gFiber,
	SocketAddOnTypeFour1gCopper,
	SocketAddOnTypeTwo10gFiber,
	SocketAddOnTypeTwo1gFiber,
}

func (e SocketAddOnType) IsValid() bool {
	switch e {
	case SocketAddOnTypeFour10gFiber, SocketAddOnTypeFour1gCopper, SocketAddOnTypeTwo10gFiber, SocketAddOnTypeTwo1gFiber:
		return true
	}
	return false
}

func (e SocketAddOnType) String() string {
	return string(e)
}

func (e *SocketAddOnType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SocketAddOnType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SocketAddOnType", str)
	}
	return nil
}

func (e SocketAddOnType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SocketInterfaceDestType string

const (
	SocketInterfaceDestTypeAlternative         SocketInterfaceDestType = "ALTERNATIVE"
	SocketInterfaceDestTypeCato                SocketInterfaceDestType = "CATO"
	SocketInterfaceDestTypeInterfaceDisabled   SocketInterfaceDestType = "INTERFACE_DISABLED"
	SocketInterfaceDestTypeLan                 SocketInterfaceDestType = "LAN"
	SocketInterfaceDestTypeLanAndHa            SocketInterfaceDestType = "LAN_AND_HA"
	SocketInterfaceDestTypeLanLagMaster        SocketInterfaceDestType = "LAN_LAG_MASTER"
	SocketInterfaceDestTypeLanLagMasterAndVrrp SocketInterfaceDestType = "LAN_LAG_MASTER_AND_VRRP"
	SocketInterfaceDestTypeLanLagMember        SocketInterfaceDestType = "LAN_LAG_MEMBER"
	SocketInterfaceDestTypeLayer2Wan           SocketInterfaceDestType = "LAYER_2_WAN"
	SocketInterfaceDestTypeVrrp                SocketInterfaceDestType = "VRRP"
	SocketInterfaceDestTypeVrrpAndLan          SocketInterfaceDestType = "VRRP_AND_LAN"
)

var AllSocketInterfaceDestType = []SocketInterfaceDestType{
	SocketInterfaceDestTypeAlternative,
	SocketInterfaceDestTypeCato,
	SocketInterfaceDestTypeInterfaceDisabled,
	SocketInterfaceDestTypeLan,
	SocketInterfaceDestTypeLanAndHa,
	SocketInterfaceDestTypeLanLagMaster,
	SocketInterfaceDestTypeLanLagMasterAndVrrp,
	SocketInterfaceDestTypeLanLagMember,
	SocketInterfaceDestTypeLayer2Wan,
	SocketInterfaceDestTypeVrrp,
	SocketInterfaceDestTypeVrrpAndLan,
}

func (e SocketInterfaceDestType) IsValid() bool {
	switch e {
	case SocketInterfaceDestTypeAlternative, SocketInterfaceDestTypeCato, SocketInterfaceDestTypeInterfaceDisabled, SocketInterfaceDestTypeLan, SocketInterfaceDestTypeLanAndHa, SocketInterfaceDestTypeLanLagMaster, SocketInterfaceDestTypeLanLagMasterAndVrrp, SocketInterfaceDestTypeLanLagMember, SocketInterfaceDestTypeLayer2Wan, SocketInterfaceDestTypeVrrp, SocketInterfaceDestTypeVrrpAndLan:
		return true
	}
	return false
}

func (e SocketInterfaceDestType) String() string {
	return string(e)
}

func (e *SocketInterfaceDestType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SocketInterfaceDestType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SocketInterfaceDestType", str)
	}
	return nil
}

func (e SocketInterfaceDestType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// SocketInterface available ids, INT_# stands for 1,2,3...12 supported ids
type SocketInterfaceIDEnum string

const (
	SocketInterfaceIDEnumInt1  SocketInterfaceIDEnum = "INT_1"
	SocketInterfaceIDEnumInt10 SocketInterfaceIDEnum = "INT_10"
	SocketInterfaceIDEnumInt11 SocketInterfaceIDEnum = "INT_11"
	SocketInterfaceIDEnumInt12 SocketInterfaceIDEnum = "INT_12"
	SocketInterfaceIDEnumInt2  SocketInterfaceIDEnum = "INT_2"
	SocketInterfaceIDEnumInt3  SocketInterfaceIDEnum = "INT_3"
	SocketInterfaceIDEnumInt4  SocketInterfaceIDEnum = "INT_4"
	SocketInterfaceIDEnumInt5  SocketInterfaceIDEnum = "INT_5"
	SocketInterfaceIDEnumInt6  SocketInterfaceIDEnum = "INT_6"
	SocketInterfaceIDEnumInt7  SocketInterfaceIDEnum = "INT_7"
	SocketInterfaceIDEnumInt8  SocketInterfaceIDEnum = "INT_8"
	SocketInterfaceIDEnumInt9  SocketInterfaceIDEnum = "INT_9"
	SocketInterfaceIDEnumLan1  SocketInterfaceIDEnum = "LAN1"
	SocketInterfaceIDEnumLan2  SocketInterfaceIDEnum = "LAN2"
	SocketInterfaceIDEnumLte   SocketInterfaceIDEnum = "LTE"
	SocketInterfaceIDEnumUsb1  SocketInterfaceIDEnum = "USB1"
	SocketInterfaceIDEnumUsb2  SocketInterfaceIDEnum = "USB2"
	SocketInterfaceIDEnumWan1  SocketInterfaceIDEnum = "WAN1"
	SocketInterfaceIDEnumWan2  SocketInterfaceIDEnum = "WAN2"
	SocketInterfaceIDEnumWlan  SocketInterfaceIDEnum = "WLAN"
)

var AllSocketInterfaceIDEnum = []SocketInterfaceIDEnum{
	SocketInterfaceIDEnumInt1,
	SocketInterfaceIDEnumInt10,
	SocketInterfaceIDEnumInt11,
	SocketInterfaceIDEnumInt12,
	SocketInterfaceIDEnumInt2,
	SocketInterfaceIDEnumInt3,
	SocketInterfaceIDEnumInt4,
	SocketInterfaceIDEnumInt5,
	SocketInterfaceIDEnumInt6,
	SocketInterfaceIDEnumInt7,
	SocketInterfaceIDEnumInt8,
	SocketInterfaceIDEnumInt9,
	SocketInterfaceIDEnumLan1,
	SocketInterfaceIDEnumLan2,
	SocketInterfaceIDEnumLte,
	SocketInterfaceIDEnumUsb1,
	SocketInterfaceIDEnumUsb2,
	SocketInterfaceIDEnumWan1,
	SocketInterfaceIDEnumWan2,
	SocketInterfaceIDEnumWlan,
}

func (e SocketInterfaceIDEnum) IsValid() bool {
	switch e {
	case SocketInterfaceIDEnumInt1, SocketInterfaceIDEnumInt10, SocketInterfaceIDEnumInt11, SocketInterfaceIDEnumInt12, SocketInterfaceIDEnumInt2, SocketInterfaceIDEnumInt3, SocketInterfaceIDEnumInt4, SocketInterfaceIDEnumInt5, SocketInterfaceIDEnumInt6, SocketInterfaceIDEnumInt7, SocketInterfaceIDEnumInt8, SocketInterfaceIDEnumInt9, SocketInterfaceIDEnumLan1, SocketInterfaceIDEnumLan2, SocketInterfaceIDEnumLte, SocketInterfaceIDEnumUsb1, SocketInterfaceIDEnumUsb2, SocketInterfaceIDEnumWan1, SocketInterfaceIDEnumWan2, SocketInterfaceIDEnumWlan:
		return true
	}
	return false
}

func (e SocketInterfaceIDEnum) String() string {
	return string(e)
}

func (e *SocketInterfaceIDEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SocketInterfaceIDEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SocketInterfaceIDEnum", str)
	}
	return nil
}

func (e SocketInterfaceIDEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SocketInterfacePrecedenceEnum string

const (
	SocketInterfacePrecedenceEnumActive     SocketInterfacePrecedenceEnum = "ACTIVE"
	SocketInterfacePrecedenceEnumLastResort SocketInterfacePrecedenceEnum = "LAST_RESORT"
	SocketInterfacePrecedenceEnumPassive    SocketInterfacePrecedenceEnum = "PASSIVE"
)

var AllSocketInterfacePrecedenceEnum = []SocketInterfacePrecedenceEnum{
	SocketInterfacePrecedenceEnumActive,
	SocketInterfacePrecedenceEnumLastResort,
	SocketInterfacePrecedenceEnumPassive,
}

func (e SocketInterfacePrecedenceEnum) IsValid() bool {
	switch e {
	case SocketInterfacePrecedenceEnumActive, SocketInterfacePrecedenceEnumLastResort, SocketInterfacePrecedenceEnumPassive:
		return true
	}
	return false
}

func (e SocketInterfacePrecedenceEnum) String() string {
	return string(e)
}

func (e *SocketInterfacePrecedenceEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SocketInterfacePrecedenceEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SocketInterfacePrecedenceEnum", str)
	}
	return nil
}

func (e SocketInterfacePrecedenceEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SocketInterfaceRole string

const (
	SocketInterfaceRoleWan1 SocketInterfaceRole = "wan_1"
	SocketInterfaceRoleWan2 SocketInterfaceRole = "wan_2"
	SocketInterfaceRoleWan3 SocketInterfaceRole = "wan_3"
	SocketInterfaceRoleWan4 SocketInterfaceRole = "wan_4"
)

var AllSocketInterfaceRole = []SocketInterfaceRole{
	SocketInterfaceRoleWan1,
	SocketInterfaceRoleWan2,
	SocketInterfaceRoleWan3,
	SocketInterfaceRoleWan4,
}

func (e SocketInterfaceRole) IsValid() bool {
	switch e {
	case SocketInterfaceRoleWan1, SocketInterfaceRoleWan2, SocketInterfaceRoleWan3, SocketInterfaceRoleWan4:
		return true
	}
	return false
}

func (e SocketInterfaceRole) String() string {
	return string(e)
}

func (e *SocketInterfaceRole) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SocketInterfaceRole(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SocketInterfaceRole", str)
	}
	return nil
}

func (e SocketInterfaceRole) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SocketInterfaceWanRole string

const (
	SocketInterfaceWanRoleNone  SocketInterfaceWanRole = "NONE"
	SocketInterfaceWanRoleWan1  SocketInterfaceWanRole = "WAN_1"
	SocketInterfaceWanRoleWan2  SocketInterfaceWanRole = "WAN_2"
	SocketInterfaceWanRoleWan3  SocketInterfaceWanRole = "WAN_3"
	SocketInterfaceWanRoleWan4  SocketInterfaceWanRole = "WAN_4"
	SocketInterfaceWanRolenone  SocketInterfaceWanRole = "none"
	SocketInterfaceWanRolewan_1 SocketInterfaceWanRole = "wan_1"
	SocketInterfaceWanRolewan_2 SocketInterfaceWanRole = "wan_2"
	SocketInterfaceWanRolewan_3 SocketInterfaceWanRole = "wan_3"
	SocketInterfaceWanRolewan_4 SocketInterfaceWanRole = "wan_4"
)

var AllSocketInterfaceWanRole = []SocketInterfaceWanRole{
	SocketInterfaceWanRoleNone,
	SocketInterfaceWanRoleWan1,
	SocketInterfaceWanRoleWan2,
	SocketInterfaceWanRoleWan3,
	SocketInterfaceWanRoleWan4,
	SocketInterfaceWanRolenone,
	SocketInterfaceWanRolewan_1,
	SocketInterfaceWanRolewan_2,
	SocketInterfaceWanRolewan_3,
	SocketInterfaceWanRolewan_4,
}

func (e SocketInterfaceWanRole) IsValid() bool {
	switch e {
	case SocketInterfaceWanRoleNone, SocketInterfaceWanRoleWan1, SocketInterfaceWanRoleWan2, SocketInterfaceWanRoleWan3, SocketInterfaceWanRoleWan4, SocketInterfaceWanRolenone, SocketInterfaceWanRolewan_1, SocketInterfaceWanRolewan_2, SocketInterfaceWanRolewan_3, SocketInterfaceWanRolewan_4:
		return true
	}
	return false
}

func (e SocketInterfaceWanRole) String() string {
	return string(e)
}

func (e *SocketInterfaceWanRole) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SocketInterfaceWanRole(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SocketInterfaceWanRole", str)
	}
	return nil
}

func (e SocketInterfaceWanRole) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SocketInventoryItemStatus string

const (
	SocketInventoryItemStatusConnected SocketInventoryItemStatus = "CONNECTED"
	SocketInventoryItemStatusDelivered SocketInventoryItemStatus = "DELIVERED"
	SocketInventoryItemStatusInstalled SocketInventoryItemStatus = "INSTALLED"
	SocketInventoryItemStatusOrdered   SocketInventoryItemStatus = "ORDERED"
	SocketInventoryItemStatusShipped   SocketInventoryItemStatus = "SHIPPED"
)

var AllSocketInventoryItemStatus = []SocketInventoryItemStatus{
	SocketInventoryItemStatusConnected,
	SocketInventoryItemStatusDelivered,
	SocketInventoryItemStatusInstalled,
	SocketInventoryItemStatusOrdered,
	SocketInventoryItemStatusShipped,
}

func (e SocketInventoryItemStatus) IsValid() bool {
	switch e {
	case SocketInventoryItemStatusConnected, SocketInventoryItemStatusDelivered, SocketInventoryItemStatusInstalled, SocketInventoryItemStatusOrdered, SocketInventoryItemStatusShipped:
		return true
	}
	return false
}

func (e SocketInventoryItemStatus) String() string {
	return string(e)
}

func (e *SocketInventoryItemStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SocketInventoryItemStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SocketInventoryItemStatus", str)
	}
	return nil
}

func (e SocketInventoryItemStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SocketLanDirection string

const (
	//  Specifies two-way direction.
	SocketLanDirectionBoth SocketLanDirection = "BOTH"
	//  Specifies one-way direction.
	SocketLanDirectionTo SocketLanDirection = "TO"
)

var AllSocketLanDirection = []SocketLanDirection{
	SocketLanDirectionBoth,
	SocketLanDirectionTo,
}

func (e SocketLanDirection) IsValid() bool {
	switch e {
	case SocketLanDirectionBoth, SocketLanDirectionTo:
		return true
	}
	return false
}

func (e SocketLanDirection) String() string {
	return string(e)
}

func (e *SocketLanDirection) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SocketLanDirection(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SocketLanDirection", str)
	}
	return nil
}

func (e SocketLanDirection) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SocketLanFirewallAction string

const (
	SocketLanFirewallActionAllow SocketLanFirewallAction = "ALLOW"
	SocketLanFirewallActionBlock SocketLanFirewallAction = "BLOCK"
)

var AllSocketLanFirewallAction = []SocketLanFirewallAction{
	SocketLanFirewallActionAllow,
	SocketLanFirewallActionBlock,
}

func (e SocketLanFirewallAction) IsValid() bool {
	switch e {
	case SocketLanFirewallActionAllow, SocketLanFirewallActionBlock:
		return true
	}
	return false
}

func (e SocketLanFirewallAction) String() string {
	return string(e)
}

func (e *SocketLanFirewallAction) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SocketLanFirewallAction(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SocketLanFirewallAction", str)
	}
	return nil
}

func (e SocketLanFirewallAction) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SocketLanFirewallDirection string

const (
	//  Specifies two-way direction.
	SocketLanFirewallDirectionBoth SocketLanFirewallDirection = "BOTH"
	//  Specifies one-way direction.
	SocketLanFirewallDirectionTo SocketLanFirewallDirection = "TO"
)

var AllSocketLanFirewallDirection = []SocketLanFirewallDirection{
	SocketLanFirewallDirectionBoth,
	SocketLanFirewallDirectionTo,
}

func (e SocketLanFirewallDirection) IsValid() bool {
	switch e {
	case SocketLanFirewallDirectionBoth, SocketLanFirewallDirectionTo:
		return true
	}
	return false
}

func (e SocketLanFirewallDirection) String() string {
	return string(e)
}

func (e *SocketLanFirewallDirection) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SocketLanFirewallDirection(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SocketLanFirewallDirection", str)
	}
	return nil
}

func (e SocketLanFirewallDirection) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SocketLanNatType string

const (
	SocketLanNatTypeDynamicPat SocketLanNatType = "DYNAMIC_PAT"
)

var AllSocketLanNatType = []SocketLanNatType{
	SocketLanNatTypeDynamicPat,
}

func (e SocketLanNatType) IsValid() bool {
	switch e {
	case SocketLanNatTypeDynamicPat:
		return true
	}
	return false
}

func (e SocketLanNatType) String() string {
	return string(e)
}

func (e *SocketLanNatType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SocketLanNatType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SocketLanNatType", str)
	}
	return nil
}

func (e SocketLanNatType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SocketLanTransportType string

const (
	//  Specifies LAN transport type, routed locally for  inspection of LAN Firewall.
	SocketLanTransportTypeLan SocketLanTransportType = "LAN"
	//  Specifies WAN transport type, send to the PoP for inspection of WAN Firewall.
	SocketLanTransportTypeWan SocketLanTransportType = "WAN"
)

var AllSocketLanTransportType = []SocketLanTransportType{
	SocketLanTransportTypeLan,
	SocketLanTransportTypeWan,
}

func (e SocketLanTransportType) IsValid() bool {
	switch e {
	case SocketLanTransportTypeLan, SocketLanTransportTypeWan:
		return true
	}
	return false
}

func (e SocketLanTransportType) String() string {
	return string(e)
}

func (e *SocketLanTransportType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SocketLanTransportType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SocketLanTransportType", str)
	}
	return nil
}

func (e SocketLanTransportType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SocketModel string

const (
	SocketModelAWS      SocketModel = "AWS"
	SocketModelAzure    SocketModel = "AZURE"
	SocketModelEsx      SocketModel = "ESX"
	SocketModelGCP      SocketModel = "GCP"
	SocketModelX1500    SocketModel = "X1500"
	SocketModelX1600    SocketModel = "X1600"
	SocketModelX1600Lte SocketModel = "X1600_LTE"
	SocketModelX1700    SocketModel = "X1700"
)

var AllSocketModel = []SocketModel{
	SocketModelAWS,
	SocketModelAzure,
	SocketModelEsx,
	SocketModelGCP,
	SocketModelX1500,
	SocketModelX1600,
	SocketModelX1600Lte,
	SocketModelX1700,
}

func (e SocketModel) IsValid() bool {
	switch e {
	case SocketModelAWS, SocketModelAzure, SocketModelEsx, SocketModelGCP, SocketModelX1500, SocketModelX1600, SocketModelX1600Lte, SocketModelX1700:
		return true
	}
	return false
}

func (e SocketModel) String() string {
	return string(e)
}

func (e *SocketModel) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SocketModel(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SocketModel", str)
	}
	return nil
}

func (e SocketModel) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SocketPlatform string

const (
	SocketPlatformAWS1500   SocketPlatform = "AWS1500"
	SocketPlatformAz1500    SocketPlatform = "AZ1500"
	SocketPlatformEsx1500   SocketPlatform = "ESX1500"
	SocketPlatformGCP1500   SocketPlatform = "GCP1500"
	SocketPlatformX1500     SocketPlatform = "X1500"
	SocketPlatformX1500bBr2 SocketPlatform = "X1500B_BR2"
	SocketPlatformX1500Br2  SocketPlatform = "X1500_BR2"
	SocketPlatformX1600     SocketPlatform = "X1600"
	SocketPlatformX1600_5g  SocketPlatform = "X1600_5G"
	SocketPlatformX1600Lte  SocketPlatform = "X1600_LTE"
	SocketPlatformX1700     SocketPlatform = "X1700"
	SocketPlatformX1700b    SocketPlatform = "X1700B"
)

var AllSocketPlatform = []SocketPlatform{
	SocketPlatformAWS1500,
	SocketPlatformAz1500,
	SocketPlatformEsx1500,
	SocketPlatformGCP1500,
	SocketPlatformX1500,
	SocketPlatformX1500bBr2,
	SocketPlatformX1500Br2,
	SocketPlatformX1600,
	SocketPlatformX1600_5g,
	SocketPlatformX1600Lte,
	SocketPlatformX1700,
	SocketPlatformX1700b,
}

func (e SocketPlatform) IsValid() bool {
	switch e {
	case SocketPlatformAWS1500, SocketPlatformAz1500, SocketPlatformEsx1500, SocketPlatformGCP1500, SocketPlatformX1500, SocketPlatformX1500bBr2, SocketPlatformX1500Br2, SocketPlatformX1600, SocketPlatformX1600_5g, SocketPlatformX1600Lte, SocketPlatformX1700, SocketPlatformX1700b:
		return true
	}
	return false
}

func (e SocketPlatform) String() string {
	return string(e)
}

func (e *SocketPlatform) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SocketPlatform(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SocketPlatform", str)
	}
	return nil
}

func (e SocketPlatform) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SocketPortMetricsFieldName string

const (
	//  Unique identifier of the account that owns the site.
	SocketPortMetricsFieldNameAccountID SocketPortMetricsFieldName = "account_id"
	//  Total bytes received downstream (from the network to the device).
	SocketPortMetricsFieldNameBytesDownstream SocketPortMetricsFieldName = "bytes_downstream"
	//  Combined total of upstream and downstream bytes.
	SocketPortMetricsFieldNameBytesTotal SocketPortMetricsFieldName = "bytes_total"
	//  Total bytes sent upstream (from the device to the network).
	SocketPortMetricsFieldNameBytesUpstream SocketPortMetricsFieldName = "bytes_upstream"
	//  Reference Signal Received Power  measures LTE/5G signal strength (dBm).
	SocketPortMetricsFieldNameCellularRsrp SocketPortMetricsFieldName = "cellular_rsrp"
	//  Reference Signal Received Quality  a key LTE/5G metric for link quality (dB).
	SocketPortMetricsFieldNameCellularRsrq SocketPortMetricsFieldName = "cellular_rsrq"
	//  Received Signal Strength Indicator  legacy strength metric (dBm).
	SocketPortMetricsFieldNameCellularRssi SocketPortMetricsFieldName = "cellular_rssi"
	//  Generic signal strength indicator (often maps to bars or percentage).
	SocketPortMetricsFieldNameCellularSignalStrength SocketPortMetricsFieldName = "cellular_signal_strength"
	//  Signal to Interference + Noise Ratio  LTE/5G metric for signal clarity (dB).
	SocketPortMetricsFieldNameCellularSinr SocketPortMetricsFieldName = "cellular_sinr"
	//  Unique identifier of the Socket (Cato edge device).
	SocketPortMetricsFieldNameDeviceID SocketPortMetricsFieldName = "device_id"
	//  Indicates the high-availability (HA) role of the device (e.g., active, standby).
	SocketPortMetricsFieldNameHaRole SocketPortMetricsFieldName = "ha_role"
	//  Type of physical interface (e.g., ethernet, cellular).
	SocketPortMetricsFieldNamePhysicalInterfaceType SocketPortMetricsFieldName = "physical_interface_type"
	//  SIM card number (for cellular interfaces).
	SocketPortMetricsFieldNameSimNum SocketPortMetricsFieldName = "sim_num"
	//  Unique identifier of the site where the socket is deployed.
	SocketPortMetricsFieldNameSiteID SocketPortMetricsFieldName = "site_id"
	//  Human-readable name of the site.
	SocketPortMetricsFieldNameSiteName SocketPortMetricsFieldName = "site_name"
	//  The name or ID of the physical or logical interface on the Socket device (e.g., eth0, cell1).
	SocketPortMetricsFieldNameSocketInterface SocketPortMetricsFieldName = "socket_interface"
	//  Describes the interface role such as primary, backup, cellular, or none.
	SocketPortMetricsFieldNameSocketInterfaceRole SocketPortMetricsFieldName = "socket_interface_role"
	//  Current download throughput in Mbps.
	SocketPortMetricsFieldNameThroughputDownstream SocketPortMetricsFieldName = "throughput_downstream"
	//  Current upload throughput in Mbps.
	SocketPortMetricsFieldNameThroughputUpstream SocketPortMetricsFieldName = "throughput_upstream"
	//  Type of transport used by the interface (e.g., wired, lte, 5g, wifi).
	SocketPortMetricsFieldNameTransportType SocketPortMetricsFieldName = "transport_type"
)

var AllSocketPortMetricsFieldName = []SocketPortMetricsFieldName{
	SocketPortMetricsFieldNameAccountID,
	SocketPortMetricsFieldNameBytesDownstream,
	SocketPortMetricsFieldNameBytesTotal,
	SocketPortMetricsFieldNameBytesUpstream,
	SocketPortMetricsFieldNameCellularRsrp,
	SocketPortMetricsFieldNameCellularRsrq,
	SocketPortMetricsFieldNameCellularRssi,
	SocketPortMetricsFieldNameCellularSignalStrength,
	SocketPortMetricsFieldNameCellularSinr,
	SocketPortMetricsFieldNameDeviceID,
	SocketPortMetricsFieldNameHaRole,
	SocketPortMetricsFieldNamePhysicalInterfaceType,
	SocketPortMetricsFieldNameSimNum,
	SocketPortMetricsFieldNameSiteID,
	SocketPortMetricsFieldNameSiteName,
	SocketPortMetricsFieldNameSocketInterface,
	SocketPortMetricsFieldNameSocketInterfaceRole,
	SocketPortMetricsFieldNameThroughputDownstream,
	SocketPortMetricsFieldNameThroughputUpstream,
	SocketPortMetricsFieldNameTransportType,
}

func (e SocketPortMetricsFieldName) IsValid() bool {
	switch e {
	case SocketPortMetricsFieldNameAccountID, SocketPortMetricsFieldNameBytesDownstream, SocketPortMetricsFieldNameBytesTotal, SocketPortMetricsFieldNameBytesUpstream, SocketPortMetricsFieldNameCellularRsrp, SocketPortMetricsFieldNameCellularRsrq, SocketPortMetricsFieldNameCellularRssi, SocketPortMetricsFieldNameCellularSignalStrength, SocketPortMetricsFieldNameCellularSinr, SocketPortMetricsFieldNameDeviceID, SocketPortMetricsFieldNameHaRole, SocketPortMetricsFieldNamePhysicalInterfaceType, SocketPortMetricsFieldNameSimNum, SocketPortMetricsFieldNameSiteID, SocketPortMetricsFieldNameSiteName, SocketPortMetricsFieldNameSocketInterface, SocketPortMetricsFieldNameSocketInterfaceRole, SocketPortMetricsFieldNameThroughputDownstream, SocketPortMetricsFieldNameThroughputUpstream, SocketPortMetricsFieldNameTransportType:
		return true
	}
	return false
}

func (e SocketPortMetricsFieldName) String() string {
	return string(e)
}

func (e *SocketPortMetricsFieldName) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SocketPortMetricsFieldName(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SocketPortMetricsFieldName", str)
	}
	return nil
}

func (e SocketPortMetricsFieldName) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SocketRegistrationStatus string

const (
	SocketRegistrationStatusAssignedSite                SocketRegistrationStatus = "ASSIGNED_SITE"
	SocketRegistrationStatusAssignedSitePendingRegister SocketRegistrationStatus = "ASSIGNED_SITE_PENDING_REGISTER"
	SocketRegistrationStatusNew                         SocketRegistrationStatus = "NEW"
	SocketRegistrationStatusPending                     SocketRegistrationStatus = "PENDING"
	SocketRegistrationStatusRegistered                  SocketRegistrationStatus = "REGISTERED"
	SocketRegistrationStatusRejected                    SocketRegistrationStatus = "REJECTED"
	SocketRegistrationStatusUnassigning                 SocketRegistrationStatus = "UNASSIGNING"
)

var AllSocketRegistrationStatus = []SocketRegistrationStatus{
	SocketRegistrationStatusAssignedSite,
	SocketRegistrationStatusAssignedSitePendingRegister,
	SocketRegistrationStatusNew,
	SocketRegistrationStatusPending,
	SocketRegistrationStatusRegistered,
	SocketRegistrationStatusRejected,
	SocketRegistrationStatusUnassigning,
}

func (e SocketRegistrationStatus) IsValid() bool {
	switch e {
	case SocketRegistrationStatusAssignedSite, SocketRegistrationStatusAssignedSitePendingRegister, SocketRegistrationStatusNew, SocketRegistrationStatusPending, SocketRegistrationStatusRegistered, SocketRegistrationStatusRejected, SocketRegistrationStatusUnassigning:
		return true
	}
	return false
}

func (e SocketRegistrationStatus) String() string {
	return string(e)
}

func (e *SocketRegistrationStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SocketRegistrationStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SocketRegistrationStatus", str)
	}
	return nil
}

func (e SocketRegistrationStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SocketUpgradeStatus string

const (
	SocketUpgradeStatusCancel        SocketUpgradeStatus = "CANCEL"
	SocketUpgradeStatusFail          SocketUpgradeStatus = "FAIL"
	SocketUpgradeStatusFatal         SocketUpgradeStatus = "FATAL"
	SocketUpgradeStatusPending       SocketUpgradeStatus = "PENDING"
	SocketUpgradeStatusPendingReboot SocketUpgradeStatus = "PENDING_REBOOT"
	SocketUpgradeStatusRetry         SocketUpgradeStatus = "RETRY"
	SocketUpgradeStatusSkip          SocketUpgradeStatus = "SKIP"
	SocketUpgradeStatusStarted       SocketUpgradeStatus = "STARTED"
	SocketUpgradeStatusStarting      SocketUpgradeStatus = "STARTING"
	SocketUpgradeStatusSuccess       SocketUpgradeStatus = "SUCCESS"
)

var AllSocketUpgradeStatus = []SocketUpgradeStatus{
	SocketUpgradeStatusCancel,
	SocketUpgradeStatusFail,
	SocketUpgradeStatusFatal,
	SocketUpgradeStatusPending,
	SocketUpgradeStatusPendingReboot,
	SocketUpgradeStatusRetry,
	SocketUpgradeStatusSkip,
	SocketUpgradeStatusStarted,
	SocketUpgradeStatusStarting,
	SocketUpgradeStatusSuccess,
}

func (e SocketUpgradeStatus) IsValid() bool {
	switch e {
	case SocketUpgradeStatusCancel, SocketUpgradeStatusFail, SocketUpgradeStatusFatal, SocketUpgradeStatusPending, SocketUpgradeStatusPendingReboot, SocketUpgradeStatusRetry, SocketUpgradeStatusSkip, SocketUpgradeStatusStarted, SocketUpgradeStatusStarting, SocketUpgradeStatusSuccess:
		return true
	}
	return false
}

func (e SocketUpgradeStatus) String() string {
	return string(e)
}

func (e *SocketUpgradeStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SocketUpgradeStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SocketUpgradeStatus", str)
	}
	return nil
}

func (e SocketUpgradeStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SortDirectionEnum string

const (
	SortDirectionEnumAsc  SortDirectionEnum = "asc"
	SortDirectionEnumDesc SortDirectionEnum = "desc"
)

var AllSortDirectionEnum = []SortDirectionEnum{
	SortDirectionEnumAsc,
	SortDirectionEnumDesc,
}

func (e SortDirectionEnum) IsValid() bool {
	switch e {
	case SortDirectionEnumAsc, SortDirectionEnumDesc:
		return true
	}
	return false
}

func (e SortDirectionEnum) String() string {
	return string(e)
}

func (e *SortDirectionEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SortDirectionEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SortDirectionEnum", str)
	}
	return nil
}

func (e SortDirectionEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SortOrder string

const (
	SortOrderAsc  SortOrder = "ASC"
	SortOrderDesc SortOrder = "DESC"
)

var AllSortOrder = []SortOrder{
	SortOrderAsc,
	SortOrderDesc,
}

func (e SortOrder) IsValid() bool {
	switch e {
	case SortOrderAsc, SortOrderDesc:
		return true
	}
	return false
}

func (e SortOrder) String() string {
	return string(e)
}

func (e *SortOrder) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SortOrder(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SortOrder", str)
	}
	return nil
}

func (e SortOrder) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type StoryEngineTypeEnum string

const (
	StoryEngineTypeEnumAnomaly  StoryEngineTypeEnum = "ANOMALY"
	StoryEngineTypeEnumEndpoint StoryEngineTypeEnum = "ENDPOINT"
	StoryEngineTypeEnumIdentity StoryEngineTypeEnum = "IDENTITY"
	StoryEngineTypeEnumNetwork  StoryEngineTypeEnum = "NETWORK"
	StoryEngineTypeEnumThreat   StoryEngineTypeEnum = "THREAT"
)

var AllStoryEngineTypeEnum = []StoryEngineTypeEnum{
	StoryEngineTypeEnumAnomaly,
	StoryEngineTypeEnumEndpoint,
	StoryEngineTypeEnumIdentity,
	StoryEngineTypeEnumNetwork,
	StoryEngineTypeEnumThreat,
}

func (e StoryEngineTypeEnum) IsValid() bool {
	switch e {
	case StoryEngineTypeEnumAnomaly, StoryEngineTypeEnumEndpoint, StoryEngineTypeEnumIdentity, StoryEngineTypeEnumNetwork, StoryEngineTypeEnumThreat:
		return true
	}
	return false
}

func (e StoryEngineTypeEnum) String() string {
	return string(e)
}

func (e *StoryEngineTypeEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StoryEngineTypeEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StoryEngineTypeEnum", str)
	}
	return nil
}

func (e StoryEngineTypeEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type StoryProducerEnum string

const (
	StoryProducerEnumAnomalyEvents             StoryProducerEnum = "AnomalyEvents"
	StoryProducerEnumAnomalyExperience         StoryProducerEnum = "AnomalyExperience"
	StoryProducerEnumAnomalyStats              StoryProducerEnum = "AnomalyStats"
	StoryProducerEnumCatoEndpointAlert         StoryProducerEnum = "CatoEndpointAlert"
	StoryProducerEnumEntraIDAlert              StoryProducerEnum = "EntraIdAlert"
	StoryProducerEnumMicrosoftEndpointDefender StoryProducerEnum = "MicrosoftEndpointDefender"
	StoryProducerEnumNetworkMonitor            StoryProducerEnum = "NetworkMonitor"
	//  The producer of the Site Operations stories
	StoryProducerEnumNetworkXdr       StoryProducerEnum = "NetworkXDR"
	StoryProducerEnumThreatHunt       StoryProducerEnum = "ThreatHunt"
	StoryProducerEnumThreatPrevention StoryProducerEnum = "ThreatPrevention"
)

var AllStoryProducerEnum = []StoryProducerEnum{
	StoryProducerEnumAnomalyEvents,
	StoryProducerEnumAnomalyExperience,
	StoryProducerEnumAnomalyStats,
	StoryProducerEnumCatoEndpointAlert,
	StoryProducerEnumEntraIDAlert,
	StoryProducerEnumMicrosoftEndpointDefender,
	StoryProducerEnumNetworkMonitor,
	StoryProducerEnumNetworkXdr,
	StoryProducerEnumThreatHunt,
	StoryProducerEnumThreatPrevention,
}

func (e StoryProducerEnum) IsValid() bool {
	switch e {
	case StoryProducerEnumAnomalyEvents, StoryProducerEnumAnomalyExperience, StoryProducerEnumAnomalyStats, StoryProducerEnumCatoEndpointAlert, StoryProducerEnumEntraIDAlert, StoryProducerEnumMicrosoftEndpointDefender, StoryProducerEnumNetworkMonitor, StoryProducerEnumNetworkXdr, StoryProducerEnumThreatHunt, StoryProducerEnumThreatPrevention:
		return true
	}
	return false
}

func (e StoryProducerEnum) String() string {
	return string(e)
}

func (e *StoryProducerEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StoryProducerEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StoryProducerEnum", str)
	}
	return nil
}

func (e StoryProducerEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type StorySortFieldName string

const (
	StorySortFieldNameAccountName StorySortFieldName = "accountName"
	StorySortFieldNameCreatedAt   StorySortFieldName = "createdAt"
	StorySortFieldNameCriticality StorySortFieldName = "criticality"
	StorySortFieldNameEngineType  StorySortFieldName = "engineType"
	StorySortFieldNameFirstSignal StorySortFieldName = "firstSignal"
	StorySortFieldNameProducer    StorySortFieldName = "producer"
	StorySortFieldNameQueryName   StorySortFieldName = "queryName"
	StorySortFieldNameRiskScore   StorySortFieldName = "riskScore"
	StorySortFieldNameSeverity    StorySortFieldName = "severity"
	StorySortFieldNameSource      StorySortFieldName = "source"
	StorySortFieldNameSourceIP    StorySortFieldName = "sourceIp"
	StorySortFieldNameStatus      StorySortFieldName = "status"
	StorySortFieldNameUpdatedAt   StorySortFieldName = "updatedAt"
)

var AllStorySortFieldName = []StorySortFieldName{
	StorySortFieldNameAccountName,
	StorySortFieldNameCreatedAt,
	StorySortFieldNameCriticality,
	StorySortFieldNameEngineType,
	StorySortFieldNameFirstSignal,
	StorySortFieldNameProducer,
	StorySortFieldNameQueryName,
	StorySortFieldNameRiskScore,
	StorySortFieldNameSeverity,
	StorySortFieldNameSource,
	StorySortFieldNameSourceIP,
	StorySortFieldNameStatus,
	StorySortFieldNameUpdatedAt,
}

func (e StorySortFieldName) IsValid() bool {
	switch e {
	case StorySortFieldNameAccountName, StorySortFieldNameCreatedAt, StorySortFieldNameCriticality, StorySortFieldNameEngineType, StorySortFieldNameFirstSignal, StorySortFieldNameProducer, StorySortFieldNameQueryName, StorySortFieldNameRiskScore, StorySortFieldNameSeverity, StorySortFieldNameSource, StorySortFieldNameSourceIP, StorySortFieldNameStatus, StorySortFieldNameUpdatedAt:
		return true
	}
	return false
}

func (e StorySortFieldName) String() string {
	return string(e)
}

func (e *StorySortFieldName) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StorySortFieldName(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StorySortFieldName", str)
	}
	return nil
}

func (e StorySortFieldName) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type StoryStatusEnum string

const (
	StoryStatusEnumClosed          StoryStatusEnum = "Closed"
	StoryStatusEnumMonitoring      StoryStatusEnum = "Monitoring"
	StoryStatusEnumOpen            StoryStatusEnum = "Open"
	StoryStatusEnumPendingAnalysis StoryStatusEnum = "PendingAnalysis"
	StoryStatusEnumPendingMoreInfo StoryStatusEnum = "PendingMoreInfo"
	StoryStatusEnumReopened        StoryStatusEnum = "Reopened"
)

var AllStoryStatusEnum = []StoryStatusEnum{
	StoryStatusEnumClosed,
	StoryStatusEnumMonitoring,
	StoryStatusEnumOpen,
	StoryStatusEnumPendingAnalysis,
	StoryStatusEnumPendingMoreInfo,
	StoryStatusEnumReopened,
}

func (e StoryStatusEnum) IsValid() bool {
	switch e {
	case StoryStatusEnumClosed, StoryStatusEnumMonitoring, StoryStatusEnumOpen, StoryStatusEnumPendingAnalysis, StoryStatusEnumPendingMoreInfo, StoryStatusEnumReopened:
		return true
	}
	return false
}

func (e StoryStatusEnum) String() string {
	return string(e)
}

func (e *StoryStatusEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StoryStatusEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StoryStatusEnum", str)
	}
	return nil
}

func (e StoryStatusEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type StoryVerdictEnum string

const (
	StoryVerdictEnumBenign        StoryVerdictEnum = "Benign"
	StoryVerdictEnumInformational StoryVerdictEnum = "Informational"
	StoryVerdictEnumMalicious     StoryVerdictEnum = "Malicious"
	StoryVerdictEnumSuspicious    StoryVerdictEnum = "Suspicious"
)

var AllStoryVerdictEnum = []StoryVerdictEnum{
	StoryVerdictEnumBenign,
	StoryVerdictEnumInformational,
	StoryVerdictEnumMalicious,
	StoryVerdictEnumSuspicious,
}

func (e StoryVerdictEnum) IsValid() bool {
	switch e {
	case StoryVerdictEnumBenign, StoryVerdictEnumInformational, StoryVerdictEnumMalicious, StoryVerdictEnumSuspicious:
		return true
	}
	return false
}

func (e StoryVerdictEnum) String() string {
	return string(e)
}

func (e *StoryVerdictEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StoryVerdictEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StoryVerdictEnum", str)
	}
	return nil
}

func (e StoryVerdictEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SubnetType string

const (
	SubnetTypeDirect          SubnetType = "Direct"
	SubnetTypeNative          SubnetType = "Native"
	SubnetTypeRouted          SubnetType = "Routed"
	SubnetTypeSecondaryNative SubnetType = "SecondaryNative"
	SubnetTypeVlan            SubnetType = "VLAN"
)

var AllSubnetType = []SubnetType{
	SubnetTypeDirect,
	SubnetTypeNative,
	SubnetTypeRouted,
	SubnetTypeSecondaryNative,
	SubnetTypeVlan,
}

func (e SubnetType) IsValid() bool {
	switch e {
	case SubnetTypeDirect, SubnetTypeNative, SubnetTypeRouted, SubnetTypeSecondaryNative, SubnetTypeVlan:
		return true
	}
	return false
}

func (e SubnetType) String() string {
	return string(e)
}

func (e *SubnetType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SubnetType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SubnetType", str)
	}
	return nil
}

func (e SubnetType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TaggingMethod string

const (
	TaggingMethodDot1q TaggingMethod = "DOT1Q"
	TaggingMethodQinq  TaggingMethod = "QINQ"
)

var AllTaggingMethod = []TaggingMethod{
	TaggingMethodDot1q,
	TaggingMethodQinq,
}

func (e TaggingMethod) IsValid() bool {
	switch e {
	case TaggingMethodDot1q, TaggingMethodQinq:
		return true
	}
	return false
}

func (e TaggingMethod) String() string {
	return string(e)
}

func (e *TaggingMethod) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TaggingMethod(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TaggingMethod", str)
	}
	return nil
}

func (e TaggingMethod) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TargetType string

const (
	TargetTypeDomain TargetType = "domain"
	TargetTypeFqdn   TargetType = "fqdn"
	TargetTypeIP     TargetType = "ip"
	TargetTypeURL    TargetType = "url"
)

var AllTargetType = []TargetType{
	TargetTypeDomain,
	TargetTypeFqdn,
	TargetTypeIP,
	TargetTypeURL,
}

func (e TargetType) IsValid() bool {
	switch e {
	case TargetTypeDomain, TargetTypeFqdn, TargetTypeIP, TargetTypeURL:
		return true
	}
	return false
}

func (e TargetType) String() string {
	return string(e)
}

func (e *TargetType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TargetType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TargetType", str)
	}
	return nil
}

func (e TargetType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TimeFrameModifier string

const (
	TimeFrameModifierAnalystUpdate TimeFrameModifier = "AnalystUpdate"
	TimeFrameModifierStoryCreate   TimeFrameModifier = "StoryCreate"
	TimeFrameModifierStoryUpdate   TimeFrameModifier = "StoryUpdate"
)

var AllTimeFrameModifier = []TimeFrameModifier{
	TimeFrameModifierAnalystUpdate,
	TimeFrameModifierStoryCreate,
	TimeFrameModifierStoryUpdate,
}

func (e TimeFrameModifier) IsValid() bool {
	switch e {
	case TimeFrameModifierAnalystUpdate, TimeFrameModifierStoryCreate, TimeFrameModifierStoryUpdate:
		return true
	}
	return false
}

func (e TimeFrameModifier) String() string {
	return string(e)
}

func (e *TimeFrameModifier) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TimeFrameModifier(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TimeFrameModifier", str)
	}
	return nil
}

func (e TimeFrameModifier) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TimelineItemCategoryEnum string

const (
	TimelineItemCategoryEnumError       TimelineItemCategoryEnum = "Error"
	TimelineItemCategoryEnumInformation TimelineItemCategoryEnum = "Information"
	TimelineItemCategoryEnumWarning     TimelineItemCategoryEnum = "Warning"
)

var AllTimelineItemCategoryEnum = []TimelineItemCategoryEnum{
	TimelineItemCategoryEnumError,
	TimelineItemCategoryEnumInformation,
	TimelineItemCategoryEnumWarning,
}

func (e TimelineItemCategoryEnum) IsValid() bool {
	switch e {
	case TimelineItemCategoryEnumError, TimelineItemCategoryEnumInformation, TimelineItemCategoryEnumWarning:
		return true
	}
	return false
}

func (e TimelineItemCategoryEnum) String() string {
	return string(e)
}

func (e *TimelineItemCategoryEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TimelineItemCategoryEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TimelineItemCategoryEnum", str)
	}
	return nil
}

func (e TimelineItemCategoryEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TimelineTypeEnum string

const (
	TimelineTypeEnumAction  TimelineTypeEnum = "Action"
	TimelineTypeEnumComment TimelineTypeEnum = "Comment"
	TimelineTypeEnumDiff    TimelineTypeEnum = "Diff"
)

var AllTimelineTypeEnum = []TimelineTypeEnum{
	TimelineTypeEnumAction,
	TimelineTypeEnumComment,
	TimelineTypeEnumDiff,
}

func (e TimelineTypeEnum) IsValid() bool {
	switch e {
	case TimelineTypeEnumAction, TimelineTypeEnumComment, TimelineTypeEnumDiff:
		return true
	}
	return false
}

func (e TimelineTypeEnum) String() string {
	return string(e)
}

func (e *TimelineTypeEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TimelineTypeEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TimelineTypeEnum", str)
	}
	return nil
}

func (e TimelineTypeEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TimeseriesMetricType string

const (
	//  Total avg downstream traffic (from the Cato Cloud to the site)
	TimeseriesMetricTypeBytesDownstream TimeseriesMetricType = "bytesDownstream"
	//  Total max downstream traffic (from the site to the Cato Cloud)
	TimeseriesMetricTypeBytesDownstreamMax TimeseriesMetricType = "bytesDownstreamMax"
	//  Total number of bytes of upstream and downstream traffic
	TimeseriesMetricTypeBytesTotal TimeseriesMetricType = "bytesTotal"
	//  Total avg upstream traffic (from the site to the Cato Cloud)
	TimeseriesMetricTypeBytesUpstream TimeseriesMetricType = "bytesUpstream"
	//  Total max upstream traffic (from the site to the Cato Cloud)
	TimeseriesMetricTypeBytesUpstreamMax TimeseriesMetricType = "bytesUpstreamMax"
	//  Health analytics for the site
	TimeseriesMetricTypeHealth TimeseriesMetricType = "health"
	//  Jitter for downstream traffic (difference in time delay in milliseconds (ms) between data packets)
	TimeseriesMetricTypeJitterDownstream TimeseriesMetricType = "jitterDownstream"
	//  Jitter for upstream traffic (difference in time delay in milliseconds (ms) between data packets)
	TimeseriesMetricTypeJitterUpstream TimeseriesMetricType = "jitterUpstream"
	// Latency from socket directly to a well known global service, not through Cato. This is used to measure last
	// mile provider's performance, independent of the service.
	TimeseriesMetricTypeLastMileLatency TimeseriesMetricType = "lastMileLatency"
	// Packet loss from socket directly to a well known global services, not through Cato This is used to measure last
	// mile provider's performance, independent of the service.
	TimeseriesMetricTypeLastMilePacketLoss TimeseriesMetricType = "lastMilePacketLoss"
	//  Number of packets lost for downstream traffic
	TimeseriesMetricTypeLostDownstream TimeseriesMetricType = "lostDownstream"
	//  Percent of packet loss for downstream traffic
	TimeseriesMetricTypeLostDownstreamPcnt TimeseriesMetricType = "lostDownstreamPcnt"
	//  Number of packets lost for upstream traffic
	TimeseriesMetricTypeLostUpstream TimeseriesMetricType = "lostUpstream"
	//  Percent of packet loss for upstream traffic
	TimeseriesMetricTypeLostUpstreamPcnt TimeseriesMetricType = "lostUpstreamPcnt"
	//  Total packets discarded for downstream traffic
	TimeseriesMetricTypePacketsDiscardedDownstream TimeseriesMetricType = "packetsDiscardedDownstream"
	//  Percent packets discarded for downstream traffic
	TimeseriesMetricTypePacketsDiscardedDownstreamPcnt TimeseriesMetricType = "packetsDiscardedDownstreamPcnt"
	//  Total packets discarded for upstream traffic
	TimeseriesMetricTypePacketsDiscardedUpstream TimeseriesMetricType = "packetsDiscardedUpstream"
	//  Percent packets discarded for upstream traffic
	TimeseriesMetricTypePacketsDiscardedUpstreamPcnt TimeseriesMetricType = "packetsDiscardedUpstreamPcnt"
	//  Total downstream packets
	TimeseriesMetricTypePacketsDownstream TimeseriesMetricType = "packetsDownstream"
	//  Total upstream packets
	TimeseriesMetricTypePacketsUpstream TimeseriesMetricType = "packetsUpstream"
	//  Round-trip time from the Socket to the Cato Cloud
	TimeseriesMetricTypeRtt TimeseriesMetricType = "rtt"
	//  The age of the physical tunnel in milliseconds (It is zeroed even on transparent reconnect)
	TimeseriesMetricTypeTunnelAge TimeseriesMetricType = "tunnelAge"
)

var AllTimeseriesMetricType = []TimeseriesMetricType{
	TimeseriesMetricTypeBytesDownstream,
	TimeseriesMetricTypeBytesDownstreamMax,
	TimeseriesMetricTypeBytesTotal,
	TimeseriesMetricTypeBytesUpstream,
	TimeseriesMetricTypeBytesUpstreamMax,
	TimeseriesMetricTypeHealth,
	TimeseriesMetricTypeJitterDownstream,
	TimeseriesMetricTypeJitterUpstream,
	TimeseriesMetricTypeLastMileLatency,
	TimeseriesMetricTypeLastMilePacketLoss,
	TimeseriesMetricTypeLostDownstream,
	TimeseriesMetricTypeLostDownstreamPcnt,
	TimeseriesMetricTypeLostUpstream,
	TimeseriesMetricTypeLostUpstreamPcnt,
	TimeseriesMetricTypePacketsDiscardedDownstream,
	TimeseriesMetricTypePacketsDiscardedDownstreamPcnt,
	TimeseriesMetricTypePacketsDiscardedUpstream,
	TimeseriesMetricTypePacketsDiscardedUpstreamPcnt,
	TimeseriesMetricTypePacketsDownstream,
	TimeseriesMetricTypePacketsUpstream,
	TimeseriesMetricTypeRtt,
	TimeseriesMetricTypeTunnelAge,
}

func (e TimeseriesMetricType) IsValid() bool {
	switch e {
	case TimeseriesMetricTypeBytesDownstream, TimeseriesMetricTypeBytesDownstreamMax, TimeseriesMetricTypeBytesTotal, TimeseriesMetricTypeBytesUpstream, TimeseriesMetricTypeBytesUpstreamMax, TimeseriesMetricTypeHealth, TimeseriesMetricTypeJitterDownstream, TimeseriesMetricTypeJitterUpstream, TimeseriesMetricTypeLastMileLatency, TimeseriesMetricTypeLastMilePacketLoss, TimeseriesMetricTypeLostDownstream, TimeseriesMetricTypeLostDownstreamPcnt, TimeseriesMetricTypeLostUpstream, TimeseriesMetricTypeLostUpstreamPcnt, TimeseriesMetricTypePacketsDiscardedDownstream, TimeseriesMetricTypePacketsDiscardedDownstreamPcnt, TimeseriesMetricTypePacketsDiscardedUpstream, TimeseriesMetricTypePacketsDiscardedUpstreamPcnt, TimeseriesMetricTypePacketsDownstream, TimeseriesMetricTypePacketsUpstream, TimeseriesMetricTypeRtt, TimeseriesMetricTypeTunnelAge:
		return true
	}
	return false
}

func (e TimeseriesMetricType) String() string {
	return string(e)
}

func (e *TimeseriesMetricType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TimeseriesMetricType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TimeseriesMetricType", str)
	}
	return nil
}

func (e TimeseriesMetricType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TLSInspectAction string

const (
	TLSInspectActionBypass  TLSInspectAction = "BYPASS"
	TLSInspectActionInspect TLSInspectAction = "INSPECT"
)

var AllTLSInspectAction = []TLSInspectAction{
	TLSInspectActionBypass,
	TLSInspectActionInspect,
}

func (e TLSInspectAction) IsValid() bool {
	switch e {
	case TLSInspectActionBypass, TLSInspectActionInspect:
		return true
	}
	return false
}

func (e TLSInspectAction) String() string {
	return string(e)
}

func (e *TLSInspectAction) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TLSInspectAction(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TlsInspectAction", str)
	}
	return nil
}

func (e TLSInspectAction) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// System categories for TLS inspection policy
type TLSInspectSystemCategory string

const (
	//  High-popularity cloud apps that were analyzed by Cato's security team and confirmed to be safe for inspection.
	TLSInspectSystemCategoryPopularCloudApps TLSInspectSystemCategory = "POPULAR_CLOUD_APPS"
	//  Top domains found to be broadly TLS-inspected across the Cato cloud. TLS-inspecting these domains is likely to be safe.
	TLSInspectSystemCategorySafeToInspectDomains TLSInspectSystemCategory = "SAFE_TO_INSPECT_DOMAINS"
)

var AllTLSInspectSystemCategory = []TLSInspectSystemCategory{
	TLSInspectSystemCategoryPopularCloudApps,
	TLSInspectSystemCategorySafeToInspectDomains,
}

func (e TLSInspectSystemCategory) IsValid() bool {
	switch e {
	case TLSInspectSystemCategoryPopularCloudApps, TLSInspectSystemCategorySafeToInspectDomains:
		return true
	}
	return false
}

func (e TLSInspectSystemCategory) String() string {
	return string(e)
}

func (e *TLSInspectSystemCategory) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TLSInspectSystemCategory(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TlsInspectSystemCategory", str)
	}
	return nil
}

func (e TLSInspectSystemCategory) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TLSInspectUntrustedCertificateAction string

const (
	TLSInspectUntrustedCertificateActionAllow  TLSInspectUntrustedCertificateAction = "ALLOW"
	TLSInspectUntrustedCertificateActionBlock  TLSInspectUntrustedCertificateAction = "BLOCK"
	TLSInspectUntrustedCertificateActionPrompt TLSInspectUntrustedCertificateAction = "PROMPT"
)

var AllTLSInspectUntrustedCertificateAction = []TLSInspectUntrustedCertificateAction{
	TLSInspectUntrustedCertificateActionAllow,
	TLSInspectUntrustedCertificateActionBlock,
	TLSInspectUntrustedCertificateActionPrompt,
}

func (e TLSInspectUntrustedCertificateAction) IsValid() bool {
	switch e {
	case TLSInspectUntrustedCertificateActionAllow, TLSInspectUntrustedCertificateActionBlock, TLSInspectUntrustedCertificateActionPrompt:
		return true
	}
	return false
}

func (e TLSInspectUntrustedCertificateAction) String() string {
	return string(e)
}

func (e *TLSInspectUntrustedCertificateAction) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TLSInspectUntrustedCertificateAction(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TlsInspectUntrustedCertificateAction", str)
	}
	return nil
}

func (e TLSInspectUntrustedCertificateAction) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TrafficDirectionEnum string

const (
	TrafficDirectionEnumDownstream TrafficDirectionEnum = "DOWNSTREAM"
	TrafficDirectionEnumUpstream   TrafficDirectionEnum = "UPSTREAM"
)

var AllTrafficDirectionEnum = []TrafficDirectionEnum{
	TrafficDirectionEnumDownstream,
	TrafficDirectionEnumUpstream,
}

func (e TrafficDirectionEnum) IsValid() bool {
	switch e {
	case TrafficDirectionEnumDownstream, TrafficDirectionEnumUpstream:
		return true
	}
	return false
}

func (e TrafficDirectionEnum) String() string {
	return string(e)
}

func (e *TrafficDirectionEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TrafficDirectionEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TrafficDirectionEnum", str)
	}
	return nil
}

func (e TrafficDirectionEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type UnitType string

const (
	UnitTypeBits UnitType = "bits"
	//  Bits per second
	UnitTypeBps   UnitType = "bps"
	UnitTypeBytes UnitType = "bytes"
	//  Bytes per second
	UnitTypeBytesPerSec UnitType = "bytesPerSec"
	//  The number of occurrences for this unit
	UnitTypeCount   UnitType = "count"
	UnitTypeMs      UnitType = "ms"
	UnitTypeNone    UnitType = "none"
	UnitTypePackets UnitType = "packets"
	UnitTypePercent UnitType = "percent"
	//  health analytics for the site
	UnitTypeScore UnitType = "score"
	//  For metrics that are measured in seconds, such as tunnelAge, the number of seconds
	UnitTypeSeconds UnitType = "seconds"
)

var AllUnitType = []UnitType{
	UnitTypeBits,
	UnitTypeBps,
	UnitTypeBytes,
	UnitTypeBytesPerSec,
	UnitTypeCount,
	UnitTypeMs,
	UnitTypeNone,
	UnitTypePackets,
	UnitTypePercent,
	UnitTypeScore,
	UnitTypeSeconds,
}

func (e UnitType) IsValid() bool {
	switch e {
	case UnitTypeBits, UnitTypeBps, UnitTypeBytes, UnitTypeBytesPerSec, UnitTypeCount, UnitTypeMs, UnitTypeNone, UnitTypePackets, UnitTypePercent, UnitTypeScore, UnitTypeSeconds:
		return true
	}
	return false
}

func (e UnitType) String() string {
	return string(e)
}

func (e *UnitType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UnitType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UnitType", str)
	}
	return nil
}

func (e UnitType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type UserRole string

const (
	UserRoleEditor       UserRole = "EDITOR"
	UserRoleOwner        UserRole = "OWNER"
	UserRolePublicEditor UserRole = "PUBLIC_EDITOR"
	UserRolePublicViewer UserRole = "PUBLIC_VIEWER"
	UserRoleSitesViewer  UserRole = "SITES_VIEWER"
	UserRoleSuperUser    UserRole = "SUPER_USER"
	UserRoleViewer       UserRole = "VIEWER"
)

var AllUserRole = []UserRole{
	UserRoleEditor,
	UserRoleOwner,
	UserRolePublicEditor,
	UserRolePublicViewer,
	UserRoleSitesViewer,
	UserRoleSuperUser,
	UserRoleViewer,
}

func (e UserRole) IsValid() bool {
	switch e {
	case UserRoleEditor, UserRoleOwner, UserRolePublicEditor, UserRolePublicViewer, UserRoleSitesViewer, UserRoleSuperUser, UserRoleViewer:
		return true
	}
	return false
}

func (e UserRole) String() string {
	return string(e)
}

func (e *UserRole) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UserRole(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UserRole", str)
	}
	return nil
}

func (e UserRole) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type VendorEnum string

const (
	VendorEnumCato      VendorEnum = "CATO"
	VendorEnumMicrosoft VendorEnum = "MICROSOFT"
)

var AllVendorEnum = []VendorEnum{
	VendorEnumCato,
	VendorEnumMicrosoft,
}

func (e VendorEnum) IsValid() bool {
	switch e {
	case VendorEnumCato, VendorEnumMicrosoft:
		return true
	}
	return false
}

func (e VendorEnum) String() string {
	return string(e)
}

func (e *VendorEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = VendorEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid VendorEnum", str)
	}
	return nil
}

func (e VendorEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type VrrpType string

const (
	VrrpTypeDirectLink VrrpType = "DIRECT_LINK"
	VrrpTypeViaSwitch  VrrpType = "VIA_SWITCH"
)

var AllVrrpType = []VrrpType{
	VrrpTypeDirectLink,
	VrrpTypeViaSwitch,
}

func (e VrrpType) IsValid() bool {
	switch e {
	case VrrpTypeDirectLink, VrrpTypeViaSwitch:
		return true
	}
	return false
}

func (e VrrpType) String() string {
	return string(e)
}

func (e *VrrpType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = VrrpType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid VrrpType", str)
	}
	return nil
}

func (e VrrpType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type WanFirewallActionEnum string

const (
	//  Allow the network traffic to pass through the firewall.
	WanFirewallActionEnumAllow WanFirewallActionEnum = "ALLOW"
	//  Deny the network traffic from passing through the firewall.
	WanFirewallActionEnumBlock WanFirewallActionEnum = "BLOCK"
	//  Requests user confirmation to allow or block network traffic.
	WanFirewallActionEnumPrompt WanFirewallActionEnum = "PROMPT"
)

var AllWanFirewallActionEnum = []WanFirewallActionEnum{
	WanFirewallActionEnumAllow,
	WanFirewallActionEnumBlock,
	WanFirewallActionEnumPrompt,
}

func (e WanFirewallActionEnum) IsValid() bool {
	switch e {
	case WanFirewallActionEnumAllow, WanFirewallActionEnumBlock, WanFirewallActionEnumPrompt:
		return true
	}
	return false
}

func (e WanFirewallActionEnum) String() string {
	return string(e)
}

func (e *WanFirewallActionEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WanFirewallActionEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WanFirewallActionEnum", str)
	}
	return nil
}

func (e WanFirewallActionEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type WanFirewallDirectionEnum string

const (
	WanFirewallDirectionEnumBoth WanFirewallDirectionEnum = "BOTH"
	WanFirewallDirectionEnumTo   WanFirewallDirectionEnum = "TO"
)

var AllWanFirewallDirectionEnum = []WanFirewallDirectionEnum{
	WanFirewallDirectionEnumBoth,
	WanFirewallDirectionEnumTo,
}

func (e WanFirewallDirectionEnum) IsValid() bool {
	switch e {
	case WanFirewallDirectionEnumBoth, WanFirewallDirectionEnumTo:
		return true
	}
	return false
}

func (e WanFirewallDirectionEnum) String() string {
	return string(e)
}

func (e *WanFirewallDirectionEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WanFirewallDirectionEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WanFirewallDirectionEnum", str)
	}
	return nil
}

func (e WanFirewallDirectionEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type WanNetworkRuleInterfaceRole string

const (
	//  Automatic interface role.
	WanNetworkRuleInterfaceRoleAutomatic WanNetworkRuleInterfaceRole = "AUTOMATIC"
	//  No interface role.
	WanNetworkRuleInterfaceRoleNone WanNetworkRuleInterfaceRole = "NONE"
	//  WAN1 interface role.
	WanNetworkRuleInterfaceRoleWan1 WanNetworkRuleInterfaceRole = "WAN1"
	//  WAN2 interface role.
	WanNetworkRuleInterfaceRoleWan2 WanNetworkRuleInterfaceRole = "WAN2"
	//  WAN3 interface role.
	WanNetworkRuleInterfaceRoleWan3 WanNetworkRuleInterfaceRole = "WAN3"
	//  WAN4 interface role.
	WanNetworkRuleInterfaceRoleWan4 WanNetworkRuleInterfaceRole = "WAN4"
	//  WAN5 interface role.
	WanNetworkRuleInterfaceRoleWan5 WanNetworkRuleInterfaceRole = "WAN5"
	//  WAN6 interface role.
	WanNetworkRuleInterfaceRoleWan6 WanNetworkRuleInterfaceRole = "WAN6"
)

var AllWanNetworkRuleInterfaceRole = []WanNetworkRuleInterfaceRole{
	WanNetworkRuleInterfaceRoleAutomatic,
	WanNetworkRuleInterfaceRoleNone,
	WanNetworkRuleInterfaceRoleWan1,
	WanNetworkRuleInterfaceRoleWan2,
	WanNetworkRuleInterfaceRoleWan3,
	WanNetworkRuleInterfaceRoleWan4,
	WanNetworkRuleInterfaceRoleWan5,
	WanNetworkRuleInterfaceRoleWan6,
}

func (e WanNetworkRuleInterfaceRole) IsValid() bool {
	switch e {
	case WanNetworkRuleInterfaceRoleAutomatic, WanNetworkRuleInterfaceRoleNone, WanNetworkRuleInterfaceRoleWan1, WanNetworkRuleInterfaceRoleWan2, WanNetworkRuleInterfaceRoleWan3, WanNetworkRuleInterfaceRoleWan4, WanNetworkRuleInterfaceRoleWan5, WanNetworkRuleInterfaceRoleWan6:
		return true
	}
	return false
}

func (e WanNetworkRuleInterfaceRole) String() string {
	return string(e)
}

func (e *WanNetworkRuleInterfaceRole) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WanNetworkRuleInterfaceRole(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WanNetworkRuleInterfaceRole", str)
	}
	return nil
}

func (e WanNetworkRuleInterfaceRole) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type WanNetworkRuleRouteType string

const (
	//  Backhaul routing.
	WanNetworkRuleRouteTypeBackhaul WanNetworkRuleRouteType = "BACKHAUL"
	//  Backhaul hairpinning routing.
	WanNetworkRuleRouteTypeBackhaulHairpinning WanNetworkRuleRouteType = "BACKHAUL_HAIRPINNING"
	//  NAT routing.
	WanNetworkRuleRouteTypeNat WanNetworkRuleRouteType = "NAT"
	//  No routing.
	WanNetworkRuleRouteTypeNone WanNetworkRuleRouteType = "NONE"
	//  Optimized routing. Smart Egress using closest destination
	WanNetworkRuleRouteTypeOptimized WanNetworkRuleRouteType = "OPTIMIZED"
	//  Route via a specific path.
	WanNetworkRuleRouteTypeVia WanNetworkRuleRouteType = "VIA"
)

var AllWanNetworkRuleRouteType = []WanNetworkRuleRouteType{
	WanNetworkRuleRouteTypeBackhaul,
	WanNetworkRuleRouteTypeBackhaulHairpinning,
	WanNetworkRuleRouteTypeNat,
	WanNetworkRuleRouteTypeNone,
	WanNetworkRuleRouteTypeOptimized,
	WanNetworkRuleRouteTypeVia,
}

func (e WanNetworkRuleRouteType) IsValid() bool {
	switch e {
	case WanNetworkRuleRouteTypeBackhaul, WanNetworkRuleRouteTypeBackhaulHairpinning, WanNetworkRuleRouteTypeNat, WanNetworkRuleRouteTypeNone, WanNetworkRuleRouteTypeOptimized, WanNetworkRuleRouteTypeVia:
		return true
	}
	return false
}

func (e WanNetworkRuleRouteType) String() string {
	return string(e)
}

func (e *WanNetworkRuleRouteType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WanNetworkRuleRouteType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WanNetworkRuleRouteType", str)
	}
	return nil
}

func (e WanNetworkRuleRouteType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type WanNetworkRuleTransportType string

const (
	//  Alternative WAN transport type.
	WanNetworkRuleTransportTypeAlternativeWan WanNetworkRuleTransportType = "ALTERNATIVE_WAN"
	//  Automatic transport type.
	WanNetworkRuleTransportTypeAutomatic WanNetworkRuleTransportType = "AUTOMATIC"
	//  No transport type.
	WanNetworkRuleTransportTypeNone WanNetworkRuleTransportType = "NONE"
	//  Off-cloud transport type.
	WanNetworkRuleTransportTypeOffCloud WanNetworkRuleTransportType = "OFF_CLOUD"
	//  WAN transport type.
	WanNetworkRuleTransportTypeWan WanNetworkRuleTransportType = "WAN"
)

var AllWanNetworkRuleTransportType = []WanNetworkRuleTransportType{
	WanNetworkRuleTransportTypeAlternativeWan,
	WanNetworkRuleTransportTypeAutomatic,
	WanNetworkRuleTransportTypeNone,
	WanNetworkRuleTransportTypeOffCloud,
	WanNetworkRuleTransportTypeWan,
}

func (e WanNetworkRuleTransportType) IsValid() bool {
	switch e {
	case WanNetworkRuleTransportTypeAlternativeWan, WanNetworkRuleTransportTypeAutomatic, WanNetworkRuleTransportTypeNone, WanNetworkRuleTransportTypeOffCloud, WanNetworkRuleTransportTypeWan:
		return true
	}
	return false
}

func (e WanNetworkRuleTransportType) String() string {
	return string(e)
}

func (e *WanNetworkRuleTransportType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WanNetworkRuleTransportType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WanNetworkRuleTransportType", str)
	}
	return nil
}

func (e WanNetworkRuleTransportType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type WanNetworkRuleType string

const (
	//  Inbound Internet transport type.
	WanNetworkRuleTypeInboundInternet WanNetworkRuleType = "INBOUND_INTERNET"
	//  Internet transport type.
	WanNetworkRuleTypeInternet WanNetworkRuleType = "INTERNET"
	//  WAN transport type.
	WanNetworkRuleTypeWan WanNetworkRuleType = "WAN"
)

var AllWanNetworkRuleType = []WanNetworkRuleType{
	WanNetworkRuleTypeInboundInternet,
	WanNetworkRuleTypeInternet,
	WanNetworkRuleTypeWan,
}

func (e WanNetworkRuleType) IsValid() bool {
	switch e {
	case WanNetworkRuleTypeInboundInternet, WanNetworkRuleTypeInternet, WanNetworkRuleTypeWan:
		return true
	}
	return false
}

func (e WanNetworkRuleType) String() string {
	return string(e)
}

func (e *WanNetworkRuleType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WanNetworkRuleType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WanNetworkRuleType", str)
	}
	return nil
}

func (e WanNetworkRuleType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The action applied by the Always on policy if the rule is matched
type ZtnaAlwaysOnRuleActionEnum string

const (
	//  Enforce always on policy.
	ZtnaAlwaysOnRuleActionEnumEnforce ZtnaAlwaysOnRuleActionEnum = "ENFORCE"
	//  On demand always on policy.
	ZtnaAlwaysOnRuleActionEnumIgnore ZtnaAlwaysOnRuleActionEnum = "IGNORE"
)

var AllZtnaAlwaysOnRuleActionEnum = []ZtnaAlwaysOnRuleActionEnum{
	ZtnaAlwaysOnRuleActionEnumEnforce,
	ZtnaAlwaysOnRuleActionEnumIgnore,
}

func (e ZtnaAlwaysOnRuleActionEnum) IsValid() bool {
	switch e {
	case ZtnaAlwaysOnRuleActionEnumEnforce, ZtnaAlwaysOnRuleActionEnumIgnore:
		return true
	}
	return false
}

func (e ZtnaAlwaysOnRuleActionEnum) String() string {
	return string(e)
}

func (e *ZtnaAlwaysOnRuleActionEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ZtnaAlwaysOnRuleActionEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ZtnaAlwaysOnRuleActionEnum", str)
	}
	return nil
}

func (e ZtnaAlwaysOnRuleActionEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Return the time unit of the duration time
type ZtnaAlwaysOnTimeUnit string

const (
	//  Time in hours
	ZtnaAlwaysOnTimeUnitHours ZtnaAlwaysOnTimeUnit = "HOURS"
	//  Time in minutes
	ZtnaAlwaysOnTimeUnitMinutes ZtnaAlwaysOnTimeUnit = "MINUTES"
)

var AllZtnaAlwaysOnTimeUnit = []ZtnaAlwaysOnTimeUnit{
	ZtnaAlwaysOnTimeUnitHours,
	ZtnaAlwaysOnTimeUnitMinutes,
}

func (e ZtnaAlwaysOnTimeUnit) IsValid() bool {
	switch e {
	case ZtnaAlwaysOnTimeUnitHours, ZtnaAlwaysOnTimeUnitMinutes:
		return true
	}
	return false
}

func (e ZtnaAlwaysOnTimeUnit) String() string {
	return string(e)
}

func (e *ZtnaAlwaysOnTimeUnit) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ZtnaAlwaysOnTimeUnit(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ZtnaAlwaysOnTimeUnit", str)
	}
	return nil
}

func (e ZtnaAlwaysOnTimeUnit) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ZtnaAppConnectorConnectivityStatus string

const (
	ZtnaAppConnectorConnectivityStatusConnected    ZtnaAppConnectorConnectivityStatus = "CONNECTED"
	ZtnaAppConnectorConnectivityStatusDisconnected ZtnaAppConnectorConnectivityStatus = "DISCONNECTED"
)

var AllZtnaAppConnectorConnectivityStatus = []ZtnaAppConnectorConnectivityStatus{
	ZtnaAppConnectorConnectivityStatusConnected,
	ZtnaAppConnectorConnectivityStatusDisconnected,
}

func (e ZtnaAppConnectorConnectivityStatus) IsValid() bool {
	switch e {
	case ZtnaAppConnectorConnectivityStatusConnected, ZtnaAppConnectorConnectivityStatusDisconnected:
		return true
	}
	return false
}

func (e ZtnaAppConnectorConnectivityStatus) String() string {
	return string(e)
}

func (e *ZtnaAppConnectorConnectivityStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ZtnaAppConnectorConnectivityStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ZtnaAppConnectorConnectivityStatus", str)
	}
	return nil
}

func (e ZtnaAppConnectorConnectivityStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ZtnaAppConnectorInterfaceType string

const (
	ZtnaAppConnectorInterfaceTypeCato ZtnaAppConnectorInterfaceType = "CATO"
	ZtnaAppConnectorInterfaceTypeLan  ZtnaAppConnectorInterfaceType = "LAN"
)

var AllZtnaAppConnectorInterfaceType = []ZtnaAppConnectorInterfaceType{
	ZtnaAppConnectorInterfaceTypeCato,
	ZtnaAppConnectorInterfaceTypeLan,
}

func (e ZtnaAppConnectorInterfaceType) IsValid() bool {
	switch e {
	case ZtnaAppConnectorInterfaceTypeCato, ZtnaAppConnectorInterfaceTypeLan:
		return true
	}
	return false
}

func (e ZtnaAppConnectorInterfaceType) String() string {
	return string(e)
}

func (e *ZtnaAppConnectorInterfaceType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ZtnaAppConnectorInterfaceType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ZtnaAppConnectorInterfaceType", str)
	}
	return nil
}

func (e ZtnaAppConnectorInterfaceType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ZtnaAppConnectorSnapshotProbingStatus string

const (
	ZtnaAppConnectorSnapshotProbingStatusDisabled ZtnaAppConnectorSnapshotProbingStatus = "DISABLED"
	ZtnaAppConnectorSnapshotProbingStatusDown     ZtnaAppConnectorSnapshotProbingStatus = "DOWN"
	ZtnaAppConnectorSnapshotProbingStatusUp       ZtnaAppConnectorSnapshotProbingStatus = "UP"
)

var AllZtnaAppConnectorSnapshotProbingStatus = []ZtnaAppConnectorSnapshotProbingStatus{
	ZtnaAppConnectorSnapshotProbingStatusDisabled,
	ZtnaAppConnectorSnapshotProbingStatusDown,
	ZtnaAppConnectorSnapshotProbingStatusUp,
}

func (e ZtnaAppConnectorSnapshotProbingStatus) IsValid() bool {
	switch e {
	case ZtnaAppConnectorSnapshotProbingStatusDisabled, ZtnaAppConnectorSnapshotProbingStatusDown, ZtnaAppConnectorSnapshotProbingStatusUp:
		return true
	}
	return false
}

func (e ZtnaAppConnectorSnapshotProbingStatus) String() string {
	return string(e)
}

func (e *ZtnaAppConnectorSnapshotProbingStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ZtnaAppConnectorSnapshotProbingStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ZtnaAppConnectorSnapshotProbingStatus", str)
	}
	return nil
}

func (e ZtnaAppConnectorSnapshotProbingStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ZtnaAppConnectorSnapshotRoutingStatus string

const (
	ZtnaAppConnectorSnapshotRoutingStatusDown ZtnaAppConnectorSnapshotRoutingStatus = "DOWN"
	ZtnaAppConnectorSnapshotRoutingStatusUp   ZtnaAppConnectorSnapshotRoutingStatus = "UP"
)

var AllZtnaAppConnectorSnapshotRoutingStatus = []ZtnaAppConnectorSnapshotRoutingStatus{
	ZtnaAppConnectorSnapshotRoutingStatusDown,
	ZtnaAppConnectorSnapshotRoutingStatusUp,
}

func (e ZtnaAppConnectorSnapshotRoutingStatus) IsValid() bool {
	switch e {
	case ZtnaAppConnectorSnapshotRoutingStatusDown, ZtnaAppConnectorSnapshotRoutingStatusUp:
		return true
	}
	return false
}

func (e ZtnaAppConnectorSnapshotRoutingStatus) String() string {
	return string(e)
}

func (e *ZtnaAppConnectorSnapshotRoutingStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ZtnaAppConnectorSnapshotRoutingStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ZtnaAppConnectorSnapshotRoutingStatus", str)
	}
	return nil
}

func (e ZtnaAppConnectorSnapshotRoutingStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ZtnaAppConnectorType string

const (
	//  physical socket
	ZtnaAppConnectorTypePhysical ZtnaAppConnectorType = "PHYSICAL"
	//  virtualized socket
	ZtnaAppConnectorTypeVirtual ZtnaAppConnectorType = "VIRTUAL"
)

var AllZtnaAppConnectorType = []ZtnaAppConnectorType{
	ZtnaAppConnectorTypePhysical,
	ZtnaAppConnectorTypeVirtual,
}

func (e ZtnaAppConnectorType) IsValid() bool {
	switch e {
	case ZtnaAppConnectorTypePhysical, ZtnaAppConnectorTypeVirtual:
		return true
	}
	return false
}

func (e ZtnaAppConnectorType) String() string {
	return string(e)
}

func (e *ZtnaAppConnectorType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ZtnaAppConnectorType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ZtnaAppConnectorType", str)
	}
	return nil
}

func (e ZtnaAppConnectorType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Geographical regions that can be associated with a remote user license
type ZtnaUsersLicenseGroup string

const (
	//  Country with stand-alone licenses (not part of a group)
	ZtnaUsersLicenseGroupChina ZtnaUsersLicenseGroup = "CHINA"
	//  Legacy group
	ZtnaUsersLicenseGroupDubai   ZtnaUsersLicenseGroup = "DUBAI"
	ZtnaUsersLicenseGroupGeneral ZtnaUsersLicenseGroup = "GENERAL"
	//  Legacy group
	ZtnaUsersLicenseGroupLatam ZtnaUsersLicenseGroup = "LATAM"
	//  Country with stand-alone licenses (not part of a group)
	ZtnaUsersLicenseGroupMorocco ZtnaUsersLicenseGroup = "MOROCCO"
	//  Country with stand-alone licenses (not part of a group)
	ZtnaUsersLicenseGroupVietnam ZtnaUsersLicenseGroup = "VIETNAM"
)

var AllZtnaUsersLicenseGroup = []ZtnaUsersLicenseGroup{
	ZtnaUsersLicenseGroupChina,
	ZtnaUsersLicenseGroupDubai,
	ZtnaUsersLicenseGroupGeneral,
	ZtnaUsersLicenseGroupLatam,
	ZtnaUsersLicenseGroupMorocco,
	ZtnaUsersLicenseGroupVietnam,
}

func (e ZtnaUsersLicenseGroup) IsValid() bool {
	switch e {
	case ZtnaUsersLicenseGroupChina, ZtnaUsersLicenseGroupDubai, ZtnaUsersLicenseGroupGeneral, ZtnaUsersLicenseGroupLatam, ZtnaUsersLicenseGroupMorocco, ZtnaUsersLicenseGroupVietnam:
		return true
	}
	return false
}

func (e ZtnaUsersLicenseGroup) String() string {
	return string(e)
}

func (e *ZtnaUsersLicenseGroup) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ZtnaUsersLicenseGroup(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ZtnaUsersLicenseGroup", str)
	}
	return nil
}

func (e ZtnaUsersLicenseGroup) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
