// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package cato_models

import (
	"bytes"
	"fmt"
	"io"
	"strconv"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/catonetworks/cato-go-sdk/scalars"
)

type AccountOperationsTimelineBase interface {
	IsAccountOperationsTimelineBase()
	GetID() string
	GetCreated() scalars.Time
	GetValidated() scalars.Time
	GetDescription() string
	GetType() AccountOperationsTimelineType
}

type Activity interface {
	IsActivity()
	GetID() string
	GetResourceID() string
	GetParentResourceID() string
}

type ActorRef interface {
	IsObjectRef()
	IsActorRef()
	GetID() string
	GetName() string
}

type Anomalies interface {
	IsMergedIncident()
	IsAnomalies()
	GetID() string
	GetFirstSignal() string
	GetLastSignal() string
	GetEngineType() *StoryEngineTypeEnum
	GetVendor() *VendorEnum
	GetProducer() StoryProducerEnum
	GetProducerName() string
	GetConnectionType() *ConnectionTypeEnum
	GetIndication() string
	GetQueryName() *string
	GetSource() *string
	GetCriticality() *int64
	GetTicket() *string
	GetStatus() *StoryStatusEnum
	GetResearch() *bool
	GetSiteName() *string
	GetStoryDuration() *int64
	GetDescription() *string
	GetAnalystFeedback() *AnalystFeedback
	GetSite() *SiteRef
	GetUser() *UserRef
	GetSourceIP() *string
	GetSimilarStoriesData() []*SimilarStoryData
	GetPredictedVerdict() *StoryVerdictEnum
	GetPredictedThreatType() *string
	GetDirection() *string
}

type CatoResource interface {
	IsEndpointResource()
	IsCatoResource()
	// Unique Cato ID for this EPP resource
	GetID() string
	// Timestamp that the this resource was used
	GetCreatedDateTime() *string
	// Enum for the remediation status associated with this resource
	GetRemediationStatus() *RemediationStatusEnum
}

// A group with members of a single type of entity (for example: IPAddress, FQDN)
type Container interface {
	IsContainer()
	// Unique container ID
	GetID() string
	// Name for the container
	GetName() string
	// Description for the container
	GetDescription() *string
	// Number of items in the container
	GetSize() int64
	// Audit metadata about the container
	GetAudit() *ContainerAudit
}

type DegradedStatusArgs interface {
	IsDegradedStatusArgs()
}

type DeviceDetails interface {
	IsDeviceDetails()
	GetID() string
	GetDeviceName() *string
	GetOsDetails() *OsDetails
	GetLoggedOnUsers() []EndpointUser
	GetExternalIP() *string
	GetLocalIP() *string
}

type DeviceNetworkRef interface {
	IsDeviceNetworkRef()
}

type Endpoint interface {
	IsMergedIncident()
	IsEndpoint()
	// Unique Cato ID for the story
	GetID() string
	// Timestamp for the first incident signal related to this story
	GetFirstSignal() string
	// Timestamp for the last (most recent) incident signal related to this story
	GetLastSignal() string
	// XDR engine involved with the incident
	GetEngineType() *StoryEngineTypeEnum
	// Vendor that identified the incident, such as Cato or Microsoft
	GetVendor() *VendorEnum
	// Enum for the Producer (specific XDR engine and service) involved with the incident
	GetProducer() StoryProducerEnum
	// Full name of the Producer (specific XDR engine and service) involved with the incident
	GetProducerName() string
	// Enum for the connection for this incident (ie. site, host, user)
	GetConnectionType() *ConnectionTypeEnum
	// An indication is a set of actions and behaviors for the Network or Security incident. Each producer has different indications.
	GetIndication() string
	// Category for the indication ID related to the story
	GetQueryName() *string
	// IP address, name of device, or SDP user on your network involved in the story
	GetSource() *string
	GetCriticality() *int64
	GetTicket() *string
	GetStatus() *StoryStatusEnum
	GetResearch() *bool
	GetSiteName() *string
	GetStoryDuration() *int64
	GetDescription() *string
	GetSourceIP() *string
	GetAnalystFeedback() *AnalystFeedback
	GetSite() *SiteRef
	GetUser() *UserRef
	GetSimilarStoriesData() []*SimilarStoryData
	GetPredictedVerdict() *StoryVerdictEnum
	GetPredictedThreatType() *string
	GetDevice() DeviceDetails
	GetAlerts() []EndpointAlert
}

type EndpointAlert interface {
	IsEndpointAlert()
	GetID() string
	GetTitle() *string
	GetDescription() *string
	GetThreatName() *string
	GetMitreTechnique() []*Mitre
	GetMitreSubTechnique() []*Mitre
	GetCreatedDateTime() *string
	GetResources() []EndpointResource
	GetActivities() []Activity
	GetCriticality() *int64
	GetExternalIP() *string
	GetLocalIP() *string
}

type EndpointResource interface {
	IsEndpointResource()
	GetID() string
	GetCreatedDateTime() *string
	GetRemediationStatus() *RemediationStatusEnum
}

type EndpointUser interface {
	IsEndpointUser()
	GetID() string
	GetName() string
}

type FileResource interface {
	IsEndpointResource()
	IsFileResource()
	GetID() string
	GetCreatedDateTime() *string
	GetRemediationStatus() *RemediationStatusEnum
	GetFileDetails() *FileDetails
	GetDetectionStatus() *DetectionStatusEnum
}

type IContainerRef interface {
	IsObjectRef()
	IsIContainerRef()
	// Unique container ID
	GetID() string
	// Name for the container
	GetName() string
}

// Shared interface for any policy
type IPolicy interface {
	IsIPolicy()
	// TRUE = Policy is enabled, FALSE = Policy is disabled
	GetEnabled() bool
	// Return list of rules in the policy
	GetRules() []IPolicyRulePayload
	// Return sections in the policy
	GetSections() []*PolicySectionPayload
	// Audit data for the policy
	GetAudit() *PolicyAudit
	// Return data for the Policy revision
	GetRevision() *PolicyRevision
}

// Results of policy change
type IPolicyMutationPayload interface {
	IsIPolicyMutationPayload()
	// Data for the policy
	GetPolicy() IPolicy
	// Enum for the status of the policy change
	GetStatus() PolicyMutationStatus
	// List of errors related to the policy change
	GetErrors() []*PolicyMutationError
}

type IPolicyRule interface {
	IsIPolicyRule()
	// Rule ID
	GetID() string
	// Name of the rule
	GetName() string
	// Description for the rule
	GetDescription() *string
	// Position / priority of rule
	GetIndex() int64
	// TRUE = Rule is enabled, FALSE = Rule is disabled
	GetEnabled() bool
	// Policy section where the rule is located
	GetSection() *PolicySectionInfo
}

// Results of rule change
type IPolicyRuleMutationPayload interface {
	IsIPolicyRuleMutationPayload()
	// Returns settings for the rule
	GetRule() IPolicyRulePayload
	// Enum for the status of the policy change
	GetStatus() PolicyMutationStatus
	// List of errors related to the policy change
	GetErrors() []*PolicyMutationError
}

// Results of changes to the rule
type IPolicyRulePayload interface {
	IsIPolicyRulePayload()
	GetAudit() *PolicyElementAudit
	// Rule that was changed
	GetRule() IPolicyRule
	// Summary of rule change, (ie. ADDED, UPDATED)
	GetProperties() []PolicyElementPropertiesEnum
}

// An interface containing properties that are common to all license types
type License interface {
	IsLicense()
	// The unique identifier for the license. If this value is not available, you can contact Cato Support, who may be able to assist in retrieving it.
	GetID() *string
	GetDescription() *string
	// License plan type
	GetPlan() LicensePlan
	// The license SKU
	GetSku() LicenseSku
	// License activation status
	GetStatus() LicenseStatus
	// License start date
	GetStartDate() *string
	// License expiration date
	GetExpirationDate() string
	// The date of the last update to the license
	GetLastUpdated() *string
}

type MergedIncident interface {
	IsMergedIncident()
	// Unique Cato ID for each story
	GetID() string
	// Timestamp for the first incident signal related to this story
	GetFirstSignal() string
	// Timestamp for the last (most recent) incident signal related to this story
	GetLastSignal() string
	// XDR engine involved with the incident
	GetEngineType() *StoryEngineTypeEnum
	// Vendor that identified the incident, such as Cato or Microsoft
	GetVendor() *VendorEnum
	// Producer (specific XDR engine and service) involved with the incident
	GetProducer() StoryProducerEnum
	// Full name of the Producer (specific XDR engine and service) involved with the incident
	GetProducerName() string
	// Connection for the incident
	GetConnectionType() *ConnectionTypeEnum
	// An indication is a set of actions and behaviors for the Network or Security incident. Each producer has different indications.
	GetIndication() string
	// Category for the indication ID related to the story
	GetQueryName() *string
	// For Network stories - The potential impact of the issue on your network. Values are from 1 (low impact) to 10 (high impact)
	//
	// For Security stories - Cato's risk analysis of the story. Values are from 1 (low risk) to 10 (high risk)
	GetCriticality() *int64
	// For Network stories - The site where the network issue is occurring
	//
	// For Security stories - IP address, name of device, or SDP user on your network involved in the story
	GetSource() *string
	// The ticket an analyst created for this story
	GetTicket() *string
	// Status for the story
	GetStatus() *StoryStatusEnum
	// The value is TRUE when the story is currently being researched by Security Analysts
	GetResearch() *bool
	// Site name related to the story
	GetSiteName() *string
	// Amount of time since the story was opened (no value for closed stories)
	GetStoryDuration() *int64
	// For Security stories, description of the threat
	GetDescription() *string
	// The source IP address of the device in your network sending or receiving the flow
	GetSourceIP() *string
	// Fields related to analysts research of the threat incident
	GetAnalystFeedback() *AnalystFeedback
	// Cato ID and name for the site
	GetSite() *SiteRef
	// Cato ID and name for the user
	GetUser() *UserRef
	GetPredictedVerdict() *StoryVerdictEnum
	GetPredictedThreatType() *string
}

type MicrosoftEndpointResource interface {
	IsEndpointResource()
	IsMicrosoftEndpointResource()
	GetID() string
	GetCreatedDateTime() *string
	GetRemediationStatus() *RemediationStatusEnum
	GetRemediationStatusDetails() *string
	GetTags() []string
	GetRoles() []ResourceRoleEnum
	GetVerdict() *MsResourceVerdictEnum
}

type NetworkResource interface {
	IsEndpointResource()
	IsNetworkResource()
	GetID() string
	GetCreatedDateTime() *string
	GetRemediationStatus() *RemediationStatusEnum
	GetDNSRequest() *string
	GetDNSResponse() *string
	GetDestinationIP() *string
	GetDestinationPort() *int64
	GetSourcePort() *int64
	GetURL() *string
	GetMethod() *string
}

type ObjectRef interface {
	IsObjectRef()
	// Object's unique identifier
	GetID() string
	// Object's unique name
	GetName() string
}

type ProcessResource interface {
	IsEndpointResource()
	IsProcessResource()
	GetID() string
	GetCreatedDateTime() *string
	GetRemediationStatus() *RemediationStatusEnum
	GetProcessID() int64
	GetProcessCommandLine() *string
	GetImageFile() *FileDetails
	GetUserAccount() EndpointUser
}

type QuantifiableLicense interface {
	IsLicense()
	IsQuantifiableLicense()
	// The unique identifier for the license. If this value is not available, you can contact Cato Support, who may be able to assist in retrieving it.
	GetID() *string
	GetDescription() *string
	// License plan type
	GetPlan() LicensePlan
	// The license SKU
	GetSku() LicenseSku
	// License activation status
	GetStatus() LicenseStatus
	// License initiation date
	GetStartDate() *string
	// License expiration date
	GetExpirationDate() string
	// The date of the last update to the license
	GetLastUpdated() *string
	// license quantity
	GetTotal() int64
}

type RegistryResource interface {
	IsEndpointResource()
	IsRegistryResource()
	GetID() string
	GetCreatedDateTime() *string
	GetRemediationStatus() *RemediationStatusEnum
	GetHive() *string
	GetKey() *string
	GetValue() *string
	GetValueName() *string
	GetValueType() *string
}

type Value interface {
	IsValue()
}

type AccountAuditData struct {
	// The Admin / API key name used for creating the account
	CreatedBy string `json:"createdBy"`
	// The date when the account created
	CreatedTime string `json:"createdTime"`
}

type AccountDataPayload struct {
	ID        string `json:"id"`
	Name      string `json:"name"`
	Subdomain string `json:"subdomain"`
}

type AccountFilter struct {
	AccountInclusion *AccountInclusion `json:"accountInclusion,omitempty"`
	In               []string          `json:"in,omitempty"`
}

type AccountIDPredicate struct {
	In    []string `json:"in,omitempty"`
	NotIn []string `json:"not_in,omitempty"`
}

type AccountInfo struct {
	// Audit data for the account
	Audit *AccountAuditData `json:"audit"`
	// User-defined information as defined by an account admin
	Description *string `json:"description,omitempty"`
	// The ID of the account
	ID string `json:"id"`
	// The name of the account
	Name string `json:"name"`
	// The account plan
	Plan *AccountPlan `json:"plan,omitempty"`
	// The account status
	Status AccountStatus `json:"status"`
	// The account tenancy e.g. single-tenant / multi-tenant
	Tenancy AccountTenancy `json:"tenancy"`
	// The time zone of the account. Default: UTC (GMT + 0).
	TimeZone string `json:"timeZone"`
	// The account type e.g. Partner or Customer
	Type AccountProfileType `json:"type"`
}

type AccountManagementMutations struct {
	// Add a new account
	AddAccount *AccountInfo `json:"addAccount,omitempty"`
	// Sets the account status to "Disabled" for accounts with plan = "Trial" and status = "Active" or "Locked".
	DisableAccount *DisableAccountPayload `json:"disableAccount,omitempty"`
	// Delete an existing account. The account status will become “Disabled”, and it will be scheduled for deletion
	RemoveAccount *RemoveAccountPayload `json:"removeAccount,omitempty"`
	// Update existing account attributes
	UpdateAccount *AccountInfo `json:"updateAccount,omitempty"`
}

type AccountManagementQueries struct {
	// Read the account information
	Account *AccountInfo `json:"account,omitempty"`
}

type AccountMetrics struct {
	// Starting time
	From *string `json:"from,omitempty"`
	// The size of a single time bucket in seconds
	Granularity *int64 `json:"granularity,omitempty"`
	// Unique Identifier of Account.
	ID *string `json:"id,omitempty"`
	// Site connectivity metrics for the requested sites.
	Sites      []*SiteMetrics `json:"sites,omitempty"`
	Timeseries []*Timeseries  `json:"timeseries,omitempty"`
	// Ending time
	To *string `json:"to,omitempty"`
	// Connectivity metrics for the requested users connecting remotely with the Client.
	// Doesn’t include user traffic behind a site.
	Users []*SiteMetrics `json:"users,omitempty"`
}

type AccountOperationsIncident struct {
	IncidentTimeline []AccountOperationsTimelineBase `json:"incidentTimeline"`
	Metadata         []*AccountOperationsMetadata    `json:"metadata"`
	Playbooks        []*AiOperationsPlaybook         `json:"playbooks"`
}

type AccountOperationsMetadata struct {
	Key   string       `json:"key"`
	Type  MetadataType `json:"type"`
	Value string       `json:"value"`
}

type AccountOperationsTimelineEvent struct {
	Created     scalars.Time                  `json:"created"`
	Description string                        `json:"description"`
	EventIds    []string                      `json:"eventIds"`
	ID          string                        `json:"id"`
	Muted       bool                          `json:"muted"`
	Type        AccountOperationsTimelineType `json:"type"`
	Validated   scalars.Time                  `json:"validated"`
}

func (AccountOperationsTimelineEvent) IsAccountOperationsTimelineBase()            {}
func (this AccountOperationsTimelineEvent) GetID() string                          { return this.ID }
func (this AccountOperationsTimelineEvent) GetCreated() scalars.Time               { return this.Created }
func (this AccountOperationsTimelineEvent) GetValidated() scalars.Time             { return this.Validated }
func (this AccountOperationsTimelineEvent) GetDescription() string                 { return this.Description }
func (this AccountOperationsTimelineEvent) GetType() AccountOperationsTimelineType { return this.Type }

// A reference identifying the Account object. ID: Unique Account Identifier, Name: The Account Name
type AccountRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (AccountRef) IsObjectRef() {}

// Object's unique identifier
func (this AccountRef) GetID() string { return this.ID }

// Object's unique name
func (this AccountRef) GetName() string { return this.Name }

type AccountRolesResult struct {
	Items []*RBACRole `json:"items"`
	Total int64       `json:"total"`
}

type AccountSnapshot struct {
	// Unique Identifier of Account
	ID *string `json:"id,omitempty"`
	// Sites includes information about online as well as offline sites
	Sites     []*SiteSnapshot `json:"sites,omitempty"`
	Timestamp *string         `json:"timestamp,omitempty"`
	// VPN users information includes only connected users by default (Unlike sites), unless specific ID is requested
	Users []*UserSnapshot `json:"users,omitempty"`
}

type ActorRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

type AddAccountInput struct {
	// User-defined information as defined by an account admin
	Description *string `json:"description,omitempty"`
	// The name of the account
	Name string `json:"name"`
	// The account tenancy (single-tenant / multi-tenant)
	Tenancy AccountTenancy `json:"tenancy"`
	// The time zone of the account. Default: UTC (GMT + 0).
	Timezone string `json:"timezone"`
	// The account type (Partner / customer)
	Type AccountProfileType `json:"type"`
}

type AddAdminInput struct {
	AdminType            *AdminType              `json:"adminType,omitempty"`
	Email                *string                 `json:"email,omitempty"`
	FirstName            string                  `json:"firstName"`
	LastName             string                  `json:"lastName"`
	ManagedRoles         []*UpdateAdminRoleInput `json:"managedRoles,omitempty"`
	MfaEnabled           *bool                   `json:"mfaEnabled,omitempty"`
	PasswordNeverExpires bool                    `json:"passwordNeverExpires"`
	ResellerRoles        []*UpdateAdminRoleInput `json:"resellerRoles,omitempty"`
}

type AddAdminPayload struct {
	AdminID string `json:"adminID"`
}

type AddBgpPeerInput struct {
	// Advertise all routes if true.
	AdvertiseAllRoutes bool `json:"advertiseAllRoutes"`
	// Advertise the default route (0.0.0.0/0) if true.
	AdvertiseDefaultRoute bool `json:"advertiseDefaultRoute"`
	// Advertise summarized routes if true.
	AdvertiseSummaryRoutes bool `json:"advertiseSummaryRoutes"`
	// Enable BFD for session failure detection if true.
	BfdEnabled bool `json:"bfdEnabled"`
	// Required BFD configuration if BFD is enabled.
	BfdSettings *BfdSettingsInput `json:"bfdSettings,omitempty"`
	// The AS number of Cato's BGP endpoint.
	CatoAsn scalars.Asn16 `json:"catoAsn"`
	// Default action for routes not matching filters (ACCEPT or DROP).
	DefaultAction BgpDefaultAction `json:"defaultAction"`
	// Excluded rules from the default action.
	DefaultActionExclusion []*BgpFilterRuleInput `json:"defaultActionExclusion"`
	// Time (in seconds) before declaring the peer unreachable.
	HoldTime int64 `json:"holdTime"`
	// Time (in seconds) between keepalive messages.
	KeepaliveInterval int64 `json:"keepaliveInterval"`
	// MD5 authentication key for secure sessions.
	Md5AuthKey *string `json:"md5AuthKey,omitempty"`
	// Route preference metric; lower values are given precedence.
	Metric int64 `json:"metric"`
	// Name of the BGP configuration entity.
	Name string `json:"name"`
	// The AS number of the peer BGP endpoint.
	PeerAsn scalars.Asn32 `json:"peerAsn"`
	// IP address of the peer BGP endpoint.
	PeerIP string `json:"peerIp"`
	// Perform NAT if true.
	PerformNat bool `json:"performNat"`
	// Information about the site where the BGP peer is being added.
	Site *SiteRefInput `json:"site"`
	// Summarized routes to advertise.
	SummaryRoute []*BgpSummaryRouteInput `json:"summaryRoute"`
	// Configuration for tracking the health and status of the BGP peer.
	Tracking *BgpTrackingInput `json:"tracking,omitempty"`
}

type AddBgpPeerPayload struct {
	// The BGP peer that was successfully added.
	BgpPeer *BgpPeer `json:"bgpPeer"`
}

// Input for adding a new physical connection to a cloud interconnect site.
type AddCloudInterconnectPhysicalConnectionInput struct {
	// Downstream bandwidth limit.
	DownstreamBwLimit string `json:"downstreamBwLimit"`
	// Method of encapsulation.Wither .1Q/QinQ
	EncapsulationMethod TaggingMethod `json:"encapsulationMethod"`
	// High availability role of the connection.
	HaRole HaRole `json:"haRole"`
	// Identifying data for the POP location.
	PopLocation *PopLocationRefInput `json:"popLocation"`
	// Private IP address of Cato.
	PrivateCatoIP string `json:"privateCatoIp"`
	// Private IP address of the site.
	PrivateSiteIP string `json:"privateSiteIp"`
	// Name of the service provider. Usually a partner, or a fabric service provider.
	ServiceProviderName string `json:"serviceProviderName"`
	// Identifying data for the site.
	Site *SiteRefInput `json:"site"`
	// Subnet for the connection, the BGP peering range. /30 CIDR.
	Subnet string `json:"subnet"`
	// Upstream bandwidth limit.
	UpstreamBwLimit string `json:"upstreamBwLimit"`
}

// Payload for adding a new physical connection to a cloud interconnect site.
type AddCloudInterconnectPhysicalConnectionPayload struct {
	// ID of the newly added connection.
	ID string `json:"id"`
}

// Input for adding a new cloud interconnect site.
type AddCloudInterconnectSiteInput struct {
	// Description of the site.
	Description *string `json:"description,omitempty"`
	// Name of the site.
	Name string `json:"name"`
	// Location details of the site.
	SiteLocation *AddSiteLocationInput `json:"siteLocation"`
	// Type of the site.
	SiteType SiteType `json:"siteType"`
}

// Payload for adding a new cloud interconnect site.
type AddCloudInterconnectSitePayload struct {
	// ID of the newly added site.
	SiteID string `json:"siteId"`
}

type AddIpsecIkeV2SiteInput struct {
	Description *string `json:"description,omitempty"`
	// The name of the site
	Name string `json:"name"`
	// The native range of the site
	NativeNetworkRange string `json:"nativeNetworkRange"`
	// The location of the site
	SiteLocation *AddSiteLocationInput `json:"siteLocation"`
	// Valid values are: BRANCH, HEADQUARTERS,	CLOUD_DC, and DATACENTER.
	SiteType SiteType `json:"siteType"`
	// VLAN ID for native range
	Vlan *scalars.Vlan `json:"vlan,omitempty"`
}

type AddIpsecIkeV2SiteMultiTunnelPayload struct {
	// Cato’s FQDN for the multi-tunnel
	Fqdn    *string                           `json:"fqdn,omitempty"`
	Tunnels []*AddIpsecIkeV2SiteTunnelPayload `json:"tunnels"`
}

type AddIpsecIkeV2SitePayload struct {
	// The ID of the site
	SiteID string `json:"siteId"`
}

type AddIpsecIkeV2SiteTunnelPayload struct {
	// The local ID for the tunnel
	LocalID *string `json:"localId,omitempty"`
	// The ID of the tunnel
	TunnelID *IPSecV2InterfaceID `json:"tunnelId,omitempty"`
}

type AddIpsecIkeV2SiteTunnelsInput struct {
	// The configuration of the site’s primary tunnel
	Primary *AddIpsecIkeV2TunnelsInput `json:"primary,omitempty"`
	// The configuration of the site’s secondary tunnel
	Secondary *AddIpsecIkeV2TunnelsInput `json:"secondary,omitempty"`
}

type AddIpsecIkeV2SiteTunnelsPayload struct {
	// Cato’s FQDN for the primary tunnel
	Primary *AddIpsecIkeV2SiteMultiTunnelPayload `json:"primary,omitempty"`
	// Cato’s FQDN for the secondary tunnel
	Secondary *AddIpsecIkeV2SiteMultiTunnelPayload `json:"secondary,omitempty"`
	// The ID of the site
	SiteID string `json:"siteId"`
}

type AddIpsecIkeV2TunnelInput struct {
	// The maximum allowed bandwidth for the site. If not specified, it will be set according to the site license. If the ISP provided bandwidth is below the site bandwidth, set this parameter to the ISP bandwidth or below
	LastMileBw *LastMileBwInput `json:"lastMileBw,omitempty"`
	// Tunnel name
	Name *string `json:"name,omitempty"`
	// Cato’s private IP, used for BGP routing. Applicable for sites using BGP only
	PrivateCatoIP *string `json:"privateCatoIp,omitempty"`
	// Site private IP, used for BGP routing. Applicable for sites using BGP only
	PrivateSiteIP *string `json:"privateSiteIp,omitempty"`
	// Pre-shared key. This field is write-only.
	Psk string `json:"psk"`
	// The public IP address where the IPsec tunnel is initiated
	PublicSiteIP *string `json:"publicSiteIp,omitempty"`
	// Tunnel role
	Role *IPSecV2TunnelRole `json:"role,omitempty"`
}

type AddIpsecIkeV2TunnelsInput struct {
	// The destination type of the IPsec tunnel
	DestinationType *DestinationType `json:"destinationType,omitempty"`
	// The PoP location ID
	PopLocationID *string `json:"popLocationId,omitempty"`
	// The ID of the public IP (Allocated IP) of the Cato PoP to which the tunnel will connect. This will be the source-IP of the traffic transmitted to the Cato cloud over this tunnel when egressing the Cato Cloud
	PublicCatoIPID *string                     `json:"publicCatoIpId,omitempty"`
	Tunnels        []*AddIpsecIkeV2TunnelInput `json:"tunnels"`
}

type AddNetworkRangeInput struct {
	// Only relevant for AZURE HA sites
	AzureFloatingIP *string `json:"azureFloatingIp,omitempty"`
	// Only relevant for NATIVE, VLAN rangeType
	DhcpSettings *NetworkDhcpSettingsInput `json:"dhcpSettings,omitempty"`
	// Only relevant for ROUTED_ROUTE rangeType
	Gateway      *string `json:"gateway,omitempty"`
	InternetOnly *bool   `json:"internetOnly,omitempty"`
	// Only relevant for NATIVE, SECONDARY_NATIVE, DIRECT_ROUTE, VLAN rangeType
	LocalIP *string `json:"localIp,omitempty"`
	// BETA - Only relevant for NATIVE, DIRECT_ROUTE and VLAN rangeType
	MdnsReflector    *bool      `json:"mdnsReflector,omitempty"`
	Name             string     `json:"name"`
	RangeType        SubnetType `json:"rangeType"`
	Subnet           string     `json:"subnet"`
	TranslatedSubnet *string    `json:"translatedSubnet,omitempty"`
	// Only relevant for VLAN network rangeType
	Vlan *int64 `json:"vlan,omitempty"`
}

type AddNetworkRangePayload struct {
	NetworkRangeID string `json:"networkRangeId"`
}

type AddSecondaryAWSVSocketInput struct {
	// The IP address of LAN interface
	EniIPAddress string `json:"eniIpAddress"`
	// The subnet of the LAN interface
	EniIPSubnet string `json:"eniIpSubnet"`
	// The ID of the LAN route table
	RouteTableID string `json:"routeTableId"`
	// Information about the site where the secondary AWS VSocket is being added.
	Site *SiteRefInput `json:"site"`
}

type AddSecondaryAWSVSocketPayload struct {
	// The secondary socket id
	ID string `json:"id"`
}

type AddSecondaryAzureVSocketInput struct {
	// The floating IP address
	FloatingIP string `json:"floatingIp"`
	// The IP address of the interface
	InterfaceIP string `json:"interfaceIp"`
	// Information about the site where the secondary Azure VSocket is being added.
	Site *SiteRefInput `json:"site"`
}

type AddSecondaryAzureVSocketPayload struct {
	// The secondary socket id
	ID string `json:"id"`
}

type AddServicePrincipalAdminInput struct {
	Email         *string                 `json:"email,omitempty"`
	ManagedRoles  []*UpdateAdminRoleInput `json:"managedRoles,omitempty"`
	Name          string                  `json:"name"`
	ResellerRoles []*UpdateAdminRoleInput `json:"resellerRoles,omitempty"`
}

type AddServicePrincipalAdminPayload struct {
	AdminID string `json:"adminID"`
}

type AddSiteLocationInput struct {
	// optional address
	Address *string `json:"address,omitempty"`
	// city name, must belong to the country or country and state
	City *string `json:"city,omitempty"`
	// country code
	CountryCode string `json:"countryCode"`
	// optional state code
	StateCode *string `json:"stateCode,omitempty"`
	// time zone
	Timezone string `json:"timezone"`
}

type AddSocketAddOnCardInput struct {
	AddOns []*SocketAddOnCardInput `json:"addOns"`
	Site   *SiteRefInput           `json:"site"`
}

type AddSocketAddOnCardPayload struct {
	AddOns []*SocketAddOnCard `json:"addOns"`
}

type AddSocketSiteInput struct {
	ConnectionType SiteConnectionTypeEnum `json:"connectionType"`
	Description    *string                `json:"description,omitempty"`
	// The name of the site
	Name string `json:"name"`
	// The native range of the site
	NativeNetworkRange string `json:"nativeNetworkRange"`
	// The location of the site
	SiteLocation *AddSiteLocationInput `json:"siteLocation"`
	// Valid values are: BRANCH, HEADQUARTERS,	CLOUD_DC, and DATACENTER.
	SiteType         SiteType `json:"siteType"`
	TranslatedSubnet *string  `json:"translatedSubnet,omitempty"`
	// VLAN ID for native range
	Vlan *scalars.Vlan `json:"vlan,omitempty"`
}

type AddSocketSitePayload struct {
	SiteID string `json:"siteId"`
}

type AddStaticHostInput struct {
	IP         string  `json:"ip"`
	MacAddress *string `json:"macAddress,omitempty"`
	Name       string  `json:"name"`
}

type AddStaticHostPayload struct {
	HostID string `json:"hostId"`
}

type AddStoryCommentInput struct {
	// The relevant Story
	StoryID string `json:"storyId"`
	// Enter the text for the XDR story comment
	Text string `json:"text"`
}

type AddStoryCommentPayload struct {
	// Add a new comment to the XDR story
	Comment *StoryComment `json:"comment"`
}

type AddressInput struct {
	// City
	CityName string `json:"cityName"`
	// Company name (recipient)
	CompanyName string `json:"companyName"`
	// Country
	CountryName string `json:"countryName"`
	// State (required only for USA)
	StateName *string `json:"stateName,omitempty"`
	// Street name and number
	Street string `json:"street"`
	// Zip Code
	ZipCode string `json:"zipCode"`
}

// A CC2 administrator
type Admin struct {
	AdminType             *AdminType                 `json:"adminType,omitempty"`
	AllowedItems          []*Entity                  `json:"allowedItems,omitempty"`
	CreationDate          *string                    `json:"creationDate,omitempty"`
	Email                 *string                    `json:"email,omitempty"`
	FirstName             *string                    `json:"firstName,omitempty"`
	ID                    string                     `json:"id"`
	LastName              *string                    `json:"lastName,omitempty"`
	ManagedRoles          []*AdminRole               `json:"managedRoles,omitempty"`
	MfaEnabled            *bool                      `json:"mfaEnabled,omitempty"`
	ModifyDate            *string                    `json:"modifyDate,omitempty"`
	NativeAccountID       *string                    `json:"nativeAccountID,omitempty"`
	PasswordNeverExpires  *bool                      `json:"passwordNeverExpires,omitempty"`
	PresentUsageAndEvents *bool                      `json:"presentUsageAndEvents,omitempty"`
	ResellerRoles         []*AdminRole               `json:"resellerRoles,omitempty"`
	Role                  *UserRole                  `json:"role,omitempty"`
	Status                *scalars.OperationalStatus `json:"status,omitempty"`
	Version               string                     `json:"version"`
}

type AdminMutations struct {
	AddAdmin                    *AddAdminPayload                    `json:"addAdmin,omitempty"`
	AddServicePrincipalAdmin    *AddServicePrincipalAdminPayload    `json:"addServicePrincipalAdmin,omitempty"`
	RemoveAdmin                 *RemoveAdminPayload                 `json:"removeAdmin,omitempty"`
	RemoveServicePrincipalAdmin *RemoveServicePrincipalAdminPayload `json:"removeServicePrincipalAdmin,omitempty"`
	UpdateAdmin                 *UpdateAdminPayload                 `json:"updateAdmin,omitempty"`
	UpdateServicePrincipalAdmin *UpdateServicePrincipalAdminPayload `json:"updateServicePrincipalAdmin,omitempty"`
}

// A reference identifying the Admin object. ID: Unique Admin Identifier, Name: The Admin Name
type AdminRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (AdminRef) IsActorRef()          {}
func (this AdminRef) GetID() string   { return this.ID }
func (this AdminRef) GetName() string { return this.Name }

func (AdminRef) IsObjectRef() {}

// Object's unique identifier

// Object's unique name

type AdminRole struct {
	AllowedAccounts []string  `json:"allowedAccounts,omitempty"`
	AllowedEntities []*Entity `json:"allowedEntities,omitempty"`
	Role            *RBACRole `json:"role"`
}

type AdminsResult struct {
	Items []*Admin `json:"items"`
	Total int64    `json:"total"`
}

type AdvancedStringFilterInput struct {
	Eq    *string  `json:"eq,omitempty"`
	In    []string `json:"in,omitempty"`
	Neq   *string  `json:"neq,omitempty"`
	Nin   []string `json:"nin,omitempty"`
	Regex *string  `json:"regex,omitempty"`
}

type AiOperationsIncident struct {
	AccountOperationIncident *AccountOperationsIncident    `json:"accountOperationIncident,omitempty"`
	AnalystFeedback          *AnalystFeedback              `json:"analystFeedback,omitempty"`
	ConnectionType           *ConnectionTypeEnum           `json:"connectionType,omitempty"`
	Criticality              *int64                        `json:"criticality,omitempty"`
	Description              *string                       `json:"description,omitempty"`
	EngineType               *StoryEngineTypeEnum          `json:"engineType,omitempty"`
	EventsGraphQuery         *EventsGraphQuery             `json:"eventsGraphQuery,omitempty"`
	FirstSignal              string                        `json:"firstSignal"`
	FlowLastTime             string                        `json:"flowLastTime"`
	FlowStartTime            string                        `json:"flowStartTime"`
	ID                       string                        `json:"id"`
	Indication               string                        `json:"indication"`
	Ioa                      string                        `json:"ioa"`
	LastSignal               string                        `json:"lastSignal"`
	Occurrences              *int64                        `json:"occurrences,omitempty"`
	PredictedThreatType      *string                       `json:"predictedThreatType,omitempty"`
	PredictedVerdict         *StoryVerdictEnum             `json:"predictedVerdict,omitempty"`
	Producer                 StoryProducerEnum             `json:"producer"`
	ProducerName             string                        `json:"producerName"`
	QueryName                *string                       `json:"queryName,omitempty"`
	Research                 *bool                         `json:"research,omitempty"`
	RiskScore                int64                         `json:"riskScore"`
	SimilarStoriesData       []*SimilarStoryData           `json:"similarStoriesData"`
	Site                     *SiteRef                      `json:"site,omitempty"`
	SiteName                 *string                       `json:"siteName,omitempty"`
	Source                   *string                       `json:"source,omitempty"`
	SourceIP                 *string                       `json:"sourceIp,omitempty"`
	Status                   *StoryStatusEnum              `json:"status,omitempty"`
	StoryDuration            *int64                        `json:"storyDuration,omitempty"`
	Ticket                   *string                       `json:"ticket,omitempty"`
	Type                     *AiOperationsIncidentTypeEnum `json:"type,omitempty"`
	User                     *UserRef                      `json:"user,omitempty"`
	Vendor                   *VendorEnum                   `json:"vendor,omitempty"`
}

func (AiOperationsIncident) IsMergedIncident() {}

// Unique Cato ID for each story
func (this AiOperationsIncident) GetID() string { return this.ID }

// Timestamp for the first incident signal related to this story
func (this AiOperationsIncident) GetFirstSignal() string { return this.FirstSignal }

// Timestamp for the last (most recent) incident signal related to this story
func (this AiOperationsIncident) GetLastSignal() string { return this.LastSignal }

// XDR engine involved with the incident
func (this AiOperationsIncident) GetEngineType() *StoryEngineTypeEnum { return this.EngineType }

// Vendor that identified the incident, such as Cato or Microsoft
func (this AiOperationsIncident) GetVendor() *VendorEnum { return this.Vendor }

// Producer (specific XDR engine and service) involved with the incident
func (this AiOperationsIncident) GetProducer() StoryProducerEnum { return this.Producer }

// Full name of the Producer (specific XDR engine and service) involved with the incident
func (this AiOperationsIncident) GetProducerName() string { return this.ProducerName }

// Connection for the incident
func (this AiOperationsIncident) GetConnectionType() *ConnectionTypeEnum { return this.ConnectionType }

// An indication is a set of actions and behaviors for the Network or Security incident. Each producer has different indications.
func (this AiOperationsIncident) GetIndication() string { return this.Indication }

// Category for the indication ID related to the story
func (this AiOperationsIncident) GetQueryName() *string { return this.QueryName }

// For Network stories - The potential impact of the issue on your network. Values are from 1 (low impact) to 10 (high impact)
//
// For Security stories - Cato's risk analysis of the story. Values are from 1 (low risk) to 10 (high risk)
func (this AiOperationsIncident) GetCriticality() *int64 { return this.Criticality }

// For Network stories - The site where the network issue is occurring
//
// For Security stories - IP address, name of device, or SDP user on your network involved in the story
func (this AiOperationsIncident) GetSource() *string { return this.Source }

// The ticket an analyst created for this story
func (this AiOperationsIncident) GetTicket() *string { return this.Ticket }

// Status for the story
func (this AiOperationsIncident) GetStatus() *StoryStatusEnum { return this.Status }

// The value is TRUE when the story is currently being researched by Security Analysts
func (this AiOperationsIncident) GetResearch() *bool { return this.Research }

// Site name related to the story
func (this AiOperationsIncident) GetSiteName() *string { return this.SiteName }

// Amount of time since the story was opened (no value for closed stories)
func (this AiOperationsIncident) GetStoryDuration() *int64 { return this.StoryDuration }

// For Security stories, description of the threat
func (this AiOperationsIncident) GetDescription() *string { return this.Description }

// The source IP address of the device in your network sending or receiving the flow
func (this AiOperationsIncident) GetSourceIP() *string { return this.SourceIP }

// Fields related to analysts research of the threat incident
func (this AiOperationsIncident) GetAnalystFeedback() *AnalystFeedback { return this.AnalystFeedback }

// Cato ID and name for the site
func (this AiOperationsIncident) GetSite() *SiteRef { return this.Site }

// Cato ID and name for the user
func (this AiOperationsIncident) GetUser() *UserRef { return this.User }
func (this AiOperationsIncident) GetPredictedVerdict() *StoryVerdictEnum {
	return this.PredictedVerdict
}
func (this AiOperationsIncident) GetPredictedThreatType() *string { return this.PredictedThreatType }

type AiOperationsPlaybook struct {
	Description string  `json:"description"`
	Link        *string `json:"link,omitempty"`
	Title       string  `json:"title"`
}

// A reference identifying the AllocatedIp object. ID: Unique AllocatedIp Identifier, Name: The AllocatedIp Name
type AllocatedIPRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (AllocatedIPRef) IsObjectRef() {}

// Object's unique identifier
func (this AllocatedIPRef) GetID() string { return this.ID }

// Object's unique name
func (this AllocatedIPRef) GetName() string { return this.Name }

type AllocatedIPRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

type AnalystFeedback struct {
	AdditionalInfo       *string                    `json:"additionalInfo,omitempty"`
	Severity             *SeverityEnum              `json:"severity,omitempty"`
	ThreatClassification *string                    `json:"threatClassification,omitempty"`
	ThreatType           *AnalystFeedbackThreatType `json:"threatType,omitempty"`
	Verdict              *StoryVerdictEnum          `json:"verdict,omitempty"`
}

type AnalystFeedbackInput struct {
	// Free text for the analyst to enter additional information about the XDR story
	AdditionalInfo *string `json:"additionalInfo,omitempty"`
	// Enum for analyst to assign the severity of a Malicious XDR story
	Severity *SeverityEnum `json:"severity,omitempty"`
	// Enum for the current status of the XDR story.
	Status *StoryStatusEnum `json:"status,omitempty"`
	// The relevant Story
	StoryID string `json:"storyId"`
	// More detailed description of the type of threat. For example, the Anonymizer threatType can be assigned the Bitorrent Client threatClassification.
	ThreatClassification *string `json:"threatClassification,omitempty"`
	// Type of threat for the XDR story that is assigned by the analyst
	ThreatType *StoryThreatType `json:"threatType,omitempty"`
	// Enum for analyst to assign the verdict of the XDR story
	Verdict *StoryVerdictEnum `json:"verdict,omitempty"`
}

type AnalystFeedbackPayload struct {
	// Data related to the actions and information that an analyst adds to the XDR story
	Story *Story `json:"story,omitempty"`
}

type AnalystFeedbackThreatType struct {
	Details           *string `json:"details,omitempty"`
	Name              *string `json:"name,omitempty"`
	RecommendedAction *string `json:"recommendedAction,omitempty"`
}

type AnalystInfo struct {
	// Security analyst email address
	Email *string `json:"email,omitempty"`
	// Security analyst name
	Name *string `json:"name,omitempty"`
}

// The `AnomalyEvents` object represents a data structure used in GraphQL queries or mutations, containing fields related to security anomalies, such as analyst feedback, connection type, criticality, description, and various identifiers and metrics, to provide detailed information about potential security incidents.
type AnomalyEvents struct {
	AnalystFeedback     *AnalystFeedback        `json:"analystFeedback,omitempty"`
	BreakdownField      *string                 `json:"breakdownField,omitempty"`
	ClientClass         []string                `json:"clientClass"`
	ConnectionType      *ConnectionTypeEnum     `json:"connectionType,omitempty"`
	Criticality         *int64                  `json:"criticality,omitempty"`
	Description         *string                 `json:"description,omitempty"`
	DeviceName          *string                 `json:"deviceName,omitempty"`
	Direction           *string                 `json:"direction,omitempty"`
	DrillDownFilter     []*StoryDrillDownFilter `json:"drillDownFilter,omitempty"`
	EngineType          *StoryEngineTypeEnum    `json:"engineType,omitempty"`
	Extra               []*Extra                `json:"extra,omitempty"`
	FirstSignal         string                  `json:"firstSignal"`
	Gaussian            *Gaussian               `json:"gaussian,omitempty"`
	ID                  string                  `json:"id"`
	Indication          string                  `json:"indication"`
	LastSignal          string                  `json:"lastSignal"`
	LogonName           *string                 `json:"logonName,omitempty"`
	MacAddress          *string                 `json:"macAddress,omitempty"`
	Metric              *Metric                 `json:"metric,omitempty"`
	MetricDetails       *MetricDetails          `json:"metricDetails,omitempty"`
	Mitres              []*Mitre                `json:"mitres,omitempty"`
	Os                  *string                 `json:"os,omitempty"`
	PredictedThreatType *string                 `json:"predictedThreatType,omitempty"`
	PredictedVerdict    *StoryVerdictEnum       `json:"predictedVerdict,omitempty"`
	Producer            StoryProducerEnum       `json:"producer"`
	ProducerName        string                  `json:"producerName"`
	QueryName           *string                 `json:"queryName,omitempty"`
	Research            *bool                   `json:"research,omitempty"`
	Rules               []string                `json:"rules,omitempty"`
	SimilarStoriesData  []*SimilarStoryData     `json:"similarStoriesData"`
	Site                *SiteRef                `json:"site,omitempty"`
	SiteName            *string                 `json:"siteName,omitempty"`
	Source              *string                 `json:"source,omitempty"`
	SourceIP            *string                 `json:"sourceIp,omitempty"`
	SrcSiteID           *string                 `json:"srcSiteId,omitempty"`
	Status              *StoryStatusEnum        `json:"status,omitempty"`
	StoryDuration       *int64                  `json:"storyDuration,omitempty"`
	SubjectType         *string                 `json:"subjectType,omitempty"`
	Targets             []*IncidentTargetRep    `json:"targets"`
	Ticket              *string                 `json:"ticket,omitempty"`
	TimeSeries          []*IncidentTimeseries   `json:"timeSeries,omitempty"`
	User                *UserRef                `json:"user,omitempty"`
	Vendor              *VendorEnum             `json:"vendor,omitempty"`
}

func (AnomalyEvents) IsAnomalies()                                {}
func (this AnomalyEvents) GetID() string                          { return this.ID }
func (this AnomalyEvents) GetFirstSignal() string                 { return this.FirstSignal }
func (this AnomalyEvents) GetLastSignal() string                  { return this.LastSignal }
func (this AnomalyEvents) GetEngineType() *StoryEngineTypeEnum    { return this.EngineType }
func (this AnomalyEvents) GetVendor() *VendorEnum                 { return this.Vendor }
func (this AnomalyEvents) GetProducer() StoryProducerEnum         { return this.Producer }
func (this AnomalyEvents) GetProducerName() string                { return this.ProducerName }
func (this AnomalyEvents) GetConnectionType() *ConnectionTypeEnum { return this.ConnectionType }
func (this AnomalyEvents) GetIndication() string                  { return this.Indication }
func (this AnomalyEvents) GetQueryName() *string                  { return this.QueryName }
func (this AnomalyEvents) GetSource() *string                     { return this.Source }
func (this AnomalyEvents) GetCriticality() *int64                 { return this.Criticality }
func (this AnomalyEvents) GetTicket() *string                     { return this.Ticket }
func (this AnomalyEvents) GetStatus() *StoryStatusEnum            { return this.Status }
func (this AnomalyEvents) GetResearch() *bool                     { return this.Research }
func (this AnomalyEvents) GetSiteName() *string                   { return this.SiteName }
func (this AnomalyEvents) GetStoryDuration() *int64               { return this.StoryDuration }
func (this AnomalyEvents) GetDescription() *string                { return this.Description }
func (this AnomalyEvents) GetAnalystFeedback() *AnalystFeedback   { return this.AnalystFeedback }
func (this AnomalyEvents) GetSite() *SiteRef                      { return this.Site }
func (this AnomalyEvents) GetUser() *UserRef                      { return this.User }
func (this AnomalyEvents) GetSourceIP() *string                   { return this.SourceIP }
func (this AnomalyEvents) GetSimilarStoriesData() []*SimilarStoryData {
	if this.SimilarStoriesData == nil {
		return nil
	}
	interfaceSlice := make([]*SimilarStoryData, 0, len(this.SimilarStoriesData))
	for _, concrete := range this.SimilarStoriesData {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this AnomalyEvents) GetPredictedVerdict() *StoryVerdictEnum { return this.PredictedVerdict }
func (this AnomalyEvents) GetPredictedThreatType() *string        { return this.PredictedThreatType }
func (this AnomalyEvents) GetDirection() *string                  { return this.Direction }

func (AnomalyEvents) IsMergedIncident() {}

// Unique Cato ID for each story

// Timestamp for the first incident signal related to this story

// Timestamp for the last (most recent) incident signal related to this story

// XDR engine involved with the incident

// Vendor that identified the incident, such as Cato or Microsoft

// Producer (specific XDR engine and service) involved with the incident

// Full name of the Producer (specific XDR engine and service) involved with the incident

// Connection for the incident

// An indication is a set of actions and behaviors for the Network or Security incident. Each producer has different indications.

// Category for the indication ID related to the story

// For Network stories - The potential impact of the issue on your network. Values are from 1 (low impact) to 10 (high impact)
//
// For Security stories - Cato's risk analysis of the story. Values are from 1 (low risk) to 10 (high risk)

// For Network stories - The site where the network issue is occurring
//
// For Security stories - IP address, name of device, or SDP user on your network involved in the story

// The ticket an analyst created for this story

// Status for the story

// The value is TRUE when the story is currently being researched by Security Analysts

// Site name related to the story

// Amount of time since the story was opened (no value for closed stories)

// For Security stories, description of the threat

// The source IP address of the device in your network sending or receiving the flow

// Fields related to analysts research of the threat incident

// Cato ID and name for the site

// Cato ID and name for the user

// The `AnomalyStats` object is a GraphQL type that represents statistical data related to anomalies, including fields such as analyst feedback, connection type, criticality, device information, and various metrics, along with associated metadata like timestamps, status, and predicted verdicts.
type AnomalyStats struct {
	AnalystFeedback     *AnalystFeedback        `json:"analystFeedback,omitempty"`
	BreakdownField      *string                 `json:"breakdownField,omitempty"`
	ClientClass         []string                `json:"clientClass"`
	ConnectionType      *ConnectionTypeEnum     `json:"connectionType,omitempty"`
	Criticality         *int64                  `json:"criticality,omitempty"`
	Description         *string                 `json:"description,omitempty"`
	DeviceName          *string                 `json:"deviceName,omitempty"`
	Direction           *string                 `json:"direction,omitempty"`
	DrillDownFilter     []*StoryDrillDownFilter `json:"drillDownFilter,omitempty"`
	EngineType          *StoryEngineTypeEnum    `json:"engineType,omitempty"`
	Extra               []*Extra                `json:"extra,omitempty"`
	FirstSignal         string                  `json:"firstSignal"`
	Gaussian            *Gaussian               `json:"gaussian,omitempty"`
	ID                  string                  `json:"id"`
	Indication          string                  `json:"indication"`
	LastSignal          string                  `json:"lastSignal"`
	LogonName           *string                 `json:"logonName,omitempty"`
	MacAddress          *string                 `json:"macAddress,omitempty"`
	Metric              *Metric                 `json:"metric,omitempty"`
	MetricDetails       *MetricDetails          `json:"metricDetails,omitempty"`
	Mitres              []*Mitre                `json:"mitres,omitempty"`
	Os                  *string                 `json:"os,omitempty"`
	PredictedThreatType *string                 `json:"predictedThreatType,omitempty"`
	PredictedVerdict    *StoryVerdictEnum       `json:"predictedVerdict,omitempty"`
	Producer            StoryProducerEnum       `json:"producer"`
	ProducerName        string                  `json:"producerName"`
	QueryName           *string                 `json:"queryName,omitempty"`
	Research            *bool                   `json:"research,omitempty"`
	Rules               []string                `json:"rules,omitempty"`
	SimilarStoriesData  []*SimilarStoryData     `json:"similarStoriesData"`
	Site                *SiteRef                `json:"site,omitempty"`
	SiteName            *string                 `json:"siteName,omitempty"`
	Source              *string                 `json:"source,omitempty"`
	SourceIP            *string                 `json:"sourceIp,omitempty"`
	SrcSiteID           *string                 `json:"srcSiteId,omitempty"`
	Status              *StoryStatusEnum        `json:"status,omitempty"`
	StoryDuration       *int64                  `json:"storyDuration,omitempty"`
	SubjectType         *string                 `json:"subjectType,omitempty"`
	Targets             []*IncidentTargetRep    `json:"targets"`
	Ticket              *string                 `json:"ticket,omitempty"`
	TimeSeries          []*IncidentTimeseries   `json:"timeSeries,omitempty"`
	User                *UserRef                `json:"user,omitempty"`
	Vendor              *VendorEnum             `json:"vendor,omitempty"`
}

func (AnomalyStats) IsAnomalies()                                {}
func (this AnomalyStats) GetID() string                          { return this.ID }
func (this AnomalyStats) GetFirstSignal() string                 { return this.FirstSignal }
func (this AnomalyStats) GetLastSignal() string                  { return this.LastSignal }
func (this AnomalyStats) GetEngineType() *StoryEngineTypeEnum    { return this.EngineType }
func (this AnomalyStats) GetVendor() *VendorEnum                 { return this.Vendor }
func (this AnomalyStats) GetProducer() StoryProducerEnum         { return this.Producer }
func (this AnomalyStats) GetProducerName() string                { return this.ProducerName }
func (this AnomalyStats) GetConnectionType() *ConnectionTypeEnum { return this.ConnectionType }
func (this AnomalyStats) GetIndication() string                  { return this.Indication }
func (this AnomalyStats) GetQueryName() *string                  { return this.QueryName }
func (this AnomalyStats) GetSource() *string                     { return this.Source }
func (this AnomalyStats) GetCriticality() *int64                 { return this.Criticality }
func (this AnomalyStats) GetTicket() *string                     { return this.Ticket }
func (this AnomalyStats) GetStatus() *StoryStatusEnum            { return this.Status }
func (this AnomalyStats) GetResearch() *bool                     { return this.Research }
func (this AnomalyStats) GetSiteName() *string                   { return this.SiteName }
func (this AnomalyStats) GetStoryDuration() *int64               { return this.StoryDuration }
func (this AnomalyStats) GetDescription() *string                { return this.Description }
func (this AnomalyStats) GetAnalystFeedback() *AnalystFeedback   { return this.AnalystFeedback }
func (this AnomalyStats) GetSite() *SiteRef                      { return this.Site }
func (this AnomalyStats) GetUser() *UserRef                      { return this.User }
func (this AnomalyStats) GetSourceIP() *string                   { return this.SourceIP }
func (this AnomalyStats) GetSimilarStoriesData() []*SimilarStoryData {
	if this.SimilarStoriesData == nil {
		return nil
	}
	interfaceSlice := make([]*SimilarStoryData, 0, len(this.SimilarStoriesData))
	for _, concrete := range this.SimilarStoriesData {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this AnomalyStats) GetPredictedVerdict() *StoryVerdictEnum { return this.PredictedVerdict }
func (this AnomalyStats) GetPredictedThreatType() *string        { return this.PredictedThreatType }
func (this AnomalyStats) GetDirection() *string                  { return this.Direction }

func (AnomalyStats) IsMergedIncident() {}

// Unique Cato ID for each story

// Timestamp for the first incident signal related to this story

// Timestamp for the last (most recent) incident signal related to this story

// XDR engine involved with the incident

// Vendor that identified the incident, such as Cato or Microsoft

// Producer (specific XDR engine and service) involved with the incident

// Full name of the Producer (specific XDR engine and service) involved with the incident

// Connection for the incident

// An indication is a set of actions and behaviors for the Network or Security incident. Each producer has different indications.

// Category for the indication ID related to the story

// For Network stories - The potential impact of the issue on your network. Values are from 1 (low impact) to 10 (high impact)
//
// For Security stories - Cato's risk analysis of the story. Values are from 1 (low risk) to 10 (high risk)

// For Network stories - The site where the network issue is occurring
//
// For Security stories - IP address, name of device, or SDP user on your network involved in the story

// The ticket an analyst created for this story

// Status for the story

// The value is TRUE when the story is currently being researched by Security Analysts

// Site name related to the story

// Amount of time since the story was opened (no value for closed stories)

// For Security stories, description of the threat

// The source IP address of the device in your network sending or receiving the flow

// Fields related to analysts research of the threat incident

// Cato ID and name for the site

// Cato ID and name for the user

type AntiMalwareFileHashAddRuleDataInput struct {
	// The action when the file hash is matched: [BLOCK | BYPASS]
	Action      AntiMalwareFileHashAction `json:"action"`
	Description string                    `json:"description"`
	Enabled     bool                      `json:"enabled"`
	// The date when the block or bypass action expires
	ExpirationDate string `json:"expirationDate"`
	// The name of the file
	FileName string `json:"fileName"`
	Name     string `json:"name"`
	// The file's unique SHA-256 hash identifier
	Sha256 string `json:"sha256"`
}

type AntiMalwareFileHashAddRuleInput struct {
	// Position of the rule in the policy
	At *PolicyRulePositionInput `json:"at,omitempty"`
	// Parameters for the rule you are adding
	Rule *AntiMalwareFileHashAddRuleDataInput `json:"rule"`
}

type AntiMalwareFileHashPolicy struct {
	Audit    *PolicyAudit                      `json:"audit,omitempty"`
	Enabled  bool                              `json:"enabled"`
	Revision *PolicyRevision                   `json:"revision,omitempty"`
	Rules    []*AntiMalwareFileHashRulePayload `json:"rules"`
	Sections []*PolicySectionPayload           `json:"sections"`
}

func (AntiMalwareFileHashPolicy) IsIPolicy() {}

// TRUE = Policy is enabled, FALSE = Policy is disabled
func (this AntiMalwareFileHashPolicy) GetEnabled() bool { return this.Enabled }

// Return list of rules in the policy
func (this AntiMalwareFileHashPolicy) GetRules() []IPolicyRulePayload {
	if this.Rules == nil {
		return nil
	}
	interfaceSlice := make([]IPolicyRulePayload, 0, len(this.Rules))
	for _, concrete := range this.Rules {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

// Return sections in the policy
func (this AntiMalwareFileHashPolicy) GetSections() []*PolicySectionPayload {
	if this.Sections == nil {
		return nil
	}
	interfaceSlice := make([]*PolicySectionPayload, 0, len(this.Sections))
	for _, concrete := range this.Sections {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

// Audit data for the policy
func (this AntiMalwareFileHashPolicy) GetAudit() *PolicyAudit { return this.Audit }

// Return data for the Policy revision
func (this AntiMalwareFileHashPolicy) GetRevision() *PolicyRevision { return this.Revision }

type AntiMalwareFileHashPolicyInput struct {
	// A revision is a specific instance of the policy.
	//  Unpublished revisions are working copies of the policy available to a specific
	//  admin or a set of admins
	//  Published revisions are revisions that were applied to the account network.
	//  The last published revision is the active policy.
	Revision *PolicyRevisionInput `json:"revision,omitempty"`
}

type AntiMalwareFileHashPolicyMutationInput struct {
	Revision *PolicyMutationRevisionInput `json:"revision,omitempty"`
}

type AntiMalwareFileHashPolicyMutationPayload struct {
	Errors []*PolicyMutationError     `json:"errors"`
	Policy *AntiMalwareFileHashPolicy `json:"policy,omitempty"`
	Status PolicyMutationStatus       `json:"status"`
}

func (AntiMalwareFileHashPolicyMutationPayload) IsIPolicyMutationPayload() {}

// Data for the policy
func (this AntiMalwareFileHashPolicyMutationPayload) GetPolicy() IPolicy { return *this.Policy }

// Enum for the status of the policy change
func (this AntiMalwareFileHashPolicyMutationPayload) GetStatus() PolicyMutationStatus {
	return this.Status
}

// List of errors related to the policy change
func (this AntiMalwareFileHashPolicyMutationPayload) GetErrors() []*PolicyMutationError {
	if this.Errors == nil {
		return nil
	}
	interfaceSlice := make([]*PolicyMutationError, 0, len(this.Errors))
	for _, concrete := range this.Errors {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

type AntiMalwareFileHashPolicyMutations struct {
	AddRule               *AntiMalwareFileHashRuleMutationPayload   `json:"addRule"`
	AddSection            *PolicySectionMutationPayload             `json:"addSection"`
	CreatePolicyRevision  *AntiMalwareFileHashPolicyMutationPayload `json:"createPolicyRevision"`
	DiscardPolicyRevision *AntiMalwareFileHashPolicyMutationPayload `json:"discardPolicyRevision"`
	MoveRule              *AntiMalwareFileHashRuleMutationPayload   `json:"moveRule"`
	MoveSection           *PolicySectionMutationPayload             `json:"moveSection"`
	PublishPolicyRevision *AntiMalwareFileHashPolicyMutationPayload `json:"publishPolicyRevision"`
	RemoveRule            *AntiMalwareFileHashRuleMutationPayload   `json:"removeRule"`
	RemoveSection         *PolicySectionMutationPayload             `json:"removeSection"`
	UpdatePolicy          *AntiMalwareFileHashPolicyMutationPayload `json:"updatePolicy"`
	UpdateRule            *AntiMalwareFileHashRuleMutationPayload   `json:"updateRule"`
	UpdateSection         *PolicySectionMutationPayload             `json:"updateSection"`
}

type AntiMalwareFileHashPolicyQueries struct {
	Policy    *AntiMalwareFileHashPolicy `json:"policy"`
	Revisions *PolicyRevisionsPayload    `json:"revisions,omitempty"`
}

type AntiMalwareFileHashPolicyUpdateInput struct {
	State *PolicyToggleState `json:"state,omitempty"`
}

type AntiMalwareFileHashRemoveRuleInput struct {
	ID string `json:"id"`
}

type AntiMalwareFileHashRule struct {
	// The action when the file hash is matched: [BLOCK | BYPASS]
	Action AntiMalwareFileHashAction `json:"action"`
	// Description for the rule
	Description string `json:"description"`
	// TRUE = Rule is enabled
	//  FALSE = Rule is disabled
	Enabled bool `json:"enabled"`
	// The date when the block or bypass action expires
	ExpirationDate string `json:"expirationDate"`
	// The name of the file
	FileName string `json:"fileName"`
	// Rule ID
	ID string `json:"id"`
	// Position / priority of rule
	Index int64 `json:"index"`
	// Name of the rule
	Name string `json:"name"`
	// Policy section where the rule is located
	Section *PolicySectionInfo `json:"section"`
	// The file's unique SHA-256 hash identifier
	Sha256 string `json:"sha256"`
}

func (AntiMalwareFileHashRule) IsIPolicyRule() {}

// Rule ID
func (this AntiMalwareFileHashRule) GetID() string { return this.ID }

// Name of the rule
func (this AntiMalwareFileHashRule) GetName() string { return this.Name }

// Description for the rule
func (this AntiMalwareFileHashRule) GetDescription() *string { return &this.Description }

// Position / priority of rule
func (this AntiMalwareFileHashRule) GetIndex() int64 { return this.Index }

// TRUE = Rule is enabled, FALSE = Rule is disabled
func (this AntiMalwareFileHashRule) GetEnabled() bool { return this.Enabled }

// Policy section where the rule is located
func (this AntiMalwareFileHashRule) GetSection() *PolicySectionInfo { return this.Section }

type AntiMalwareFileHashRuleMutationPayload struct {
	Errors []*PolicyMutationError          `json:"errors"`
	Rule   *AntiMalwareFileHashRulePayload `json:"rule,omitempty"`
	Status PolicyMutationStatus            `json:"status"`
}

func (AntiMalwareFileHashRuleMutationPayload) IsIPolicyRuleMutationPayload() {}

// Returns settings for the rule
func (this AntiMalwareFileHashRuleMutationPayload) GetRule() IPolicyRulePayload { return *this.Rule }

// Enum for the status of the policy change
func (this AntiMalwareFileHashRuleMutationPayload) GetStatus() PolicyMutationStatus {
	return this.Status
}

// List of errors related to the policy change
func (this AntiMalwareFileHashRuleMutationPayload) GetErrors() []*PolicyMutationError {
	if this.Errors == nil {
		return nil
	}
	interfaceSlice := make([]*PolicyMutationError, 0, len(this.Errors))
	for _, concrete := range this.Errors {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

type AntiMalwareFileHashRulePayload struct {
	Audit      *PolicyElementAudit           `json:"audit"`
	Properties []PolicyElementPropertiesEnum `json:"properties"`
	Rule       *AntiMalwareFileHashRule      `json:"rule"`
}

func (AntiMalwareFileHashRulePayload) IsIPolicyRulePayload()              {}
func (this AntiMalwareFileHashRulePayload) GetAudit() *PolicyElementAudit { return this.Audit }

// Rule that was changed
func (this AntiMalwareFileHashRulePayload) GetRule() IPolicyRule { return *this.Rule }

// Summary of rule change, (ie. ADDED, UPDATED)
func (this AntiMalwareFileHashRulePayload) GetProperties() []PolicyElementPropertiesEnum {
	if this.Properties == nil {
		return nil
	}
	interfaceSlice := make([]PolicyElementPropertiesEnum, 0, len(this.Properties))
	for _, concrete := range this.Properties {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

type AntiMalwareFileHashUpdateRuleDataInput struct {
	// The action when the file hash is matched: [BLOCK | BYPASS]
	Action      *AntiMalwareFileHashAction `json:"action,omitempty"`
	Description *string                    `json:"description,omitempty"`
	Enabled     *bool                      `json:"enabled,omitempty"`
	// The date when the block or bypass action expires
	ExpirationDate *string `json:"expirationDate,omitempty"`
	// The name of the file
	FileName *string `json:"fileName,omitempty"`
	Name     *string `json:"name,omitempty"`
	// The file's unique SHA-256 hash identifier
	Sha256 *string `json:"sha256,omitempty"`
}

type AntiMalwareFileHashUpdateRuleInput struct {
	ID   string                                  `json:"id"`
	Rule *AntiMalwareFileHashUpdateRuleDataInput `json:"rule"`
}

// A reference identifying the ApiKey object. ID: Unique ApiKey Identifier, Name: The ApiKey Name
type APIKeyRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (APIKeyRef) IsActorRef()          {}
func (this APIKeyRef) GetID() string   { return this.ID }
func (this APIKeyRef) GetName() string { return this.Name }

func (APIKeyRef) IsObjectRef() {}

// Object's unique identifier

// Object's unique name

type AppStats struct {
	From    *string           `json:"from,omitempty"`
	ID      *string           `json:"id,omitempty"`
	Records []*AppStatsRecord `json:"records,omitempty"`
	To      *string           `json:"to,omitempty"`
	Total   *int64            `json:"total,omitempty"`
	Totals  map[string]any    `json:"totals,omitempty"`
}

type AppStatsField struct {
	Name  AppStatsFieldName `json:"name"`
	Value Value             `json:"value"`
}

type AppStatsFilter struct {
	FieldName AppStatsFieldName `json:"fieldName"`
	Operator  FilterOperator    `json:"operator"`
	Values    []string          `json:"values"`
}

type AppStatsRecord struct {
	Fields []*AppStatsField `json:"fields,omitempty"`
	// fields in map format (see Map scalar)
	FieldsMap       map[string]any `json:"fieldsMap,omitempty"`
	FieldsUnitTypes []UnitType     `json:"fieldsUnitTypes,omitempty"`
	// Simplified fields, as array of name value tuples, e.g: [ [ "name", "val" ], [ "name2", "val2" ] ... ]
	FlatFields    [][]string     `json:"flatFields,omitempty"`
	PrevTimeFrame map[string]any `json:"prevTimeFrame,omitempty"`
	Trends        map[string]any `json:"trends,omitempty"`
}

type AppStatsSort struct {
	FieldName AppStatsFieldName `json:"fieldName"`
	Order     DirectionEnum     `json:"order"`
}

type AppStatsTimeSeries struct {
	From        *string       `json:"from,omitempty"`
	Granularity *int64        `json:"granularity,omitempty"`
	ID          *string       `json:"id,omitempty"`
	Timeseries  []*Timeseries `json:"timeseries,omitempty"`
	To          *string       `json:"to,omitempty"`
}

type AppTenantRestrictionAddRuleDataInput struct {
	// The action applied by the App Tenant Restriction if the rule is matched
	Action AppTenantRestrictionActionEnum `json:"action"`
	// Applications for the rule (pre-defined)
	Application *ApplicationRefInput `json:"application"`
	Description string               `json:"description"`
	Enabled     bool                 `json:"enabled"`
	// Headers and Values to Inject
	Headers []*AppTenantRestrictionHeaderValueInput `json:"headers"`
	Name    string                                  `json:"name"`
	// The time period specifying when the rule is enabled, otherwise it is disabled.
	Schedule *PolicyScheduleInput `json:"schedule"`
	// Severity defined for the rule
	Severity AppTenantRestrictionSeverityEnum `json:"severity"`
	// Source traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Source *AppTenantRestrictionSourceInput `json:"source"`
}

type AppTenantRestrictionAddRuleInput struct {
	// Position of the rule in the policy
	At *PolicyRulePositionInput `json:"at,omitempty"`
	// Parameters for the rule you are adding
	Rule *AppTenantRestrictionAddRuleDataInput `json:"rule"`
}

// pair of header name and value
type AppTenantRestrictionHeaderValue struct {
	// Header to inject
	Name string `json:"name"`
	// Value to inject
	Value string `json:"value"`
}

// pair of header name and value
type AppTenantRestrictionHeaderValueInput struct {
	// Header to inject
	Name string `json:"name"`
	// Value to inject
	Value string `json:"value"`
}

type AppTenantRestrictionPolicy struct {
	Audit    *PolicyAudit                       `json:"audit,omitempty"`
	Enabled  bool                               `json:"enabled"`
	Revision *PolicyRevision                    `json:"revision,omitempty"`
	Rules    []*AppTenantRestrictionRulePayload `json:"rules"`
	Sections []*PolicySectionPayload            `json:"sections"`
}

func (AppTenantRestrictionPolicy) IsIPolicy() {}

// TRUE = Policy is enabled, FALSE = Policy is disabled
func (this AppTenantRestrictionPolicy) GetEnabled() bool { return this.Enabled }

// Return list of rules in the policy
func (this AppTenantRestrictionPolicy) GetRules() []IPolicyRulePayload {
	if this.Rules == nil {
		return nil
	}
	interfaceSlice := make([]IPolicyRulePayload, 0, len(this.Rules))
	for _, concrete := range this.Rules {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

// Return sections in the policy
func (this AppTenantRestrictionPolicy) GetSections() []*PolicySectionPayload {
	if this.Sections == nil {
		return nil
	}
	interfaceSlice := make([]*PolicySectionPayload, 0, len(this.Sections))
	for _, concrete := range this.Sections {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

// Audit data for the policy
func (this AppTenantRestrictionPolicy) GetAudit() *PolicyAudit { return this.Audit }

// Return data for the Policy revision
func (this AppTenantRestrictionPolicy) GetRevision() *PolicyRevision { return this.Revision }

type AppTenantRestrictionPolicyInput struct {
	// A revision is a specific instance of the policy.
	//  Unpublished revisions are working copies of the policy available to a specific
	//  admin or a set of admins
	//  Published revisions are revisions that were applied to the account network.
	//  The last published revision is the active policy.
	Revision *PolicyRevisionInput `json:"revision,omitempty"`
}

type AppTenantRestrictionPolicyMutationInput struct {
	Revision *PolicyMutationRevisionInput `json:"revision,omitempty"`
}

type AppTenantRestrictionPolicyMutationPayload struct {
	Errors []*PolicyMutationError      `json:"errors"`
	Policy *AppTenantRestrictionPolicy `json:"policy,omitempty"`
	Status PolicyMutationStatus        `json:"status"`
}

func (AppTenantRestrictionPolicyMutationPayload) IsIPolicyMutationPayload() {}

// Data for the policy
func (this AppTenantRestrictionPolicyMutationPayload) GetPolicy() IPolicy { return *this.Policy }

// Enum for the status of the policy change
func (this AppTenantRestrictionPolicyMutationPayload) GetStatus() PolicyMutationStatus {
	return this.Status
}

// List of errors related to the policy change
func (this AppTenantRestrictionPolicyMutationPayload) GetErrors() []*PolicyMutationError {
	if this.Errors == nil {
		return nil
	}
	interfaceSlice := make([]*PolicyMutationError, 0, len(this.Errors))
	for _, concrete := range this.Errors {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

type AppTenantRestrictionPolicyMutations struct {
	AddRule               *AppTenantRestrictionRuleMutationPayload   `json:"addRule"`
	AddSection            *PolicySectionMutationPayload              `json:"addSection"`
	CreatePolicyRevision  *AppTenantRestrictionPolicyMutationPayload `json:"createPolicyRevision"`
	DiscardPolicyRevision *AppTenantRestrictionPolicyMutationPayload `json:"discardPolicyRevision"`
	MoveRule              *AppTenantRestrictionRuleMutationPayload   `json:"moveRule"`
	MoveSection           *PolicySectionMutationPayload              `json:"moveSection"`
	PublishPolicyRevision *AppTenantRestrictionPolicyMutationPayload `json:"publishPolicyRevision"`
	RemoveRule            *AppTenantRestrictionRuleMutationPayload   `json:"removeRule"`
	RemoveSection         *PolicySectionMutationPayload              `json:"removeSection"`
	UpdatePolicy          *AppTenantRestrictionPolicyMutationPayload `json:"updatePolicy"`
	UpdateRule            *AppTenantRestrictionRuleMutationPayload   `json:"updateRule"`
	UpdateSection         *PolicySectionMutationPayload              `json:"updateSection"`
}

type AppTenantRestrictionPolicyQueries struct {
	Policy    *AppTenantRestrictionPolicy `json:"policy"`
	Revisions *PolicyRevisionsPayload     `json:"revisions,omitempty"`
}

type AppTenantRestrictionPolicyUpdateInput struct {
	State *PolicyToggleState `json:"state,omitempty"`
}

type AppTenantRestrictionRemoveRuleInput struct {
	ID string `json:"id"`
}

type AppTenantRestrictionRule struct {
	// The action applied by the App Tenant Restriction if the rule is matched
	Action AppTenantRestrictionActionEnum `json:"action"`
	// Applications for the rule (pre-defined)
	Application *ApplicationRef `json:"application"`
	// Description for the rule
	Description string `json:"description"`
	// TRUE = Rule is enabled
	//  FALSE = Rule is disabled
	Enabled bool `json:"enabled"`
	// Headers and Values to Inject
	Headers []*AppTenantRestrictionHeaderValue `json:"headers"`
	// Rule ID
	ID string `json:"id"`
	// Position / priority of rule
	Index int64 `json:"index"`
	// Name of the rule
	Name string `json:"name"`
	// The time period specifying when the rule is enabled, otherwise it is disabled.
	Schedule *PolicySchedule `json:"schedule"`
	// Policy section where the rule is located
	Section *PolicySectionInfo `json:"section"`
	// Severity defined for the rule
	Severity AppTenantRestrictionSeverityEnum `json:"severity"`
	// Source traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Source *AppTenantRestrictionSource `json:"source"`
}

func (AppTenantRestrictionRule) IsIPolicyRule() {}

// Rule ID
func (this AppTenantRestrictionRule) GetID() string { return this.ID }

// Name of the rule
func (this AppTenantRestrictionRule) GetName() string { return this.Name }

// Description for the rule
func (this AppTenantRestrictionRule) GetDescription() *string { return &this.Description }

// Position / priority of rule
func (this AppTenantRestrictionRule) GetIndex() int64 { return this.Index }

// TRUE = Rule is enabled, FALSE = Rule is disabled
func (this AppTenantRestrictionRule) GetEnabled() bool { return this.Enabled }

// Policy section where the rule is located
func (this AppTenantRestrictionRule) GetSection() *PolicySectionInfo { return this.Section }

type AppTenantRestrictionRuleMutationPayload struct {
	Errors []*PolicyMutationError           `json:"errors"`
	Rule   *AppTenantRestrictionRulePayload `json:"rule,omitempty"`
	Status PolicyMutationStatus             `json:"status"`
}

func (AppTenantRestrictionRuleMutationPayload) IsIPolicyRuleMutationPayload() {}

// Returns settings for the rule
func (this AppTenantRestrictionRuleMutationPayload) GetRule() IPolicyRulePayload { return *this.Rule }

// Enum for the status of the policy change
func (this AppTenantRestrictionRuleMutationPayload) GetStatus() PolicyMutationStatus {
	return this.Status
}

// List of errors related to the policy change
func (this AppTenantRestrictionRuleMutationPayload) GetErrors() []*PolicyMutationError {
	if this.Errors == nil {
		return nil
	}
	interfaceSlice := make([]*PolicyMutationError, 0, len(this.Errors))
	for _, concrete := range this.Errors {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

type AppTenantRestrictionRulePayload struct {
	Audit      *PolicyElementAudit           `json:"audit"`
	Properties []PolicyElementPropertiesEnum `json:"properties"`
	Rule       *AppTenantRestrictionRule     `json:"rule"`
}

func (AppTenantRestrictionRulePayload) IsIPolicyRulePayload()              {}
func (this AppTenantRestrictionRulePayload) GetAudit() *PolicyElementAudit { return this.Audit }

// Rule that was changed
func (this AppTenantRestrictionRulePayload) GetRule() IPolicyRule { return *this.Rule }

// Summary of rule change, (ie. ADDED, UPDATED)
func (this AppTenantRestrictionRulePayload) GetProperties() []PolicyElementPropertiesEnum {
	if this.Properties == nil {
		return nil
	}
	interfaceSlice := make([]PolicyElementPropertiesEnum, 0, len(this.Properties))
	for _, concrete := range this.Properties {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

// Returns the settings for Source of an App Tenant Restriction rule
type AppTenantRestrictionSource struct {
	// Source country traffic matching criteria.
	Country []*CountryRef `json:"country"`
	// Floating Subnets (ie. Floating Ranges) are used to identify traffic exactly matched to the route advertised by BGP. They are not associated with a specific site. This is useful in scenarios such as active-standby high availability routed via BGP.
	FloatingSubnet []*FloatingSubnetRef `json:"floatingSubnet"`
	// Globally defined IP range, IP and subnet objects
	GlobalIPRange []*GlobalIPRangeRef `json:"globalIpRange"`
	// Groups defined for your account
	Group []*GroupRef `json:"group"`
	// Hosts and servers defined for your account
	Host []*HostRef `json:"host"`
	// IPv4 address
	IP []string `json:"ip"`
	// Multiple separate IP addresses or an IP range
	IPRange []*IPAddressRange `json:"ipRange"`
	// Network range defined for a site
	NetworkInterface []*NetworkInterfaceRef `json:"networkInterface"`
	// Site defined for the account
	Site []*SiteRef `json:"site"`
	// GlobalRange + InterfaceSubnet
	SiteNetworkSubnet []*SiteNetworkSubnetRef `json:"siteNetworkSubnet"`
	// Subnets and network ranges defined for the LAN interfaces of a site
	Subnet []string `json:"subnet"`
	// Predefined Cato groups
	SystemGroup []*SystemGroupRef `json:"systemGroup"`
	// Individual users defined for the account
	User []*UserRef `json:"user"`
	// Group of users
	UsersGroup []*UsersGroupRef `json:"usersGroup"`
}

// Input of the settings for Source of an App Tenant Restriction rule
type AppTenantRestrictionSourceInput struct {
	// Source country traffic matching criteria.
	Country []*CountryRefInput `json:"country"`
	// Floating Subnets (ie. Floating Ranges) are used to identify traffic exactly matched to the route advertised by BGP. They are not associated with a specific site. This is useful in scenarios such as active-standby high availability routed via BGP.
	FloatingSubnet []*FloatingSubnetRefInput `json:"floatingSubnet"`
	// Globally defined IP range, IP and subnet objects
	GlobalIPRange []*GlobalIPRangeRefInput `json:"globalIpRange"`
	// Groups defined for your account
	Group []*GroupRefInput `json:"group"`
	// Hosts and servers defined for your account
	Host []*HostRefInput `json:"host"`
	// IPv4 address
	IP []string `json:"ip"`
	// Multiple separate IP addresses or an IP range
	IPRange []*IPAddressRangeInput `json:"ipRange"`
	// Network range defined for a site
	NetworkInterface []*NetworkInterfaceRefInput `json:"networkInterface"`
	// Site defined for the account
	Site []*SiteRefInput `json:"site"`
	// GlobalRange + InterfaceSubnet
	SiteNetworkSubnet []*SiteNetworkSubnetRefInput `json:"siteNetworkSubnet"`
	// Subnets and network ranges defined for the LAN interfaces of a site
	Subnet []string `json:"subnet"`
	// Predefined Cato groups
	SystemGroup []*SystemGroupRefInput `json:"systemGroup"`
	// Individual users defined for the account
	User []*UserRefInput `json:"user"`
	// Group of users
	UsersGroup []*UsersGroupRefInput `json:"usersGroup"`
}

// Input of the settings for Source of an App Tenant Restriction rule
type AppTenantRestrictionSourceUpdateInput struct {
	// Source country traffic matching criteria.
	Country []*CountryRefInput `json:"country,omitempty"`
	// Floating Subnets (ie. Floating Ranges) are used to identify traffic exactly matched to the route advertised by BGP. They are not associated with a specific site. This is useful in scenarios such as active-standby high availability routed via BGP.
	FloatingSubnet []*FloatingSubnetRefInput `json:"floatingSubnet,omitempty"`
	// Globally defined IP range, IP and subnet objects
	GlobalIPRange []*GlobalIPRangeRefInput `json:"globalIpRange,omitempty"`
	// Groups defined for your account
	Group []*GroupRefInput `json:"group,omitempty"`
	// Hosts and servers defined for your account
	Host []*HostRefInput `json:"host,omitempty"`
	// IPv4 address
	IP []string `json:"ip,omitempty"`
	// Multiple separate IP addresses or an IP range
	IPRange []*IPAddressRangeInput `json:"ipRange,omitempty"`
	// Network range defined for a site
	NetworkInterface []*NetworkInterfaceRefInput `json:"networkInterface,omitempty"`
	// Site defined for the account
	Site []*SiteRefInput `json:"site,omitempty"`
	// GlobalRange + InterfaceSubnet
	SiteNetworkSubnet []*SiteNetworkSubnetRefInput `json:"siteNetworkSubnet,omitempty"`
	// Subnets and network ranges defined for the LAN interfaces of a site
	Subnet []string `json:"subnet,omitempty"`
	// Predefined Cato groups
	SystemGroup []*SystemGroupRefInput `json:"systemGroup,omitempty"`
	// Individual users defined for the account
	User []*UserRefInput `json:"user,omitempty"`
	// Group of users
	UsersGroup []*UsersGroupRefInput `json:"usersGroup,omitempty"`
}

type AppTenantRestrictionUpdateRuleDataInput struct {
	// The action applied by the App Tenant Restriction if the rule is matched
	Action *AppTenantRestrictionActionEnum `json:"action,omitempty"`
	// Applications for the rule (pre-defined)
	Application *ApplicationRefInput `json:"application,omitempty"`
	Description *string              `json:"description,omitempty"`
	Enabled     *bool                `json:"enabled,omitempty"`
	// Headers and Values to Inject
	Headers []*AppTenantRestrictionHeaderValueInput `json:"headers,omitempty"`
	Name    *string                                 `json:"name,omitempty"`
	// The time period specifying when the rule is enabled, otherwise it is disabled.
	Schedule *PolicyScheduleUpdateInput `json:"schedule,omitempty"`
	// Severity defined for the rule
	Severity *AppTenantRestrictionSeverityEnum `json:"severity,omitempty"`
	// Source traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Source *AppTenantRestrictionSourceUpdateInput `json:"source,omitempty"`
}

type AppTenantRestrictionUpdateRuleInput struct {
	ID   string                                   `json:"id"`
	Rule *AppTenantRestrictionUpdateRuleDataInput `json:"rule"`
}

// A reference identifying the ApplicationCategory object. ID: Unique ApplicationCategory Identifier, Name: The ApplicationCategory Name
type ApplicationCategoryRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (ApplicationCategoryRef) IsObjectRef() {}

// Object's unique identifier
func (this ApplicationCategoryRef) GetID() string { return this.ID }

// Object's unique name
func (this ApplicationCategoryRef) GetName() string { return this.Name }

type ApplicationCategoryRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

// Access method matching configuration
type ApplicationControlAccessMethod struct {
	// Specifies the access method type
	AccessMethod ApplicationControlAccessMethodType `json:"accessMethod"`
	// Defines the comparison operator
	Operator ApplicationControlOperator `json:"operator"`
	// Specifies the comparison value (used with all operators except IN)
	Value *string `json:"value,omitempty"`
	// References a set of values (used only with IN operator)
	ValueSet *StringValueSetRef `json:"valueSet,omitempty"`
}

// Access method matching configuration
type ApplicationControlAccessMethodInput struct {
	// Specifies the access method type
	AccessMethod ApplicationControlAccessMethodType `json:"accessMethod"`
	// Defines the comparison operator
	Operator ApplicationControlOperator `json:"operator"`
	// Specifies the comparison value (used with all operators except IN)
	Value *string `json:"value,omitempty"`
	// References a set of values (used only with IN operator)
	ValueSet *StringValueSetRefInput `json:"valueSet,omitempty"`
}

// Activity matching configuration
type ApplicationControlActivity struct {
	// References the application control activity type
	Activity *ApplicationControlActivityRef `json:"activity"`
	// References specific application control activity fields associated with the activity type
	Field *ApplicationControlActivityFieldRef `json:"field,omitempty"`
	// Defines the operator used for comparisons
	Operator *ApplicationControlOperator `json:"operator,omitempty"`
	// Specifies the comparison value (used with all operators except IN)
	Value *string `json:"value,omitempty"`
	// References a set of values (used only with IN operator)
	ValueSet *StringValueSetRef `json:"valueSet,omitempty"`
}

type ApplicationControlActivityFieldRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (ApplicationControlActivityFieldRef) IsObjectRef() {}

// Object's unique identifier
func (this ApplicationControlActivityFieldRef) GetID() string { return this.ID }

// Object's unique name
func (this ApplicationControlActivityFieldRef) GetName() string { return this.Name }

type ApplicationControlActivityFieldRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

// Activity matching configuration
type ApplicationControlActivityInput struct {
	// References the application control activity type
	Activity *ApplicationControlActivityRefInput `json:"activity"`
	// References specific application control activity fields associated with the activity type
	Field *ApplicationControlActivityFieldRefInput `json:"field,omitempty"`
	// Defines the operator used for comparisons
	Operator *ApplicationControlOperator `json:"operator,omitempty"`
	// Specifies the comparison value (used with all operators except IN)
	Value *string `json:"value,omitempty"`
	// References a set of values (used only with IN operator)
	ValueSet *StringValueSetRefInput `json:"valueSet,omitempty"`
}

type ApplicationControlActivityRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (ApplicationControlActivityRef) IsObjectRef() {}

// Object's unique identifier
func (this ApplicationControlActivityRef) GetID() string { return this.ID }

// Object's unique name
func (this ApplicationControlActivityRef) GetName() string { return this.Name }

type ApplicationControlActivityRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

type ApplicationControlAddRuleDataInput struct {
	// Defines application control settings. Must only be used when ruleType is APPLICATION
	ApplicationRule *ApplicationControlApplicationRuleInput `json:"applicationRule,omitempty"`
	// Defines data control settings. Must only be used when ruleType is DATA
	DataRule    *ApplicationControlDataRuleInput `json:"dataRule,omitempty"`
	Description string                           `json:"description"`
	Enabled     bool                             `json:"enabled"`
	// Defines file control settings. Must only be used when ruleType is FILE
	FileRule *ApplicationControlFileRuleInput `json:"fileRule,omitempty"`
	Name     string                           `json:"name"`
	// Determines which rule configuration to use.
	// When set to APPLICATION, only applicationRule should be used.
	// When set to DATA, only dataRule should be used.
	// When set to FILE, only fileRule should be used
	RuleType ApplicationControlRuleType `json:"ruleType"`
}

type ApplicationControlAddRuleInput struct {
	// Position of the rule in the policy
	At *PolicyRulePositionInput `json:"at,omitempty"`
	// Parameters for the rule you are adding
	Rule *ApplicationControlAddRuleDataInput `json:"rule"`
}

// Application matching configuration. Only one of the following fields should be filled - the others must remain empty.
type ApplicationControlApplication struct {
	// Cato category of applications which are dynamically updated by Cato
	AppCategory *ApplicationCategoryRef `json:"appCategory,omitempty"`
	// Applications for the rule (pre-defined)
	Application *ApplicationRef `json:"application,omitempty"`
	// Application types
	ApplicationType []ApplicationType `json:"applicationType"`
	// Custom (user-defined) applications
	CustomApp *CustomApplicationRef `json:"customApp,omitempty"`
	// Custom Categories – Groups of objects such as predefined and custom applications, predefined and custom services, domains, FQDNs etc.
	CustomCategory *CustomCategoryRef `json:"customCategory,omitempty"`
	// Sanctioned Cloud Applications - apps that are approved and generally represent an understood and acceptable level of risk in your organization.
	SanctionedAppsCategory *SanctionedAppsCategoryRef `json:"sanctionedAppsCategory,omitempty"`
}

// Application matching configuration. Only one of the following fields should be filled - the others must remain empty.
type ApplicationControlApplicationInput struct {
	// Cato category of applications which are dynamically updated by Cato
	AppCategory *ApplicationCategoryRefInput `json:"appCategory,omitempty"`
	// Applications for the rule (pre-defined)
	Application *ApplicationRefInput `json:"application,omitempty"`
	// Application types
	ApplicationType []ApplicationType `json:"applicationType"`
	// Custom (user-defined) applications
	CustomApp *CustomApplicationRefInput `json:"customApp,omitempty"`
	// Custom Categories – Groups of objects such as predefined and custom applications, predefined and custom services, domains, FQDNs etc.
	CustomCategory *CustomCategoryRefInput `json:"customCategory,omitempty"`
	// Sanctioned Cloud Applications - apps that are approved and generally represent an understood and acceptable level of risk in your organization.
	SanctionedAppsCategory *SanctionedAppsCategoryRefInput `json:"sanctionedAppsCategory,omitempty"`
}

// Configuration for application-based control rules
type ApplicationControlApplicationRule struct {
	// Defines access method criteria with OR logic within sets and AND between sets
	AccessMethod []*ApplicationControlAccessMethod `json:"accessMethod"`
	// Defines the enforcement action when rule conditions match
	Action ApplicationControlAction `json:"action"`
	// Defines application matching criteria with OR logic within sets and AND between sets
	Application *ApplicationControlApplication `json:"application"`
	// Defines activity matching criteria using activitySatisfy logic within sets and AND between sets
	ApplicationActivity []*ApplicationControlActivity `json:"applicationActivity"`
	// Determines whether ANY or ALL activity criteria must match
	ApplicationActivitySatisfy ApplicationControlSatisfy `json:"applicationActivitySatisfy"`
	// Defines application context criteria with OR logic within sets and AND between sets
	ApplicationContext *ApplicationControlContext `json:"applicationContext"`
	// Defines custom criteria using applicationCriteriaSatisfy logic within sets and AND between sets
	ApplicationCriteria *ApplicationControlCriteria `json:"applicationCriteria"`
	// Determines whether ANY or ALL criteria must match
	ApplicationCriteriaSatisfy ApplicationControlSatisfy `json:"applicationCriteriaSatisfy"`
	// Defines device profile criteria with OR logic within sets and AND between sets
	Device []*DeviceProfileRef `json:"device"`
	// Defines time periods when the rule is active
	Schedule *PolicySchedule `json:"schedule"`
	// Indicates the rule's severity level
	Severity ApplicationControlSeverity `json:"severity"`
	// Defines source traffic criteria with OR logic within sets and AND between sets
	Source *ApplicationControlSource `json:"source"`
	// Specifies event logging and notification settings
	Tracking *PolicyTracking `json:"tracking"`
}

// Configuration for application-based control rules
type ApplicationControlApplicationRuleInput struct {
	// Defines access method criteria with OR logic within sets and AND between sets
	AccessMethod []*ApplicationControlAccessMethodInput `json:"accessMethod"`
	// Defines the enforcement action when rule conditions match
	Action ApplicationControlAction `json:"action"`
	// Defines application matching criteria with OR logic within sets and AND between sets
	Application *ApplicationControlApplicationInput `json:"application"`
	// Defines activity matching criteria using activitySatisfy logic within sets and AND between sets
	ApplicationActivity []*ApplicationControlActivityInput `json:"applicationActivity"`
	// Determines whether ANY or ALL activity criteria must match
	ApplicationActivitySatisfy ApplicationControlSatisfy `json:"applicationActivitySatisfy"`
	// Defines application context criteria with OR logic within sets and AND between sets
	ApplicationContext *ApplicationControlContextInput `json:"applicationContext"`
	// Defines custom criteria using applicationCriteriaSatisfy logic within sets and AND between sets
	ApplicationCriteria *ApplicationControlCriteriaInput `json:"applicationCriteria"`
	// Determines whether ANY or ALL criteria must match
	ApplicationCriteriaSatisfy ApplicationControlSatisfy `json:"applicationCriteriaSatisfy"`
	// Defines device profile criteria with OR logic within sets and AND between sets
	Device []*DeviceProfileRefInput `json:"device"`
	// Defines time periods when the rule is active
	Schedule *PolicyScheduleInput `json:"schedule"`
	// Indicates the rule's severity level
	Severity ApplicationControlSeverity `json:"severity"`
	// Defines source traffic criteria with OR logic within sets and AND between sets
	Source *ApplicationControlSourceInput `json:"source"`
	// Specifies event logging and notification settings
	Tracking *PolicyTrackingInput `json:"tracking"`
}

// Configuration for application-based control rules
type ApplicationControlApplicationRuleUpdateInput struct {
	// Defines access method criteria with OR logic within sets and AND between sets
	AccessMethod []*ApplicationControlAccessMethodInput `json:"accessMethod,omitempty"`
	// Defines the enforcement action when rule conditions match
	Action *ApplicationControlAction `json:"action,omitempty"`
	// Defines application matching criteria with OR logic within sets and AND between sets
	Application *ApplicationControlApplicationUpdateInput `json:"application,omitempty"`
	// Defines activity matching criteria using activitySatisfy logic within sets and AND between sets
	ApplicationActivity []*ApplicationControlActivityInput `json:"applicationActivity,omitempty"`
	// Determines whether ANY or ALL activity criteria must match
	ApplicationActivitySatisfy *ApplicationControlSatisfy `json:"applicationActivitySatisfy,omitempty"`
	// Defines application context criteria with OR logic within sets and AND between sets
	ApplicationContext *ApplicationControlContextUpdateInput `json:"applicationContext,omitempty"`
	// Defines custom criteria using applicationCriteriaSatisfy logic within sets and AND between sets
	ApplicationCriteria *ApplicationControlCriteriaUpdateInput `json:"applicationCriteria,omitempty"`
	// Determines whether ANY or ALL criteria must match
	ApplicationCriteriaSatisfy *ApplicationControlSatisfy `json:"applicationCriteriaSatisfy,omitempty"`
	// Defines device profile criteria with OR logic within sets and AND between sets
	Device []*DeviceProfileRefInput `json:"device,omitempty"`
	// Defines time periods when the rule is active
	Schedule *PolicyScheduleUpdateInput `json:"schedule,omitempty"`
	// Indicates the rule's severity level
	Severity *ApplicationControlSeverity `json:"severity,omitempty"`
	// Defines source traffic criteria with OR logic within sets and AND between sets
	Source *ApplicationControlSourceUpdateInput `json:"source,omitempty"`
	// Specifies event logging and notification settings
	Tracking *PolicyTrackingUpdateInput `json:"tracking,omitempty"`
}

// Application matching configuration. Only one of the following fields should be filled - the others must remain empty.
type ApplicationControlApplicationUpdateInput struct {
	// Cato category of applications which are dynamically updated by Cato
	AppCategory *ApplicationCategoryRefInput `json:"appCategory,omitempty"`
	// Applications for the rule (pre-defined)
	Application *ApplicationRefInput `json:"application,omitempty"`
	// Application types
	ApplicationType []ApplicationType `json:"applicationType,omitempty"`
	// Custom (user-defined) applications
	CustomApp *CustomApplicationRefInput `json:"customApp,omitempty"`
	// Custom Categories – Groups of objects such as predefined and custom applications, predefined and custom services, domains, FQDNs etc.
	CustomCategory *CustomCategoryRefInput `json:"customCategory,omitempty"`
	// Sanctioned Cloud Applications - apps that are approved and generally represent an understood and acceptable level of risk in your organization.
	SanctionedAppsCategory *SanctionedAppsCategoryRefInput `json:"sanctionedAppsCategory,omitempty"`
}

// Application attributes, such as compliance and security, see the app catalog for details
type ApplicationControlAttributes struct {
	// Compliance attributes
	ComplianceAttributes *ApplicationControlComplianceAttributes `json:"complianceAttributes"`
	// Security attributes
	SecurityAttributes *ApplicationControlSecurityAttributes `json:"securityAttributes"`
}

// Application attributes, such as compliance and security, see the app catalog for details
type ApplicationControlAttributesInput struct {
	// Compliance attributes
	ComplianceAttributes *ApplicationControlComplianceAttributesInput `json:"complianceAttributes"`
	// Security attributes
	SecurityAttributes *ApplicationControlSecurityAttributesInput `json:"securityAttributes"`
}

// Application attributes, such as compliance and security, see the app catalog for details
type ApplicationControlAttributesUpdateInput struct {
	// Compliance attributes
	ComplianceAttributes *ApplicationControlComplianceAttributesUpdateInput `json:"complianceAttributes,omitempty"`
	// Security attributes
	SecurityAttributes *ApplicationControlSecurityAttributesUpdateInput `json:"securityAttributes,omitempty"`
}

// Compliance attributes
type ApplicationControlComplianceAttributes struct {
	// HIPAA
	Hippa ApplicationControlAttributeValue `json:"hippa"`
	// ISAE 3402
	Isae3402 ApplicationControlAttributeValue `json:"isae3402"`
	// ISO 27001
	Iso27001 ApplicationControlAttributeValue `json:"iso27001"`
	// PCI DSS
	PciDss ApplicationControlAttributeValue `json:"pciDss"`
	// SOC 1
	Soc1 ApplicationControlAttributeValue `json:"soc1"`
	// SOC 2
	Soc2 ApplicationControlAttributeValue `json:"soc2"`
	// SOC 3
	Soc3 ApplicationControlAttributeValue `json:"soc3"`
	// SOX
	Sox ApplicationControlAttributeValue `json:"sox"`
}

// Compliance attributes
type ApplicationControlComplianceAttributesInput struct {
	// HIPAA
	Hippa ApplicationControlAttributeValue `json:"hippa"`
	// ISAE 3402
	Isae3402 ApplicationControlAttributeValue `json:"isae3402"`
	// ISO 27001
	Iso27001 ApplicationControlAttributeValue `json:"iso27001"`
	// PCI DSS
	PciDss ApplicationControlAttributeValue `json:"pciDss"`
	// SOC 1
	Soc1 ApplicationControlAttributeValue `json:"soc1"`
	// SOC 2
	Soc2 ApplicationControlAttributeValue `json:"soc2"`
	// SOC 3
	Soc3 ApplicationControlAttributeValue `json:"soc3"`
	// SOX
	Sox ApplicationControlAttributeValue `json:"sox"`
}

// Compliance attributes
type ApplicationControlComplianceAttributesUpdateInput struct {
	// HIPAA
	Hippa *ApplicationControlAttributeValue `json:"hippa,omitempty"`
	// ISAE 3402
	Isae3402 *ApplicationControlAttributeValue `json:"isae3402,omitempty"`
	// ISO 27001
	Iso27001 *ApplicationControlAttributeValue `json:"iso27001,omitempty"`
	// PCI DSS
	PciDss *ApplicationControlAttributeValue `json:"pciDss,omitempty"`
	// SOC 1
	Soc1 *ApplicationControlAttributeValue `json:"soc1,omitempty"`
	// SOC 2
	Soc2 *ApplicationControlAttributeValue `json:"soc2,omitempty"`
	// SOC 3
	Soc3 *ApplicationControlAttributeValue `json:"soc3,omitempty"`
	// SOX
	Sox *ApplicationControlAttributeValue `json:"sox,omitempty"`
}

// Additional attributes for application control
type ApplicationControlConfig struct {
	// Data Control Enabled
	DataControlEnabled PolicyToggleState `json:"dataControlEnabled"`
}

type ApplicationControlConfigInput struct {
	// Data Control Enabled
	DataControlEnabled PolicyToggleState `json:"dataControlEnabled"`
}

type ApplicationControlContentTypeGroupRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (ApplicationControlContentTypeGroupRef) IsObjectRef() {}

// Object's unique identifier
func (this ApplicationControlContentTypeGroupRef) GetID() string { return this.ID }

// Object's unique name
func (this ApplicationControlContentTypeGroupRef) GetName() string { return this.Name }

type ApplicationControlContentTypeGroupRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

type ApplicationControlContentTypeRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (ApplicationControlContentTypeRef) IsObjectRef() {}

// Object's unique identifier
func (this ApplicationControlContentTypeRef) GetID() string { return this.ID }

// Object's unique name
func (this ApplicationControlContentTypeRef) GetName() string { return this.Name }

type ApplicationControlContentTypeRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

type ApplicationControlContext struct {
	// Defines the name of the application tenant to which the policy rule applies
	ApplicationTenant []*ApplicationControlTenant `json:"applicationTenant"`
}

type ApplicationControlContextInput struct {
	// Defines the name of the application tenant to which the policy rule applies
	ApplicationTenant []*ApplicationControlTenantInput `json:"applicationTenant"`
}

type ApplicationControlContextUpdateInput struct {
	// Defines the name of the application tenant to which the policy rule applies
	ApplicationTenant []*ApplicationControlTenantInput `json:"applicationTenant,omitempty"`
}

// Application criteria configuration
type ApplicationControlCriteria struct {
	// Application attributes, such as compliance and security, see the app catalog for details
	Attributes *ApplicationControlAttributes `json:"attributes"`
	// Application registered country of origin
	OriginCountry []*CountryRef `json:"originCountry"`
	// Application risk
	Risk []*ApplicationControlRiskCriteria `json:"risk"`
}

// Application criteria configuration
type ApplicationControlCriteriaInput struct {
	// Application attributes, such as compliance and security, see the app catalog for details
	Attributes *ApplicationControlAttributesInput `json:"attributes"`
	// Application registered country of origin
	OriginCountry []*CountryRefInput `json:"originCountry"`
	// Application risk
	Risk []*ApplicationControlRiskCriteriaInput `json:"risk"`
}

// Application criteria configuration
type ApplicationControlCriteriaUpdateInput struct {
	// Application attributes, such as compliance and security, see the app catalog for details
	Attributes *ApplicationControlAttributesUpdateInput `json:"attributes,omitempty"`
	// Application registered country of origin
	OriginCountry []*CountryRefInput `json:"originCountry,omitempty"`
	// Application risk
	Risk []*ApplicationControlRiskCriteriaInput `json:"risk,omitempty"`
}

// Configuration for data-based control rules
type ApplicationControlDataRule struct {
	// Defines access method criteria with OR logic within sets and AND between sets
	AccessMethod []*ApplicationControlAccessMethod `json:"accessMethod"`
	// Defines the enforcement action when rule conditions match
	Action ApplicationControlAction `json:"action"`
	// Defines application matching criteria with OR logic within sets and AND between sets
	Application *ApplicationControlApplication `json:"application"`
	// Defines activity matching criteria using activitySatisfy logic within sets and AND between sets
	ApplicationActivity []*ApplicationControlActivity `json:"applicationActivity"`
	// Determines whether ANY or ALL activity criteria must match
	ApplicationActivitySatisfy ApplicationControlSatisfy `json:"applicationActivitySatisfy"`
	// Defines application context criteria with OR logic within sets and AND between sets
	ApplicationContext *ApplicationControlContext `json:"applicationContext"`
	// Defines device profile criteria with OR logic within sets and AND between sets
	Device []*DeviceProfileRef `json:"device"`
	// Specifies DLP profile matching criteria with OR logic within sets and AND between sets
	DlpProfile *ApplicationControlDlpProfile `json:"dlpProfile"`
	// Defines file attribute criteria using fileAttributeSatisfy logic within sets and AND between sets
	FileAttribute []*ApplicationControlFileAttribute `json:"fileAttribute"`
	// Determines whether ANY or ALL file attribute criteria must match
	FileAttributeSatisfy ApplicationControlSatisfy `json:"fileAttributeSatisfy"`
	// Defines time periods when the rule is active
	Schedule *PolicySchedule `json:"schedule"`
	// Indicates the rule's severity level
	Severity ApplicationControlSeverity `json:"severity"`
	// Defines source traffic criteria with OR logic within sets and AND between sets
	Source *ApplicationControlSource `json:"source"`
	// Specifies event logging and notification settings
	Tracking *PolicyTracking `json:"tracking"`
}

// Configuration for data-based control rules
type ApplicationControlDataRuleInput struct {
	// Defines access method criteria with OR logic within sets and AND between sets
	AccessMethod []*ApplicationControlAccessMethodInput `json:"accessMethod"`
	// Defines the enforcement action when rule conditions match
	Action ApplicationControlAction `json:"action"`
	// Defines application matching criteria with OR logic within sets and AND between sets
	Application *ApplicationControlApplicationInput `json:"application"`
	// Defines activity matching criteria using activitySatisfy logic within sets and AND between sets
	ApplicationActivity []*ApplicationControlActivityInput `json:"applicationActivity"`
	// Determines whether ANY or ALL activity criteria must match
	ApplicationActivitySatisfy ApplicationControlSatisfy `json:"applicationActivitySatisfy"`
	// Defines application context criteria with OR logic within sets and AND between sets
	ApplicationContext *ApplicationControlContextInput `json:"applicationContext"`
	// Defines device profile criteria with OR logic within sets and AND between sets
	Device []*DeviceProfileRefInput `json:"device"`
	// Specifies DLP profile matching criteria with OR logic within sets and AND between sets
	DlpProfile *ApplicationControlDlpProfileInput `json:"dlpProfile"`
	// Defines file attribute criteria using fileAttributeSatisfy logic within sets and AND between sets
	FileAttribute []*ApplicationControlFileAttributeInput `json:"fileAttribute"`
	// Determines whether ANY or ALL file attribute criteria must match
	FileAttributeSatisfy ApplicationControlSatisfy `json:"fileAttributeSatisfy"`
	// Defines time periods when the rule is active
	Schedule *PolicyScheduleInput `json:"schedule"`
	// Indicates the rule's severity level
	Severity ApplicationControlSeverity `json:"severity"`
	// Defines source traffic criteria with OR logic within sets and AND between sets
	Source *ApplicationControlSourceInput `json:"source"`
	// Specifies event logging and notification settings
	Tracking *PolicyTrackingInput `json:"tracking"`
}

// Configuration for data-based control rules
type ApplicationControlDataRuleUpdateInput struct {
	// Defines access method criteria with OR logic within sets and AND between sets
	AccessMethod []*ApplicationControlAccessMethodInput `json:"accessMethod,omitempty"`
	// Defines the enforcement action when rule conditions match
	Action *ApplicationControlAction `json:"action,omitempty"`
	// Defines application matching criteria with OR logic within sets and AND between sets
	Application *ApplicationControlApplicationUpdateInput `json:"application,omitempty"`
	// Defines activity matching criteria using activitySatisfy logic within sets and AND between sets
	ApplicationActivity []*ApplicationControlActivityInput `json:"applicationActivity,omitempty"`
	// Determines whether ANY or ALL activity criteria must match
	ApplicationActivitySatisfy *ApplicationControlSatisfy `json:"applicationActivitySatisfy,omitempty"`
	// Defines application context criteria with OR logic within sets and AND between sets
	ApplicationContext *ApplicationControlContextUpdateInput `json:"applicationContext,omitempty"`
	// Defines device profile criteria with OR logic within sets and AND between sets
	Device []*DeviceProfileRefInput `json:"device,omitempty"`
	// Specifies DLP profile matching criteria with OR logic within sets and AND between sets
	DlpProfile *ApplicationControlDlpProfileUpdateInput `json:"dlpProfile,omitempty"`
	// Defines file attribute criteria using fileAttributeSatisfy logic within sets and AND between sets
	FileAttribute []*ApplicationControlFileAttributeInput `json:"fileAttribute,omitempty"`
	// Determines whether ANY or ALL file attribute criteria must match
	FileAttributeSatisfy *ApplicationControlSatisfy `json:"fileAttributeSatisfy,omitempty"`
	// Defines time periods when the rule is active
	Schedule *PolicyScheduleUpdateInput `json:"schedule,omitempty"`
	// Indicates the rule's severity level
	Severity *ApplicationControlSeverity `json:"severity,omitempty"`
	// Defines source traffic criteria with OR logic within sets and AND between sets
	Source *ApplicationControlSourceUpdateInput `json:"source,omitempty"`
	// Specifies event logging and notification settings
	Tracking *PolicyTrackingUpdateInput `json:"tracking,omitempty"`
}

// DLP profile configuration
type ApplicationControlDlpProfile struct {
	// References DLP content matching profiles
	ContentProfile []*DlpContentProfileRef `json:"contentProfile"`
	// References DLP exact data matching profiles
	EdmProfile []*DlpEdmProfileRef `json:"edmProfile"`
}

// DLP profile configuration
type ApplicationControlDlpProfileInput struct {
	// References DLP content matching profiles
	ContentProfile []*DlpContentProfileRefInput `json:"contentProfile"`
	// References DLP exact data matching profiles
	EdmProfile []*DlpEdmProfileRefInput `json:"edmProfile"`
}

// DLP profile configuration
type ApplicationControlDlpProfileUpdateInput struct {
	// References DLP content matching profiles
	ContentProfile []*DlpContentProfileRefInput `json:"contentProfile,omitempty"`
	// References DLP exact data matching profiles
	EdmProfile []*DlpEdmProfileRefInput `json:"edmProfile,omitempty"`
}

// File attribute matching configuration
type ApplicationControlFileAttribute struct {
	// Specifies the content types groups (used only with Content Type attribute)
	ContentTypeGroupValues []*ApplicationControlContentTypeGroupRef `json:"contentTypeGroupValues"`
	// Specifies the content types (used only with Content Type attribute)
	ContentTypeValues []*ApplicationControlContentTypeRef `json:"contentTypeValues"`
	// Specifies the file attribute type
	FileAttribute ApplicationControlFileAttributeType `json:"fileAttribute"`
	// Defines the comparison operator
	Operator ApplicationControlOperator `json:"operator"`
	// Specifies the comparison value (used with all attributes except Content Type)
	Value *string `json:"value,omitempty"`
}

// File attribute matching configuration
type ApplicationControlFileAttributeInput struct {
	// Specifies the content types groups (used only with Content Type attribute)
	ContentTypeGroupValues []*ApplicationControlContentTypeGroupRefInput `json:"contentTypeGroupValues"`
	// Specifies the content types (used only with Content Type attribute)
	ContentTypeValues []*ApplicationControlContentTypeRefInput `json:"contentTypeValues"`
	// Specifies the file attribute type
	FileAttribute ApplicationControlFileAttributeType `json:"fileAttribute"`
	// Defines the comparison operator
	Operator ApplicationControlOperator `json:"operator"`
	// Specifies the comparison value (used with all attributes except Content Type)
	Value *string `json:"value,omitempty"`
}

// Configuration for file-based control rules
type ApplicationControlFileRule struct {
	// Defines access method criteria with OR logic within sets and AND between sets
	AccessMethod []*ApplicationControlAccessMethod `json:"accessMethod"`
	// Defines the enforcement action when rule conditions match
	Action ApplicationControlAction `json:"action"`
	// Defines application matching criteria with OR logic within sets and AND between sets
	Application *ApplicationControlApplication `json:"application"`
	// Defines activity matching criteria using activitySatisfy logic within sets and AND between sets
	ApplicationActivity []*ApplicationControlActivity `json:"applicationActivity"`
	// Determines whether ANY or ALL activity criteria must match
	ApplicationActivitySatisfy ApplicationControlSatisfy `json:"applicationActivitySatisfy"`
	// Defines device profile criteria with OR logic within sets and AND between sets
	Device []*DeviceProfileRef `json:"device"`
	// Defines file attribute criteria using fileAttributeSatisfy logic within sets and AND between sets
	FileAttribute []*ApplicationControlFileAttribute `json:"fileAttribute"`
	// Determines whether ANY or ALL file attribute criteria must match
	FileAttributeSatisfy ApplicationControlSatisfy `json:"fileAttributeSatisfy"`
	// Defines time periods when the rule is active
	Schedule *PolicySchedule `json:"schedule"`
	// Indicates the rule's severity level
	Severity ApplicationControlSeverity `json:"severity"`
	// Defines source traffic criteria with OR logic within sets and AND between sets
	Source *ApplicationControlSource `json:"source"`
	// Specifies event logging and notification settings
	Tracking *PolicyTracking `json:"tracking"`
}

// Configuration for file-based control rules
type ApplicationControlFileRuleInput struct {
	// Defines access method criteria with OR logic within sets and AND between sets
	AccessMethod []*ApplicationControlAccessMethodInput `json:"accessMethod"`
	// Defines the enforcement action when rule conditions match
	Action ApplicationControlAction `json:"action"`
	// Defines application matching criteria with OR logic within sets and AND between sets
	Application *ApplicationControlApplicationInput `json:"application"`
	// Defines activity matching criteria using activitySatisfy logic within sets and AND between sets
	ApplicationActivity []*ApplicationControlActivityInput `json:"applicationActivity"`
	// Determines whether ANY or ALL activity criteria must match
	ApplicationActivitySatisfy ApplicationControlSatisfy `json:"applicationActivitySatisfy"`
	// Defines device profile criteria with OR logic within sets and AND between sets
	Device []*DeviceProfileRefInput `json:"device"`
	// Defines file attribute criteria using fileAttributeSatisfy logic within sets and AND between sets
	FileAttribute []*ApplicationControlFileAttributeInput `json:"fileAttribute"`
	// Determines whether ANY or ALL file attribute criteria must match
	FileAttributeSatisfy ApplicationControlSatisfy `json:"fileAttributeSatisfy"`
	// Defines time periods when the rule is active
	Schedule *PolicyScheduleInput `json:"schedule"`
	// Indicates the rule's severity level
	Severity ApplicationControlSeverity `json:"severity"`
	// Defines source traffic criteria with OR logic within sets and AND between sets
	Source *ApplicationControlSourceInput `json:"source"`
	// Specifies event logging and notification settings
	Tracking *PolicyTrackingInput `json:"tracking"`
}

// Configuration for file-based control rules
type ApplicationControlFileRuleUpdateInput struct {
	// Defines access method criteria with OR logic within sets and AND between sets
	AccessMethod []*ApplicationControlAccessMethodInput `json:"accessMethod,omitempty"`
	// Defines the enforcement action when rule conditions match
	Action *ApplicationControlAction `json:"action,omitempty"`
	// Defines application matching criteria with OR logic within sets and AND between sets
	Application *ApplicationControlApplicationUpdateInput `json:"application,omitempty"`
	// Defines activity matching criteria using activitySatisfy logic within sets and AND between sets
	ApplicationActivity []*ApplicationControlActivityInput `json:"applicationActivity,omitempty"`
	// Determines whether ANY or ALL activity criteria must match
	ApplicationActivitySatisfy *ApplicationControlSatisfy `json:"applicationActivitySatisfy,omitempty"`
	// Defines device profile criteria with OR logic within sets and AND between sets
	Device []*DeviceProfileRefInput `json:"device,omitempty"`
	// Defines file attribute criteria using fileAttributeSatisfy logic within sets and AND between sets
	FileAttribute []*ApplicationControlFileAttributeInput `json:"fileAttribute,omitempty"`
	// Determines whether ANY or ALL file attribute criteria must match
	FileAttributeSatisfy *ApplicationControlSatisfy `json:"fileAttributeSatisfy,omitempty"`
	// Defines time periods when the rule is active
	Schedule *PolicyScheduleUpdateInput `json:"schedule,omitempty"`
	// Indicates the rule's severity level
	Severity *ApplicationControlSeverity `json:"severity,omitempty"`
	// Defines source traffic criteria with OR logic within sets and AND between sets
	Source *ApplicationControlSourceUpdateInput `json:"source,omitempty"`
	// Specifies event logging and notification settings
	Tracking *PolicyTrackingUpdateInput `json:"tracking,omitempty"`
}

type ApplicationControlPolicy struct {
	AdditionalAttributes *ApplicationControlConfig        `json:"additionalAttributes,omitempty"`
	Audit                *PolicyAudit                     `json:"audit,omitempty"`
	Enabled              bool                             `json:"enabled"`
	Revision             *PolicyRevision                  `json:"revision,omitempty"`
	Rules                []*ApplicationControlRulePayload `json:"rules"`
	Sections             []*PolicySectionPayload          `json:"sections"`
}

func (ApplicationControlPolicy) IsIPolicy() {}

// TRUE = Policy is enabled, FALSE = Policy is disabled
func (this ApplicationControlPolicy) GetEnabled() bool { return this.Enabled }

// Return list of rules in the policy
func (this ApplicationControlPolicy) GetRules() []IPolicyRulePayload {
	if this.Rules == nil {
		return nil
	}
	interfaceSlice := make([]IPolicyRulePayload, 0, len(this.Rules))
	for _, concrete := range this.Rules {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

// Return sections in the policy
func (this ApplicationControlPolicy) GetSections() []*PolicySectionPayload {
	if this.Sections == nil {
		return nil
	}
	interfaceSlice := make([]*PolicySectionPayload, 0, len(this.Sections))
	for _, concrete := range this.Sections {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

// Audit data for the policy
func (this ApplicationControlPolicy) GetAudit() *PolicyAudit { return this.Audit }

// Return data for the Policy revision
func (this ApplicationControlPolicy) GetRevision() *PolicyRevision { return this.Revision }

type ApplicationControlPolicyInput struct {
	// A revision is a specific instance of the policy.
	//  Unpublished revisions are working copies of the policy available to a specific
	//  admin or a set of admins
	//  Published revisions are revisions that were applied to the account network.
	//  The last published revision is the active policy.
	Revision *PolicyRevisionInput `json:"revision,omitempty"`
}

type ApplicationControlPolicyMutationInput struct {
	Revision *PolicyMutationRevisionInput `json:"revision,omitempty"`
}

type ApplicationControlPolicyMutationPayload struct {
	Errors []*PolicyMutationError    `json:"errors"`
	Policy *ApplicationControlPolicy `json:"policy,omitempty"`
	Status PolicyMutationStatus      `json:"status"`
}

func (ApplicationControlPolicyMutationPayload) IsIPolicyMutationPayload() {}

// Data for the policy
func (this ApplicationControlPolicyMutationPayload) GetPolicy() IPolicy { return *this.Policy }

// Enum for the status of the policy change
func (this ApplicationControlPolicyMutationPayload) GetStatus() PolicyMutationStatus {
	return this.Status
}

// List of errors related to the policy change
func (this ApplicationControlPolicyMutationPayload) GetErrors() []*PolicyMutationError {
	if this.Errors == nil {
		return nil
	}
	interfaceSlice := make([]*PolicyMutationError, 0, len(this.Errors))
	for _, concrete := range this.Errors {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

type ApplicationControlPolicyMutations struct {
	AddRule               *ApplicationControlRuleMutationPayload   `json:"addRule"`
	AddSection            *PolicySectionMutationPayload            `json:"addSection"`
	CreatePolicyRevision  *ApplicationControlPolicyMutationPayload `json:"createPolicyRevision"`
	DiscardPolicyRevision *ApplicationControlPolicyMutationPayload `json:"discardPolicyRevision"`
	MoveRule              *ApplicationControlRuleMutationPayload   `json:"moveRule"`
	MoveSection           *PolicySectionMutationPayload            `json:"moveSection"`
	PublishPolicyRevision *ApplicationControlPolicyMutationPayload `json:"publishPolicyRevision"`
	RemoveRule            *ApplicationControlRuleMutationPayload   `json:"removeRule"`
	RemoveSection         *PolicySectionMutationPayload            `json:"removeSection"`
	UpdatePolicy          *ApplicationControlPolicyMutationPayload `json:"updatePolicy"`
	UpdateRule            *ApplicationControlRuleMutationPayload   `json:"updateRule"`
	UpdateSection         *PolicySectionMutationPayload            `json:"updateSection"`
}

type ApplicationControlPolicyQueries struct {
	Policy    *ApplicationControlPolicy `json:"policy"`
	Revisions *PolicyRevisionsPayload   `json:"revisions,omitempty"`
}

type ApplicationControlPolicyUpdateInput struct {
	AdditionalAttributes *ApplicationControlConfigInput `json:"additionalAttributes,omitempty"`
	State                *PolicyToggleState             `json:"state,omitempty"`
}

type ApplicationControlRemoveRuleInput struct {
	ID string `json:"id"`
}

// Application risk
type ApplicationControlRiskCriteria struct {
	// Application risk
	Risk string `json:"risk"`
	// Application risk operator
	RiskOperator ApplicationControlOperator `json:"riskOperator"`
}

// Application risk
type ApplicationControlRiskCriteriaInput struct {
	// Application risk
	Risk string `json:"risk"`
	// Application risk operator
	RiskOperator ApplicationControlOperator `json:"riskOperator"`
}

type ApplicationControlRule struct {
	// Defines application control settings. Must only be used when ruleType is APPLICATION
	ApplicationRule *ApplicationControlApplicationRule `json:"applicationRule,omitempty"`
	// Defines data control settings. Must only be used when ruleType is DATA
	DataRule *ApplicationControlDataRule `json:"dataRule,omitempty"`
	// Description for the rule
	Description string `json:"description"`
	// TRUE = Rule is enabled
	//  FALSE = Rule is disabled
	Enabled bool `json:"enabled"`
	// Defines file control settings. Must only be used when ruleType is FILE
	FileRule *ApplicationControlFileRule `json:"fileRule,omitempty"`
	// Rule ID
	ID string `json:"id"`
	// Position / priority of rule
	Index int64 `json:"index"`
	// Name of the rule
	Name string `json:"name"`
	// Determines which rule configuration to use.
	// When set to APPLICATION, only applicationRule should be used.
	// When set to DATA, only dataRule should be used.
	// When set to FILE, only fileRule should be used
	RuleType ApplicationControlRuleType `json:"ruleType"`
	// Policy section where the rule is located
	Section *PolicySectionInfo `json:"section"`
}

func (ApplicationControlRule) IsIPolicyRule() {}

// Rule ID
func (this ApplicationControlRule) GetID() string { return this.ID }

// Name of the rule
func (this ApplicationControlRule) GetName() string { return this.Name }

// Description for the rule
func (this ApplicationControlRule) GetDescription() *string { return &this.Description }

// Position / priority of rule
func (this ApplicationControlRule) GetIndex() int64 { return this.Index }

// TRUE = Rule is enabled, FALSE = Rule is disabled
func (this ApplicationControlRule) GetEnabled() bool { return this.Enabled }

// Policy section where the rule is located
func (this ApplicationControlRule) GetSection() *PolicySectionInfo { return this.Section }

type ApplicationControlRuleMutationPayload struct {
	Errors []*PolicyMutationError         `json:"errors"`
	Rule   *ApplicationControlRulePayload `json:"rule,omitempty"`
	Status PolicyMutationStatus           `json:"status"`
}

func (ApplicationControlRuleMutationPayload) IsIPolicyRuleMutationPayload() {}

// Returns settings for the rule
func (this ApplicationControlRuleMutationPayload) GetRule() IPolicyRulePayload { return *this.Rule }

// Enum for the status of the policy change
func (this ApplicationControlRuleMutationPayload) GetStatus() PolicyMutationStatus {
	return this.Status
}

// List of errors related to the policy change
func (this ApplicationControlRuleMutationPayload) GetErrors() []*PolicyMutationError {
	if this.Errors == nil {
		return nil
	}
	interfaceSlice := make([]*PolicyMutationError, 0, len(this.Errors))
	for _, concrete := range this.Errors {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

type ApplicationControlRulePayload struct {
	Audit      *PolicyElementAudit           `json:"audit"`
	Properties []PolicyElementPropertiesEnum `json:"properties"`
	Rule       *ApplicationControlRule       `json:"rule"`
}

func (ApplicationControlRulePayload) IsIPolicyRulePayload()              {}
func (this ApplicationControlRulePayload) GetAudit() *PolicyElementAudit { return this.Audit }

// Rule that was changed
func (this ApplicationControlRulePayload) GetRule() IPolicyRule { return *this.Rule }

// Summary of rule change, (ie. ADDED, UPDATED)
func (this ApplicationControlRulePayload) GetProperties() []PolicyElementPropertiesEnum {
	if this.Properties == nil {
		return nil
	}
	interfaceSlice := make([]PolicyElementPropertiesEnum, 0, len(this.Properties))
	for _, concrete := range this.Properties {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

// Security attributes
type ApplicationControlSecurityAttributes struct {
	// Audit trail
	AuditTrail ApplicationControlAttributeValue `json:"auditTrail"`
	// Encryption at rest
	EncryptionAtRest ApplicationControlAttributeValue `json:"encryptionAtRest"`
	// Http security headers
	HTTPSecurityHeaders ApplicationControlAttributeValue `json:"httpSecurityHeaders"`
	// MFA
	Mfa ApplicationControlAttributeValue `json:"mfa"`
	// RBAC
	Rbac ApplicationControlAttributeValue `json:"rbac"`
	// Remember password
	RememberPassword ApplicationControlAttributeValue `json:"rememberPassword"`
	// SSO
	Sso ApplicationControlAttributeValue `json:"sso"`
	// TLS enforcement
	TLSEnforcement ApplicationControlAttributeValue `json:"tlsEnforcement"`
	// Trusted certificate
	TrustedCertificate ApplicationControlAttributeValue `json:"trustedCertificate"`
}

// Security attributes
type ApplicationControlSecurityAttributesInput struct {
	// Audit trail
	AuditTrail ApplicationControlAttributeValue `json:"auditTrail"`
	// Encryption at rest
	EncryptionAtRest ApplicationControlAttributeValue `json:"encryptionAtRest"`
	// Http security headers
	HTTPSecurityHeaders ApplicationControlAttributeValue `json:"httpSecurityHeaders"`
	// MFA
	Mfa ApplicationControlAttributeValue `json:"mfa"`
	// RBAC
	Rbac ApplicationControlAttributeValue `json:"rbac"`
	// Remember password
	RememberPassword ApplicationControlAttributeValue `json:"rememberPassword"`
	// SSO
	Sso ApplicationControlAttributeValue `json:"sso"`
	// TLS enforcement
	TLSEnforcement ApplicationControlAttributeValue `json:"tlsEnforcement"`
	// Trusted certificate
	TrustedCertificate ApplicationControlAttributeValue `json:"trustedCertificate"`
}

// Security attributes
type ApplicationControlSecurityAttributesUpdateInput struct {
	// Audit trail
	AuditTrail *ApplicationControlAttributeValue `json:"auditTrail,omitempty"`
	// Encryption at rest
	EncryptionAtRest *ApplicationControlAttributeValue `json:"encryptionAtRest,omitempty"`
	// Http security headers
	HTTPSecurityHeaders *ApplicationControlAttributeValue `json:"httpSecurityHeaders,omitempty"`
	// MFA
	Mfa *ApplicationControlAttributeValue `json:"mfa,omitempty"`
	// RBAC
	Rbac *ApplicationControlAttributeValue `json:"rbac,omitempty"`
	// Remember password
	RememberPassword *ApplicationControlAttributeValue `json:"rememberPassword,omitempty"`
	// SSO
	Sso *ApplicationControlAttributeValue `json:"sso,omitempty"`
	// TLS enforcement
	TLSEnforcement *ApplicationControlAttributeValue `json:"tlsEnforcement,omitempty"`
	// Trusted certificate
	TrustedCertificate *ApplicationControlAttributeValue `json:"trustedCertificate,omitempty"`
}

// Source traffic matching configuration
type ApplicationControlSource struct {
	// Country traffic matching criteria
	Country []*CountryRef `json:"country"`
	// Floating Subnets (ie. Floating Ranges) are used to identify traffic exactly matched to the route advertised by BGP.
	// They are not associated with a specific site.
	// This is useful in scenarios such as active-standby high availability routed via BGP.
	FloatingSubnet []*FloatingSubnetRef `json:"floatingSubnet"`
	// Globally defined IP range, IP and subnet objects
	GlobalIPRange []*GlobalIPRangeRef `json:"globalIpRange"`
	// Groups defined for your account
	Group []*GroupRef `json:"group"`
	// Hosts and servers defined for your account
	Host []*HostRef `json:"host"`
	// IPv4 address
	IP []string `json:"ip"`
	// Multiple separate IP addresses or an IP range
	IPRange []*IPAddressRange `json:"ipRange"`
	// Network range defined for a site
	NetworkInterface []*NetworkInterfaceRef `json:"networkInterface"`
	// Site defined for the account
	Site []*SiteRef `json:"site"`
	// GlobalRange + InterfaceSubnet
	SiteNetworkSubnet []*SiteNetworkSubnetRef `json:"siteNetworkSubnet"`
	// Subnets and network ranges defined for the LAN interfaces of a site
	Subnet []string `json:"subnet"`
	// Predefined Cato groups
	SystemGroup []*SystemGroupRef `json:"systemGroup"`
	// Individual users defined for the account
	User []*UserRef `json:"user"`
	// Group of users
	UsersGroup []*UsersGroupRef `json:"usersGroup"`
}

// Source traffic matching configuration
type ApplicationControlSourceInput struct {
	// Country traffic matching criteria
	Country []*CountryRefInput `json:"country"`
	// Floating Subnets (ie. Floating Ranges) are used to identify traffic exactly matched to the route advertised by BGP.
	// They are not associated with a specific site.
	// This is useful in scenarios such as active-standby high availability routed via BGP.
	FloatingSubnet []*FloatingSubnetRefInput `json:"floatingSubnet"`
	// Globally defined IP range, IP and subnet objects
	GlobalIPRange []*GlobalIPRangeRefInput `json:"globalIpRange"`
	// Groups defined for your account
	Group []*GroupRefInput `json:"group"`
	// Hosts and servers defined for your account
	Host []*HostRefInput `json:"host"`
	// IPv4 address
	IP []string `json:"ip"`
	// Multiple separate IP addresses or an IP range
	IPRange []*IPAddressRangeInput `json:"ipRange"`
	// Network range defined for a site
	NetworkInterface []*NetworkInterfaceRefInput `json:"networkInterface"`
	// Site defined for the account
	Site []*SiteRefInput `json:"site"`
	// GlobalRange + InterfaceSubnet
	SiteNetworkSubnet []*SiteNetworkSubnetRefInput `json:"siteNetworkSubnet"`
	// Subnets and network ranges defined for the LAN interfaces of a site
	Subnet []string `json:"subnet"`
	// Predefined Cato groups
	SystemGroup []*SystemGroupRefInput `json:"systemGroup"`
	// Individual users defined for the account
	User []*UserRefInput `json:"user"`
	// Group of users
	UsersGroup []*UsersGroupRefInput `json:"usersGroup"`
}

// Source traffic matching configuration
type ApplicationControlSourceUpdateInput struct {
	// Country traffic matching criteria
	Country []*CountryRefInput `json:"country,omitempty"`
	// Floating Subnets (ie. Floating Ranges) are used to identify traffic exactly matched to the route advertised by BGP.
	// They are not associated with a specific site.
	// This is useful in scenarios such as active-standby high availability routed via BGP.
	FloatingSubnet []*FloatingSubnetRefInput `json:"floatingSubnet,omitempty"`
	// Globally defined IP range, IP and subnet objects
	GlobalIPRange []*GlobalIPRangeRefInput `json:"globalIpRange,omitempty"`
	// Groups defined for your account
	Group []*GroupRefInput `json:"group,omitempty"`
	// Hosts and servers defined for your account
	Host []*HostRefInput `json:"host,omitempty"`
	// IPv4 address
	IP []string `json:"ip,omitempty"`
	// Multiple separate IP addresses or an IP range
	IPRange []*IPAddressRangeInput `json:"ipRange,omitempty"`
	// Network range defined for a site
	NetworkInterface []*NetworkInterfaceRefInput `json:"networkInterface,omitempty"`
	// Site defined for the account
	Site []*SiteRefInput `json:"site,omitempty"`
	// GlobalRange + InterfaceSubnet
	SiteNetworkSubnet []*SiteNetworkSubnetRefInput `json:"siteNetworkSubnet,omitempty"`
	// Subnets and network ranges defined for the LAN interfaces of a site
	Subnet []string `json:"subnet,omitempty"`
	// Predefined Cato groups
	SystemGroup []*SystemGroupRefInput `json:"systemGroup,omitempty"`
	// Individual users defined for the account
	User []*UserRefInput `json:"user,omitempty"`
	// Group of users
	UsersGroup []*UsersGroupRefInput `json:"usersGroup,omitempty"`
}

// Tenant matching configuration
type ApplicationControlTenant struct {
	// Defines the operator used for comparisons
	Operator *ApplicationControlOperator `json:"operator,omitempty"`
	// Specifies the comparison value
	Value *string `json:"value,omitempty"`
	// References a set of values (used only with IN operator)
	ValueSet *StringValueSetRef `json:"valueSet,omitempty"`
}

// Tenant matching configuration
type ApplicationControlTenantInput struct {
	// Defines the operator used for comparisons
	Operator *ApplicationControlOperator `json:"operator,omitempty"`
	// Specifies the comparison value
	Value *string `json:"value,omitempty"`
	// References a set of values (used only with IN operator)
	ValueSet *StringValueSetRefInput `json:"valueSet,omitempty"`
}

type ApplicationControlUpdateRuleDataInput struct {
	// Defines application control settings. Must only be used when ruleType is APPLICATION
	ApplicationRule *ApplicationControlApplicationRuleUpdateInput `json:"applicationRule,omitempty"`
	// Defines data control settings. Must only be used when ruleType is DATA
	DataRule    *ApplicationControlDataRuleUpdateInput `json:"dataRule,omitempty"`
	Description *string                                `json:"description,omitempty"`
	Enabled     *bool                                  `json:"enabled,omitempty"`
	// Defines file control settings. Must only be used when ruleType is FILE
	FileRule *ApplicationControlFileRuleUpdateInput `json:"fileRule,omitempty"`
	Name     *string                                `json:"name,omitempty"`
	// Determines which rule configuration to use.
	// When set to APPLICATION, only applicationRule should be used.
	// When set to DATA, only dataRule should be used.
	// When set to FILE, only fileRule should be used
	RuleType *ApplicationControlRuleType `json:"ruleType,omitempty"`
}

type ApplicationControlUpdateRuleInput struct {
	ID   string                                 `json:"id"`
	Rule *ApplicationControlUpdateRuleDataInput `json:"rule"`
}

// A reference identifying the Application object. ID: Unique Application Identifier, Name: The Application Name
type ApplicationRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (ApplicationRef) IsObjectRef() {}

// Object's unique identifier
func (this ApplicationRef) GetID() string { return this.ID }

// Object's unique name
func (this ApplicationRef) GetName() string { return this.Name }

type ApplicationRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

type AssignSiteBwLicenseInput struct {
	// Specifies the bandwidth (in Mbps) to allocate to the site when using a pooled bandwidth license.
	// This field should not be used if a site license is used.
	Bw *int64 `json:"bw,omitempty"`
	// The license that is being assigned
	LicenseID string `json:"licenseId"`
	// The site the license is assigned to
	Site *SiteRefInput `json:"site"`
}

type AssignSiteBwLicensePayload struct {
	License License `json:"license"`
}

// Advanced Threat Prevention (ATP) service license details
type AtpLicense struct {
	Description *string `json:"description,omitempty"`
	// License expiration date
	ExpirationDate string `json:"expirationDate"`
	// The unique identifier for the license. If this value is not available, you can contact Cato Support, who may be able to assist in retrieving it.
	ID *string `json:"id,omitempty"`
	// The date of the last update to the license
	LastUpdated *string `json:"lastUpdated,omitempty"`
	// License plan type
	Plan LicensePlan `json:"plan"`
	// The license SKU
	Sku LicenseSku `json:"sku"`
	// License start date
	StartDate *string `json:"startDate,omitempty"`
	// License activation status
	Status LicenseStatus `json:"status"`
}

func (AtpLicense) IsLicense() {}

// The unique identifier for the license. If this value is not available, you can contact Cato Support, who may be able to assist in retrieving it.
func (this AtpLicense) GetID() *string          { return this.ID }
func (this AtpLicense) GetDescription() *string { return this.Description }

// License plan type
func (this AtpLicense) GetPlan() LicensePlan { return this.Plan }

// The license SKU
func (this AtpLicense) GetSku() LicenseSku { return this.Sku }

// License activation status
func (this AtpLicense) GetStatus() LicenseStatus { return this.Status }

// License start date
func (this AtpLicense) GetStartDate() *string { return this.StartDate }

// License expiration date
func (this AtpLicense) GetExpirationDate() string { return this.ExpirationDate }

// The date of the last update to the license
func (this AtpLicense) GetLastUpdated() *string { return this.LastUpdated }

type AuditFeed struct {
	Accounts     []*AuditFeedAccountRecords `json:"accounts,omitempty"`
	FetchedCount int64                      `json:"fetchedCount"`
	From         *string                    `json:"from,omitempty"`
	HasMore      *bool                      `json:"hasMore,omitempty"`
	Marker       *string                    `json:"marker,omitempty"`
	To           *string                    `json:"to,omitempty"`
}

type AuditFeedAccountRecords struct {
	ID      *string        `json:"id,omitempty"`
	Records []*AuditRecord `json:"records,omitempty"`
}

type AuditField struct {
	Name  string `json:"name"`
	Value Value  `json:"value"`
}

type AuditFieldFilterInput struct {
	FieldName *FieldNameInput `json:"fieldName"`
	// Use AuditFieldName for audits
	Operator ElasticOperator `json:"operator"`
	Values   []string        `json:"values,omitempty"`
}

// Represents a single event in the audit database
type AuditRecord struct {
	Account *EntityInfo `json:"account,omitempty"`
	Admin   *Entity     `json:"admin,omitempty"`
	APIKey  *Entity     `json:"apiKey,omitempty"`
	// All fields in the audit record (including the admin and object)
	Fields []*AuditField `json:"fields,omitempty"`
	// fields in map format (see Map scalar)
	FieldsMap map[string]any `json:"fieldsMap,omitempty"`
	// Simplified fields, as array of name value tuples, e.g: [ [ "name", "val" ], [ "name2", "val2" ] ... ]
	FlatFields [][]string `json:"flatFields,omitempty"`
	Object     *Entity    `json:"object,omitempty"`
	Time       *string    `json:"time,omitempty"`
}

type AuditingMetadata struct {
	UpdatedBy   ActorRef `json:"updatedBy"`
	UpdatedTime string   `json:"updatedTime"`
}

type AuditingMetadataFilterInput struct {
	UpdatedBy   *ActorRefInput       `json:"updatedBy,omitempty"`
	UpdatedTime *DateTimeFilterInput `json:"updatedTime,omitempty"`
}

type AuditingMetadataSortInput struct {
	UpdatedBy   *SortOrderInput `json:"updatedBy,omitempty"`
	UpdatedTime *SortOrderInput `json:"updatedTime,omitempty"`
}

// Input parameters for querying available versions.
type AvailableVersionListInput struct {
	// List of platforms to retrieve available versions for.
	Platforms []string `json:"platforms"`
}

// Response payload for available versions query.
type AvailableVersionListPayload struct {
	// List of available versions for each requested platform.
	Items []*PlatformVersions `json:"items"`
}

type BGPConnection struct {
	CatoAsn        *scalars.Asn16 `json:"catoAsn,omitempty"`
	CatoIP         *string        `json:"catoIp,omitempty"`
	ConnectionName *string        `json:"connectionName,omitempty"`
	PeerAsn        *scalars.Asn32 `json:"peerAsn,omitempty"`
	PeerIP         *string        `json:"peerIp,omitempty"`
}

type BandwidthManagementRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (BandwidthManagementRef) IsObjectRef() {}

// Object's unique identifier
func (this BandwidthManagementRef) GetID() string { return this.ID }

// Object's unique name
func (this BandwidthManagementRef) GetName() string { return this.Name }

type BandwidthManagementRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

type BfdSettings struct {
	// Number of missed BFD packets before considering the session down.
	Multiplier int64 `json:"multiplier"`
	// Time interval (in milliseconds) in which this peer expects to receive BFD packets.
	ReceiveInterval int64 `json:"receiveInterval"`
	// Time interval (in milliseconds) between BFD packets sent by this peer.
	TransmitInterval int64 `json:"transmitInterval"`
}

type BfdSettingsInput struct {
	// Number of missed BFD packets before considering the session down.
	Multiplier int64 `json:"multiplier"`
	// Time interval (in milliseconds) in which this peer expects to receive BFD packets.
	ReceiveInterval int64 `json:"receiveInterval"`
	// Time interval (in milliseconds) between BFD packets sent by this peer.
	TransmitInterval int64 `json:"transmitInterval"`
}

type BgpCommunity struct {
	// Start of the community range.
	From scalars.Asn16 `json:"from"`
	// End of the community range.
	To scalars.Asn16 `json:"to"`
}

type BgpCommunityFilterRule struct {
	// Community values to match.
	Community []*BgpCommunity `json:"community"`
	// Unique identifier of the community filter rule.
	ID string `json:"id"`
	// Predicate to apply to the community filter (e.g., EQUAL, NOT_EQUAL).
	Predicate BgpCommunityFilterPredicate `json:"predicate"`
}

type BgpCommunityFilterRuleInput struct {
	// Community values to match.
	Community []*BgpCommunityInput `json:"community"`
	// Predicate to apply to the community filter (e.g., EQUAL, NOT_EQUAL).
	Predicate *BgpCommunityFilterPredicate `json:"predicate,omitempty"`
}

type BgpCommunityInput struct {
	// Start of the community range.
	From scalars.Asn16 `json:"from"`
	// End of the community range.
	To scalars.Asn16 `json:"to"`
}

type BgpDetailedStatus struct {
	// Status of the BFD session (if applicable).
	BfdSession *string `json:"bfdSession,omitempty"`
	// Status of the BGP session (e.g., established, down).
	BgpSession string `json:"bgpSession"`
	// Routes rejected from the peer.
	RejectedRoutesFromPeer []*BgpRejectedRoutesFromPeer `json:"rejectedRoutesFromPeer"`
	// IP address of the remote BGP peer.
	RemoteIP string `json:"remoteIp"`
	// Routes received from the peer.
	RoutesFromPeer []string `json:"routesFromPeer"`
	// Routes sent to the peer.
	RoutesToPeer []string `json:"routesToPeer"`
}

type BgpFilterRule struct {
	// Exact and inclusive filter rule. Please choose only one filter rule type.
	BgpRouteExactAndInclusiveFilterRule *BgpRouteExactAndInclusiveFilterRule `json:"bgpRouteExactAndInclusiveFilterRule,omitempty"`
	// Exact route filter rule. Please choose only one filter rule type.
	BgpRouteExactFilterRule *BgpRouteExactFilterRule `json:"bgpRouteExactFilterRule,omitempty"`
	// Community filter rule. Please choose only one filter rule type.
	CommunityFilterRule *BgpCommunityFilterRule `json:"communityFilterRule,omitempty"`
}

type BgpFilterRuleInput struct {
	// Input for exact and inclusive filter rule.
	BgpRouteExactAndInclusiveFilterRule *BgpRouteExactAndInclusiveFilterRuleInput `json:"bgpRouteExactAndInclusiveFilterRule,omitempty"`
	// Input for exact route filter rule.
	BgpRouteExactFilterRule *BgpRouteExactFilterRuleInput `json:"bgpRouteExactFilterRule,omitempty"`
	// Input for community filter rule.
	CommunityFilterRule *BgpCommunityFilterRuleInput `json:"communityFilterRule,omitempty"`
}

type BgpPeer struct {
	// Indicates if all routes are advertised.
	AdvertiseAllRoutes bool `json:"advertiseAllRoutes"`
	// Indicates if the default route is advertised.
	AdvertiseDefaultRoute bool `json:"advertiseDefaultRoute"`
	// Indicates if summarized routes are advertised.
	AdvertiseSummaryRoutes bool `json:"advertiseSummaryRoutes"`
	// Indicates if BFD is enabled for failure detection.
	BfdEnabled bool `json:"bfdEnabled"`
	// BFD configuration.
	BfdSettings *BfdSettings `json:"bfdSettings,omitempty"`
	// AS number of Cato's BGP endpoint.
	CatoAsn scalars.Asn16 `json:"catoAsn"`
	// IP address of Cato's BGP endpoint.
	CatoIP string `json:"catoIp"`
	// Default action for routes not matching filters (ACCEPT or DROP).
	DefaultAction BgpDefaultAction `json:"defaultAction"`
	// Rules excluded from the default action.
	DefaultActionExclusion []*BgpFilterRule `json:"defaultActionExclusion"`
	// Time before declaring the peer unreachable.
	HoldTime int64 `json:"holdTime"`
	// Unique identifier for the BGP peer.
	ID string `json:"id"`
	// Interval between keepalive messages.
	KeepaliveInterval int64 `json:"keepaliveInterval"`
	// MD5 authentication key for secure sessions.
	Md5AuthKey *string `json:"md5AuthKey,omitempty"`
	// Metric for route preferences.
	Metric int64 `json:"metric"`
	// Name of the BGP configuration entity.
	Name string `json:"name"`
	// AS number of the peer BGP endpoint.
	PeerAsn scalars.Asn32 `json:"peerAsn"`
	// IP address of the peer BGP endpoint.
	PeerIP string `json:"peerIp"`
	// Indicates if NAT is performed on routes.
	PerformNat bool `json:"performNat"`
	// Site associated with this BGP peer.
	Site *SiteRef `json:"site"`
	// Summarized routes advertised to the peer.
	SummaryRoute []*BgpSummaryRoute `json:"summaryRoute"`
	// Tracking configuration for health and availability.
	Tracking *BgpTracking `json:"tracking,omitempty"`
}

type BgpPeerListInput struct {
	// Identifies the site whose BGP peers are listed.
	Site *SiteRefInput `json:"site"`
}

type BgpPeerListPayload struct {
	// BGP peers associated with the site.
	BgpPeer []*BgpPeer `json:"bgpPeer"`
	// Total number of BGP peers found.
	Total int64 `json:"total"`
}

type BgpPeerRefInput struct {
	// Specifies the method of identification (default is by ID).
	By ObjectRefBy `json:"by"`
	// Value used to identify the BGP peer (e.g., ID or name).
	Input string `json:"input"`
}

type BgpRejectedRoutesFromPeer struct {
	// Community values associated with the rejected route.
	Community []*BgpCommunity `json:"community"`
	// Timestamp of the last attempt to publish the rejected route.
	LastPublishAttempt *string `json:"lastPublishAttempt,omitempty"`
	// Filter rule that caused the rejection.
	Rule *string `json:"rule,omitempty"`
	// Subnet of the rejected route.
	Subnet *string `json:"subnet,omitempty"`
	// Reason for rejecting the route.
	Type *string `json:"type,omitempty"`
}

type BgpRouteExactAndInclusiveFilterRule struct {
	// Minimum prefix length for the filter rule.
	Ge *int64 `json:"ge,omitempty"`
	// Global IP ranges to include.
	GlobalIPRange []*GlobalIPRangeRef `json:"globalIpRange"`
	// Global IP ranges to exclude.
	GlobalIPRangeException []*GlobalIPRangeRef `json:"globalIpRangeException"`
	// Unique identifier of the filter rule.
	ID string `json:"id"`
	// Maximum prefix length for the filter rule.
	Le *int64 `json:"le,omitempty"`
	// Network subnets to include.
	NetworkSubnet []string `json:"networkSubnet"`
	// Network subnets to exclude.
	NetworkSubnetException []string `json:"networkSubnetException"`
}

type BgpRouteExactAndInclusiveFilterRuleInput struct {
	// Minimum prefix length for the filter rule.
	Ge *int64 `json:"ge,omitempty"`
	// Global IP ranges to include.
	GlobalIPRange []*GlobalIPRangeRefInput `json:"globalIpRange"`
	// Global IP ranges to exclude.
	GlobalIPRangeException []*GlobalIPRangeRefInput `json:"globalIpRangeException"`
	// Maximum prefix length for the filter rule.
	Le *int64 `json:"le,omitempty"`
	// Network subnets to include.
	NetworkSubnet []string `json:"networkSubnet"`
	// Network subnets to exclude.
	NetworkSubnetException []string `json:"networkSubnetException"`
}

type BgpRouteExactFilterRule struct {
	// Global IP ranges to include.
	GlobalIPRange []*GlobalIPRangeRef `json:"globalIpRange"`
	// Unique identifier of the exact filter rule.
	ID string `json:"id"`
	// Network subnets to include.
	NetworkSubnet []string `json:"networkSubnet"`
}

type BgpRouteExactFilterRuleInput struct {
	// Global IP ranges to include.
	GlobalIPRange []*GlobalIPRangeRefInput `json:"globalIpRange"`
	// Network subnets to include.
	NetworkSubnet []string `json:"networkSubnet"`
}

type BgpSummaryRoute struct {
	// Community values associated with the route.
	Community []*BgpCommunity `json:"community"`
	// Unique identifier of the summarized route.
	ID string `json:"id"`
	// Subnet of the summarized route.
	Route string `json:"route"`
}

type BgpSummaryRouteInput struct {
	// Community values to associate with the summarized route.
	Community []*BgpCommunityInput `json:"community"`
	// Subnet of the summarized route to be advertised.
	Route string `json:"route"`
}

type BgpTracking struct {
	// Frequency of health alerts.
	AlertFrequency PolicyRuleTrackingFrequencyEnum `json:"alertFrequency"`
	// Indicates if tracking is enabled.
	Enabled bool `json:"enabled"`
	// Unique identifier for the tracking rule.
	ID string `json:"id"`
	// Subscription ID associated with the rule.
	SubscriptionID *string `json:"subscriptionId,omitempty"`
}

type BgpTrackingInput struct {
	// Frequency of health alerts.
	AlertFrequency PolicyRuleTrackingFrequencyEnum `json:"alertFrequency"`
	// Indicates if tracking is enabled.
	Enabled bool `json:"enabled"`
	// Subscription ID associated with this tracking rule.
	SubscriptionID string `json:"subscriptionId"`
}

type BooleanFilterInput struct {
	Eq  *bool `json:"eq,omitempty"`
	Neq *bool `json:"neq,omitempty"`
}

type BooleanPredicate struct {
	Is string `json:"is"`
}

type BulkUpgradeSiteInfo struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

// Cloud Access Security Broker (CASB) service license details
type CasbLicense struct {
	Description *string `json:"description,omitempty"`
	// License expiration date
	ExpirationDate string `json:"expirationDate"`
	// The unique identifier for the license. If this value is not available, you can contact Cato Support, who may be able to assist in retrieving it.
	ID *string `json:"id,omitempty"`
	// The date of the last update to the license
	LastUpdated *string `json:"lastUpdated,omitempty"`
	// License plan type
	Plan LicensePlan `json:"plan"`
	// The license SKU
	Sku LicenseSku `json:"sku"`
	// License start date
	StartDate *string `json:"startDate,omitempty"`
	// License activation status
	Status LicenseStatus `json:"status"`
}

func (CasbLicense) IsLicense() {}

// The unique identifier for the license. If this value is not available, you can contact Cato Support, who may be able to assist in retrieving it.
func (this CasbLicense) GetID() *string          { return this.ID }
func (this CasbLicense) GetDescription() *string { return this.Description }

// License plan type
func (this CasbLicense) GetPlan() LicensePlan { return this.Plan }

// The license SKU
func (this CasbLicense) GetSku() LicenseSku { return this.Sku }

// License activation status
func (this CasbLicense) GetStatus() LicenseStatus { return this.Status }

// License start date
func (this CasbLicense) GetStartDate() *string { return this.StartDate }

// License expiration date
func (this CasbLicense) GetExpirationDate() string { return this.ExpirationDate }

// The date of the last update to the license
func (this CasbLicense) GetLastUpdated() *string { return this.LastUpdated }

type CatalogApplication struct {
	Activity             []*CatalogApplicationActivity           `json:"activity"`
	Capability           []CatalogApplicationCapability          `json:"capability"`
	Category             []*ApplicationCategoryRef               `json:"category"`
	City                 *string                                 `json:"city,omitempty"`
	ComplianceAttributes *CatalogApplicationComplianceAttributes `json:"complianceAttributes"`
	Description          *string                                 `json:"description,omitempty"`
	DescriptionSummary   *string                                 `json:"descriptionSummary,omitempty"`
	ID                   string                                  `json:"id"`
	IpoStatus            *string                                 `json:"ipoStatus,omitempty"`
	Name                 string                                  `json:"name"`
	NumOfEmployees       *EmployeeRange                          `json:"numOfEmployees,omitempty"`
	OriginCountry        *CountryRef                             `json:"originCountry,omitempty"`
	RecentlyAdded        bool                                    `json:"recentlyAdded"`
	Region               *string                                 `json:"region,omitempty"`
	Risk                 *string                                 `json:"risk,omitempty"`
	Sanctioned           bool                                    `json:"sanctioned"`
	SecurityAttributes   *CatalogApplicationSecurityAttributes   `json:"securityAttributes"`
	StandardPorts        []*CustomService                        `json:"standardPorts"`
	Type                 CatalogApplicationType                  `json:"type"`
	Website              *string                                 `json:"website,omitempty"`
}

type CatalogApplicationActivity struct {
	Fields []*CatalogApplicationActivityField `json:"fields"`
	ID     string                             `json:"id"`
	Name   string                             `json:"name"`
}

type CatalogApplicationActivityField struct {
	ID                string                                    `json:"id"`
	Name              string                                    `json:"name"`
	PossibleOperators []CatalogApplicationActivityFieldOperator `json:"possibleOperators"`
	PossibleValues    []string                                  `json:"possibleValues"`
}

type CatalogApplicationActivityFilterInput struct {
	HasAny []*CatalogApplicationActivityRefInput `json:"hasAny,omitempty"`
}

type CatalogApplicationActivityRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

type CatalogApplicationCapabilityFilterInput struct {
	HasAny []CatalogApplicationCapability `json:"hasAny,omitempty"`
}

type CatalogApplicationCategoryFilterInput struct {
	HasAny []*ApplicationCategoryRefInput `json:"hasAny,omitempty"`
}

type CatalogApplicationCategorySortInput struct {
	Name *SortOrderInput `json:"name,omitempty"`
}

type CatalogApplicationComplianceAttributes struct {
	Hippa    CatalogApplicationAttribute `json:"hippa"`
	Isae3402 CatalogApplicationAttribute `json:"isae3402"`
	Iso27001 CatalogApplicationAttribute `json:"iso27001"`
	PciDss   CatalogApplicationAttribute `json:"pciDss"`
	Soc1     CatalogApplicationAttribute `json:"soc1"`
	Soc2     CatalogApplicationAttribute `json:"soc2"`
	Soc3     CatalogApplicationAttribute `json:"soc3"`
	Sox      CatalogApplicationAttribute `json:"sox"`
}

type CatalogApplicationContentType struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

type CatalogApplicationContentTypeFilterInput struct {
	ID   []*IDFilterInput     `json:"id,omitempty"`
	Name []*StringFilterInput `json:"name,omitempty"`
}

type CatalogApplicationContentTypeGroup struct {
	ContentType []*CatalogApplicationContentType `json:"contentType"`
	ID          string                           `json:"id"`
	Name        string                           `json:"name"`
}

type CatalogApplicationContentTypeGroupFilterInput struct {
	ContentType []*CatalogApplicationContentTypeFilterInput `json:"contentType,omitempty"`
	ID          []*IDFilterInput                            `json:"id,omitempty"`
	Name        []*StringFilterInput                        `json:"name,omitempty"`
}

type CatalogApplicationContentTypeGroupListInput struct {
	Filter []*CatalogApplicationContentTypeGroupFilterInput `json:"filter,omitempty"`
	Paging *PagingInput                                     `json:"paging,omitempty"`
	Sort   *CatalogApplicationContentTypeGroupSortInput     `json:"sort,omitempty"`
}

type CatalogApplicationContentTypeGroupListPayload struct {
	ContentTypeGroup []*CatalogApplicationContentTypeGroup `json:"contentTypeGroup"`
	PageInfo         *PageInfo                             `json:"pageInfo"`
}

type CatalogApplicationContentTypeGroupSortInput struct {
	Name *SortOrderInput `json:"name,omitempty"`
}

type CatalogApplicationFilterInput struct {
	Activity      []*CatalogApplicationActivityFilterInput   `json:"activity,omitempty"`
	Capability    []*CatalogApplicationCapabilityFilterInput `json:"capability,omitempty"`
	Category      []*CatalogApplicationCategoryFilterInput   `json:"category,omitempty"`
	ID            []*IDFilterInput                           `json:"id,omitempty"`
	Name          []*StringFilterInput                       `json:"name,omitempty"`
	RecentlyAdded []*BooleanFilterInput                      `json:"recentlyAdded,omitempty"`
	Risk          []*IntFilterInput                          `json:"risk,omitempty"`
	Type          []*CatalogApplicationTypeFilterInput       `json:"type,omitempty"`
}

type CatalogApplicationListInput struct {
	Filter []*CatalogApplicationFilterInput `json:"filter,omitempty"`
	Paging *PagingInput                     `json:"paging,omitempty"`
	Sort   *CatalogApplicationSortInput     `json:"sort,omitempty"`
}

type CatalogApplicationListPayload struct {
	Application []*CatalogApplication `json:"application"`
	PageInfo    *PageInfo             `json:"pageInfo"`
}

type CatalogApplicationSecurityAttributes struct {
	AuditTrail          CatalogApplicationAttribute `json:"auditTrail"`
	EncryptionAtRest    CatalogApplicationAttribute `json:"encryptionAtRest"`
	HTTPSecurityHeaders CatalogApplicationAttribute `json:"httpSecurityHeaders"`
	Mfa                 CatalogApplicationAttribute `json:"mfa"`
	Rbac                CatalogApplicationAttribute `json:"rbac"`
	RememberPassword    CatalogApplicationAttribute `json:"rememberPassword"`
	Sso                 CatalogApplicationAttribute `json:"sso"`
	TLSEnforcement      CatalogApplicationAttribute `json:"tlsEnforcement"`
	TrustedCertificate  CatalogApplicationAttribute `json:"trustedCertificate"`
}

type CatalogApplicationSortInput struct {
	Category    *CatalogApplicationCategorySortInput `json:"category,omitempty"`
	Description *SortOrderInput                      `json:"description,omitempty"`
	Name        *SortOrderInput                      `json:"name,omitempty"`
	Risk        *SortOrderInput                      `json:"risk,omitempty"`
	Type        *SortOrderInput                      `json:"type,omitempty"`
}

type CatalogApplicationTypeFilterInput struct {
	Eq  *CatalogApplicationType  `json:"eq,omitempty"`
	In  []CatalogApplicationType `json:"in,omitempty"`
	Neq *CatalogApplicationType  `json:"neq,omitempty"`
	Nin []CatalogApplicationType `json:"nin,omitempty"`
}

type CatalogQueries struct {
	CatalogApplication     *CatalogApplication                            `json:"catalogApplication,omitempty"`
	CatalogApplicationList *CatalogApplicationListPayload                 `json:"catalogApplicationList,omitempty"`
	ContentTypeGroupList   *CatalogApplicationContentTypeGroupListPayload `json:"contentTypeGroupList,omitempty"`
}

// CatoActivity is an object type representing an activity in a Cato alert, containing unique identifiers for the activity itself, the preceding resource, and the involved resource.
type CatoActivity struct {
	// Unique Cato ID for this activity
	ID string `json:"id"`
	// Unique Cato ID for the preceding resource (process or file) in the alert
	ParentResourceID string `json:"parentResourceId"`
	// Unique Cato ID for the resource (process or file) involved in the alert
	ResourceID string `json:"resourceId"`
}

func (CatoActivity) IsActivity()                      {}
func (this CatoActivity) GetID() string               { return this.ID }
func (this CatoActivity) GetResourceID() string       { return this.ResourceID }
func (this CatoActivity) GetParentResourceID() string { return this.ParentResourceID }

// The `CatoEndpoint` object represents a comprehensive data structure used in GraphQL queries or mutations to encapsulate details about a security incident detected by an Endpoint Protection Platform (EPP). It includes fields such as threat alerts, analyst feedback, connection type, criticality score, device details, timestamps for incident signals, and various enums and strings that describe the incident's status, source, and producer.
type CatoEndpoint struct {
	// Details for the threat detected by the EPP
	Alerts []*CatoEndpointAlert `json:"alerts"`
	// Fields related to analysts research of the threat incident
	AnalystFeedback *AnalystFeedback `json:"analystFeedback,omitempty"`
	// enum for the connection for this incident (ie. host, user)
	ConnectionType *ConnectionTypeEnum `json:"connectionType,omitempty"`
	// Cato's risk analysis of the story. Values are from 1 (low risk) to 10 (high risk)
	Criticality *int64 `json:"criticality,omitempty"`
	// Description of the threat
	Description *string `json:"description,omitempty"`
	// Details for the EPP device (ie. device name, OS, MAC address)
	Device *CatoEndpointDeviceDetails `json:"device,omitempty"`
	// enum that shows XDR engine involved with the incident
	EngineType *StoryEngineTypeEnum `json:"engineType,omitempty"`
	// Timestamp for the first incident signal related to this story
	FirstSignal string `json:"firstSignal"`
	// ID for the Endpoint Protection story
	ID string `json:"id"`
	// An indication is a set of actions and behaviors for the Network or Security incident. Each producer has different indications.
	Indication string `json:"indication"`
	// Timestamp for the last (most recent) incident signal related to this story
	LastSignal          string            `json:"lastSignal"`
	PredictedThreatType *string           `json:"predictedThreatType,omitempty"`
	PredictedVerdict    *StoryVerdictEnum `json:"predictedVerdict,omitempty"`
	// enum for the Producer (specific XDR engine or service) involved with the incident
	Producer StoryProducerEnum `json:"producer"`
	// Full name of the Producer (specific XDR engine and service) involved with the incident
	ProducerName string  `json:"producerName"`
	QueryName    *string `json:"queryName,omitempty"`
	// TRUE indicates that the story is currently being researched by Security Analysts
	Research           *bool               `json:"research,omitempty"`
	SimilarStoriesData []*SimilarStoryData `json:"similarStoriesData"`
	// Cato ID and name for the site
	Site *SiteRef `json:"site,omitempty"`
	// Site name related to the story
	SiteName *string `json:"siteName,omitempty"`
	// IP address, name of device, or SDP user on your network involved in the story
	Source *string `json:"source,omitempty"`
	// Source IP address of the device in your network sending or receiving the flow
	SourceIP *string `json:"sourceIp,omitempty"`
	// Enum for the status of this story (ie. Open, Closed, Monitoring)
	Status *StoryStatusEnum `json:"status,omitempty"`
	// Amount of time since the story was opened (no value for closed stories)
	StoryDuration *int64 `json:"storyDuration,omitempty"`
	// The ticket for this story
	Ticket *string `json:"ticket,omitempty"`
	// Cato ID and name for the site
	User *UserRef `json:"user,omitempty"`
	// Vendor that identified the incident, such as Cato or Microsoft
	Vendor *VendorEnum `json:"vendor,omitempty"`
}

func (CatoEndpoint) IsEndpoint() {}

// Unique Cato ID for the story
func (this CatoEndpoint) GetID() string { return this.ID }

// Timestamp for the first incident signal related to this story
func (this CatoEndpoint) GetFirstSignal() string { return this.FirstSignal }

// Timestamp for the last (most recent) incident signal related to this story
func (this CatoEndpoint) GetLastSignal() string { return this.LastSignal }

// XDR engine involved with the incident
func (this CatoEndpoint) GetEngineType() *StoryEngineTypeEnum { return this.EngineType }

// Vendor that identified the incident, such as Cato or Microsoft
func (this CatoEndpoint) GetVendor() *VendorEnum { return this.Vendor }

// Enum for the Producer (specific XDR engine and service) involved with the incident
func (this CatoEndpoint) GetProducer() StoryProducerEnum { return this.Producer }

// Full name of the Producer (specific XDR engine and service) involved with the incident
func (this CatoEndpoint) GetProducerName() string { return this.ProducerName }

// Enum for the connection for this incident (ie. site, host, user)
func (this CatoEndpoint) GetConnectionType() *ConnectionTypeEnum { return this.ConnectionType }

// An indication is a set of actions and behaviors for the Network or Security incident. Each producer has different indications.
func (this CatoEndpoint) GetIndication() string { return this.Indication }

// Category for the indication ID related to the story
func (this CatoEndpoint) GetQueryName() *string { return this.QueryName }

// IP address, name of device, or SDP user on your network involved in the story
func (this CatoEndpoint) GetSource() *string                   { return this.Source }
func (this CatoEndpoint) GetCriticality() *int64               { return this.Criticality }
func (this CatoEndpoint) GetTicket() *string                   { return this.Ticket }
func (this CatoEndpoint) GetStatus() *StoryStatusEnum          { return this.Status }
func (this CatoEndpoint) GetResearch() *bool                   { return this.Research }
func (this CatoEndpoint) GetSiteName() *string                 { return this.SiteName }
func (this CatoEndpoint) GetStoryDuration() *int64             { return this.StoryDuration }
func (this CatoEndpoint) GetDescription() *string              { return this.Description }
func (this CatoEndpoint) GetSourceIP() *string                 { return this.SourceIP }
func (this CatoEndpoint) GetAnalystFeedback() *AnalystFeedback { return this.AnalystFeedback }
func (this CatoEndpoint) GetSite() *SiteRef                    { return this.Site }
func (this CatoEndpoint) GetUser() *UserRef                    { return this.User }
func (this CatoEndpoint) GetSimilarStoriesData() []*SimilarStoryData {
	if this.SimilarStoriesData == nil {
		return nil
	}
	interfaceSlice := make([]*SimilarStoryData, 0, len(this.SimilarStoriesData))
	for _, concrete := range this.SimilarStoriesData {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this CatoEndpoint) GetPredictedVerdict() *StoryVerdictEnum { return this.PredictedVerdict }
func (this CatoEndpoint) GetPredictedThreatType() *string        { return this.PredictedThreatType }
func (this CatoEndpoint) GetDevice() DeviceDetails               { return *this.Device }
func (this CatoEndpoint) GetAlerts() []EndpointAlert {
	if this.Alerts == nil {
		return nil
	}
	interfaceSlice := make([]EndpointAlert, 0, len(this.Alerts))
	for _, concrete := range this.Alerts {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

func (CatoEndpoint) IsMergedIncident() {}

// Unique Cato ID for each story

// Timestamp for the first incident signal related to this story

// Timestamp for the last (most recent) incident signal related to this story

// XDR engine involved with the incident

// Vendor that identified the incident, such as Cato or Microsoft

// Producer (specific XDR engine and service) involved with the incident

// Full name of the Producer (specific XDR engine and service) involved with the incident

// Connection for the incident

// An indication is a set of actions and behaviors for the Network or Security incident. Each producer has different indications.

// Category for the indication ID related to the story

// For Network stories - The potential impact of the issue on your network. Values are from 1 (low impact) to 10 (high impact)
//
// For Security stories - Cato's risk analysis of the story. Values are from 1 (low risk) to 10 (high risk)

// For Network stories - The site where the network issue is occurring
//
// For Security stories - IP address, name of device, or SDP user on your network involved in the story

// The ticket an analyst created for this story

// Status for the story

// The value is TRUE when the story is currently being researched by Security Analysts

// Site name related to the story

// Amount of time since the story was opened (no value for closed stories)

// For Security stories, description of the threat

// The source IP address of the device in your network sending or receiving the flow

// Fields related to analysts research of the threat incident

// Cato ID and name for the site

// Cato ID and name for the user

// The `CatoEndpointAlert` object represents an alert generated by Cato's endpoint protection system, detailing information about detected threats, including associated activities, threat description, criticality level, endpoint protection profile, and remediation status.
type CatoEndpointAlert struct {
	// Unique Cato IDs for the activities related to the alert
	Activities []*CatoActivity `json:"activities"`
	// Timestamp that the threat was detected and the alert generated
	CreatedDateTime *string `json:"createdDateTime,omitempty"`
	// Cato's risk analysis of the story. Values are from 1 (low risk) to 10 (high risk)
	Criticality *int64 `json:"criticality,omitempty"`
	// Description of the threat
	Description *string `json:"description,omitempty"`
	// EPP profile that is assigned to this device
	EndpointProtectionProfile *string `json:"endpointProtectionProfile,omitempty"`
	// Enum for the EPP engine related to this story
	EngineType *CatoEndpointEngineType `json:"engineType,omitempty"`
	ExternalIP *string                 `json:"externalIp,omitempty"`
	// Unique Cato ID for the Endpoint Protection story
	ID      string  `json:"id"`
	LocalIP *string `json:"localIp,omitempty"`
	// MITRE ATT&CK® sub-technique for the threat
	MitreSubTechnique []*Mitre `json:"mitreSubTechnique"`
	// MITRE ATT&CK® technique for the threat
	MitreTechnique []*Mitre `json:"mitreTechnique"`
	// Data for the remediation status of the alert
	Resources []CatoResource `json:"resources"`
	// Enum for the remediation status of the EPP alert
	Status *RemediationStatusEnum `json:"status,omitempty"`
	// Name of threat detected on the device
	ThreatName *string `json:"threatName,omitempty"`
	// Title of the endpoint alert
	Title *string `json:"title,omitempty"`
}

func (CatoEndpointAlert) IsEndpointAlert()             {}
func (this CatoEndpointAlert) GetID() string           { return this.ID }
func (this CatoEndpointAlert) GetTitle() *string       { return this.Title }
func (this CatoEndpointAlert) GetDescription() *string { return this.Description }
func (this CatoEndpointAlert) GetThreatName() *string  { return this.ThreatName }
func (this CatoEndpointAlert) GetMitreTechnique() []*Mitre {
	if this.MitreTechnique == nil {
		return nil
	}
	interfaceSlice := make([]*Mitre, 0, len(this.MitreTechnique))
	for _, concrete := range this.MitreTechnique {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this CatoEndpointAlert) GetMitreSubTechnique() []*Mitre {
	if this.MitreSubTechnique == nil {
		return nil
	}
	interfaceSlice := make([]*Mitre, 0, len(this.MitreSubTechnique))
	for _, concrete := range this.MitreSubTechnique {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this CatoEndpointAlert) GetCreatedDateTime() *string { return this.CreatedDateTime }
func (this CatoEndpointAlert) GetResources() []EndpointResource {
	if this.Resources == nil {
		return nil
	}
	interfaceSlice := make([]EndpointResource, 0, len(this.Resources))
	for _, concrete := range this.Resources {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this CatoEndpointAlert) GetActivities() []Activity {
	if this.Activities == nil {
		return nil
	}
	interfaceSlice := make([]Activity, 0, len(this.Activities))
	for _, concrete := range this.Activities {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this CatoEndpointAlert) GetCriticality() *int64 { return this.Criticality }
func (this CatoEndpointAlert) GetExternalIP() *string { return this.ExternalIP }
func (this CatoEndpointAlert) GetLocalIP() *string    { return this.LocalIP }

// The `CatoEndpointDeviceDetails` object represents detailed information about a device, including its name, unique ID, logged-on users, MAC address, and operating system details.
type CatoEndpointDeviceDetails struct {
	// Name of the device
	DeviceName *string `json:"deviceName,omitempty"`
	ExternalIP *string `json:"externalIp,omitempty"`
	// Unique Cato ID for this story
	ID      string  `json:"id"`
	LocalIP *string `json:"localIp,omitempty"`
	// Data for one or more users logged in to the device
	LoggedOnUsers []EndpointUser `json:"loggedOnUsers"`
	// MAC address of the device
	MacAddress *string `json:"macAddress,omitempty"`
	// OS data (ie. type, build, version)
	OsDetails *OsDetails `json:"osDetails,omitempty"`
}

func (CatoEndpointDeviceDetails) IsDeviceDetails()              {}
func (this CatoEndpointDeviceDetails) GetID() string            { return this.ID }
func (this CatoEndpointDeviceDetails) GetDeviceName() *string   { return this.DeviceName }
func (this CatoEndpointDeviceDetails) GetOsDetails() *OsDetails { return this.OsDetails }
func (this CatoEndpointDeviceDetails) GetLoggedOnUsers() []EndpointUser {
	if this.LoggedOnUsers == nil {
		return nil
	}
	interfaceSlice := make([]EndpointUser, 0, len(this.LoggedOnUsers))
	for _, concrete := range this.LoggedOnUsers {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this CatoEndpointDeviceDetails) GetExternalIP() *string { return this.ExternalIP }
func (this CatoEndpointDeviceDetails) GetLocalIP() *string    { return this.LocalIP }

// The `CatoEndpointUser` is a GraphQL object type representing a user, with fields for a unique identifier (`id`) and a username (`name`), both of which are required.
type CatoEndpointUser struct {
	// ID for the user
	ID string `json:"id"`
	// Username for the user whose activity generated the indication
	Name string `json:"name"`
}

func (CatoEndpointUser) IsEndpointUser()      {}
func (this CatoEndpointUser) GetID() string   { return this.ID }
func (this CatoEndpointUser) GetName() string { return this.Name }

// The `CatoFileResource` is a GraphQL object type that represents a file resource with fields for its creation timestamp, detection and remediation statuses, file details, and a unique identifier.
type CatoFileResource struct {
	// Timestamp that the this file resource was used
	CreatedDateTime *string `json:"createdDateTime,omitempty"`
	// Enum for the detection status of this file resource
	DetectionStatus *DetectionStatusEnum `json:"detectionStatus,omitempty"`
	// Details of the file related to this resource
	FileDetails *FileDetails `json:"fileDetails,omitempty"`
	// Unique Cato ID for this file resource
	ID string `json:"id"`
	// Enum for the remediation status associated with this file resource
	RemediationStatus *RemediationStatusEnum `json:"remediationStatus,omitempty"`
}

func (CatoFileResource) IsCatoResource() {}

// Unique Cato ID for this EPP resource
func (this CatoFileResource) GetID() string { return this.ID }

// Timestamp that the this resource was used
func (this CatoFileResource) GetCreatedDateTime() *string { return this.CreatedDateTime }

// Enum for the remediation status associated with this resource
func (this CatoFileResource) GetRemediationStatus() *RemediationStatusEnum {
	return this.RemediationStatus
}

func (CatoFileResource) IsEndpointResource() {}

func (CatoFileResource) IsFileResource() {}

func (this CatoFileResource) GetFileDetails() *FileDetails             { return this.FileDetails }
func (this CatoFileResource) GetDetectionStatus() *DetectionStatusEnum { return this.DetectionStatus }

// The `CatoProcessResource` is a GraphQL object type that represents a process resource, including details such as a unique Cato ID, the timestamp of usage, associated file details, command line information, process ID, remediation status, and the related user account.
type CatoProcessResource struct {
	// Timestamp that the this resource was used
	CreatedDateTime *string `json:"createdDateTime,omitempty"`
	// Unique Cato ID for this resource
	ID string `json:"id"`
	// Details of the file related to this process
	ImageFile *FileDetails `json:"imageFile,omitempty"`
	// CLI command related to this process
	ProcessCommandLine *string `json:"processCommandLine,omitempty"`
	// ID for the process
	ProcessID int64 `json:"processId"`
	// Enum for the remediation status associated with this resource
	RemediationStatus *RemediationStatusEnum `json:"remediationStatus,omitempty"`
	// User account related to this process
	UserAccount EndpointUser `json:"userAccount,omitempty"`
}

func (CatoProcessResource) IsCatoResource() {}

// Unique Cato ID for this EPP resource
func (this CatoProcessResource) GetID() string { return this.ID }

// Timestamp that the this resource was used
func (this CatoProcessResource) GetCreatedDateTime() *string { return this.CreatedDateTime }

// Enum for the remediation status associated with this resource
func (this CatoProcessResource) GetRemediationStatus() *RemediationStatusEnum {
	return this.RemediationStatus
}

func (CatoProcessResource) IsEndpointResource() {}

func (CatoProcessResource) IsProcessResource() {}

func (this CatoProcessResource) GetProcessID() int64            { return this.ProcessID }
func (this CatoProcessResource) GetProcessCommandLine() *string { return this.ProcessCommandLine }
func (this CatoProcessResource) GetImageFile() *FileDetails     { return this.ImageFile }
func (this CatoProcessResource) GetUserAccount() EndpointUser   { return this.UserAccount }

type CellularInterface struct {
	// Represents the Access Point Name (e.g., uwap.orange.co.il). Configurable from Socket WebUI or SIM switch.
	Apn *string `json:"apn,omitempty"`
	// Determines how the APN is selected. Valid values are Auto or Manual (configurable in WebUI).
	ApnSelectionMethod *ApnMethod `json:"apnSelectionMethod,omitempty"`
	// Displays the reason for the modem disconnecting. Valid values are 0 (No reason provided) or 1 (The session timed out).
	DisconnectionReason *CellularDisconnectionReason `json:"disconnectionReason,omitempty"`
	// Unique identifier (20-digit number) for the modem.
	Iccid *string `json:"iccid,omitempty"`
	// Unique identifier (15-digit number) for a specific SIM.
	Imei *string `json:"imei,omitempty"`
	// Indicates if the cellular modem is currently connected to the internet.
	IsModemConnected bool `json:"isModemConnected"`
	// Indicates if the modem is currently suspended.
	IsModemSuspended bool `json:"isModemSuspended"`
	// Indicates whether roaming is enabled.
	IsRoamingAllowed bool `json:"isRoamingAllowed"`
	// Indicates whether a SIM is detected in the first slot.
	IsSimSlot1Detected bool `json:"isSimSlot1Detected"`
	// Indicates whether a SIM is detected in the second slot.
	IsSimSlot2Detected bool `json:"isSimSlot2Detected"`
	// Represents the current status of the modem. Valid values are Error, OK, or Unknown.
	ModemStatus *CellularModemStatus `json:"modemStatus,omitempty"`
	// 2G, 3G, or 4G
	NetworkType *CellularNetworkType `json:"networkType,omitempty"`
	// Displays the operator or carrier name, such as Verizon.
	OperatorName *string `json:"operatorName,omitempty"`
	// Represents the signal strength of the cellular connection, in units of calculation.
	SignalStrength *string `json:"signalStrength,omitempty"`
	// The phone number associated with the SIM.
	SimNumber *string `json:"simNumber,omitempty"`
	// Shows the currently active SIM slot; the other slot is in standby. Slot 1 is active by default.
	SimSlotID *int64 `json:"simSlotId,omitempty"`
}

// Connectivity status of a cloud interconnect connection.
type CloudInterconnectConnectionConnectivity struct {
	// Indicates if the connection is successful.
	Success bool `json:"success"`
}

// Input for checking the connectivity status of a cloud interconnect connection.
type CloudInterconnectConnectionConnectivityInput struct {
	// ID of the connection.
	ID string `json:"id"`
}

// Details of a physical connection at a cloud interconnect site.
type CloudInterconnectPhysicalConnection struct {
	// C-VLAN applicable only for QINQ connections.
	CVlan *scalars.Vlan `json:"cVlan,omitempty"`
	// Downstream bandwidth limit.
	DownstreamBwLimit string `json:"downstreamBwLimit"`
	// Method of encapsulation.
	EncapsulationMethod TaggingMethod `json:"encapsulationMethod"`
	// High availability role of the connection. Either Primary or Secondary.
	HaRole HaRole `json:"haRole"`
	// ID of the connection.
	ID string `json:"id"`
	// Identifying data for the POP location.
	PopLocation *PopLocationRef `json:"popLocation"`
	// Private IP address of Cato, used for BGP routing.
	PrivateCatoIP string `json:"privateCatoIp"`
	// Private IP address of the site, used for BGP routing.
	PrivateSiteIP string `json:"privateSiteIp"`
	// Name of the service provider.
	ServiceProviderName string `json:"serviceProviderName"`
	// Identifying data for the site.
	Site *SiteRef `json:"site"`
	// Subnet for the connection.
	Subnet string `json:"subnet"`
	// S-VLAN applicable only for QINQ connections.
	SVlan *scalars.Vlan `json:"sVlan,omitempty"`
	// Upstream bandwidth limit.
	UpstreamBwLimit string `json:"upstreamBwLimit"`
	// VLAN applicable only for DOT1Q connections.
	Vlan *scalars.Vlan `json:"vlan,omitempty"`
}

// ID of a physical connection at a cloud interconnect site.
type CloudInterconnectPhysicalConnectionID struct {
	// ID of the connection.
	ID string `json:"id"`
}

// Input for getting the ID of a physical connection at a cloud interconnect site.
type CloudInterconnectPhysicalConnectionIDInput struct {
	// High availability role of the connection.
	HaRole HaRole `json:"haRole"`
	// Identifying data for the site.
	Site *SiteRefInput `json:"site"`
}

// Input for getting details of a physical connection at a cloud interconnect site.
type CloudInterconnectPhysicalConnectionInput struct {
	// ID of the connection.
	ID string `json:"id"`
}

type ContactDetails struct {
	// Contact email address
	Email *string `json:"email,omitempty"`
	// Contact name
	Name *string `json:"name,omitempty"`
	// Contact phone number
	Phone *string `json:"phone,omitempty"`
}

type ContactDetailsInput struct {
	// Contact email address
	Email *string `json:"email,omitempty"`
	// Contact name
	Name *string `json:"name,omitempty"`
	// Contact phone number
	Phone *string `json:"phone,omitempty"`
}

// Audit metadata about the container
type ContainerAudit struct {
	// Indicates when the container was created
	CreatedAt string `json:"createdAt"`
	// Indicates who created the container
	CreatedBy string `json:"createdBy"`
	// Indicated when the container was last updated
	LastModifiedAt string `json:"lastModifiedAt"`
	// Indicates who was the last to update the container
	LastModifiedBy string `json:"lastModifiedBy"`
}

type ContainerMutations struct {
	Delete         *DeleteContainerPayload           `json:"delete"`
	Fqdn           *FqdnContainerMutations           `json:"fqdn"`
	IPAddressRange *IPAddressRangeContainerMutations `json:"ipAddressRange"`
}

type ContainerQueries struct {
	Fqdn           *FqdnContainerQueries           `json:"fqdn"`
	IPAddressRange *IPAddressRangeContainerQueries `json:"ipAddressRange"`
	List           *ContainerSearchPayload         `json:"list"`
}

// Add a container by ID or name
type ContainerRefInput struct {
	// Defines the object identification method – by ID (default) or by name
	By ObjectRefBy `json:"by"`
	// The object identification (ID or name) value
	Input string `json:"input"`
}

// Filtering input to container search
type ContainerSearchInput struct {
	// Allows filtering container search by container ID or container name
	Refs []*ContainerRefInput `json:"refs"`
	// Allows filtering container search by specific container types
	Types []ContainerType `json:"types"`
}

// Container search result, including all containers that matched input criteria
type ContainerSearchPayload struct {
	// A list of matched containers
	Containers []Container `json:"containers"`
}

// A reference identifying the Country object. ID: Unique Country Identifier, Name: The Country Name
type CountryRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (CountryRef) IsObjectRef() {}

// Object's unique identifier
func (this CountryRef) GetID() string { return this.ID }

// Object's unique name
func (this CountryRef) GetName() string { return this.Name }

type CountryRefFilterInput struct {
	Eq  *CountryRefInput   `json:"eq,omitempty"`
	In  []*CountryRefInput `json:"in,omitempty"`
	Neq *CountryRefInput   `json:"neq,omitempty"`
	Nin []*CountryRefInput `json:"nin,omitempty"`
}

type CountryRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

// Input for creating FQDN typed container from file
type CreateFqdnContainerFromFileInput struct {
	// Description for the container
	Description string `json:"description"`
	// File type that will be uploaded
	FileType ContainerFileType `json:"fileType"`
	// Name for the container
	Name string `json:"name"`
	// Multipart file containing FQDNs with fileType delimiter
	UploadFile *graphql.Upload `json:"uploadFile,omitempty"`
}

// Payload of CreateFromFile operation on FQDN typed container
type CreateFqdnContainerFromFilePayload struct {
	// Container with members of type FQDN
	Container *FqdnContainer `json:"container"`
}

type CreateFqdnContainerFromListInput struct {
	Description string   `json:"description"`
	Name        string   `json:"name"`
	Values      []string `json:"values"`
}

// Payload of CreateFromList operation on FQDN typed container
type CreateFqdnContainerFromListPayload struct {
	// Container with members of type FQDN
	Container *FqdnContainer `json:"container"`
}

// Create a new group
type CreateGroupInput struct {
	// Optional description for the group
	Description *string `json:"description,omitempty"`
	// Initial list of members for the new group. There is a maximum of 500 members per createGroup mutation
	Members []*GroupMemberRefTypedInput `json:"members,omitempty"`
	// The name of the new group
	Name string `json:"name"`
}

// The created group object.
type CreateGroupPayload struct {
	Group *Group `json:"group"`
}

// Input for creating IPAddressRange typed container from file
type CreateIPAddressRangeContainerFromFileInput struct {
	// Description for the container
	Description string `json:"description"`
	// File type that will be uploaded
	FileType ContainerFileType `json:"fileType"`
	// Name for the container
	Name string `json:"name"`
	// Multipart file containing IPAddressRanges with fileType delimiter
	UploadFile *graphql.Upload `json:"uploadFile,omitempty"`
}

// Payload of CreateFromFile operation on IPAddressRange typed container
type CreateIPAddressRangeContainerFromFilePayload struct {
	// Container with members of type IPAddressRange
	Container *IPAddressRangeContainer `json:"container"`
}

type CreateIPAddressRangeContainerFromListInput struct {
	Description string                 `json:"description"`
	Name        string                 `json:"name"`
	Values      []*IPAddressRangeInput `json:"values"`
}

// Payload of CreateFromList operation on IPAddressRange typed container
type CreateIPAddressRangeContainerFromListPayload struct {
	// Container with members of type IPAddressRange
	Container *IPAddressRangeContainer `json:"container"`
}

type CreateLocationDetailsInput struct {
	// Company name (recipient)
	CompanyName *string `json:"companyName,omitempty"`
	// Delivery contact detail
	Contact *ContactDetailsInput `json:"contact,omitempty"`
	// Postal location
	PostalAddress *PostalAddressInput `json:"postalAddress"`
	// Vat id (required for Brazil)
	VatID *string `json:"vatId,omitempty"`
}

// A reference identifying the CustomApplication object. ID: Unique CustomApplication Identifier, Name: The CustomApplication Name
type CustomApplicationRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (CustomApplicationRef) IsObjectRef() {}

// Object's unique identifier
func (this CustomApplicationRef) GetID() string { return this.ID }

// Object's unique name
func (this CustomApplicationRef) GetName() string { return this.Name }

type CustomApplicationRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

// A reference identifying the CustomCategory object. ID: Unique CustomCategory Identifier, Name: The CustomCategory Name
type CustomCategoryRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (CustomCategoryRef) IsObjectRef() {}

// Object's unique identifier
func (this CustomCategoryRef) GetID() string { return this.ID }

// Object's unique name
func (this CustomCategoryRef) GetName() string { return this.Name }

type CustomCategoryRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

// Returns data for Custom Service defined by a combination of L4 ports and an IP Protocol
type CustomService struct {
	Port      []scalars.Port `json:"port,omitempty"`
	PortRange *PortRange     `json:"portRange,omitempty"`
	Protocol  IPProtocol     `json:"protocol"`
}

// Add a Custom Service defined by a combination of L4 ports and an IP Protocol
type CustomServiceInput struct {
	Port      []scalars.Port  `json:"port,omitempty"`
	PortRange *PortRangeInput `json:"portRange,omitempty"`
	Protocol  IPProtocol      `json:"protocol"`
}

type CustomServiceIP struct {
	IP      *string         `json:"ip,omitempty"`
	IPRange *IPAddressRange `json:"ipRange,omitempty"`
	Name    string          `json:"name"`
}

type CustomServiceIPInput struct {
	IP      *string              `json:"ip,omitempty"`
	IPRange *IPAddressRangeInput `json:"ipRange,omitempty"`
	Name    string               `json:"name"`
}

type DataLakeLicense struct {
	Description *string `json:"description,omitempty"`
	// The version of the Data Processing Agreement (DPA) that your company signed with Cato.
	DpaVersion DpaVersion `json:"dpaVersion"`
	// License expiration date
	ExpirationDate string `json:"expirationDate"`
	// The unique identifier for the license. If this value is not available, you can contact Cato Support, who may be able to assist in retrieving it.
	ID *string `json:"id,omitempty"`
	// The date of the last update to the license
	LastUpdated *string `json:"lastUpdated,omitempty"`
	// License plan type
	Plan LicensePlan `json:"plan"`
	// Data retention period, in months, during which the account data may remain on the Cato Cloud. After this period the data will be permanently deleted.
	RetentionPeriod *int64 `json:"retentionPeriod,omitempty"`
	// The license SKU
	Sku LicenseSku `json:"sku"`
	// License start date
	StartDate *string `json:"startDate,omitempty"`
	// License activation status
	Status LicenseStatus `json:"status"`
	// Total number of the Data Storage Units under this license. Each Data Storage Unit increases the allowed ingestion rate (events per hour and total events storage)
	Total int64 `json:"total"`
}

func (DataLakeLicense) IsLicense() {}

// The unique identifier for the license. If this value is not available, you can contact Cato Support, who may be able to assist in retrieving it.
func (this DataLakeLicense) GetID() *string          { return this.ID }
func (this DataLakeLicense) GetDescription() *string { return this.Description }

// License plan type
func (this DataLakeLicense) GetPlan() LicensePlan { return this.Plan }

// The license SKU
func (this DataLakeLicense) GetSku() LicenseSku { return this.Sku }

// License activation status
func (this DataLakeLicense) GetStatus() LicenseStatus { return this.Status }

// License start date
func (this DataLakeLicense) GetStartDate() *string { return this.StartDate }

// License expiration date
func (this DataLakeLicense) GetExpirationDate() string { return this.ExpirationDate }

// The date of the last update to the license
func (this DataLakeLicense) GetLastUpdated() *string { return this.LastUpdated }

func (DataLakeLicense) IsQuantifiableLicense() {}

// The unique identifier for the license. If this value is not available, you can contact Cato Support, who may be able to assist in retrieving it.

// License plan type

// The license SKU

// License activation status

// License initiation date

// License expiration date

// The date of the last update to the license

// license quantity
func (this DataLakeLicense) GetTotal() int64 { return this.Total }

type DateTimeFilterInput struct {
	Between []string `json:"between,omitempty"`
	Eq      *string  `json:"eq,omitempty"`
	Gt      *string  `json:"gt,omitempty"`
	Gte     *string  `json:"gte,omitempty"`
	In      []string `json:"in,omitempty"`
	Lt      *string  `json:"lt,omitempty"`
	Lte     *string  `json:"lte,omitempty"`
	Neq     *string  `json:"neq,omitempty"`
	Nin     []string `json:"nin,omitempty"`
}

type DateValue struct {
	Date *string `json:"date,omitempty"`
}

func (DateValue) IsValue() {}

type DegradedDetail struct {
	Args   DegradedStatusArgs   `json:"args,omitempty"`
	Reason DegradedStatusReason `json:"reason"`
}

type DegradedStatus struct {
	DegradedDetails []*DegradedDetail `json:"degradedDetails"`
	IsDegraded      bool              `json:"isDegraded"`
}

type DegradedStatusBasicDataArgs struct {
	DeviceName        string  `json:"deviceName"`
	LastConnectedDate *string `json:"lastConnectedDate,omitempty"`
}

func (DegradedStatusBasicDataArgs) IsDegradedStatusArgs() {}

type DegradedStatusLastConnectedArgs struct {
	LastConnectedDate *string `json:"lastConnectedDate,omitempty"`
}

func (DegradedStatusLastConnectedArgs) IsDegradedStatusArgs() {}

type DegradedStatusMultiTunnelArgs struct {
	DeviceName        string  `json:"deviceName"`
	LastConnectedDate *string `json:"lastConnectedDate,omitempty"`
	TunnelID          string  `json:"tunnelID"`
	TunnelName        string  `json:"tunnelName"`
}

func (DegradedStatusMultiTunnelArgs) IsDegradedStatusArgs() {}

type DegradedStatusSocketArgs struct {
	DeviceName        string  `json:"deviceName"`
	LastConnectedDate *string `json:"lastConnectedDate,omitempty"`
	PortID            string  `json:"portID"`
	PortName          string  `json:"portName"`
}

func (DegradedStatusSocketArgs) IsDegradedStatusArgs() {}

type DegradedStatusSocketVersionsArgs struct {
	PrimaryVersion   string `json:"primaryVersion"`
	SecondaryVersion string `json:"secondaryVersion"`
}

func (DegradedStatusSocketVersionsArgs) IsDegradedStatusArgs() {}

// Identification of container for delete operation
type DeleteContainerInput struct {
	// Reference to existing container by container ID or container name
	Ref *ContainerRefInput `json:"ref"`
}

type DeleteContainerPayload struct {
	// The data of the container before it was deleted
	Container Container `json:"container"`
}

// The deleted group object
type DeleteGroupPayload struct {
	// The group that was deleted
	Group *Group `json:"group"`
}

// Delete report input
type DeleteReportInput struct {
	//  File hash (SHA-256) to be deleted
	FileHash string `json:"fileHash"`
}

// Delete report response
type DeleteReportPayload struct {
	//  File hash (SHA-256)
	FileHash string `json:"fileHash"`
}

type DeleteStoryCommentInput struct {
	// The comment ID
	CommentID string `json:"commentId"`
	// The relevant Story
	StoryID string `json:"storyId"`
}

type DeleteStoryCommentPayload struct {
	// Delete an existing comment from an XDR story
	Comment *StoryComment `json:"comment"`
}

// DEM service license details
type DemLicense struct {
	Description *string `json:"description,omitempty"`
	// License expiration date
	ExpirationDate string `json:"expirationDate"`
	// The unique identifier for the license. If this value is not available, you can contact Cato Support, who may be able to assist in retrieving it.
	ID *string `json:"id,omitempty"`
	// The date of the last update to the license
	LastUpdated *string `json:"lastUpdated,omitempty"`
	// License plan type
	Plan LicensePlan `json:"plan"`
	// The license SKU
	Sku LicenseSku `json:"sku"`
	// License start date
	StartDate *string `json:"startDate,omitempty"`
	// License activation status
	Status LicenseStatus `json:"status"`
	// License quantity
	Total int64 `json:"total"`
}

func (DemLicense) IsLicense() {}

// The unique identifier for the license. If this value is not available, you can contact Cato Support, who may be able to assist in retrieving it.
func (this DemLicense) GetID() *string          { return this.ID }
func (this DemLicense) GetDescription() *string { return this.Description }

// License plan type
func (this DemLicense) GetPlan() LicensePlan { return this.Plan }

// The license SKU
func (this DemLicense) GetSku() LicenseSku { return this.Sku }

// License activation status
func (this DemLicense) GetStatus() LicenseStatus { return this.Status }

// License start date
func (this DemLicense) GetStartDate() *string { return this.StartDate }

// License expiration date
func (this DemLicense) GetExpirationDate() string { return this.ExpirationDate }

// The date of the last update to the license
func (this DemLicense) GetLastUpdated() *string { return this.LastUpdated }

func (DemLicense) IsQuantifiableLicense() {}

// The unique identifier for the license. If this value is not available, you can contact Cato Support, who may be able to assist in retrieving it.

// License plan type

// The license SKU

// License activation status

// License initiation date

// License expiration date

// The date of the last update to the license

// license quantity
func (this DemLicense) GetTotal() int64 { return this.Total }

type DeviceAttributeCatalogInput struct {
	Filter *StringFilterInput `json:"filter,omitempty"`
	Paging *PagingInput       `json:"paging,omitempty"`
	Sort   *SortOrderInput    `json:"sort,omitempty"`
}

type DeviceAttributeCatalogPayload struct {
	Items    []string  `json:"items"`
	PageInfo *PageInfo `json:"pageInfo"`
}

type DeviceAttributes struct {
	// The category of the firewall device.
	Category []string `json:"category"`
	// The manufacturer of the firewall device.
	Manufacturer []string `json:"manufacturer"`
	// The model of the firewall device.
	Model []string `json:"model"`
	// The operating system of the firewall device.
	Os []string `json:"os"`
	// The version of the operating system of the firewall device.
	OsVersion []string `json:"osVersion"`
	// The type of the firewall device.
	Type []string `json:"type"`
}

type DeviceAttributesCatalogQueries struct {
	Category     *DeviceAttributeCatalogPayload `json:"category"`
	Manufacturer *DeviceAttributeCatalogPayload `json:"manufacturer"`
	Model        *DeviceAttributeCatalogPayload `json:"model"`
	Os           *DeviceAttributeCatalogPayload `json:"os"`
	Type         *DeviceAttributeCatalogPayload `json:"type"`
}

type DeviceAttributesInput struct {
	// The category of the firewall device.
	Category []string `json:"category"`
	// The manufacturer of the firewall device.
	Manufacturer []string `json:"manufacturer"`
	// The model of the firewall device.
	Model []string `json:"model"`
	// The operating system of the firewall device.
	Os []string `json:"os"`
	// The version of the operating system of the firewall device.
	OsVersion []string `json:"osVersion"`
	// The type of the firewall device.
	Type []string `json:"type"`
}

type DeviceAttributesUpdateInput struct {
	// The category of the firewall device.
	Category []string `json:"category,omitempty"`
	// The manufacturer of the firewall device.
	Manufacturer []string `json:"manufacturer,omitempty"`
	// The model of the firewall device.
	Model []string `json:"model,omitempty"`
	// The operating system of the firewall device.
	Os []string `json:"os,omitempty"`
	// The version of the operating system of the firewall device.
	OsVersion []string `json:"osVersion,omitempty"`
	// The type of the firewall device.
	Type []string `json:"type,omitempty"`
}

// Filter input for device confidence level with equality and inclusion operators
type DeviceCategoryFilterInput struct {
	Eq  *DeviceCategory  `json:"eq,omitempty"`
	In  []DeviceCategory `json:"in,omitempty"`
	Neq *DeviceCategory  `json:"neq,omitempty"`
	Nin []DeviceCategory `json:"nin,omitempty"`
}

type DeviceConfidenceLevelFilterInput struct {
	// Equals - exact confidence level match
	Eq *DeviceConfidenceLevel `json:"eq,omitempty"`
	// In - match any of the specified confidence levels
	In []DeviceConfidenceLevel `json:"in,omitempty"`
	// Not equals - exclude specific confidence level
	Neq *DeviceConfidenceLevel `json:"neq,omitempty"`
	// Not in - exclude all specified confidence levels
	Nin []DeviceConfidenceLevel `json:"nin,omitempty"`
}

type DeviceConnectionProfile struct {
	// List of applications the device communicates with
	DestApps []string `json:"destApps"`
	// Domains contacted by the device
	DestDomains []string `json:"destDomains"`
	// Destination hosts accessed by the device
	DestHosts []string `json:"destHosts"`
	// Traffic direction indicators (e.g., inbound, outbound)
	Directions []string `json:"directions"`
}

// Input for CSV export with optional filtering
type DeviceCSVExportInput struct {
	// Filter devices by various criteria before export
	Filter []*DeviceV2FilterInput `json:"filter,omitempty"`
}

type DeviceHw struct {
	// Brand or vendor that produced the device
	Manufacturer *string `json:"manufacturer,omitempty"`
	// Specific hardware model identifier
	Model *string `json:"model,omitempty"`
	// Hardware type of the device (e.g., laptop, printer)
	Type *string `json:"type,omitempty"`
}

type DeviceHwFilterInput struct {
	Manufacturer []*StringFilterInput `json:"manufacturer,omitempty"`
	Model        []*StringFilterInput `json:"model,omitempty"`
	Type         []*StringFilterInput `json:"type,omitempty"`
}

type DeviceHwSortOrderInput struct {
	Manufacturer *SortOrderInput `json:"manufacturer,omitempty"`
	Model        *SortOrderInput `json:"model,omitempty"`
	Type         *SortOrderInput `json:"type,omitempty"`
}

type DeviceNetwork struct {
	// Name of the associated network
	NetworkName *string `json:"networkName,omitempty"`
	// Subnet in which the device resides
	Subnet *string `json:"subnet,omitempty"`
}

type DeviceNetworkFilterInput struct {
	NetworkName []*StringFilterInput `json:"networkName,omitempty"`
	Subnet      []*StringFilterInput `json:"subnet,omitempty"`
}

type DeviceNetworkSortOrderInput struct {
	NetworkName *SortOrderInput `json:"networkName,omitempty"`
	Subnet      *SortOrderInput `json:"subnet,omitempty"`
}

type DeviceNic struct {
	// The unique MAC address of the device's network interface card
	MacAddress *string `json:"macAddress,omitempty"`
	// Manufacturer of the network interface (e.g., Intel, Broadcom)
	Vendor *string `json:"vendor,omitempty"`
}

type DeviceNicFilterInput struct {
	MacAddress []*MacAddressFilterInput `json:"macAddress,omitempty"`
	Vendor     []*StringFilterInput     `json:"vendor,omitempty"`
}

type DeviceNicSortOrderInput struct {
	MacAddress *SortOrderInput `json:"macAddress,omitempty"`
	Vendor     *SortOrderInput `json:"vendor,omitempty"`
}

type DeviceOs struct {
	// Name of the operating system product (e.g., Windows, iOS)
	Product *string `json:"product,omitempty"`
	// Vendor or publisher of the operating system
	Vendor *string `json:"vendor,omitempty"`
	// Specific version or release of the operating system
	Version *string `json:"version,omitempty"`
}

type DeviceOsFilterInput struct {
	Product []*StringFilterInput `json:"product,omitempty"`
	Vendor  []*StringFilterInput `json:"vendor,omitempty"`
	Version []*StringFilterInput `json:"version,omitempty"`
}

type DeviceOsSortOrderInput struct {
	Product *SortOrderInput `json:"product,omitempty"`
	Vendor  *SortOrderInput `json:"vendor,omitempty"`
	Version *SortOrderInput `json:"version,omitempty"`
}

// A reference identifying the DeviceProfile object. ID: Unique DeviceProfile Identifier, Name: The DeviceProfile Name
type DeviceProfileRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (DeviceProfileRef) IsObjectRef() {}

// Object's unique identifier
func (this DeviceProfileRef) GetID() string { return this.ID }

// Object's unique name
func (this DeviceProfileRef) GetName() string { return this.Name }

type DeviceProfileRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

type DeviceSiteSortOrderInput struct {
	ID   *SortOrderInput `json:"id,omitempty"`
	Name *SortOrderInput `json:"name,omitempty"`
}

type DeviceSnapshot struct {
	// A boolean value that indicates if the site is connected to the Cato Cloud
	Connected *bool `json:"connected,omitempty"`
	// For connected devices (this somewhat overlaps to last duration)
	ConnectedSince *string `json:"connectedSince,omitempty"`
	// Indicates the Socket uptime
	DeviceUptime *int64 `json:"deviceUptime,omitempty"`
	// Shows if this is the primary or secondary Socket in high availability mode
	HaRole *string `json:"haRole,omitempty"`
	// Unique internal Cato ID for the Socket
	ID *string `json:"id,omitempty"`
	// Unique identifier for the device
	Identifier *string `json:"identifier,omitempty"`
	// Snapshot data for outbound facing interfaces
	Interfaces []*InterfaceSnapshot `json:"interfaces,omitempty"`
	// Information of the link state of various interfaces in the devices. Unlike the `interfacess` field, it contains
	// all links of the device, not just the outbound facing ones
	InterfacesLinkState []*InterfaceLinkState `json:"interfacesLinkState,omitempty"`
	// Device's internal IP in the account's routing table
	InternalIP *string `json:"internalIP,omitempty"`
	// The last time the device was seen
	LastConnected *string `json:"lastConnected,omitempty"`
	// The uptime of the last tunnel from this device (or current), in seconds
	LastDuration *int64 `json:"lastDuration,omitempty"`
	// The ID of the PoP that the Socket is connected to
	LastPopID *int64 `json:"lastPopID,omitempty"`
	// The PoP name that the Socket is connected to
	LastPopName *string `json:"lastPopName,omitempty"`
	// The time the mfa cookie (for sdp users) was created
	MfaCreationTime *int64 `json:"mfaCreationTime,omitempty"`
	// Shows the amount of time remaining before the MFA token expires
	MfaExpirationTime *int64 `json:"mfaExpirationTime,omitempty"`
	// Name of the device
	Name *string `json:"name,omitempty"`
	// Operating system of the Device.
	OsType *string `json:"osType,omitempty"`
	// Version of the Socket operating system
	OsVersion *string `json:"osVersion,omitempty"`
	// Data related to the most recent completed traffic flows
	RecentConnections []*RecentConnection `json:"recentConnections,omitempty"`
	// Shows the release group for the site
	ReleaseGroup *string `json:"releaseGroup,omitempty"`
	// Shows data related to the Socket, such as version and serial number
	SocketInfo *SocketInfo `json:"socketInfo,omitempty"`
	// Shows the Socket model or vSocket type
	Type *string `json:"type,omitempty"`
	// Device version
	Version *string `json:"version,omitempty"`
	// Device major version
	VersionNumber *int64 `json:"versionNumber,omitempty"`
}

// Input for sorting devices by various fields
type DeviceSortInput struct {
	// Sort by device category
	Category *SortOrderInput `json:"category,omitempty"`
	// Sort by classification confidence level
	Confidence *SortOrderInput `json:"confidence,omitempty"`
	// Sort by first detection timestamp
	FirstSeen *SortOrderInput `json:"firstSeen,omitempty"`
	// Sort by hardware fields
	Hw *DeviceHwSortOrderInput `json:"hw,omitempty"`
	// Sort by device unique identifier
	ID *SortOrderInput `json:"id,omitempty"`
	// Sort by IP address
	IP *SortOrderInput `json:"ip,omitempty"`
	// Sort by last activity timestamp
	LastSeen *SortOrderInput `json:"lastSeen,omitempty"`
	// Sort by device name
	Name *SortOrderInput `json:"name,omitempty"`
	// Sort by network fields
	Network *DeviceNetworkSortOrderInput `json:"network,omitempty"`
	// Sort by network interface fields
	Nic *DeviceNicSortOrderInput `json:"nic,omitempty"`
	// Sort by operating system fields
	Os *DeviceOsSortOrderInput `json:"os,omitempty"`
	// Sort by security risk score
	RiskScore *SortOrderInput `json:"riskScore,omitempty"`
	// Sort by site-related fields
	Site *DeviceSiteSortOrderInput `json:"site,omitempty"`
	// Sort by user-related fields
	User *DeviceUserSortOrderInput `json:"user,omitempty"`
}

type DeviceUserSortOrderInput struct {
	ID   *SortOrderInput `json:"id,omitempty"`
	Name *SortOrderInput `json:"name,omitempty"`
}

type DeviceV2 struct {
	// Device category grouping based on role or type
	Category *string `json:"category,omitempty"`
	// Compliance posture of the device according to policy/integration checks (e.g., 'compliant', 'noncompliant', 'unknown')
	ComplianceState *string `json:"complianceState,omitempty"`
	// Confidence score for device classification accuracy
	Confidence *DeviceConfidenceLevel `json:"confidence,omitempty"`
	// Profile describing how the device connects to the network
	ConnectionProfile *DeviceConnectionProfile `json:"connectionProfile,omitempty"`
	// Timestamp of when the device was first detected
	FirstSeen *string `json:"firstSeen,omitempty"`
	// Hardware information for the device
	Hw *DeviceHw `json:"hw,omitempty"`
	// Unique identifier for the device record
	ID string  `json:"id"`
	IP *string `json:"ip,omitempty"`
	// Current or last known IP address of the device
	IPAddress *string `json:"ipAddress,omitempty"`
	// True/false flag showing whether the device is under admin management
	IsManaged bool `json:"isManaged"`
	// Timestamp of the most recent device activity
	LastSeen *string `json:"lastSeen,omitempty"`
	// Human-readable name of the device
	Name *string `json:"name,omitempty"`
	// Information about the network environment the device connects to
	Network *DeviceNetwork `json:"network,omitempty"`
	// Reference to the device's network (Rename to 'network' after fe is aligned)
	NetworkInfo DeviceNetworkRef `json:"networkInfo,omitempty"`
	// Network interface card details for the device
	Nic *DeviceNic `json:"nic,omitempty"`
	// The origins (e.g., integrations, data feeds) that detected the device
	OriginTypes []OriginType `json:"originTypes"`
	// Operating system details of the device
	Os *DeviceOs `json:"os,omitempty"`
	// Numerical value representing the device's security risk
	RiskScore *int64 `json:"riskScore,omitempty"`
	// Reference to the site where the device is located
	Site *SiteRef `json:"site,omitempty"`
	// Reference to the user linked with this device
	User *UserRef `json:"user,omitempty"`
}

// Input for filtering devices by various criteria
type DeviceV2FilterInput struct {
	// Filter by device category
	Category []*StringFilterInput `json:"category,omitempty"`
	// Filter by compliance state criteria
	ComplianceState []*StringFilterInput `json:"complianceState,omitempty"`
	// Filter by classification confidence level
	Confidence []*DeviceConfidenceLevelFilterInput `json:"confidence,omitempty"`
	// Filter by first detection timestamp
	FirstSeen []*DateTimeFilterInput `json:"firstSeen,omitempty"`
	// Filter by hardware criteria
	Hw *DeviceHwFilterInput `json:"hw,omitempty"`
	// Filter by device unique identifier
	ID []*IDFilterInput     `json:"id,omitempty"`
	IP []*StringFilterInput `json:"ip,omitempty"`
	// Filter by IP address
	IPAddress []*IPAddressFilterInput `json:"ipAddress,omitempty"`
	// Filter by management status
	IsManaged []*BooleanFilterInput `json:"isManaged,omitempty"`
	// Filter by last activity timestamp
	LastSeen []*DateTimeFilterInput `json:"lastSeen,omitempty"`
	// Filter by device name
	Name []*StringFilterInput `json:"name,omitempty"`
	// Filter by network criteria
	Network *DeviceNetworkFilterInput `json:"network,omitempty"`
	// Filter by network interface criteria
	Nic         *DeviceNicFilterInput    `json:"nic,omitempty"`
	OriginTypes []*OriginTypeFilterInput `json:"originTypes,omitempty"`
	// Filter by operating system criteria
	Os *DeviceOsFilterInput `json:"os,omitempty"`
	// Filter by security risk score
	RiskScore []*IntFilterInput `json:"riskScore,omitempty"`
	// Filter by site reference
	Site []*SiteRefFilterInput `json:"site,omitempty"`
	// Filter by user reference
	User []*UserRefFilterInput `json:"user,omitempty"`
}

type DeviceV2Input struct {
	// List of filter conditions applied to narrow down devices
	Filter []*DeviceV2FilterInput `json:"filter,omitempty"`
	// Paging input to control results (default limit = 100)
	Paging *PagingInput `json:"paging"`
	// Sorting configuration (default: sort by id descending)
	Sort *DeviceSortInput `json:"sort"`
}

type DevicesPayload struct {
	// List of devices returned by the query
	Device []*DeviceV2 `json:"device"`
	// Metadata describing pagination details
	Paging *PageInfo `json:"paging"`
}

type DevicesQueries struct {
	AttributesCatalog *DeviceAttributesCatalogQueries `json:"attributesCatalog"`
	CSVExport         *ExportJobResponse              `json:"csvExport"`
	CSVExportStatus   *ExportStatusResponse           `json:"csvExportStatus"`
	List              *DevicesPayload                 `json:"list,omitempty"`
}

type Dimension struct {
	FieldName AppStatsFieldName `json:"fieldName"`
}

type DimensionData struct {
	// Type of the dimension
	Label string `json:"label"`
	// String value of the dimension
	Value *string `json:"value,omitempty"`
}

type DimensionKey struct {
	// Dimension field
	FieldName string `json:"fieldName"`
	// String value of the dimension
	Value *string `json:"value,omitempty"`
}

type DisableAccountPayload struct {
	// General info of the disabled account
	AccountInfo *AccountInfo `json:"accountInfo"`
}

type DlpContentProfileRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (DlpContentProfileRef) IsObjectRef() {}

// Object's unique identifier
func (this DlpContentProfileRef) GetID() string { return this.ID }

// Object's unique name
func (this DlpContentProfileRef) GetName() string { return this.Name }

type DlpContentProfileRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

type DlpEdmProfileRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (DlpEdmProfileRef) IsObjectRef() {}

// Object's unique identifier
func (this DlpEdmProfileRef) GetID() string { return this.ID }

// Object's unique name
func (this DlpEdmProfileRef) GetName() string { return this.Name }

type DlpEdmProfileRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

// Data Loss Prevention (DLP) Service license details
type DlpLicense struct {
	Description *string `json:"description,omitempty"`
	// License expiration date
	ExpirationDate string `json:"expirationDate"`
	// The unique identifier for the license. If this value is not available, you can contact Cato Support, who may be able to assist in retrieving it.
	ID *string `json:"id,omitempty"`
	// The date of the last update to the license
	LastUpdated *string `json:"lastUpdated,omitempty"`
	// License plan type
	Plan LicensePlan `json:"plan"`
	// The license SKU
	Sku LicenseSku `json:"sku"`
	// License start date
	StartDate *string `json:"startDate,omitempty"`
	// License activation status
	Status LicenseStatus `json:"status"`
}

func (DlpLicense) IsLicense() {}

// The unique identifier for the license. If this value is not available, you can contact Cato Support, who may be able to assist in retrieving it.
func (this DlpLicense) GetID() *string          { return this.ID }
func (this DlpLicense) GetDescription() *string { return this.Description }

// License plan type
func (this DlpLicense) GetPlan() LicensePlan { return this.Plan }

// The license SKU
func (this DlpLicense) GetSku() LicenseSku { return this.Sku }

// License activation status
func (this DlpLicense) GetStatus() LicenseStatus { return this.Status }

// License start date
func (this DlpLicense) GetStartDate() *string { return this.StartDate }

// License expiration date
func (this DlpLicense) GetExpirationDate() string { return this.ExpirationDate }

// The date of the last update to the license
func (this DlpLicense) GetLastUpdated() *string { return this.LastUpdated }

// Input for searching FQDN typed container to download its content
type DownloadFqdnContainerFileInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

// Payload of download FQDN typed container file
type DownloadFqdnContainerFilePayload struct {
	// Content of a file encoded in base64 format
	EncodedFile string `json:"encodedFile"`
	// Unique container ID
	ID string `json:"id"`
	// Name for the container
	Name string `json:"name"`
}

// Input for searching IPAddressRange typed container to download its content
type DownloadIPAddressRangeContainerFileInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

// Payload of download IPAddressRange typed container file
type DownloadIPAddressRangeContainerFilePayload struct {
	// Content of a file encoded in base64 format
	EncodedFile string `json:"encodedFile"`
	// Unique container ID
	ID string `json:"id"`
	// Name for the container
	Name string `json:"name"`
}

type DynamicIPAllocationAddRuleDataInput struct {
	Country     []*CountryRefInput              `json:"country"`
	Description string                          `json:"description"`
	Enabled     bool                            `json:"enabled"`
	Name        string                          `json:"name"`
	Platform    []OperatingSystem               `json:"platform"`
	Range       *DynamicIPAllocationRangeInput  `json:"range"`
	Source      *DynamicIPAllocationSourceInput `json:"source"`
}

type DynamicIPAllocationAddRuleInput struct {
	// Position of the rule in the policy
	At *PolicyRulePositionInput `json:"at,omitempty"`
	// Parameters for the rule you are adding
	Rule *DynamicIPAllocationAddRuleDataInput `json:"rule"`
}

type DynamicIPAllocationPolicy struct {
	Audit    *PolicyAudit                      `json:"audit,omitempty"`
	Enabled  bool                              `json:"enabled"`
	Revision *PolicyRevision                   `json:"revision,omitempty"`
	Rules    []*DynamicIPAllocationRulePayload `json:"rules"`
	Sections []*PolicySectionPayload           `json:"sections"`
}

func (DynamicIPAllocationPolicy) IsIPolicy() {}

// TRUE = Policy is enabled, FALSE = Policy is disabled
func (this DynamicIPAllocationPolicy) GetEnabled() bool { return this.Enabled }

// Return list of rules in the policy
func (this DynamicIPAllocationPolicy) GetRules() []IPolicyRulePayload {
	if this.Rules == nil {
		return nil
	}
	interfaceSlice := make([]IPolicyRulePayload, 0, len(this.Rules))
	for _, concrete := range this.Rules {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

// Return sections in the policy
func (this DynamicIPAllocationPolicy) GetSections() []*PolicySectionPayload {
	if this.Sections == nil {
		return nil
	}
	interfaceSlice := make([]*PolicySectionPayload, 0, len(this.Sections))
	for _, concrete := range this.Sections {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

// Audit data for the policy
func (this DynamicIPAllocationPolicy) GetAudit() *PolicyAudit { return this.Audit }

// Return data for the Policy revision
func (this DynamicIPAllocationPolicy) GetRevision() *PolicyRevision { return this.Revision }

type DynamicIPAllocationPolicyInput struct {
	// A revision is a specific instance of the policy.
	//  Unpublished revisions are working copies of the policy available to a specific
	//  admin or a set of admins
	//  Published revisions are revisions that were applied to the account network.
	//  The last published revision is the active policy.
	Revision *PolicyRevisionInput `json:"revision,omitempty"`
}

type DynamicIPAllocationPolicyMutationInput struct {
	Revision *PolicyMutationRevisionInput `json:"revision,omitempty"`
}

type DynamicIPAllocationPolicyMutationPayload struct {
	Errors []*PolicyMutationError     `json:"errors"`
	Policy *DynamicIPAllocationPolicy `json:"policy,omitempty"`
	Status PolicyMutationStatus       `json:"status"`
}

func (DynamicIPAllocationPolicyMutationPayload) IsIPolicyMutationPayload() {}

// Data for the policy
func (this DynamicIPAllocationPolicyMutationPayload) GetPolicy() IPolicy { return *this.Policy }

// Enum for the status of the policy change
func (this DynamicIPAllocationPolicyMutationPayload) GetStatus() PolicyMutationStatus {
	return this.Status
}

// List of errors related to the policy change
func (this DynamicIPAllocationPolicyMutationPayload) GetErrors() []*PolicyMutationError {
	if this.Errors == nil {
		return nil
	}
	interfaceSlice := make([]*PolicyMutationError, 0, len(this.Errors))
	for _, concrete := range this.Errors {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

type DynamicIPAllocationPolicyMutations struct {
	AddRule               *DynamicIPAllocationRuleMutationPayload   `json:"addRule"`
	AddSection            *PolicySectionMutationPayload             `json:"addSection"`
	CreatePolicyRevision  *DynamicIPAllocationPolicyMutationPayload `json:"createPolicyRevision"`
	DiscardPolicyRevision *DynamicIPAllocationPolicyMutationPayload `json:"discardPolicyRevision"`
	MoveRule              *DynamicIPAllocationRuleMutationPayload   `json:"moveRule"`
	MoveSection           *PolicySectionMutationPayload             `json:"moveSection"`
	PublishPolicyRevision *DynamicIPAllocationPolicyMutationPayload `json:"publishPolicyRevision"`
	RemoveRule            *DynamicIPAllocationRuleMutationPayload   `json:"removeRule"`
	RemoveSection         *PolicySectionMutationPayload             `json:"removeSection"`
	UpdatePolicy          *DynamicIPAllocationPolicyMutationPayload `json:"updatePolicy"`
	UpdateRule            *DynamicIPAllocationRuleMutationPayload   `json:"updateRule"`
	UpdateSection         *PolicySectionMutationPayload             `json:"updateSection"`
}

type DynamicIPAllocationPolicyQueries struct {
	Policy    *DynamicIPAllocationPolicy `json:"policy"`
	Revisions *PolicyRevisionsPayload    `json:"revisions,omitempty"`
}

type DynamicIPAllocationPolicyUpdateInput struct {
	State *PolicyToggleState `json:"state,omitempty"`
}

type DynamicIPAllocationRange struct {
	GlobalIPRange *GlobalIPRangeRef `json:"globalIpRange"`
}

type DynamicIPAllocationRangeInput struct {
	GlobalIPRange *GlobalIPRangeRefInput `json:"globalIpRange"`
}

type DynamicIPAllocationRangeUpdateInput struct {
	GlobalIPRange *GlobalIPRangeRefInput `json:"globalIpRange,omitempty"`
}

type DynamicIPAllocationRemoveRuleInput struct {
	ID string `json:"id"`
}

type DynamicIPAllocationRule struct {
	Country []*CountryRef `json:"country"`
	// Description for the rule
	Description string `json:"description"`
	// TRUE = Rule is enabled
	//  FALSE = Rule is disabled
	Enabled bool `json:"enabled"`
	// Rule ID
	ID string `json:"id"`
	// Position / priority of rule
	Index int64 `json:"index"`
	// Name of the rule
	Name     string                    `json:"name"`
	Platform []OperatingSystem         `json:"platform"`
	Range    *DynamicIPAllocationRange `json:"range"`
	// Policy section where the rule is located
	Section *PolicySectionInfo         `json:"section"`
	Source  *DynamicIPAllocationSource `json:"source"`
}

func (DynamicIPAllocationRule) IsIPolicyRule() {}

// Rule ID
func (this DynamicIPAllocationRule) GetID() string { return this.ID }

// Name of the rule
func (this DynamicIPAllocationRule) GetName() string { return this.Name }

// Description for the rule
func (this DynamicIPAllocationRule) GetDescription() *string { return &this.Description }

// Position / priority of rule
func (this DynamicIPAllocationRule) GetIndex() int64 { return this.Index }

// TRUE = Rule is enabled, FALSE = Rule is disabled
func (this DynamicIPAllocationRule) GetEnabled() bool { return this.Enabled }

// Policy section where the rule is located
func (this DynamicIPAllocationRule) GetSection() *PolicySectionInfo { return this.Section }

type DynamicIPAllocationRuleMutationPayload struct {
	Errors []*PolicyMutationError          `json:"errors"`
	Rule   *DynamicIPAllocationRulePayload `json:"rule,omitempty"`
	Status PolicyMutationStatus            `json:"status"`
}

func (DynamicIPAllocationRuleMutationPayload) IsIPolicyRuleMutationPayload() {}

// Returns settings for the rule
func (this DynamicIPAllocationRuleMutationPayload) GetRule() IPolicyRulePayload { return *this.Rule }

// Enum for the status of the policy change
func (this DynamicIPAllocationRuleMutationPayload) GetStatus() PolicyMutationStatus {
	return this.Status
}

// List of errors related to the policy change
func (this DynamicIPAllocationRuleMutationPayload) GetErrors() []*PolicyMutationError {
	if this.Errors == nil {
		return nil
	}
	interfaceSlice := make([]*PolicyMutationError, 0, len(this.Errors))
	for _, concrete := range this.Errors {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

type DynamicIPAllocationRulePayload struct {
	Audit      *PolicyElementAudit           `json:"audit"`
	Properties []PolicyElementPropertiesEnum `json:"properties"`
	Rule       *DynamicIPAllocationRule      `json:"rule"`
}

func (DynamicIPAllocationRulePayload) IsIPolicyRulePayload()              {}
func (this DynamicIPAllocationRulePayload) GetAudit() *PolicyElementAudit { return this.Audit }

// Rule that was changed
func (this DynamicIPAllocationRulePayload) GetRule() IPolicyRule { return *this.Rule }

// Summary of rule change, (ie. ADDED, UPDATED)
func (this DynamicIPAllocationRulePayload) GetProperties() []PolicyElementPropertiesEnum {
	if this.Properties == nil {
		return nil
	}
	interfaceSlice := make([]PolicyElementPropertiesEnum, 0, len(this.Properties))
	for _, concrete := range this.Properties {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

type DynamicIPAllocationSource struct {
	User       []*UserRef       `json:"user"`
	UsersGroup []*UsersGroupRef `json:"usersGroup"`
}

type DynamicIPAllocationSourceInput struct {
	User       []*UserRefInput       `json:"user"`
	UsersGroup []*UsersGroupRefInput `json:"usersGroup"`
}

type DynamicIPAllocationSourceUpdateInput struct {
	User       []*UserRefInput       `json:"user,omitempty"`
	UsersGroup []*UsersGroupRefInput `json:"usersGroup,omitempty"`
}

type DynamicIPAllocationUpdateRuleDataInput struct {
	Country     []*CountryRefInput                    `json:"country,omitempty"`
	Description *string                               `json:"description,omitempty"`
	Enabled     *bool                                 `json:"enabled,omitempty"`
	Name        *string                               `json:"name,omitempty"`
	Platform    []OperatingSystem                     `json:"platform,omitempty"`
	Range       *DynamicIPAllocationRangeUpdateInput  `json:"range,omitempty"`
	Source      *DynamicIPAllocationSourceUpdateInput `json:"source,omitempty"`
}

type DynamicIPAllocationUpdateRuleInput struct {
	ID   string                                  `json:"id"`
	Rule *DynamicIPAllocationUpdateRuleDataInput `json:"rule"`
}

// End Point Protection (EPP) license details
type EndpointProtectionLicense struct {
	Description *string `json:"description,omitempty"`
	// License expiration date
	ExpirationDate string `json:"expirationDate"`
	// The unique identifier for the license. If this value is not available, you can contact Cato Support, who may be able to assist in retrieving it.
	ID *string `json:"id,omitempty"`
	// The date of the last update to the license
	LastUpdated *string `json:"lastUpdated,omitempty"`
	// License plan type
	Plan LicensePlan `json:"plan"`
	// The license SKU
	Sku LicenseSku `json:"sku"`
	// License start date
	StartDate *string `json:"startDate,omitempty"`
	// License activation status
	Status LicenseStatus `json:"status"`
	// The maximum number of users that can use this service
	Total int64 `json:"total"`
}

func (EndpointProtectionLicense) IsLicense() {}

// The unique identifier for the license. If this value is not available, you can contact Cato Support, who may be able to assist in retrieving it.
func (this EndpointProtectionLicense) GetID() *string          { return this.ID }
func (this EndpointProtectionLicense) GetDescription() *string { return this.Description }

// License plan type
func (this EndpointProtectionLicense) GetPlan() LicensePlan { return this.Plan }

// The license SKU
func (this EndpointProtectionLicense) GetSku() LicenseSku { return this.Sku }

// License activation status
func (this EndpointProtectionLicense) GetStatus() LicenseStatus { return this.Status }

// License start date
func (this EndpointProtectionLicense) GetStartDate() *string { return this.StartDate }

// License expiration date
func (this EndpointProtectionLicense) GetExpirationDate() string { return this.ExpirationDate }

// The date of the last update to the license
func (this EndpointProtectionLicense) GetLastUpdated() *string { return this.LastUpdated }

func (EndpointProtectionLicense) IsQuantifiableLicense() {}

// The unique identifier for the license. If this value is not available, you can contact Cato Support, who may be able to assist in retrieving it.

// License plan type

// The license SKU

// License activation status

// License initiation date

// License expiration date

// The date of the last update to the license

// license quantity
func (this EndpointProtectionLicense) GetTotal() int64 { return this.Total }

type EngineTypePredicate struct {
	In    []StoryEngineTypeEnum `json:"in,omitempty"`
	NotIn []StoryEngineTypeEnum `json:"not_in,omitempty"`
}

type EnterpriseDirectoryArchiveLocationPayload struct {
	// The archived location
	Location *Location `json:"location"`
}

type EnterpriseDirectoryCreateLocationInput struct {
	// Business unit
	BusinessUnit *string `json:"businessUnit,omitempty"`
	// Description
	Description *string `json:"description,omitempty"`
	// Location details
	Details *CreateLocationDetailsInput `json:"details"`
	// Location name
	Name string `json:"name"`
	// Location type
	Type LocationType `json:"type"`
}

type EnterpriseDirectoryCreateLocationPayload struct {
	// The created location
	Location *Location `json:"location"`
}

type EnterpriseDirectoryLocationListInput struct {
	Filter *LocationFilterInput `json:"filter,omitempty"`
	Paging *PagingInput         `json:"paging,omitempty"`
	Sort   *LocationSortInput   `json:"sort,omitempty"`
}

type EnterpriseDirectoryLocationListPayload struct {
	// The results
	Items []*Location `json:"items"`
	// Pagination details
	PageInfo *PageInfo `json:"pageInfo,omitempty"`
}

type EnterpriseDirectoryMutations struct {
	ArchiveLocation *EnterpriseDirectoryArchiveLocationPayload `json:"archiveLocation,omitempty"`
	CreateLocation  *EnterpriseDirectoryCreateLocationPayload  `json:"createLocation,omitempty"`
	RestoreLocation *EnterpriseDirectoryRestoreLocationPayload `json:"restoreLocation,omitempty"`
	UpdateLocation  *EnterpriseDirectoryUpdateLocationPayload  `json:"updateLocation,omitempty"`
}

type EnterpriseDirectoryQueries struct {
	// Retrieve the account location items
	LocationList *EnterpriseDirectoryLocationListPayload `json:"locationList"`
}

type EnterpriseDirectoryRestoreLocationPayload struct {
	// The restored location
	Location *Location `json:"location"`
}

type EnterpriseDirectoryUpdateLocationInput struct {
	// Business unit
	BusinessUnit *string `json:"businessUnit,omitempty"`
	// Description
	Description *string `json:"description,omitempty"`
	// Location details
	Details *UpdateLocationDetailsInput `json:"details,omitempty"`
	// Location id
	ID string `json:"id"`
	// Location name
	Name *string `json:"name,omitempty"`
	// Location type
	Type *LocationType `json:"type,omitempty"`
}

type EnterpriseDirectoryUpdateLocationPayload struct {
	// The updated location
	Location *Location `json:"location"`
}

type Entity struct {
	ID   string     `json:"id"`
	Name *string    `json:"name,omitempty"`
	Type EntityType `json:"type"`
}

func (Entity) IsValue() {}

type EntityInfo struct {
	Description  string         `json:"description"`
	Entity       *Entity        `json:"entity"`
	HelperFields map[string]any `json:"helperFields"`
}

type EntityInput struct {
	ID   string     `json:"id"`
	Name *string    `json:"name,omitempty"`
	Type EntityType `json:"type"`
}

type EntityLookupResult struct {
	Items []*EntityInfo `json:"items"`
	Total *int64        `json:"total,omitempty"`
}

type Event struct {
	Action                *string     `json:"action,omitempty"`
	AppID                 *string     `json:"appId,omitempty"`
	AppName               *string     `json:"appName,omitempty"`
	DNSProtectionCategory *string     `json:"dnsProtectionCategory,omitempty"`
	EventType             *string     `json:"eventType,omitempty"`
	RuleID                *string     `json:"ruleId,omitempty"`
	ScanResult            *ScanResult `json:"scanResult,omitempty"`
	Severity              *string     `json:"severity,omitempty"`
	SignatureID           *string     `json:"signatureId,omitempty"`
	ThreatName            *string     `json:"threatName,omitempty"`
	ThreatType            *string     `json:"threatType,omitempty"`
	VirusName             *string     `json:"virusName,omitempty"`
}

type EventFeedFieldFilterInput struct {
	FieldName EventFeedFilterFieldName `json:"fieldName"`
	// Use event_type and event_sub_type for events
	Operator EventFeedFilterOperator `json:"operator"`
	Values   []string                `json:"values,omitempty"`
}

type EventField struct {
	Name  EventFieldName `json:"name"`
	Value Value          `json:"value"`
}

type EventRecord struct {
	// fields in map format (see Map scalar)
	FieldsMap map[string]any `json:"fieldsMap,omitempty"`
	// Simplified fields, as array of name value tuples, e.g: [ [ "name", "val" ], [ "name2", "val2" ] ... ]
	FlatFields [][]string `json:"flatFields,omitempty"`
	Time       *string    `json:"time,omitempty"`
}

type Events struct {
	From    *string         `json:"from,omitempty"`
	ID      *string         `json:"id,omitempty"`
	Records []*EventsRecord `json:"records,omitempty"`
	To      *string         `json:"to,omitempty"`
	Total   *int64          `json:"total,omitempty"`
	Totals  map[string]any  `json:"totals,omitempty"`
}

type EventsDimension struct {
	FieldName EventFieldName `json:"fieldName"`
}

type EventsFeedAccountRecords struct {
	ErrorString *string        `json:"errorString,omitempty"`
	ID          *string        `json:"id,omitempty"`
	Records     []*EventRecord `json:"records,omitempty"`
}

type EventsFeedData struct {
	Accounts     []*EventsFeedAccountRecords `json:"accounts,omitempty"`
	FetchedCount int64                       `json:"fetchedCount"`
	Marker       *string                     `json:"marker,omitempty"`
}

type EventsFilter struct {
	FieldName EventFieldName `json:"fieldName"`
	Operator  FilterOperator `json:"operator"`
	Values    []string       `json:"values"`
}

type EventsGraphQuery struct {
	TimeSeriesEvents *TimeSeriesEvents `json:"timeSeriesEvents,omitempty"`
	Type             GraphType         `json:"type"`
}

type EventsMeasure struct {
	AggType   AggregationType `json:"aggType"`
	FieldName EventFieldName  `json:"fieldName"`
	Trend     *bool           `json:"trend,omitempty"`
}

type EventsRecord struct {
	Fields []*EventField `json:"fields,omitempty"`
	// fields in map format (see Map scalar)
	FieldsMap       map[string]any `json:"fieldsMap,omitempty"`
	FieldsUnitTypes []UnitType     `json:"fieldsUnitTypes,omitempty"`
	// Simplified fields, as array of name value tuples, e.g: [ [ "name", "val" ], [ "name2", "val2" ] ... ]
	FlatFields    [][]string     `json:"flatFields,omitempty"`
	PrevTimeFrame map[string]any `json:"prevTimeFrame,omitempty"`
	Trends        map[string]any `json:"trends,omitempty"`
}

type EventsSort struct {
	FieldName EventFieldName `json:"fieldName"`
	Order     DirectionEnum  `json:"order"`
}

type EventsTimeSeries struct {
	From        *string       `json:"from,omitempty"`
	Granularity *int64        `json:"granularity,omitempty"`
	ID          *string       `json:"id,omitempty"`
	Timeseries  []*Timeseries `json:"timeseries,omitempty"`
	To          *string       `json:"to,omitempty"`
}

// Response returned when initiating a CSV export job
type ExportJobResponse struct {
	// Unique identifier for the export job
	JobID string `json:"jobId"`
	// Status message about the export job initiation
	Message *string `json:"message,omitempty"`
}

// Response containing the current status and details of an export job
type ExportStatusResponse struct {
	// Download URL (available when status is COMPLETED)
	DownloadURL *string `json:"downloadUrl,omitempty"`
	// Timestamp when the download URL expires
	ExpiresAt *string `json:"expiresAt,omitempty"`
	// Unique identifier for the export job
	JobID string `json:"jobId"`
	// Status message describing current state
	Message *string `json:"message,omitempty"`
	// Completion percentage (0-100%)
	Progress *float64 `json:"progress,omitempty"`
	// Current status of the export job
	Status ExportJobStatus `json:"status"`
}

type Extra struct {
	Name  string `json:"name"`
	Type  string `json:"type"`
	Value string `json:"value"`
}

// FieldName for the different types of FieldName inputs
// Use the EventFieldName for events, and AuditFieldName for audit
type FieldNameInput struct {
	AuditFieldName *AuditFieldName `json:"AuditFieldName,omitempty"`
	EventFieldName *EventFieldName `json:"EventFieldName,omitempty"`
}

type FileDetails struct {
	Issuer    *string `json:"issuer,omitempty"`
	Md5       *string `json:"md5,omitempty"`
	Name      *string `json:"name,omitempty"`
	Path      *string `json:"path,omitempty"`
	Publisher *string `json:"publisher,omitempty"`
	Sha1      *string `json:"sha1,omitempty"`
	Sha256    *string `json:"sha256,omitempty"`
	Signer    *string `json:"signer,omitempty"`
	Size      *int64  `json:"size,omitempty"`
}

// Returns data for the Floating Subnet object. Floating Subnets (ie. Floating Ranges) are used to identify traffic exactly matched
// to the route advertised by BGP. They are not associated with a specific site.
// This is useful in scenarios such as active-standby high availability routed via BGP.
type FloatingSubnetRef struct {
	// Unique Floating Subnet ID
	ID string `json:"id"`
	// Name for the Floating Subnet
	Name string `json:"name"`
}

func (FloatingSubnetRef) IsObjectRef() {}

// Object's unique identifier
func (this FloatingSubnetRef) GetID() string { return this.ID }

// Object's unique name
func (this FloatingSubnetRef) GetName() string { return this.Name }

// Defines the Floating Subnet object. Floating Subnets (ie. Floating Ranges) are used to identify traffic exactly matched
// to the route advertised by BGP. They are not associated with a specific site.
// This is useful in scenarios such as active-standby high availability routed via BGP.
type FloatingSubnetRefInput struct {
	// Defines the object identification method – by ID (default) or by name
	By ObjectRefBy `json:"by"`
	// The object identification (ID or name) value
	Input string `json:"input"`
}

// A group with members of FQDN type
type FqdnContainer struct {
	// Audit metadata about the container
	Audit *ContainerAudit `json:"audit"`
	// Description for the container
	Description *string `json:"description,omitempty"`
	// Unique container ID
	ID string `json:"id"`
	// Name for the container
	Name string `json:"name"`
	// Number of items in the container
	Size int64 `json:"size"`
}

func (FqdnContainer) IsContainer() {}

// Unique container ID
func (this FqdnContainer) GetID() string { return this.ID }

// Name for the container
func (this FqdnContainer) GetName() string { return this.Name }

// Description for the container
func (this FqdnContainer) GetDescription() *string { return this.Description }

// Number of items in the container
func (this FqdnContainer) GetSize() int64 { return this.Size }

// Audit metadata about the container
func (this FqdnContainer) GetAudit() *ContainerAudit { return this.Audit }

// Input for adding values to existing FQDN typed container
type FqdnContainerAddValuesInput struct {
	// Reference to existing container by container ID or container name
	Ref    *ContainerRefInput `json:"ref"`
	Values []string           `json:"values"`
}

// Payload of AddValues operation on FQDN typed container
type FqdnContainerAddValuesPayload struct {
	// Container with members of type FQDN
	Container *FqdnContainer `json:"container"`
}

type FqdnContainerMutations struct {
	AddValues      *FqdnContainerAddValuesPayload      `json:"addValues"`
	CreateFromFile *CreateFqdnContainerFromFilePayload `json:"createFromFile"`
	CreateFromList *CreateFqdnContainerFromListPayload `json:"createFromList"`
	RemoveValues   *FqdnContainerRemoveValuesPayload   `json:"removeValues"`
	UpdateFromFile *UpdateFqdnContainerFromFilePayload `json:"updateFromFile"`
	UpdateFromList *UpdateFqdnContainerFromListPayload `json:"updateFromList"`
}

type FqdnContainerQueries struct {
	DownloadFile *DownloadFqdnContainerFilePayload `json:"downloadFile"`
	Search       *FqdnContainerSearchPayload       `json:"search"`
	SearchFqdn   *FqdnContainerSearchFqdnPayload   `json:"searchFqdn"`
}

// A group with members of FQDN type
type FqdnContainerRef struct {
	// Unique container ID
	ID string `json:"id"`
	// Name for the container
	Name string `json:"name"`
}

func (FqdnContainerRef) IsObjectRef() {}

// Object's unique identifier
func (this FqdnContainerRef) GetID() string { return this.ID }

// Object's unique name
func (this FqdnContainerRef) GetName() string { return this.Name }

type FqdnContainerRefInput struct {
	// Defines the object identification method – by ID (default) or by name
	By ObjectRefBy `json:"by"`
	// The object identification (ID or name) value
	Input string `json:"input"`
}

// Input for removing values from existing FQDN typed container
type FqdnContainerRemoveValuesInput struct {
	// Reference to existing container by container ID or container name
	Ref    *ContainerRefInput `json:"ref"`
	Values []string           `json:"values"`
}

// Payload of RemoveValues operation on FQDN typed container
type FqdnContainerRemoveValuesPayload struct {
	// Container with members of type FQDN
	Container *FqdnContainer `json:"container"`
}

// Input for searching FQDN typed containers that contain a specific FQDN
type FqdnContainerSearchFqdnInput struct {
	Fqdn string `json:"fqdn"`
}

// Payload of FQDN search query
type FqdnContainerSearchFqdnPayload struct {
	// List of containers with members of type FQDN
	Containers []*FqdnContainer `json:"containers"`
}

// Input for searching FQDN typed container
type FqdnContainerSearchInput struct {
	// Reference to existing container by container ID or container name
	Ref *ContainerRefInput `json:"ref"`
}

// Payload of FQDN container search
type FqdnContainerSearchPayload struct {
	// Container with members of type FQDN
	Container *FqdnContainer `json:"container"`
}

type FreeTextFilterInput struct {
	Search string `json:"search"`
}

type Gaussian struct {
	Avg    *float64 `json:"avg,omitempty"`
	N      *float64 `json:"n,omitempty"`
	Ss     *float64 `json:"ss,omitempty"`
	Std    *float64 `json:"std,omitempty"`
	ZScore *float64 `json:"z_score,omitempty"`
}

type GetAdminPayload struct {
	AdminType            AdminType    `json:"adminType"`
	CreationDate         string       `json:"creationDate"`
	Email                string       `json:"email"`
	FirstName            string       `json:"firstName"`
	ID                   string       `json:"id"`
	LastName             string       `json:"lastName"`
	ManagedRoles         []*AdminRole `json:"managedRoles,omitempty"`
	MfaEnabled           bool         `json:"mfaEnabled"`
	PasswordNeverExpires bool         `json:"passwordNeverExpires"`
	ResellerRoles        []*AdminRole `json:"resellerRoles,omitempty"`
}

type GetServicePrincipalAdminPayload struct {
	AdminType     AdminType    `json:"adminType"`
	CreationDate  string       `json:"creationDate"`
	Email         *string      `json:"email,omitempty"`
	ID            string       `json:"id"`
	ManagedRoles  []*AdminRole `json:"managedRoles,omitempty"`
	Name          string       `json:"name"`
	ResellerRoles []*AdminRole `json:"resellerRoles,omitempty"`
}

// A reference identifying the GlobalIpRange object. ID: Unique GlobalIpRange Identifier, Name: The GlobalIpRange Name
type GlobalIPRangeRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (GlobalIPRangeRef) IsObjectRef() {}

// Object's unique identifier
func (this GlobalIPRangeRef) GetID() string { return this.ID }

// Object's unique name
func (this GlobalIPRangeRef) GetName() string { return this.Name }

type GlobalIPRangeRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

// License usage and allocation across all accounts
type GlobalLicenseAllocations struct {
	// Public IP addresses usage across the accounts
	PublicIps *PublicIpsLicenseAllocations `json:"publicIps,omitempty"`
	// ZTNA license allocation across the accounts
	ZtnaUsers *ZtnaUsersLicenseAllocations `json:"ztnaUsers,omitempty"`
}

type GlobalRangeRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (GlobalRangeRef) IsDeviceNetworkRef() {}

func (GlobalRangeRef) IsObjectRef() {}

// Object's unique identifier
func (this GlobalRangeRef) GetID() string { return this.ID }

// Object's unique name
func (this GlobalRangeRef) GetName() string { return this.Name }

type GraphEventsDimension struct {
	FieldName string `json:"fieldName"`
}

type GraphEventsFilter struct {
	FieldName string   `json:"fieldName"`
	Operator  string   `json:"operator"`
	Values    []string `json:"values"`
}

type GraphEventsMeasure struct {
	AggType   string `json:"aggType"`
	FieldName string `json:"fieldName"`
	Trend     *bool  `json:"trend,omitempty"`
}

// A group is a collection of typed members (e.g., sites, hosts).
// Groups can include members of different types.
//
// When you update a group or use it in a policy, the system verifies that all members are allowed in the policy's scope.
// If a group is used in a policy that doesn’t support certain member types, you can't add those types to the group.
// If a group already includes unsupported types, you can only assign it to a policy that supports those types.
// A member type is valid if it's supported in the group and allowed in the policy scope.
type Group struct {
	// Contains creation and modification metadata for the group
	Audit *AuditingMetadata `json:"audit"`
	// Optional free-text description for documentation or context
	Description *string `json:"description,omitempty"`
	// Unique ID for the group.
	ID string `json:"id"`
	// Lists the members in this group. Supports paging, filtering, and sorting by type and name
	Members *GroupMembersListPayload `json:"members"`
	// Total number of group members. When paging and filtering is used, this number may be higher than the number of members returned by the query
	MembersCount int64 `json:"membersCount"`
	// Breakdown of member count by type (e.g., number of sites, hosts, etc.).
	MembersCountPerType []*GroupMemberTypeCount `json:"membersCountPerType"`
	// Name of the group (not guaranteed to be globally unique).
	Name string `json:"name"`
}

// Apply filters when fetching the list of groups.
type GroupListFilterInput struct {
	// Filter by audit metadata (e.g., created by)
	Audit []*AuditingMetadataFilterInput `json:"audit,omitempty"`
	// Free-text search across textual fields like name
	FreeText *FreeTextFilterInput `json:"freeText,omitempty"`
	// Filter by group ID
	ID []*IDFilterInput `json:"id,omitempty"`
	// Filter groups that include specific members
	Member []*GroupMemberFilterInput `json:"member,omitempty"`
	// Filter by group name
	Name []*AdvancedStringFilterInput `json:"name,omitempty"`
}

// List groups with optional filters, sorting, and pagination.
type GroupListInput struct {
	// Filter groups by ID, name, member, audit data, or free-text
	Filter []*GroupListFilterInput `json:"filter,omitempty"`
	// Pagination settings
	Paging *PagingInput `json:"paging"`
	// Sorting options, default behavior is ascending by name
	Sort *GroupListSortInput `json:"sort"`
}

// A list of groups returned by the groupList query, with pagination info.
type GroupListPayload struct {
	// The list of fetched groups
	Items []*Group `json:"items"`
	// Pagination that was applied during the fetch
	Paging *PageInfo `json:"paging"`
}

// Sort groups by name or audit metadata
type GroupListSortInput struct {
	// Sort groups by audit metadata (e.g., creation time)
	Audit *AuditingMetadataSortInput `json:"audit,omitempty"`
	// ort groups by name
	Name *SortOrderInput `json:"name,omitempty"`
}

// Filter groups by member reference.
type GroupMemberFilterInput struct {
	// Member reference used to identify the groups it belongs to
	Ref *GroupMemberRefTypedInput `json:"ref"`
}

// Filter member types using the supported operators
type GroupMemberRefTypeFilterInput struct {
	// Match if member type equals this value
	Eq *GroupMemberRefType `json:"eq,omitempty"`
	// Match if member type is in this list
	In []GroupMemberRefType `json:"in,omitempty"`
	// Match if member type does not equal this value
	Neq *GroupMemberRefType `json:"neq,omitempty"`
	// Match if member type is not in this list
	Nin []GroupMemberRefType `json:"nin,omitempty"`
}

// Reference to a group member, including its ID, name, and type.
// Used when listing or identifying members within a group.
type GroupMemberRefTyped struct {
	// Object's unique identifier
	ID string `json:"id"`
	// Object's unique name
	Name string             `json:"name"`
	Type GroupMemberRefType `json:"type"`
}

func (GroupMemberRefTyped) IsObjectRef() {}

// Object's unique identifier
func (this GroupMemberRefTyped) GetID() string { return this.ID }

// Object's unique name
func (this GroupMemberRefTyped) GetName() string { return this.Name }

// A reference to a group member, used when adding or filtering members.
type GroupMemberRefTypedInput struct {
	// Whether to resolve the reference by ID or name. Defaults to ID.
	By ObjectRefBy `json:"by"`
	// The value of the member identifier (ID or name)
	Input string `json:"input"`
	// The member type.
	Type GroupMemberRefType `json:"type"`
}

// Counts how many members of each type the group contains.
type GroupMemberTypeCount struct {
	// Number of members of this type that belong to the group
	MembersCount int64 `json:"membersCount"`
	// The member type (e.g., SITE, HOST)
	Type GroupMemberRefType `json:"type"`
}

// Filters to narrow down group members that are fetched.
type GroupMembersListFilterInput struct {
	// Filter group members by name
	Name []*AdvancedStringFilterInput `json:"name,omitempty"`
	// Filter group members by type
	Type []*GroupMemberRefTypeFilterInput `json:"type,omitempty"`
}

// Filter, sort, and pagination applied when fetching the the list of group members.
type GroupMembersListInput struct {
	Filter []*GroupMembersListFilterInput `json:"filter,omitempty"`
	Paging *PagingInput                   `json:"paging"`
	Sort   *GroupMembersListSortInput     `json:"sort"`
}

// A list of group members, pagination details, applied filters, and sorting information.
type GroupMembersListPayload struct {
	// List of members that matched the query (including filtering, sorting, and paging).
	Items []*GroupMemberRefTyped `json:"items"`
	// Pagination information for the result set (e.g., offset, total count).
	Paging *PageInfo `json:"paging"`
}

// Sort group members by one or more fields.
// If multiple fields are specified, the system uses their priority to determine order. For example, type with priority 1 will be used first, then name with priority 2.
type GroupMembersListSortInput struct {
	// Sort by member name
	Name *SortOrderInput `json:"name,omitempty"`
	// Sort by member type
	Type *SortOrderInput `json:"type,omitempty"`
}

// A reference identifying the Group object. ID: Unique Group Identifier, Name: The Group Name
type GroupRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (GroupRef) IsObjectRef() {}

// Object's unique identifier
func (this GroupRef) GetID() string { return this.ID }

// Object's unique name
func (this GroupRef) GetName() string { return this.Name }

type GroupRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

// The scope (context) in which a group is used or supported.
// Includes the policy type and the specific field name(s) where the group is used.
type GroupScope struct {
	// The specific fields within the policy where the group is used (e.g., 'source', 'destination').
	Field []string `json:"field"`
	// The type of policy (e.g.,WAN Firewall).
	Type string `json:"type"`
}

// Describes where the group is used across policies and scopes.
//
// Includes a list of policy scopes where the group is applied,
// and identifies any member types that are not supported in those policy scopes.
type GroupWhereUsedPayload struct {
	// Member types in the group that are not valid in one or more scopes where the group is used.
	InvalidMemberTypes []*InvalidGroupMemberTypeInScope `json:"invalidMemberTypes"`
	// List of scopes where the group is used. Each scope indicates the policy type and field.
	Usage []*GroupScope `json:"usage"`
	// Value is True if the group is used in at least one policy or scope.
	Used bool `json:"used"`
}

// Operations for managing groups
type GroupsMutations struct {
	// Create a new group
	CreateGroup *CreateGroupPayload `json:"createGroup,omitempty"`
	// Delete a group
	DeleteGroup *DeleteGroupPayload `json:"deleteGroup,omitempty"`
	// Update an existing group, including attributes such as name, description, and member items
	UpdateGroup *UpdateGroupPayload `json:"updateGroup,omitempty"`
}

// Queries for reading groups-related information
type GroupsQueries struct {
	// Get a specific group configuration. The group can be identified by ID or name.
	Group *Group `json:"group,omitempty"`
	// Get a list of groups, with optional filters and sorting.
	// This query only returns basic information for each group (e.g. name, ID).
	// To view full configuration details, including members, use the `group` query for each result.
	GroupList *GroupListPayload `json:"groupList,omitempty"`
	// Check which policies use the group.
	WhereUsed *GroupWhereUsedPayload `json:"whereUsed,omitempty"`
}

// Basic Site Ha readiness information
type HaStatus struct {
	Keepalive       *HaSubStatus `json:"keepalive,omitempty"`
	Readiness       *HaReadiness `json:"readiness,omitempty"`
	SocketVersion   *HaSubStatus `json:"socketVersion,omitempty"`
	WanConnectivity *HaSubStatus `json:"wanConnectivity,omitempty"`
}

type Hardware struct {
	// Cma account
	Account *AccountRef `json:"account,omitempty"`
	// Id
	ID string `json:"id"`
	// Last modified
	LastModified *string `json:"lastModified,omitempty"`
	// Crm License Id
	LicenseID *string `json:"licenseId,omitempty"`
	// License start date
	LicenseStartDate *time.Time `json:"licenseStartDate,omitempty"`
	// Reference to the Enterprise Directory address
	LocationID *string `json:"locationId,omitempty"`
	// Product Mac address
	MacAddress *string `json:"macAddress,omitempty"`
	// Product model
	Model *string `json:"model,omitempty"`
	// Product order number
	PoNumber *string `json:"poNumber,omitempty"`
	// Product type
	ProductType *string `json:"productType,omitempty"`
	// Quote ID where the product was purchased
	QuoteID *string `json:"quoteId,omitempty"`
	// Serial number
	SerialNumber *string `json:"serialNumber,omitempty"`
	// Shipping details
	ShippingDetail *ShippingDetails `json:"shippingDetail,omitempty"`
	// Shipping tracking data
	ShippingTracking *ShippingTracking `json:"shippingTracking,omitempty"`
	// The site’s country
	SiteCountryName *string `json:"siteCountryName,omitempty"`
	// Validation details
	Validation *HardwareValidation `json:"validation,omitempty"`
}

type HardwareFilterInput struct {
	Account     []*AccountFilter     `json:"account,omitempty"`
	CountryCode *StringFilterInput   `json:"countryCode,omitempty"`
	CountryName []*StringFilterInput `json:"countryName,omitempty"`
	// Will run contains operation for the provided text on the following fields productType,
	// sfId, siteName, quoteId, model, zipCode, country, city, state, street, companyName, contactName,
	// trackingUrl, trackingNumber and comment with OR between them
	FreeText         *FreeTextFilterInput         `json:"freeText,omitempty"`
	ID               []*IDFilterInput             `json:"id,omitempty"`
	LicenseStartDate []*DateTimeFilterInput       `json:"licenseStartDate,omitempty"`
	Product          []*StringFilterInput         `json:"product,omitempty"`
	SerialNumber     []*StringFilterInput         `json:"serialNumber,omitempty"`
	ShippingStatus   []*ShippingStatusFilterInput `json:"shippingStatus,omitempty"`
	ValidAddress     *BooleanFilterInput          `json:"validAddress,omitempty"`
}

type HardwareManagementQueries struct {
	// Retrieve the account socket inventory
	SocketInventory *SocketInventoryPayload `json:"socketInventory"`
}

type HardwareMutations struct {
	// Set Shipping details for a list of hardware
	UpdateHardwareShipping *HardwarePayload `json:"updateHardwareShipping,omitempty"`
}

type HardwarePayload struct {
	// The results
	Items []*Hardware `json:"items"`
	// Pagination details
	PageInfo *PageInfo `json:"pageInfo,omitempty"`
}

type HardwareQueries struct {
	// Retrieve the account hardware items
	Hardware *HardwarePayload `json:"hardware,omitempty"`
}

type HardwareSearchInput struct {
	Filter *HardwareFilterInput `json:"filter,omitempty"`
	Paging *PagingInput         `json:"paging,omitempty"`
	Sort   *HardwareSortInput   `json:"sort,omitempty"`
}

type HardwareShippingDetailsInput struct {
	// The shipping details
	Details *ShippingDetailsInput `json:"details"`
	// Power cable type (for sockets only)
	PowerCable *string `json:"powerCable,omitempty"`
}

type HardwareSortInput struct {
	AccountName *SortOrderInput `json:"accountName,omitempty"`
	Country     *SortOrderInput `json:"country,omitempty"`
	Incoterms   *SortOrderInput `json:"incoterms,omitempty"`
	LicenseID   *SortOrderInput `json:"licenseId,omitempty"`
	// Default sort field
	LicenseStartDate *SortOrderInput `json:"licenseStartDate,omitempty"`
	ProductType      *SortOrderInput `json:"productType,omitempty"`
	QuoteID          *SortOrderInput `json:"quoteId,omitempty"`
	ShippingDate     *SortOrderInput `json:"shippingDate,omitempty"`
	ShippingStatus   *SortOrderInput `json:"shippingStatus,omitempty"`
	SiteName         *SortOrderInput `json:"siteName,omitempty"`
}

type HardwareValidation struct {
	// Address validation details
	AddressValidationStatus *AddressValidationStatus `json:"addressValidationStatus,omitempty"`
	// Complete item
	Completed bool `json:"completed"`
	// Incomplete reason
	IncompleteReason *string `json:"incompleteReason,omitempty"`
}

// A reference identifying the Host object. ID: Unique Host Identifier, Name: The Host Name
type HostRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (HostRef) IsObjectRef() {}

// Object's unique identifier
func (this HostRef) GetID() string { return this.ID }

// Object's unique name
func (this HostRef) GetName() string { return this.Name }

type HostRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

type IPAddressFilterInput struct {
	Between []string `json:"between,omitempty"`
	Eq      *string  `json:"eq,omitempty"`
	In      []string `json:"in,omitempty"`
	Neq     *string  `json:"neq,omitempty"`
	Nin     []string `json:"nin,omitempty"`
	Nwithin *string  `json:"nwithin,omitempty"`
	Within  *string  `json:"within,omitempty"`
}

// A general structure to contain IP detailed information
type IPInfo struct {
	// Geolocation city
	City *string `json:"city,omitempty"`
	// Geolocation ISO country code
	CountryCode *string `json:"countryCode,omitempty"`
	// Geolocation country name
	CountryName *string `json:"countryName,omitempty"`
	// IP address of the link
	IP *string `json:"ip,omitempty"`
	// Geolocation latitude for the ISP
	Latitude *float64 `json:"latitude,omitempty"`
	// Geolocation longitude for the ISP
	Longitude *float64 `json:"longitude,omitempty"`
	// ISP Internet provider
	Provider *string `json:"provider,omitempty"`
	// Geolocation state
	State *string `json:"state,omitempty"`
}

// Basic IPSec configuration information
type IPSecInfo struct {
	// The source IP address for the IPsec tunnel in the Cato Cloud
	CatoIP *string `json:"catoIP,omitempty"`
	// Shows 1 for IKEv1 and 2 for IKEv2
	IkeVersion *int64 `json:"ikeVersion,omitempty"`
	// For HA configurations, when this boolean value is true, this the primary IPsec firewall or routing device
	IsPrimary *bool `json:"isPrimary,omitempty"`
	// The destination IP address for the IPsec tunnel (in the site)
	RemoteIP *string `json:"remoteIP,omitempty"`
	// List of tunnels configured on the device
	TunnelConfig []*TunnelConfig `json:"tunnelConfig"`
}

type IDFilterInput struct {
	Eq  *string  `json:"eq,omitempty"`
	In  []string `json:"in,omitempty"`
	Neq *string  `json:"neq,omitempty"`
	Nin []string `json:"nin,omitempty"`
}

type IlmmContact struct {
	Email *string `json:"email,omitempty"`
	Name  *string `json:"name,omitempty"`
	Phone *string `json:"phone,omitempty"`
}

type IlmmDetails struct {
	Contacts    []*IlmmContact   `json:"contacts,omitempty"`
	IspDetails  *IlmmIspDetails  `json:"ispDetails,omitempty"`
	LinkDetails *IlmmLinkDetails `json:"linkDetails,omitempty"`
}

type IlmmIspDetails struct {
	CountryCode  *string     `json:"countryCode,omitempty"`
	Description  *string     `json:"description,omitempty"`
	IspAccountID *string     `json:"ispAccountId,omitempty"`
	LoaFile      *IspLoaFile `json:"loaFile,omitempty"`
	Name         *string     `json:"name,omitempty"`
	SupportEmail *string     `json:"supportEmail,omitempty"`
	SupportPhone *string     `json:"supportPhone,omitempty"`
}

// Intelligent Last Mile Monitoring (ILMM) License details
type IlmmLicense struct {
	Description *string `json:"description,omitempty"`
	// License expiration date
	ExpirationDate string `json:"expirationDate"`
	// The unique identifier for the license. If this value is not available, you can contact Cato Support, who may be able to assist in retrieving it.
	ID *string `json:"id,omitempty"`
	// The date of the last update to the license
	LastUpdated *string `json:"lastUpdated,omitempty"`
	// License plan type
	Plan LicensePlan `json:"plan"`
	// The license SKU
	Sku LicenseSku `json:"sku"`
	// License start date
	StartDate *string `json:"startDate,omitempty"`
	// License activation status
	Status LicenseStatus `json:"status"`
	// The total amount of ILMM licenses.
	Total int64 `json:"total"`
}

func (IlmmLicense) IsLicense() {}

// The unique identifier for the license. If this value is not available, you can contact Cato Support, who may be able to assist in retrieving it.
func (this IlmmLicense) GetID() *string          { return this.ID }
func (this IlmmLicense) GetDescription() *string { return this.Description }

// License plan type
func (this IlmmLicense) GetPlan() LicensePlan { return this.Plan }

// The license SKU
func (this IlmmLicense) GetSku() LicenseSku { return this.Sku }

// License activation status
func (this IlmmLicense) GetStatus() LicenseStatus { return this.Status }

// License start date
func (this IlmmLicense) GetStartDate() *string { return this.StartDate }

// License expiration date
func (this IlmmLicense) GetExpirationDate() string { return this.ExpirationDate }

// The date of the last update to the license
func (this IlmmLicense) GetLastUpdated() *string { return this.LastUpdated }

func (IlmmLicense) IsQuantifiableLicense() {}

// The unique identifier for the license. If this value is not available, you can contact Cato Support, who may be able to assist in retrieving it.

// License plan type

// The license SKU

// License activation status

// License initiation date

// License expiration date

// The date of the last update to the license

// license quantity
func (this IlmmLicense) GetTotal() int64 { return this.Total }

type IlmmLinkDetails struct {
	ActiveLicense    *bool                 `json:"activeLicense,omitempty"`
	Comments         *string               `json:"comments,omitempty"`
	Description      *string               `json:"description,omitempty"`
	IspLinkID        *string               `json:"ispLinkId,omitempty"`
	LinkID           *string               `json:"linkId,omitempty"`
	OnboardingStatus *IlmmOnboardingStatus `json:"onboardingStatus,omitempty"`
}

type IncidentFlow struct {
	AppName                *string `json:"appName,omitempty"`
	ClientClass            *string `json:"clientClass,omitempty"`
	CreatedAt              *string `json:"createdAt,omitempty"`
	DestinationCountry     *string `json:"destinationCountry,omitempty"`
	DestinationGeolocation *string `json:"destinationGeolocation,omitempty"`
	DestinationIP          *string `json:"destinationIp,omitempty"`
	DestinationPort        *int64  `json:"destinationPort,omitempty"`
	Direction              *string `json:"direction,omitempty"`
	DNSResponseIP          *string `json:"dnsResponseIP,omitempty"`
	Domain                 *string `json:"domain,omitempty"`
	FileHash               *string `json:"fileHash,omitempty"`
	HTTPResponseCode       *int64  `json:"httpResponseCode,omitempty"`
	Ja3                    *string `json:"ja3,omitempty"`
	Method                 *string `json:"method,omitempty"`
	Referer                *string `json:"referer,omitempty"`
	SmbFileName            *string `json:"smbFileName,omitempty"`
	SourceGeolocation      *string `json:"sourceGeolocation,omitempty"`
	SourceIP               *string `json:"sourceIp,omitempty"`
	SourcePort             *int64  `json:"sourcePort,omitempty"`
	Target                 *string `json:"target,omitempty"`
	TunnelGeolocation      *string `json:"tunnelGeolocation,omitempty"`
	URL                    *string `json:"url,omitempty"`
	User                   *string `json:"user,omitempty"`
	UserAgent              *string `json:"userAgent,omitempty"`
}

type IncidentTargetRep struct {
	AnalysisScore         *float64    `json:"analysisScore,omitempty"`
	Categories            *string     `json:"categories,omitempty"`
	CatoPopularity        *int64      `json:"catoPopularity,omitempty"`
	CountryOfRegistration *string     `json:"countryOfRegistration,omitempty"`
	CreationTime          *string     `json:"creationTime,omitempty"`
	Engines               *int64      `json:"engines,omitempty"`
	EventData             []*Event    `json:"eventData"`
	InfectionSource       *bool       `json:"infectionSource,omitempty"`
	Name                  *string     `json:"name,omitempty"`
	SearchHits            *string     `json:"searchHits,omitempty"`
	ThreatFeeds           *int64      `json:"threatFeeds,omitempty"`
	ThreatReference       *string     `json:"threatReference,omitempty"`
	Type                  *TargetType `json:"type,omitempty"`
}

type IncidentTimeseries struct {
	// Data is an array of tuples, each containing two values:  [timestamp, metric], where the timestamp is in
	// milliseconds from the epoch (1.1.1970), and the metric is a number (according to the unit type)
	Data [][]float64 `json:"data,omitempty"`
	// The parameter by which the timeseries data is grouped
	GroupBy *string `json:"groupBy,omitempty"`
	// Specific information about the timeseries, used to build its name, title etc
	Info []string       `json:"info,omitempty"`
	Key  *TimeseriesKey `json:"key,omitempty"`
	// Indicates the type of the timeseries
	Label string   `json:"label"`
	Sum   *float64 `json:"sum,omitempty"`
	// Identifies what unit of data this timeseries represents. Note that toRate is only available for particular types
	// of data to make sense.
	Units *UnitType `json:"units,omitempty"`
}

type IntFilterInput struct {
	Between []int64 `json:"between,omitempty"`
	Eq      *int64  `json:"eq,omitempty"`
	Gt      *int64  `json:"gt,omitempty"`
	Gte     *int64  `json:"gte,omitempty"`
	In      []int64 `json:"in,omitempty"`
	Lt      *int64  `json:"lt,omitempty"`
	Lte     *int64  `json:"lte,omitempty"`
	Neq     *int64  `json:"neq,omitempty"`
	Nin     []int64 `json:"nin,omitempty"`
}

type IntPredicate struct {
	Eq    *int64  `json:"eq,omitempty"`
	Gt    *int64  `json:"gt,omitempty"`
	Gte   *int64  `json:"gte,omitempty"`
	In    []int64 `json:"in,omitempty"`
	Lt    *int64  `json:"lt,omitempty"`
	Lte   *int64  `json:"lte,omitempty"`
	NotIn []int64 `json:"not_in,omitempty"`
}

// Basic Socket Interface configuration information
type InterfaceInfo struct {
	// The destination type configured to the Socket interface
	DestType *string `json:"destType,omitempty"`
	// Maximum allowed bandwidth for traffic on this port, from the Cato Cloud to the site
	DownstreamBandwidth *int64 `json:"downstreamBandwidth,omitempty"`
	// Maximum allowed bandwidth for traffic on this port in MBPS with single decimal point, from the Cato Cloud to the site
	DownstreamBandwidthMbpsPrecision *float64 `json:"downstreamBandwidthMbpsPrecision,omitempty"`
	// ID for the Socket port in the Socket WebUI Monitor tab
	ID string `json:"id"`
	// Name for the port in the Cato Management Application
	Name *string `json:"name,omitempty"`
	// Maximum allowed bandwidth on this port, for traffic from the site to the Cato Cloud
	UpstreamBandwidth *int64 `json:"upstreamBandwidth,omitempty"`
	// Maximum allowed bandwidth on this port in MBPS with single decimal point, for traffic from the site to the Cato Cloud
	UpstreamBandwidthMbpsPrecision *float64 `json:"upstreamBandwidthMbpsPrecision,omitempty"`
	// Role for the WAN interface
	WanRole *SocketInterfaceWanRole `json:"wanRole,omitempty"`
}

type InterfaceLinkState struct {
	// Shows the duplex mode for the link
	Duplex *string `json:"duplex,omitempty"`
	// Indicates if the WAN interface has an IP address
	HasAddress *bool `json:"hasAddress,omitempty"`
	// Indicates if the interface is connected to the Internet
	HasInternet *bool `json:"hasInternet,omitempty"`
	// Indicates if a connection has been established with the Cato Cloud
	HasTunnel *bool `json:"hasTunnel,omitempty"`
	// The ID for the specific Socket port, for example LAN1 or LAN2
	ID *string `json:"id,omitempty"`
	// Shows the maximum bandwidth configured for the link
	LinkSpeed *string `json:"linkSpeed,omitempty"`
	// Indicates if there is a physical connection to the port
	MediaIn *bool `json:"mediaIn,omitempty"`
	// When this boolean value is true, then the link for the port is up
	Up *bool `json:"up,omitempty"`
}

type InterfaceMetrics struct {
	// Time stamp annotation that shows a time increment for a GUI
	Annotations []*TimeAnnotation `json:"annotations,omitempty"`
	// Basic configuration information about the Socket interface . Applicable only for site
	InterfaceInfo *InterfaceInfo `json:"interfaceInfo,omitempty"`
	// Data related to IPsec sites, such as IKE version . Applicable only for site
	IpsecInfo *IPSecInfo `json:"ipsecInfo,omitempty"`
	// Traffic data for the link
	Metrics *Metrics `json:"metrics,omitempty"`
	// Link name in the Cato Management Application
	Name *string `json:"name,omitempty"`
	// object that is a specific time duration
	Periods []*TimePeriod `json:"periods,omitempty"`
	// IP address the ISP allocates to the WAN link
	RemoteIP *string `json:"remoteIP,omitempty"`
	// Data related to the link IP address, such as country code
	RemoteIPInfo *IPInfo `json:"remoteIPInfo,omitempty"`
	// Data related to Socket and vSocket sites, such as serial number and Socket version. Applicable only for site
	SocketInfo *SocketInfo `json:"socketInfo,omitempty"`
	// For site metrics, timeseries info field will include: siteID, interfaceName, for last mile metrics it will also
	// include the destination last mile check
	Timeseries []*Timeseries `json:"timeseries,omitempty"`
}

type InterfaceSnapshot struct {
	// State of the BGP tunnel to the Cato Cloud
	BgpState *BgpState `json:"bgpState,omitempty"`
	// Information about cellular (LTE) interface
	CellularInterfaceInfo *CellularInterface `json:"cellularInterfaceInfo,omitempty"`
	// Shows if the WAN link is connected to the PoP
	Connected *bool `json:"connected,omitempty"`
	// Interface ID for the WAN link
	ID *string `json:"id,omitempty"`
	// data about the WAN link that is configured in the Socket Configuration window for the site
	Info *InterfaceInfo `json:"info,omitempty"`
	// WAN link name in the Cato Management Application
	Name *string `json:"name,omitempty"`
	// Interface Natural order for WAN link
	NaturalOrder *int64 `json:"naturalOrder,omitempty"`
	// Physical WAN port on the Socket
	PhysicalPort *int64 `json:"physicalPort,omitempty"`
	// The name of the PoP that the WAN link is connected to
	PopName *string `json:"popName,omitempty"`
	// The ID of the PoP that the WAN link was connected to before the current one
	PreviousPopID *int64 `json:"previousPopID,omitempty"`
	// The name of the PoP that the WAN link was connected to before the current one
	PreviousPopName *string `json:"previousPopName,omitempty"`
	// Reason that the tunnel required a new connection (for example, PoP or Socket restarted)
	TunnelConnectionReason *string `json:"tunnelConnectionReason,omitempty"`
	// IP address of the WAN ISP
	TunnelRemoteIP *string `json:"tunnelRemoteIP,omitempty"`
	// IP address, ISP, and geographical information related to the WAN ISP
	TunnelRemoteIPInfo *IPInfo `json:"tunnelRemoteIPInfo,omitempty"`
	// Number of seconds that the tunnel is connected to a PoP
	TunnelUptime *int64  `json:"tunnelUptime,omitempty"`
	Type         *string `json:"type,omitempty"`
}

type InternetFirewallAddRuleDataInput struct {
	// The action applied by the Internet Firewall if the rule is matched
	Action InternetFirewallActionEnum `json:"action"`
	// The time period during which the rule is active, outside this period, the rule is inactive
	ActivePeriod *PolicyRuleActivePeriodInput `json:"activePeriod"`
	// Connection origin of the traffic
	ConnectionOrigin ConnectionOriginEnum `json:"connectionOrigin"`
	// Source country traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Country     []*CountryRefInput `json:"country"`
	Description string             `json:"description"`
	// Destination traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Destination *InternetFirewallDestinationInput `json:"destination"`
	// Source Device Profile traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Device []*DeviceProfileRefInput `json:"device"`
	// Additional device attributes such as category, type, model, and manufacturer.
	// Logical 'OR' is applied within the criteria set.
	// Logical 'AND' is applied between criteria sets.
	DeviceAttributes *DeviceAttributesInput `json:"deviceAttributes"`
	// Source device Operating System traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	DeviceOs []OperatingSystem `json:"deviceOS"`
	Enabled  bool              `json:"enabled"`
	// The set of exceptions for the rule.
	// Exceptions define when the rule will be ignored and the firewall evaluation will continue with the lower priority rules.
	Exceptions []*InternetFirewallRuleExceptionInput `json:"exceptions"`
	Name       string                                `json:"name"`
	// The time period specifying when the rule is enabled, otherwise it is disabled.
	Schedule *PolicyScheduleInput `json:"schedule"`
	// Destination service traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Service *InternetFirewallServiceTypeInput `json:"service,omitempty"`
	// Source traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Source *InternetFirewallSourceInput `json:"source"`
	// Tracking information when the rule is matched, such as events and notifications
	Tracking *PolicyTrackingInput `json:"tracking"`
}

// Rule parameters and relevant position
type InternetFirewallAddRuleInput struct {
	// Position of the rule in the policy
	At *PolicyRulePositionInput `json:"at,omitempty"`
	// Parameters for the rule you are adding
	Rule *InternetFirewallAddRuleDataInput `json:"rule"`
}

type InternetFirewallContainer struct {
	FqdnContainer           []*FqdnContainerRef           `json:"fqdnContainer"`
	IPAddressRangeContainer []*IPAddressRangeContainerRef `json:"ipAddressRangeContainer"`
}

type InternetFirewallContainerInput struct {
	FqdnContainer           []*FqdnContainerRefInput           `json:"fqdnContainer"`
	IPAddressRangeContainer []*IPAddressRangeContainerRefInput `json:"ipAddressRangeContainer"`
}

type InternetFirewallContainerUpdateInput struct {
	FqdnContainer           []*FqdnContainerRefInput           `json:"fqdnContainer,omitempty"`
	IPAddressRangeContainer []*IPAddressRangeContainerRefInput `json:"ipAddressRangeContainer,omitempty"`
}

// Returns the settings for Destination of an Internet Firewall rule
type InternetFirewallDestination struct {
	// Cato category of applications which are dynamically updated by Cato
	AppCategory []*ApplicationCategoryRef `json:"appCategory"`
	// Applications for the rule (pre-defined)
	Application []*ApplicationRef          `json:"application"`
	Containers  *InternetFirewallContainer `json:"containers"`
	// Countries
	Country []*CountryRef `json:"country"`
	// Custom (user-defined) applications
	CustomApp []*CustomApplicationRef `json:"customApp"`
	// Custom Categories – Groups of objects such as predefined and custom applications, predefined and custom services, domains, FQDNs etc.
	CustomCategory []*CustomCategoryRef `json:"customCategory"`
	// A Second-Level Domain (SLD). It matches all Top-Level Domains (TLD), and subdomains that include the Domain. Example: example.com.
	Domain []string `json:"domain"`
	// An exact match of the fully qualified domain (FQDN). Example: www.my.example.com.
	Fqdn []string `json:"fqdn"`
	// Globally defined IP range, IP and subnet objects
	GlobalIPRange []*GlobalIPRangeRef `json:"globalIpRange"`
	// IPv4 addresses
	IP []string `json:"ip"`
	// A range of IPs. Every IP within the range will be matched
	IPRange []*IPAddressRange `json:"ipRange"`
	// Remote Autonomous System Number (ASN)
	RemoteAsn []scalars.Asn16 `json:"remoteAsn"`
	// Sanctioned Cloud Applications - apps that are approved and generally represent an understood and acceptable level of risk in your organization.
	SanctionedAppsCategory []*SanctionedAppsCategoryRef `json:"sanctionedAppsCategory"`
	// Network subnets in CIDR notation
	Subnet []string `json:"subnet"`
}

// Input of the settings for Destination of an Internet Firewall rule. To specify 'ANY' destination, an empty list must be provided for each match criteria field (e.g. application: [], country: [], etc...)
type InternetFirewallDestinationInput struct {
	// Cato category of applications which are dynamically updated by Cato
	AppCategory []*ApplicationCategoryRefInput `json:"appCategory"`
	// Applications for the rule (pre-defined)
	Application []*ApplicationRefInput `json:"application"`
	// Countries
	Country []*CountryRefInput `json:"country"`
	// Custom (user-defined) applications
	CustomApp []*CustomApplicationRefInput `json:"customApp"`
	// Custom Categories – Groups of objects such as predefined and custom applications, predefined and custom services, domains, FQDNs etc.
	CustomCategory []*CustomCategoryRefInput `json:"customCategory"`
	// A Second-Level Domain (SLD). It matches all Top-Level Domains (TLD), and subdomains that include the Domain. Example: example.com.
	Domain []string `json:"domain"`
	// An exact match of the fully qualified domain (FQDN). Example: www.my.example.com.
	Fqdn []string `json:"fqdn"`
	// Globally defined IP range, IP and subnet objects
	GlobalIPRange []*GlobalIPRangeRefInput `json:"globalIpRange"`
	// IPv4 addresses
	IP []string `json:"ip"`
	// A range of IPs. Every IP within the range will be matched
	IPRange []*IPAddressRangeInput `json:"ipRange"`
	// Remote Autonomous System Number (ASN)
	RemoteAsn []scalars.Asn16 `json:"remoteAsn"`
	// Sanctioned Cloud Applications - apps that are approved and generally represent an understood and acceptable level of risk in your organization.
	SanctionedAppsCategory []*SanctionedAppsCategoryRefInput `json:"sanctionedAppsCategory"`
	// Network subnets in CIDR notation
	Subnet []string `json:"subnet"`
}

// Input of the settings for Destination of an Internet Firewall rule. To specify 'ANY' destination, an empty list must be provided for each match criteria field (e.g. application: [], country: [], etc...)
type InternetFirewallDestinationUpdateInput struct {
	// Cato category of applications which are dynamically updated by Cato
	AppCategory []*ApplicationCategoryRefInput `json:"appCategory,omitempty"`
	// Applications for the rule (pre-defined)
	Application []*ApplicationRefInput `json:"application,omitempty"`
	// Countries
	Country []*CountryRefInput `json:"country,omitempty"`
	// Custom (user-defined) applications
	CustomApp []*CustomApplicationRefInput `json:"customApp,omitempty"`
	// Custom Categories – Groups of objects such as predefined and custom applications, predefined and custom services, domains, FQDNs etc.
	CustomCategory []*CustomCategoryRefInput `json:"customCategory,omitempty"`
	// A Second-Level Domain (SLD). It matches all Top-Level Domains (TLD), and subdomains that include the Domain. Example: example.com.
	Domain []string `json:"domain,omitempty"`
	// An exact match of the fully qualified domain (FQDN). Example: www.my.example.com.
	Fqdn []string `json:"fqdn,omitempty"`
	// Globally defined IP range, IP and subnet objects
	GlobalIPRange []*GlobalIPRangeRefInput `json:"globalIpRange,omitempty"`
	// IPv4 addresses
	IP []string `json:"ip,omitempty"`
	// A range of IPs. Every IP within the range will be matched
	IPRange []*IPAddressRangeInput `json:"ipRange,omitempty"`
	// Remote Autonomous System Number (ASN)
	RemoteAsn []scalars.Asn16 `json:"remoteAsn,omitempty"`
	// Sanctioned Cloud Applications - apps that are approved and generally represent an understood and acceptable level of risk in your organization.
	SanctionedAppsCategory []*SanctionedAppsCategoryRefInput `json:"sanctionedAppsCategory,omitempty"`
	// Network subnets in CIDR notation
	Subnet []string `json:"subnet,omitempty"`
}

type InternetFirewallPolicy struct {
	Audit    *PolicyAudit                   `json:"audit,omitempty"`
	Enabled  bool                           `json:"enabled"`
	Revision *PolicyRevision                `json:"revision,omitempty"`
	Rules    []*InternetFirewallRulePayload `json:"rules"`
	Sections []*PolicySectionPayload        `json:"sections"`
}

func (InternetFirewallPolicy) IsIPolicy() {}

// TRUE = Policy is enabled, FALSE = Policy is disabled
func (this InternetFirewallPolicy) GetEnabled() bool { return this.Enabled }

// Return list of rules in the policy
func (this InternetFirewallPolicy) GetRules() []IPolicyRulePayload {
	if this.Rules == nil {
		return nil
	}
	interfaceSlice := make([]IPolicyRulePayload, 0, len(this.Rules))
	for _, concrete := range this.Rules {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

// Return sections in the policy
func (this InternetFirewallPolicy) GetSections() []*PolicySectionPayload {
	if this.Sections == nil {
		return nil
	}
	interfaceSlice := make([]*PolicySectionPayload, 0, len(this.Sections))
	for _, concrete := range this.Sections {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

// Audit data for the policy
func (this InternetFirewallPolicy) GetAudit() *PolicyAudit { return this.Audit }

// Return data for the Policy revision
func (this InternetFirewallPolicy) GetRevision() *PolicyRevision { return this.Revision }

type InternetFirewallPolicyInput struct {
	// A revision is a specific instance of the policy.
	//  Unpublished revisions are working copies of the policy available to a specific
	//  admin or a set of admins
	//  Published revisions are revisions that were applied to the account network.
	//  The last published revision is the active policy.
	Revision *PolicyRevisionInput `json:"revision,omitempty"`
}

type InternetFirewallPolicyMutationInput struct {
	Revision *PolicyMutationRevisionInput `json:"revision,omitempty"`
}

// Internet Firewall policy information provided in the API response
type InternetFirewallPolicyMutationPayload struct {
	Errors []*PolicyMutationError  `json:"errors"`
	Policy *InternetFirewallPolicy `json:"policy,omitempty"`
	Status PolicyMutationStatus    `json:"status"`
}

func (InternetFirewallPolicyMutationPayload) IsIPolicyMutationPayload() {}

// Data for the policy
func (this InternetFirewallPolicyMutationPayload) GetPolicy() IPolicy { return *this.Policy }

// Enum for the status of the policy change
func (this InternetFirewallPolicyMutationPayload) GetStatus() PolicyMutationStatus {
	return this.Status
}

// List of errors related to the policy change
func (this InternetFirewallPolicyMutationPayload) GetErrors() []*PolicyMutationError {
	if this.Errors == nil {
		return nil
	}
	interfaceSlice := make([]*PolicyMutationError, 0, len(this.Errors))
	for _, concrete := range this.Errors {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

// The Internet firewall Policy information returned to the caller in the API response.
type InternetFirewallPolicyMutations struct {
	// Add a new rule to the Internet Firewall policy.
	AddRule *InternetFirewallRuleMutationPayload `json:"addRule"`
	// Add a new section to the policy.
	// First section behaves as follows:
	// When the first section is created,  all the rules in the policy, including the default system rules, are automatically added to it.
	// The first section containing the default system rules can be modified but not deleted.
	// The first section will always remain first-in-policy, i.e. it cannot be moved, and not other sections can be moved or created before it.
	AddSection *PolicySectionMutationPayload `json:"addSection"`
	// Create the policy revision. Create a new empty policy revision.
	CreatePolicyRevision *InternetFirewallPolicyMutationPayload `json:"createPolicyRevision"`
	// Discard the policy revision. All changes in this discarded revision are discarded, and the revision is deleted.
	DiscardPolicyRevision *InternetFirewallPolicyMutationPayload `json:"discardPolicyRevision"`
	// Change the relative location of an existing rule within the Internet Firewall policy.
	MoveRule *InternetFirewallRuleMutationPayload `json:"moveRule"`
	// Move a section to a new position within the policy.
	//  The section will be anchored in the new position, i.e. other admins will not be able to move it, or reference it when moving other sections, until the modified policy revision is published.
	MoveSection *PolicySectionMutationPayload `json:"moveSection"`
	// Publish the policy revision. A published revision becomes the active policy, and its content is merged with all unpublished revisions for other admins.
	PublishPolicyRevision *InternetFirewallPolicyMutationPayload `json:"publishPolicyRevision"`
	// Remove an existing rule from the Internet Firewall policy.
	RemoveRule *InternetFirewallRuleMutationPayload `json:"removeRule"`
	// Delete an existing section. The first section in policy cannot be deleted.
	RemoveSection *PolicySectionMutationPayload `json:"removeSection"`
	// Change the state of the policy, e.g. enable or disable the policy.
	// Applicable to the published policy only. State changes are applied immediately and not as part of publishing a policy revision.
	UpdatePolicy *InternetFirewallPolicyMutationPayload `json:"updatePolicy"`
	// Update an existing rule of the Internet Firewall policy.
	UpdateRule *InternetFirewallRuleMutationPayload `json:"updateRule"`
	// Update policy section attributes
	UpdateSection *PolicySectionMutationPayload `json:"updateSection"`
}

type InternetFirewallPolicyQueries struct {
	Policy    *InternetFirewallPolicy `json:"policy"`
	Revisions *PolicyRevisionsPayload `json:"revisions,omitempty"`
}

type InternetFirewallPolicyUpdateInput struct {
	State *PolicyToggleState `json:"state,omitempty"`
}

type InternetFirewallRemoveRuleInput struct {
	ID string `json:"id"`
}

type InternetFirewallRule struct {
	// The action applied by the Internet Firewall if the rule is matched
	Action InternetFirewallActionEnum `json:"action"`
	// The time period during which the rule is active, outside this period, the rule is inactive
	ActivePeriod *PolicyRuleActivePeriod `json:"activePeriod"`
	// Connection origin of the traffic
	ConnectionOrigin ConnectionOriginEnum `json:"connectionOrigin"`
	// Source country traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Country []*CountryRef `json:"country"`
	// Description for the rule
	Description string `json:"description"`
	// Destination traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Destination *InternetFirewallDestination `json:"destination"`
	// Source Device Profile traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Device []*DeviceProfileRef `json:"device"`
	// Additional device attributes such as category, type, model, and manufacturer.
	// Logical 'OR' is applied within the criteria set.
	// Logical 'AND' is applied between criteria sets.
	DeviceAttributes *DeviceAttributes `json:"deviceAttributes"`
	// Source device Operating System traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	DeviceOs []OperatingSystem `json:"deviceOS"`
	// TRUE = Rule is enabled
	//  FALSE = Rule is disabled
	Enabled bool `json:"enabled"`
	// The set of exceptions for the rule.
	// Exceptions define when the rule will be ignored and the firewall evaluation will continue with the lower priority rules.
	Exceptions []*InternetFirewallRuleException `json:"exceptions"`
	// Rule ID
	ID string `json:"id"`
	// Position / priority of rule
	Index int64 `json:"index"`
	// Name of the rule
	Name string `json:"name"`
	// The time period specifying when the rule is enabled, otherwise it is disabled.
	Schedule *PolicySchedule `json:"schedule"`
	// Policy section where the rule is located
	Section *PolicySectionInfo `json:"section"`
	// Destination service traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Service *InternetFirewallServiceType `json:"service"`
	// Source traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Source *InternetFirewallSource `json:"source"`
	// Tracking information when the rule is matched, such as events and notifications
	Tracking *PolicyTracking `json:"tracking"`
}

func (InternetFirewallRule) IsIPolicyRule() {}

// Rule ID
func (this InternetFirewallRule) GetID() string { return this.ID }

// Name of the rule
func (this InternetFirewallRule) GetName() string { return this.Name }

// Description for the rule
func (this InternetFirewallRule) GetDescription() *string { return &this.Description }

// Position / priority of rule
func (this InternetFirewallRule) GetIndex() int64 { return this.Index }

// TRUE = Rule is enabled, FALSE = Rule is disabled
func (this InternetFirewallRule) GetEnabled() bool { return this.Enabled }

// Policy section where the rule is located
func (this InternetFirewallRule) GetSection() *PolicySectionInfo { return this.Section }

// Exceptions define when a rule is ignored, and the firewall policy evaluation continues with the lower priority rules.
type InternetFirewallRuleException struct {
	// Connection origin matching criteria for the exception.
	ConnectionOrigin ConnectionOriginEnum `json:"connectionOrigin"`
	// Source country matching criteria for the exception.
	Country []*CountryRef `json:"country"`
	// Destination matching criteria for the exception.
	Destination *InternetFirewallDestination `json:"destination"`
	// Source Device Profile matching criteria for the exception.
	Device []*DeviceProfileRef `json:"device"`
	// Source Device Attributes matching criteria for the exception.
	DeviceAttributes *DeviceAttributes `json:"deviceAttributes"`
	// Source device OS matching criteria for the exception.
	DeviceOs []OperatingSystem `json:"deviceOS"`
	// A unique name of the rule exception.
	Name string `json:"name"`
	// Destination service matching criteria for the exception.
	Service *InternetFirewallServiceType `json:"service"`
	// Source traffic matching criteria for the exception.
	Source *InternetFirewallSource `json:"source"`
}

// Exceptions define when a rule is ignored, and the firewall policy evaluation continues with the lower priority rules.
type InternetFirewallRuleExceptionInput struct {
	// Connection origin matching criteria for the exception.
	ConnectionOrigin ConnectionOriginEnum `json:"connectionOrigin"`
	// Source country matching criteria for the exception.
	Country []*CountryRefInput `json:"country"`
	// Destination matching criteria for the exception.
	Destination *InternetFirewallDestinationInput `json:"destination"`
	// Source Device Profile matching criteria for the exception.
	Device []*DeviceProfileRefInput `json:"device"`
	// Source Device Attributes matching criteria for the exception.
	DeviceAttributes *DeviceAttributesInput `json:"deviceAttributes"`
	// Source device OS matching criteria for the exception.
	DeviceOs []OperatingSystem `json:"deviceOS"`
	// A unique name of the rule exception.
	Name string `json:"name"`
	// Destination service matching criteria for the exception.
	Service *InternetFirewallServiceTypeInput `json:"service"`
	// Source traffic matching criteria for the exception.
	Source *InternetFirewallSourceInput `json:"source"`
}

type InternetFirewallRuleMutationPayload struct {
	Errors []*PolicyMutationError       `json:"errors"`
	Rule   *InternetFirewallRulePayload `json:"rule,omitempty"`
	Status PolicyMutationStatus         `json:"status"`
}

func (InternetFirewallRuleMutationPayload) IsIPolicyRuleMutationPayload() {}

// Returns settings for the rule
func (this InternetFirewallRuleMutationPayload) GetRule() IPolicyRulePayload { return *this.Rule }

// Enum for the status of the policy change
func (this InternetFirewallRuleMutationPayload) GetStatus() PolicyMutationStatus { return this.Status }

// List of errors related to the policy change
func (this InternetFirewallRuleMutationPayload) GetErrors() []*PolicyMutationError {
	if this.Errors == nil {
		return nil
	}
	interfaceSlice := make([]*PolicyMutationError, 0, len(this.Errors))
	for _, concrete := range this.Errors {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

// Internet Firewall policy information for a specific revision
type InternetFirewallRulePayload struct {
	Audit      *PolicyElementAudit           `json:"audit"`
	Properties []PolicyElementPropertiesEnum `json:"properties"`
	Rule       *InternetFirewallRule         `json:"rule"`
}

func (InternetFirewallRulePayload) IsIPolicyRulePayload()              {}
func (this InternetFirewallRulePayload) GetAudit() *PolicyElementAudit { return this.Audit }

// Rule that was changed
func (this InternetFirewallRulePayload) GetRule() IPolicyRule { return *this.Rule }

// Summary of rule change, (ie. ADDED, UPDATED)
func (this InternetFirewallRulePayload) GetProperties() []PolicyElementPropertiesEnum {
	if this.Properties == nil {
		return nil
	}
	interfaceSlice := make([]PolicyElementPropertiesEnum, 0, len(this.Properties))
	for _, concrete := range this.Properties {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

// Returns the Service Type to which this Internet Firewall rule applies
type InternetFirewallServiceType struct {
	Custom   []*CustomService `json:"custom"`
	Standard []*ServiceRef    `json:"standard"`
}

// Input of the Service Type to which this Internet Firewall rule applies. To specify 'ANY' source, an empty list must be provided for each match criteria field (e.g. standard: [], custom: [], etc...)
type InternetFirewallServiceTypeInput struct {
	Custom   []*CustomServiceInput `json:"custom"`
	Standard []*ServiceRefInput    `json:"standard"`
}

// Input of the Service Type to which this Internet Firewall rule applies. To specify 'ANY' source, an empty list must be provided for each match criteria field (e.g. standard: [], custom: [], etc...)
type InternetFirewallServiceTypeUpdateInput struct {
	Custom   []*CustomServiceInput `json:"custom,omitempty"`
	Standard []*ServiceRefInput    `json:"standard,omitempty"`
}

// Returns the settings for Source of an Internet Firewall rule
type InternetFirewallSource struct {
	// Floating Subnets (ie. Floating Ranges) are used to identify traffic exactly matched to the route advertised by BGP. They are not associated with a specific site. This is useful in scenarios such as active-standby high availability routed via BGP.
	FloatingSubnet []*FloatingSubnetRef `json:"floatingSubnet"`
	// Globally defined IP range, IP and subnet objects
	GlobalIPRange []*GlobalIPRangeRef `json:"globalIpRange"`
	// Groups defined for your account
	Group []*GroupRef `json:"group"`
	// Hosts and servers defined for your account
	Host []*HostRef `json:"host"`
	// IPv4 address
	IP []string `json:"ip"`
	// Multiple separate IP addresses or an IP range
	IPRange []*IPAddressRange `json:"ipRange"`
	// Network range defined for a site
	NetworkInterface []*NetworkInterfaceRef `json:"networkInterface"`
	// Site defined for the account
	Site []*SiteRef `json:"site"`
	// GlobalRange + InterfaceSubnet
	SiteNetworkSubnet []*SiteNetworkSubnetRef `json:"siteNetworkSubnet"`
	// Subnets and network ranges defined for the LAN interfaces of a site
	Subnet []string `json:"subnet"`
	// Predefined Cato groups
	SystemGroup []*SystemGroupRef `json:"systemGroup"`
	// Individual users defined for the account
	User []*UserRef `json:"user"`
	// Group of users
	UsersGroup []*UsersGroupRef `json:"usersGroup"`
}

// Input of the settings for Source of an Internet Firewall rule. To specify 'ANY' source, an empty list must be provided for each match criteria field (e.g. ip: [], group: [], etc...)
type InternetFirewallSourceInput struct {
	// Floating Subnets (ie. Floating Ranges) are used to identify traffic exactly matched to the route advertised by BGP. They are not associated with a specific site. This is useful in scenarios such as active-standby high availability routed via BGP.
	FloatingSubnet []*FloatingSubnetRefInput `json:"floatingSubnet"`
	// Globally defined IP range, IP and subnet objects
	GlobalIPRange []*GlobalIPRangeRefInput `json:"globalIpRange"`
	// Groups defined for your account
	Group []*GroupRefInput `json:"group"`
	// Hosts and servers defined for your account
	Host []*HostRefInput `json:"host"`
	// IPv4 address
	IP []string `json:"ip"`
	// Multiple separate IP addresses or an IP range
	IPRange []*IPAddressRangeInput `json:"ipRange"`
	// Network range defined for a site
	NetworkInterface []*NetworkInterfaceRefInput `json:"networkInterface"`
	// Site defined for the account
	Site []*SiteRefInput `json:"site"`
	// GlobalRange + InterfaceSubnet
	SiteNetworkSubnet []*SiteNetworkSubnetRefInput `json:"siteNetworkSubnet"`
	// Subnets and network ranges defined for the LAN interfaces of a site
	Subnet []string `json:"subnet"`
	// Predefined Cato groups
	SystemGroup []*SystemGroupRefInput `json:"systemGroup"`
	// Individual users defined for the account
	User []*UserRefInput `json:"user"`
	// Group of users
	UsersGroup []*UsersGroupRefInput `json:"usersGroup"`
}

// Input of the settings for Source of an Internet Firewall rule. To specify 'ANY' source, an empty list must be provided for each match criteria field (e.g. ip: [], group: [], etc...)
type InternetFirewallSourceUpdateInput struct {
	// Floating Subnets (ie. Floating Ranges) are used to identify traffic exactly matched to the route advertised by BGP. They are not associated with a specific site. This is useful in scenarios such as active-standby high availability routed via BGP.
	FloatingSubnet []*FloatingSubnetRefInput `json:"floatingSubnet,omitempty"`
	// Globally defined IP range, IP and subnet objects
	GlobalIPRange []*GlobalIPRangeRefInput `json:"globalIpRange,omitempty"`
	// Groups defined for your account
	Group []*GroupRefInput `json:"group,omitempty"`
	// Hosts and servers defined for your account
	Host []*HostRefInput `json:"host,omitempty"`
	// IPv4 address
	IP []string `json:"ip,omitempty"`
	// Multiple separate IP addresses or an IP range
	IPRange []*IPAddressRangeInput `json:"ipRange,omitempty"`
	// Network range defined for a site
	NetworkInterface []*NetworkInterfaceRefInput `json:"networkInterface,omitempty"`
	// Site defined for the account
	Site []*SiteRefInput `json:"site,omitempty"`
	// GlobalRange + InterfaceSubnet
	SiteNetworkSubnet []*SiteNetworkSubnetRefInput `json:"siteNetworkSubnet,omitempty"`
	// Subnets and network ranges defined for the LAN interfaces of a site
	Subnet []string `json:"subnet,omitempty"`
	// Predefined Cato groups
	SystemGroup []*SystemGroupRefInput `json:"systemGroup,omitempty"`
	// Individual users defined for the account
	User []*UserRefInput `json:"user,omitempty"`
	// Group of users
	UsersGroup []*UsersGroupRefInput `json:"usersGroup,omitempty"`
}

type InternetFirewallUpdateRuleDataInput struct {
	// The action applied by the Internet Firewall if the rule is matched
	Action *InternetFirewallActionEnum `json:"action,omitempty"`
	// The time period during which the rule is active, outside this period, the rule is inactive
	ActivePeriod *PolicyRuleActivePeriodUpdateInput `json:"activePeriod,omitempty"`
	// Connection origin of the traffic
	ConnectionOrigin *ConnectionOriginEnum `json:"connectionOrigin,omitempty"`
	// Source country traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Country     []*CountryRefInput `json:"country,omitempty"`
	Description *string            `json:"description,omitempty"`
	// Destination traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Destination *InternetFirewallDestinationUpdateInput `json:"destination,omitempty"`
	// Source Device Profile traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Device []*DeviceProfileRefInput `json:"device,omitempty"`
	// Additional device attributes such as category, type, model, and manufacturer.
	// Logical 'OR' is applied within the criteria set.
	// Logical 'AND' is applied between criteria sets.
	DeviceAttributes *DeviceAttributesUpdateInput `json:"deviceAttributes,omitempty"`
	// Source device Operating System traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	DeviceOs []OperatingSystem `json:"deviceOS,omitempty"`
	Enabled  *bool             `json:"enabled,omitempty"`
	// The set of exceptions for the rule.
	// Exceptions define when the rule will be ignored and the firewall evaluation will continue with the lower priority rules.
	Exceptions []*InternetFirewallRuleExceptionInput `json:"exceptions,omitempty"`
	Name       *string                               `json:"name,omitempty"`
	// The time period specifying when the rule is enabled, otherwise it is disabled.
	Schedule *PolicyScheduleUpdateInput `json:"schedule,omitempty"`
	// Destination service traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Service *InternetFirewallServiceTypeUpdateInput `json:"service,omitempty"`
	// Source traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Source *InternetFirewallSourceUpdateInput `json:"source,omitempty"`
	// Tracking information when the rule is matched, such as events and notifications
	Tracking *PolicyTrackingUpdateInput `json:"tracking,omitempty"`
}

type InternetFirewallUpdateRuleInput struct {
	ID   string                               `json:"id"`
	Rule *InternetFirewallUpdateRuleDataInput `json:"rule"`
}

// Represents a member type in the group that is not supported in one or more scopes.
// Each scope indicates where the member type is not allowed.
type InvalidGroupMemberTypeInScope struct {
	// List of scopes (policy type and field) where this member type is not supported.
	Scope []*GroupScope `json:"scope"`
	// The unsupported member type (e.g., site, host, etc.)
	Type GroupMemberRefType `json:"type"`
}

// IoT/OT Security service license details
type IotOtLicense struct {
	Description *string `json:"description,omitempty"`
	// License expiration date
	ExpirationDate string `json:"expirationDate"`
	// The unique identifier for the license. If this value is not available, you can contact Cato Support, who may be able to assist in retrieving it.
	ID *string `json:"id,omitempty"`
	// The date of the last update to the license
	LastUpdated *string `json:"lastUpdated,omitempty"`
	// License plan type
	Plan LicensePlan `json:"plan"`
	// The license SKU
	Sku LicenseSku `json:"sku"`
	// License start date
	StartDate *string `json:"startDate,omitempty"`
	// License activation status
	Status LicenseStatus `json:"status"`
}

func (IotOtLicense) IsLicense() {}

// The unique identifier for the license. If this value is not available, you can contact Cato Support, who may be able to assist in retrieving it.
func (this IotOtLicense) GetID() *string          { return this.ID }
func (this IotOtLicense) GetDescription() *string { return this.Description }

// License plan type
func (this IotOtLicense) GetPlan() LicensePlan { return this.Plan }

// The license SKU
func (this IotOtLicense) GetSku() LicenseSku { return this.Sku }

// License activation status
func (this IotOtLicense) GetStatus() LicenseStatus { return this.Status }

// License start date
func (this IotOtLicense) GetStartDate() *string { return this.StartDate }

// License expiration date
func (this IotOtLicense) GetExpirationDate() string { return this.ExpirationDate }

// The date of the last update to the license
func (this IotOtLicense) GetLastUpdated() *string { return this.LastUpdated }

// Inclusive range of IPs
type IPAddressRange struct {
	From string `json:"from"`
	To   string `json:"to"`
}

// A group with members of IPAddressRange type
type IPAddressRangeContainer struct {
	// Audit metadata about the container
	Audit *ContainerAudit `json:"audit"`
	// Description for the container
	Description *string `json:"description,omitempty"`
	// Unique container ID
	ID string `json:"id"`
	// Name for the container
	Name string `json:"name"`
	// Number of items in the container
	Size int64 `json:"size"`
}

func (IPAddressRangeContainer) IsContainer() {}

// Unique container ID
func (this IPAddressRangeContainer) GetID() string { return this.ID }

// Name for the container
func (this IPAddressRangeContainer) GetName() string { return this.Name }

// Description for the container
func (this IPAddressRangeContainer) GetDescription() *string { return this.Description }

// Number of items in the container
func (this IPAddressRangeContainer) GetSize() int64 { return this.Size }

// Audit metadata about the container
func (this IPAddressRangeContainer) GetAudit() *ContainerAudit { return this.Audit }

// Input for adding values to existing IPAddressRange typed container
type IPAddressRangeContainerAddValuesInput struct {
	// Reference to existing container by container ID or container name
	Ref    *ContainerRefInput     `json:"ref"`
	Values []*IPAddressRangeInput `json:"values"`
}

// Payload of AddValues operation on IPAddressRange typed container
type IPAddressRangeContainerAddValuesPayload struct {
	// Container with members of type IPAddressRange
	Container *IPAddressRangeContainer `json:"container"`
}

type IPAddressRangeContainerMutations struct {
	AddValues      *IPAddressRangeContainerAddValuesPayload      `json:"addValues"`
	CreateFromFile *CreateIPAddressRangeContainerFromFilePayload `json:"createFromFile"`
	CreateFromList *CreateIPAddressRangeContainerFromListPayload `json:"createFromList"`
	RemoveValues   *IPAddressRangeContainerRemoveValuesPayload   `json:"removeValues"`
	UpdateFromFile *UpdateIPAddressRangeContainerFromFilePayload `json:"updateFromFile"`
	UpdateFromList *UpdateIPAddressRangeContainerFromListPayload `json:"updateFromList"`
}

type IPAddressRangeContainerQueries struct {
	DownloadFile         *DownloadIPAddressRangeContainerFilePayload         `json:"downloadFile"`
	Search               *IPAddressRangeContainerSearchPayload               `json:"search"`
	SearchIPAddressRange *IPAddressRangeContainerSearchIPAddressRangePayload `json:"searchIpAddressRange"`
}

// A group with members of IPAddressRange type
type IPAddressRangeContainerRef struct {
	// Unique container ID
	ID string `json:"id"`
	// Name for the container
	Name string `json:"name"`
}

func (IPAddressRangeContainerRef) IsObjectRef() {}

// Object's unique identifier
func (this IPAddressRangeContainerRef) GetID() string { return this.ID }

// Object's unique name
func (this IPAddressRangeContainerRef) GetName() string { return this.Name }

type IPAddressRangeContainerRefInput struct {
	// Defines the object identification method – by ID (default) or by name
	By ObjectRefBy `json:"by"`
	// The object identification (ID or name) value
	Input string `json:"input"`
}

// Input for removing values from existing IPAddressRange typed container
type IPAddressRangeContainerRemoveValuesInput struct {
	// Reference to existing container by container ID or container name
	Ref    *ContainerRefInput     `json:"ref"`
	Values []*IPAddressRangeInput `json:"values"`
}

// Payload of AddValues operation on IPAddressRange typed container
type IPAddressRangeContainerRemoveValuesPayload struct {
	// Container with members of type IPAddressRange
	Container *IPAddressRangeContainer `json:"container"`
}

// Filtering input to IPAddressRange container search
type IPAddressRangeContainerSearchInput struct {
	// Reference to existing container by container ID or container name
	Ref *ContainerRefInput `json:"ref"`
}

// Input for searching IPAddressRange typed containers that contain a specific IPAddressRange
type IPAddressRangeContainerSearchIPAddressRangeInput struct {
	IPAddressRange *IPAddressRangeInput `json:"ipAddressRange"`
}

// Payload of IPAddressRange search query
type IPAddressRangeContainerSearchIPAddressRangePayload struct {
	// List of containers with members of type IPAddressRange
	Containers []*IPAddressRangeContainer `json:"containers"`
}

// Payload of IPAddressRange container search
type IPAddressRangeContainerSearchPayload struct {
	// Container with members of type IPAddressRange
	Container *IPAddressRangeContainer `json:"container"`
}

// Inclusive range of IPs
type IPAddressRangeInput struct {
	From string `json:"from"`
	To   string `json:"to"`
}

// Intrusion Prevention System (IPS) service license (Legacy license, replaced by TP)
type IpsLicense struct {
	Description *string `json:"description,omitempty"`
	// License expiration date
	ExpirationDate string `json:"expirationDate"`
	// The unique identifier for the license. If this value is not available, you can contact Cato Support, who may be able to assist in retrieving it.
	ID *string `json:"id,omitempty"`
	// The date of the last update to the license
	LastUpdated *string `json:"lastUpdated,omitempty"`
	// License plan type
	Plan LicensePlan `json:"plan"`
	// The license SKU
	Sku LicenseSku `json:"sku"`
	// License start date
	StartDate *string `json:"startDate,omitempty"`
	// License activation status
	Status LicenseStatus `json:"status"`
}

func (IpsLicense) IsLicense() {}

// The unique identifier for the license. If this value is not available, you can contact Cato Support, who may be able to assist in retrieving it.
func (this IpsLicense) GetID() *string          { return this.ID }
func (this IpsLicense) GetDescription() *string { return this.Description }

// License plan type
func (this IpsLicense) GetPlan() LicensePlan { return this.Plan }

// The license SKU
func (this IpsLicense) GetSku() LicenseSku { return this.Sku }

// License activation status
func (this IpsLicense) GetStatus() LicenseStatus { return this.Status }

// License start date
func (this IpsLicense) GetStartDate() *string { return this.StartDate }

// License expiration date
func (this IpsLicense) GetExpirationDate() string { return this.ExpirationDate }

// The date of the last update to the license
func (this IpsLicense) GetLastUpdated() *string { return this.LastUpdated }

type IpsecIkeV2MessageInput struct {
	// The SA tunnel encryption method. Note: For situations where GCM isn’t supported for the INIT phase, we recommend that you use the CBC algorithm for the INIT phase, and GCM for AUTH
	Cipher *IPSecCipher `json:"cipher,omitempty"`
	// The Diffie-Hellman Group. The first number is the DH-group number, and the second number is the corresponding prime modulus size in bits
	DhGroup *IPSecDHGroup `json:"dhGroup,omitempty"`
	// The algorithm used to verify the integrity and authenticity of IPsec packets
	Integrity *IPSecHash `json:"integrity,omitempty"`
	// The Pseudo-random function (PRF) used to derive the cryptographic keys used in the SA establishment process
	Prf *IPSecHash `json:"prf,omitempty"`
}

type IspLoaFile struct {
	FileHash   *string       `json:"fileHash,omitempty"`
	FileName   *string       `json:"fileName,omitempty"`
	UploadedAt *scalars.Time `json:"uploadedAt,omitempty"`
}

type LastMileBwInput struct {
	// The maximum downstream bandwidth from the Cato Cloud to the site, in Mbps. This value can be used for capping the downstream traffic. It should not be set above the ISP downstream bandwidth or the site license bandwidth.
	Downstream *int64 `json:"downstream,omitempty"`
	// The maximum downstream bandwidth from the Cato Cloud to the site, in Mbps with single decimal precision. This value can be used for capping the downstream traffic. It should not be set above the ISP downstream bandwidth or the site license bandwidth.
	DownstreamMbpsPrecision *float64 `json:"downstreamMbpsPrecision,omitempty"`
	// The maximum upstream bandwidth, in Mbps. The Cato Cloud cannot cap this direction, and this setting is used as a best-effort indication by the Cato Cloud.
	Upstream *int64 `json:"upstream,omitempty"`
	// The maximum upstream bandwidth, in Mbps with single decimal precision. The Cato Cloud cannot cap this direction, and this setting is used as a best-effort indication by the Cato Cloud.
	UpstreamMbpsPrecision *float64 `json:"upstreamMbpsPrecision,omitempty"`
}

// Public license API
type LicensingInfo struct {
	Atp                []*AtpLicense                `json:"atp"`
	Casb               []*CasbLicense               `json:"casb"`
	DataLake           []*DataLakeLicense           `json:"dataLake"`
	Dem                []*DemLicense                `json:"dem"`
	Dlp                []*DlpLicense                `json:"dlp"`
	EndpointProtection []*EndpointProtectionLicense `json:"endpointProtection"`
	// License usage and allocation across the managed accounts
	GlobalLicenseAllocations *GlobalLicenseAllocations `json:"globalLicenseAllocations"`
	Ilmm                     []*IlmmLicense            `json:"ilmm"`
	IotOt                    []*IotOtLicense           `json:"iotOt"`
	Ips                      []*IpsLicense             `json:"ips"`
	// License inventory
	Licenses                 []License                          `json:"licenses"`
	MalwareProtection        []*MalwareProtectionLicense        `json:"malwareProtection"`
	ManagedXdr               []*ManagedXdrLicense               `json:"managedXdr"`
	Mdr                      []*MdrLicense                      `json:"mdr"`
	NextGenMalwareProtection []*NextGenMalwareProtectionLicense `json:"nextGenMalwareProtection"`
	Nocaas                   []*NOCaaSLicense                   `json:"nocaas"`
	PooledBandwidth          []*PooledBandwidthLicense          `json:"pooledBandwidth"`
	PublicIps                []*PublicIpsLicense                `json:"publicIps"`
	Rbi                      []*RbiLicense                      `json:"rbi"`
	SaasSecurityAPI          []*SaasSecurityAPILicense          `json:"saasSecurityApi"`
	Site                     []*SiteLicense                     `json:"site"`
	ThreatPrevention         []*ThreatPreventionLicense         `json:"threatPrevention"`
	XdrPro                   []*XdrProLicense                   `json:"xdrPro"`
	XOps                     []*XOpsLicense                     `json:"xOps"`
	ZtnaUsers                []*ZtnaUsersLicense                `json:"ztnaUsers"`
}

type LicensingMutations struct {
	// BETA
	UpdateCommercialLicense *UpdateCommercialLicensePayload `json:"updateCommercialLicense,omitempty"`
}

type LicensingQueries struct {
	// BETA
	LicensingInfo *LicensingInfo `json:"licensingInfo,omitempty"`
}

type LinkQualityIssue struct {
	Current   *int64                    `json:"current,omitempty"`
	Direction *TrafficDirectionEnum     `json:"direction,omitempty"`
	IssueType *LinkQualityIssueTypeEnum `json:"issueType,omitempty"`
	Threshold *int64                    `json:"threshold,omitempty"`
}

type Location struct {
	// Cma account
	Account *AccountRef `json:"account"`
	// Is archived
	Archived bool `json:"archived"`
	// Audit data
	Audit *AuditingMetadata `json:"audit"`
	// Business unit
	BusinessUnit *string `json:"businessUnit,omitempty"`
	// Location description
	Description *string `json:"description,omitempty"`
	// Location details
	Details *LocationDetails `json:"details"`
	// Location id
	ID string `json:"id"`
	// Location name
	Name string `json:"name"`
	// Location type
	Type LocationType `json:"type"`
}

type LocationDetails struct {
	// Company name (recipient)
	CompanyName *string `json:"companyName,omitempty"`
	// Delivery contact detail
	Contact *ContactDetails `json:"contact,omitempty"`
	// Postal location
	PostalAddress *PostalAddress `json:"postalAddress"`
	// Is shipping location
	ShippingLocation bool `json:"shippingLocation"`
	// Vat id (required for Brazil)
	VatID *string `json:"vatId,omitempty"`
}

type LocationFilterInput struct {
	Account     []*AccountFilter     `json:"account,omitempty"`
	CountryCode []*StringFilterInput `json:"countryCode,omitempty"`
	// Will use contains operator for the provided text on the location fields
	FreeText           *FreeTextFilterInput       `json:"freeText,omitempty"`
	ID                 []*IDFilterInput           `json:"id,omitempty"`
	IncludeArchived    *bool                      `json:"includeArchived,omitempty"`
	IsShippingLocation *bool                      `json:"isShippingLocation,omitempty"`
	Name               []*StringFilterInput       `json:"name,omitempty"`
	Type               []*LocationTypeFilterInput `json:"type,omitempty"`
}

type LocationSortInput struct {
	Country *SortOrderInput `json:"country,omitempty"`
	// Default sort field
	Name *SortOrderInput `json:"name,omitempty"`
	Type *SortOrderInput `json:"type,omitempty"`
}

type LocationTypeFilterInput struct {
	Eq  *LocationType  `json:"eq,omitempty"`
	In  []LocationType `json:"in,omitempty"`
	Neq *LocationType  `json:"neq,omitempty"`
	Nin []LocationType `json:"nin,omitempty"`
}

type LookupFilterInput struct {
	Filter *LookupFilterType `json:"filter,omitempty"`
	Value  *string           `json:"value,omitempty"`
}

type MacAddressFilterInput struct {
	Eq  *string  `json:"eq,omitempty"`
	In  []string `json:"in,omitempty"`
	Neq *string  `json:"neq,omitempty"`
	Nin []string `json:"nin,omitempty"`
}

// Anti-Malware service license details (Legacy license, replaced by TP)
type MalwareProtectionLicense struct {
	Description *string `json:"description,omitempty"`
	// License expiration date
	ExpirationDate string `json:"expirationDate"`
	// The unique identifier for the license. If this value is not available, you can contact Cato Support, who may be able to assist in retrieving it.
	ID *string `json:"id,omitempty"`
	// The date of the last update to the license
	LastUpdated *string `json:"lastUpdated,omitempty"`
	// License plan type
	Plan LicensePlan `json:"plan"`
	// The license SKU
	Sku LicenseSku `json:"sku"`
	// License start date
	StartDate *string `json:"startDate,omitempty"`
	// License activation status
	Status LicenseStatus `json:"status"`
}

func (MalwareProtectionLicense) IsLicense() {}

// The unique identifier for the license. If this value is not available, you can contact Cato Support, who may be able to assist in retrieving it.
func (this MalwareProtectionLicense) GetID() *string          { return this.ID }
func (this MalwareProtectionLicense) GetDescription() *string { return this.Description }

// License plan type
func (this MalwareProtectionLicense) GetPlan() LicensePlan { return this.Plan }

// The license SKU
func (this MalwareProtectionLicense) GetSku() LicenseSku { return this.Sku }

// License activation status
func (this MalwareProtectionLicense) GetStatus() LicenseStatus { return this.Status }

// License start date
func (this MalwareProtectionLicense) GetStartDate() *string { return this.StartDate }

// License expiration date
func (this MalwareProtectionLicense) GetExpirationDate() string { return this.ExpirationDate }

// The date of the last update to the license
func (this MalwareProtectionLicense) GetLastUpdated() *string { return this.LastUpdated }

// Managed XDR service license details
type ManagedXdrLicense struct {
	Description *string `json:"description,omitempty"`
	// License expiration date
	ExpirationDate string `json:"expirationDate"`
	// The unique identifier for the license. If this value is not available, you can contact Cato Support, who may be able to assist in retrieving it.
	ID *string `json:"id,omitempty"`
	// The date of the last update to the license
	LastUpdated *string `json:"lastUpdated,omitempty"`
	// License plan type
	Plan LicensePlan `json:"plan"`
	// The license SKU
	Sku LicenseSku `json:"sku"`
	// License start date
	StartDate *string `json:"startDate,omitempty"`
	// License activation status
	Status LicenseStatus `json:"status"`
}

func (ManagedXdrLicense) IsLicense() {}

// The unique identifier for the license. If this value is not available, you can contact Cato Support, who may be able to assist in retrieving it.
func (this ManagedXdrLicense) GetID() *string          { return this.ID }
func (this ManagedXdrLicense) GetDescription() *string { return this.Description }

// License plan type
func (this ManagedXdrLicense) GetPlan() LicensePlan { return this.Plan }

// The license SKU
func (this ManagedXdrLicense) GetSku() LicenseSku { return this.Sku }

// License activation status
func (this ManagedXdrLicense) GetStatus() LicenseStatus { return this.Status }

// License start date
func (this ManagedXdrLicense) GetStartDate() *string { return this.StartDate }

// License expiration date
func (this ManagedXdrLicense) GetExpirationDate() string { return this.ExpirationDate }

// The date of the last update to the license
func (this ManagedXdrLicense) GetLastUpdated() *string { return this.LastUpdated }

// MDR service license details
type MdrLicense struct {
	Description *string `json:"description,omitempty"`
	// License expiration date
	ExpirationDate string `json:"expirationDate"`
	// The unique identifier for the license. If this value is not available, you can contact Cato Support, who may be able to assist in retrieving it.
	ID *string `json:"id,omitempty"`
	// The date of the last update to the license
	LastUpdated *string `json:"lastUpdated,omitempty"`
	// License plan type
	Plan LicensePlan `json:"plan"`
	// The license SKU
	Sku LicenseSku `json:"sku"`
	// License start date
	StartDate *string `json:"startDate,omitempty"`
	// License activation status
	Status LicenseStatus `json:"status"`
}

func (MdrLicense) IsLicense() {}

// The unique identifier for the license. If this value is not available, you can contact Cato Support, who may be able to assist in retrieving it.
func (this MdrLicense) GetID() *string          { return this.ID }
func (this MdrLicense) GetDescription() *string { return this.Description }

// License plan type
func (this MdrLicense) GetPlan() LicensePlan { return this.Plan }

// The license SKU
func (this MdrLicense) GetSku() LicenseSku { return this.Sku }

// License activation status
func (this MdrLicense) GetStatus() LicenseStatus { return this.Status }

// License start date
func (this MdrLicense) GetStartDate() *string { return this.StartDate }

// License expiration date
func (this MdrLicense) GetExpirationDate() string { return this.ExpirationDate }

// The date of the last update to the license
func (this MdrLicense) GetLastUpdated() *string { return this.LastUpdated }

type Measure struct {
	AggType   AggregationType   `json:"aggType"`
	FieldName AppStatsFieldName `json:"fieldName"`
	Trend     *bool             `json:"trend,omitempty"`
}

type Metric struct {
	Name  string  `json:"name"`
	Value float64 `json:"value"`
}

type MetricDetails struct {
	Name  string `json:"name"`
	Units string `json:"units"`
}

type Metrics struct {
	// total downstream traffic (from the Cato Cloud to the site)
	BytesDownstream *float64 `json:"bytesDownstream,omitempty"`
	// total traffic for the site
	BytesTotal *float64 `json:"bytesTotal,omitempty"`
	// total upstream traffic (from the site to the Cato Cloud)
	BytesUpstream *float64 `json:"bytesUpstream,omitempty"`
	// total amount of time for the site data
	Duration *int64 `json:"duration,omitempty"`
	// The number of flows (connections) in the tunnel. Relevant only for per site Metrics, ignored in per-interface
	// metrics.
	FlowCount *float64 `json:"flowCount,omitempty"`
	// duration in seconds for a single metrics bucket
	Granularity *int64 `json:"granularity,omitempty"`
	// The number of hosts in the tunnel. Relevant only for per site Metrics, ignored in per-interface metrics.
	HostCount *float64 `json:"hostCount,omitempty"`
	// The configurable limit of the number of hosts in the tunnel. Relevant only for per site Metrics, ignored in
	// per-interface metrics.
	HostLimit *float64 `json:"hostLimit,omitempty"`
	// jitter for downstream traffic (difference in time delay in milliseconds (ms) between data packets)
	JitterDownstream *float64 `json:"jitterDownstream,omitempty"`
	// jitter for upstream traffic (difference in time delay in milliseconds (ms) between data packets)
	JitterUpstream *float64 `json:"jitterUpstream,omitempty"`
	// number of packets lost for downstream traffic
	LostDownstream *float64 `json:"lostDownstream,omitempty"`
	// percent of packet loss for downstream traffic
	LostDownstreamPcnt *float64 `json:"lostDownstreamPcnt,omitempty"`
	// number of packets lost for upstream traffic
	LostUpstream *float64 `json:"lostUpstream,omitempty"`
	// percent of packet loss for upstream traffic
	LostUpstreamPcnt *float64 `json:"lostUpstreamPcnt,omitempty"`
	// total packets discarded for downstream traffic
	PacketsDiscardedDownstream *float64 `json:"packetsDiscardedDownstream,omitempty"`
	// total packets discarded for upstream traffic
	PacketsDiscardedUpstream *float64 `json:"packetsDiscardedUpstream,omitempty"`
	// total downstream packets
	PacketsDownstream *float64 `json:"packetsDownstream,omitempty"`
	// total upstream packets
	PacketsUpstream *float64 `json:"packetsUpstream,omitempty"`
	// round-trip time from the site to the Cato Cloud
	Rtt *int64 `json:"rtt,omitempty"`
}

// The `MicrosoftActivity` object represents an activity within Microsoft services, containing fields such as action type, timestamps for the first and last activity, and identifiers for the activity and its associated resources.
type MicrosoftActivity struct {
	Action                *string `json:"action,omitempty"`
	FirstActivityDateTime *string `json:"firstActivityDateTime,omitempty"`
	ID                    string  `json:"id"`
	LastActivityDateTime  *string `json:"lastActivityDateTime,omitempty"`
	ParentResourceID      string  `json:"parentResourceId"`
	ResourceID            string  `json:"resourceId"`
}

func (MicrosoftActivity) IsActivity()                      {}
func (this MicrosoftActivity) GetID() string               { return this.ID }
func (this MicrosoftActivity) GetResourceID() string       { return this.ResourceID }
func (this MicrosoftActivity) GetParentResourceID() string { return this.ParentResourceID }

// The `MicrosoftDefenderEndpointAlert` object represents an alert generated by Microsoft Defender for Endpoint, containing details such as activities, classification, criticality, detection source, and recommended actions, among other attributes, to help in identifying and managing security threats.
type MicrosoftDefenderEndpointAlert struct {
	Activities            []*MicrosoftActivity        `json:"activities"`
	AlertWebURL           *string                     `json:"alertWebUrl,omitempty"`
	Category              *string                     `json:"category,omitempty"`
	Classification        *AlertClassificationEnum    `json:"classification,omitempty"`
	Comments              []string                    `json:"comments"`
	CreatedDateTime       *string                     `json:"createdDateTime,omitempty"`
	Criticality           *int64                      `json:"criticality,omitempty"`
	Description           *string                     `json:"description,omitempty"`
	DestinationIP         *string                     `json:"destinationIp,omitempty"`
	DestinationURL        *string                     `json:"destinationUrl,omitempty"`
	DetectionSource       *DetectionSourceEnum        `json:"detectionSource,omitempty"`
	Determination         *AlertDeterminationEnum     `json:"determination,omitempty"`
	ExternalIP            *string                     `json:"externalIp,omitempty"`
	FirstActivityDateTime *string                     `json:"firstActivityDateTime,omitempty"`
	ID                    string                      `json:"id"`
	LastActivityDateTime  *string                     `json:"lastActivityDateTime,omitempty"`
	LastUpdateDateTime    *string                     `json:"lastUpdateDateTime,omitempty"`
	LocalIP               *string                     `json:"localIp,omitempty"`
	MitreSubTechnique     []*Mitre                    `json:"mitreSubTechnique"`
	MitreTechnique        []*Mitre                    `json:"mitreTechnique"`
	OwnerName             *string                     `json:"ownerName,omitempty"`
	ProviderAlertID       *string                     `json:"providerAlertId,omitempty"`
	RecommendedActions    *string                     `json:"recommendedActions,omitempty"`
	ResolvedDateTime      *string                     `json:"resolvedDateTime,omitempty"`
	Resources             []MicrosoftEndpointResource `json:"resources"`
	Status                *MsAlertStatus              `json:"status,omitempty"`
	ThreatFamilyName      *string                     `json:"threatFamilyName,omitempty"`
	ThreatName            *string                     `json:"threatName,omitempty"`
	ThreatType            *string                     `json:"threatType,omitempty"`
	Title                 *string                     `json:"title,omitempty"`
}

func (MicrosoftDefenderEndpointAlert) IsEndpointAlert()             {}
func (this MicrosoftDefenderEndpointAlert) GetID() string           { return this.ID }
func (this MicrosoftDefenderEndpointAlert) GetTitle() *string       { return this.Title }
func (this MicrosoftDefenderEndpointAlert) GetDescription() *string { return this.Description }
func (this MicrosoftDefenderEndpointAlert) GetThreatName() *string  { return this.ThreatName }
func (this MicrosoftDefenderEndpointAlert) GetMitreTechnique() []*Mitre {
	if this.MitreTechnique == nil {
		return nil
	}
	interfaceSlice := make([]*Mitre, 0, len(this.MitreTechnique))
	for _, concrete := range this.MitreTechnique {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this MicrosoftDefenderEndpointAlert) GetMitreSubTechnique() []*Mitre {
	if this.MitreSubTechnique == nil {
		return nil
	}
	interfaceSlice := make([]*Mitre, 0, len(this.MitreSubTechnique))
	for _, concrete := range this.MitreSubTechnique {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this MicrosoftDefenderEndpointAlert) GetCreatedDateTime() *string { return this.CreatedDateTime }
func (this MicrosoftDefenderEndpointAlert) GetResources() []EndpointResource {
	if this.Resources == nil {
		return nil
	}
	interfaceSlice := make([]EndpointResource, 0, len(this.Resources))
	for _, concrete := range this.Resources {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this MicrosoftDefenderEndpointAlert) GetActivities() []Activity {
	if this.Activities == nil {
		return nil
	}
	interfaceSlice := make([]Activity, 0, len(this.Activities))
	for _, concrete := range this.Activities {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this MicrosoftDefenderEndpointAlert) GetCriticality() *int64 { return this.Criticality }
func (this MicrosoftDefenderEndpointAlert) GetExternalIP() *string { return this.ExternalIP }
func (this MicrosoftDefenderEndpointAlert) GetLocalIP() *string    { return this.LocalIP }

// The `MicrosoftDeviceDetails` object represents detailed information about a Microsoft device, including its antivirus status, Azure AD device ID, device name, first seen date and time, health status, IP interfaces, logged-on users, onboarding status, operating system details, and RBAC group.
type MicrosoftDeviceDetails struct {
	AvStatus          *DeviceAvStatusEnum     `json:"avStatus,omitempty"`
	AzureAdDeviceID   *string                 `json:"azureAdDeviceId,omitempty"`
	DeviceName        *string                 `json:"deviceName,omitempty"`
	ExternalIP        *string                 `json:"externalIp,omitempty"`
	FirstSeenDateTime *string                 `json:"firstSeenDateTime,omitempty"`
	HealthStatus      *DeviceHealthStatusEnum `json:"healthStatus,omitempty"`
	ID                string                  `json:"id"`
	IPInterfaces      []string                `json:"ipInterfaces"`
	LocalIP           *string                 `json:"localIp,omitempty"`
	LoggedOnUsers     []EndpointUser          `json:"loggedOnUsers"`
	OnboardingStatus  *OnboardingStatusEnum   `json:"onboardingStatus,omitempty"`
	OsDetails         *OsDetails              `json:"osDetails,omitempty"`
	RbacGroup         *RbacGroup              `json:"rbacGroup,omitempty"`
}

func (MicrosoftDeviceDetails) IsDeviceDetails()              {}
func (this MicrosoftDeviceDetails) GetID() string            { return this.ID }
func (this MicrosoftDeviceDetails) GetDeviceName() *string   { return this.DeviceName }
func (this MicrosoftDeviceDetails) GetOsDetails() *OsDetails { return this.OsDetails }
func (this MicrosoftDeviceDetails) GetLoggedOnUsers() []EndpointUser {
	if this.LoggedOnUsers == nil {
		return nil
	}
	interfaceSlice := make([]EndpointUser, 0, len(this.LoggedOnUsers))
	for _, concrete := range this.LoggedOnUsers {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this MicrosoftDeviceDetails) GetExternalIP() *string { return this.ExternalIP }
func (this MicrosoftDeviceDetails) GetLocalIP() *string    { return this.LocalIP }

// The `MicrosoftEndpoint` object represents a comprehensive data structure used in GraphQL queries or mutations, containing fields related to security alerts, device details, threat predictions, and other metadata associated with Microsoft's security ecosystem.
type MicrosoftEndpoint struct {
	Alerts              []*MicrosoftDefenderEndpointAlert `json:"alerts"`
	AnalystFeedback     *AnalystFeedback                  `json:"analystFeedback,omitempty"`
	ConnectionType      *ConnectionTypeEnum               `json:"connectionType,omitempty"`
	Criticality         *int64                            `json:"criticality,omitempty"`
	Description         *string                           `json:"description,omitempty"`
	Device              *MicrosoftDeviceDetails           `json:"device,omitempty"`
	EngineType          *StoryEngineTypeEnum              `json:"engineType,omitempty"`
	FirstSignal         string                            `json:"firstSignal"`
	ID                  string                            `json:"id"`
	Indication          string                            `json:"indication"`
	LastSignal          string                            `json:"lastSignal"`
	PredictedThreatType *string                           `json:"predictedThreatType,omitempty"`
	PredictedVerdict    *StoryVerdictEnum                 `json:"predictedVerdict,omitempty"`
	Producer            StoryProducerEnum                 `json:"producer"`
	ProducerName        string                            `json:"producerName"`
	QueryName           *string                           `json:"queryName,omitempty"`
	Research            *bool                             `json:"research,omitempty"`
	SimilarStoriesData  []*SimilarStoryData               `json:"similarStoriesData"`
	Site                *SiteRef                          `json:"site,omitempty"`
	SiteName            *string                           `json:"siteName,omitempty"`
	Source              *string                           `json:"source,omitempty"`
	SourceIP            *string                           `json:"sourceIp,omitempty"`
	Status              *StoryStatusEnum                  `json:"status,omitempty"`
	StoryDuration       *int64                            `json:"storyDuration,omitempty"`
	Ticket              *string                           `json:"ticket,omitempty"`
	User                *UserRef                          `json:"user,omitempty"`
	Vendor              *VendorEnum                       `json:"vendor,omitempty"`
}

func (MicrosoftEndpoint) IsEndpoint() {}

// Unique Cato ID for the story
func (this MicrosoftEndpoint) GetID() string { return this.ID }

// Timestamp for the first incident signal related to this story
func (this MicrosoftEndpoint) GetFirstSignal() string { return this.FirstSignal }

// Timestamp for the last (most recent) incident signal related to this story
func (this MicrosoftEndpoint) GetLastSignal() string { return this.LastSignal }

// XDR engine involved with the incident
func (this MicrosoftEndpoint) GetEngineType() *StoryEngineTypeEnum { return this.EngineType }

// Vendor that identified the incident, such as Cato or Microsoft
func (this MicrosoftEndpoint) GetVendor() *VendorEnum { return this.Vendor }

// Enum for the Producer (specific XDR engine and service) involved with the incident
func (this MicrosoftEndpoint) GetProducer() StoryProducerEnum { return this.Producer }

// Full name of the Producer (specific XDR engine and service) involved with the incident
func (this MicrosoftEndpoint) GetProducerName() string { return this.ProducerName }

// Enum for the connection for this incident (ie. site, host, user)
func (this MicrosoftEndpoint) GetConnectionType() *ConnectionTypeEnum { return this.ConnectionType }

// An indication is a set of actions and behaviors for the Network or Security incident. Each producer has different indications.
func (this MicrosoftEndpoint) GetIndication() string { return this.Indication }

// Category for the indication ID related to the story
func (this MicrosoftEndpoint) GetQueryName() *string { return this.QueryName }

// IP address, name of device, or SDP user on your network involved in the story
func (this MicrosoftEndpoint) GetSource() *string                   { return this.Source }
func (this MicrosoftEndpoint) GetCriticality() *int64               { return this.Criticality }
func (this MicrosoftEndpoint) GetTicket() *string                   { return this.Ticket }
func (this MicrosoftEndpoint) GetStatus() *StoryStatusEnum          { return this.Status }
func (this MicrosoftEndpoint) GetResearch() *bool                   { return this.Research }
func (this MicrosoftEndpoint) GetSiteName() *string                 { return this.SiteName }
func (this MicrosoftEndpoint) GetStoryDuration() *int64             { return this.StoryDuration }
func (this MicrosoftEndpoint) GetDescription() *string              { return this.Description }
func (this MicrosoftEndpoint) GetSourceIP() *string                 { return this.SourceIP }
func (this MicrosoftEndpoint) GetAnalystFeedback() *AnalystFeedback { return this.AnalystFeedback }
func (this MicrosoftEndpoint) GetSite() *SiteRef                    { return this.Site }
func (this MicrosoftEndpoint) GetUser() *UserRef                    { return this.User }
func (this MicrosoftEndpoint) GetSimilarStoriesData() []*SimilarStoryData {
	if this.SimilarStoriesData == nil {
		return nil
	}
	interfaceSlice := make([]*SimilarStoryData, 0, len(this.SimilarStoriesData))
	for _, concrete := range this.SimilarStoriesData {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this MicrosoftEndpoint) GetPredictedVerdict() *StoryVerdictEnum { return this.PredictedVerdict }
func (this MicrosoftEndpoint) GetPredictedThreatType() *string        { return this.PredictedThreatType }
func (this MicrosoftEndpoint) GetDevice() DeviceDetails               { return *this.Device }
func (this MicrosoftEndpoint) GetAlerts() []EndpointAlert {
	if this.Alerts == nil {
		return nil
	}
	interfaceSlice := make([]EndpointAlert, 0, len(this.Alerts))
	for _, concrete := range this.Alerts {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

func (MicrosoftEndpoint) IsMergedIncident() {}

// Unique Cato ID for each story

// Timestamp for the first incident signal related to this story

// Timestamp for the last (most recent) incident signal related to this story

// XDR engine involved with the incident

// Vendor that identified the incident, such as Cato or Microsoft

// Producer (specific XDR engine and service) involved with the incident

// Full name of the Producer (specific XDR engine and service) involved with the incident

// Connection for the incident

// An indication is a set of actions and behaviors for the Network or Security incident. Each producer has different indications.

// Category for the indication ID related to the story

// For Network stories - The potential impact of the issue on your network. Values are from 1 (low impact) to 10 (high impact)
//
// For Security stories - Cato's risk analysis of the story. Values are from 1 (low risk) to 10 (high risk)

// For Network stories - The site where the network issue is occurring
//
// For Security stories - IP address, name of device, or SDP user on your network involved in the story

// The ticket an analyst created for this story

// Status for the story

// The value is TRUE when the story is currently being researched by Security Analysts

// Site name related to the story

// Amount of time since the story was opened (no value for closed stories)

// For Security stories, description of the threat

// The source IP address of the device in your network sending or receiving the flow

// Fields related to analysts research of the threat incident

// Cato ID and name for the site

// Cato ID and name for the user

// The `MicrosoftEndpointUser` object represents a user associated with a Microsoft endpoint, containing fields such as account name, domain name, unique identifier, user name, principal name, and user security identifier.
type MicrosoftEndpointUser struct {
	AccountName   *string `json:"accountName,omitempty"`
	DomainName    *string `json:"domainName,omitempty"`
	ID            string  `json:"id"`
	Name          string  `json:"name"`
	PrincipalName *string `json:"principalName,omitempty"`
	UserSid       *string `json:"userSid,omitempty"`
}

func (MicrosoftEndpointUser) IsEndpointUser()      {}
func (this MicrosoftEndpointUser) GetID() string   { return this.ID }
func (this MicrosoftEndpointUser) GetName() string { return this.Name }

// The `MicrosoftFileResource` object represents a file resource in a Microsoft system, containing fields such as creation date, detection and remediation status, file details, unique identifier, roles, tags, and a verdict on the file's status.
type MicrosoftFileResource struct {
	CreatedDateTime          *string                `json:"createdDateTime,omitempty"`
	DetectionStatus          *DetectionStatusEnum   `json:"detectionStatus,omitempty"`
	FileDetails              *FileDetails           `json:"fileDetails,omitempty"`
	ID                       string                 `json:"id"`
	RemediationStatus        *RemediationStatusEnum `json:"remediationStatus,omitempty"`
	RemediationStatusDetails *string                `json:"remediationStatusDetails,omitempty"`
	Roles                    []ResourceRoleEnum     `json:"roles"`
	Tags                     []string               `json:"tags"`
	Verdict                  *MsResourceVerdictEnum `json:"verdict,omitempty"`
}

func (MicrosoftFileResource) IsEndpointResource()              {}
func (this MicrosoftFileResource) GetID() string               { return this.ID }
func (this MicrosoftFileResource) GetCreatedDateTime() *string { return this.CreatedDateTime }
func (this MicrosoftFileResource) GetRemediationStatus() *RemediationStatusEnum {
	return this.RemediationStatus
}

func (MicrosoftFileResource) IsFileResource() {}

func (this MicrosoftFileResource) GetFileDetails() *FileDetails { return this.FileDetails }
func (this MicrosoftFileResource) GetDetectionStatus() *DetectionStatusEnum {
	return this.DetectionStatus
}

func (MicrosoftFileResource) IsMicrosoftEndpointResource() {}

func (this MicrosoftFileResource) GetRemediationStatusDetails() *string {
	return this.RemediationStatusDetails
}
func (this MicrosoftFileResource) GetTags() []string {
	if this.Tags == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.Tags))
	for _, concrete := range this.Tags {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this MicrosoftFileResource) GetRoles() []ResourceRoleEnum {
	if this.Roles == nil {
		return nil
	}
	interfaceSlice := make([]ResourceRoleEnum, 0, len(this.Roles))
	for _, concrete := range this.Roles {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this MicrosoftFileResource) GetVerdict() *MsResourceVerdictEnum { return this.Verdict }

// The `MicrosoftNetworkResource` object represents a registry resource in a Microsoft environment, containing fields such as creation date, remediation status, roles, tags, and verdict, which are used to manage and assess the resource's status and attributes.
type MicrosoftNetworkResource struct {
	Action                   *string                `json:"action,omitempty"`
	CreatedDateTime          *string                `json:"createdDateTime,omitempty"`
	DestinationIP            *string                `json:"destinationIp,omitempty"`
	DestinationPort          *int64                 `json:"destinationPort,omitempty"`
	DNSRequest               *string                `json:"dnsRequest,omitempty"`
	DNSResponse              *string                `json:"dnsResponse,omitempty"`
	ID                       string                 `json:"id"`
	Method                   *string                `json:"method,omitempty"`
	RemediationStatus        *RemediationStatusEnum `json:"remediationStatus,omitempty"`
	RemediationStatusDetails *string                `json:"remediationStatusDetails,omitempty"`
	Roles                    []ResourceRoleEnum     `json:"roles"`
	SourcePort               *int64                 `json:"sourcePort,omitempty"`
	Tags                     []string               `json:"tags"`
	URL                      *string                `json:"url,omitempty"`
	Verdict                  *MsResourceVerdictEnum `json:"verdict,omitempty"`
}

func (MicrosoftNetworkResource) IsEndpointResource()              {}
func (this MicrosoftNetworkResource) GetID() string               { return this.ID }
func (this MicrosoftNetworkResource) GetCreatedDateTime() *string { return this.CreatedDateTime }
func (this MicrosoftNetworkResource) GetRemediationStatus() *RemediationStatusEnum {
	return this.RemediationStatus
}

func (MicrosoftNetworkResource) IsMicrosoftEndpointResource() {}

func (this MicrosoftNetworkResource) GetRemediationStatusDetails() *string {
	return this.RemediationStatusDetails
}
func (this MicrosoftNetworkResource) GetTags() []string {
	if this.Tags == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.Tags))
	for _, concrete := range this.Tags {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this MicrosoftNetworkResource) GetRoles() []ResourceRoleEnum {
	if this.Roles == nil {
		return nil
	}
	interfaceSlice := make([]ResourceRoleEnum, 0, len(this.Roles))
	for _, concrete := range this.Roles {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this MicrosoftNetworkResource) GetVerdict() *MsResourceVerdictEnum { return this.Verdict }

func (MicrosoftNetworkResource) IsNetworkResource() {}

func (this MicrosoftNetworkResource) GetDNSRequest() *string     { return this.DNSRequest }
func (this MicrosoftNetworkResource) GetDNSResponse() *string    { return this.DNSResponse }
func (this MicrosoftNetworkResource) GetDestinationIP() *string  { return this.DestinationIP }
func (this MicrosoftNetworkResource) GetDestinationPort() *int64 { return this.DestinationPort }
func (this MicrosoftNetworkResource) GetSourcePort() *int64      { return this.SourcePort }
func (this MicrosoftNetworkResource) GetURL() *string            { return this.URL }
func (this MicrosoftNetworkResource) GetMethod() *string         { return this.Method }

// The `MicrosoftProcessResource` object represents a process resource in a Microsoft environment, containing fields such as creation date, process ID, command line details, remediation status, roles, tags, user account information, and a verdict on the process's nature.
type MicrosoftProcessResource struct {
	Action                   *string                `json:"action,omitempty"`
	CreatedDateTime          *string                `json:"createdDateTime,omitempty"`
	ID                       string                 `json:"id"`
	ImageFile                *FileDetails           `json:"imageFile,omitempty"`
	ProcessCommandLine       *string                `json:"processCommandLine,omitempty"`
	ProcessID                int64                  `json:"processId"`
	RemediationStatus        *RemediationStatusEnum `json:"remediationStatus,omitempty"`
	RemediationStatusDetails *string                `json:"remediationStatusDetails,omitempty"`
	Roles                    []ResourceRoleEnum     `json:"roles"`
	Tags                     []string               `json:"tags"`
	UserAccount              EndpointUser           `json:"userAccount,omitempty"`
	Verdict                  *MsResourceVerdictEnum `json:"verdict,omitempty"`
}

func (MicrosoftProcessResource) IsEndpointResource()              {}
func (this MicrosoftProcessResource) GetID() string               { return this.ID }
func (this MicrosoftProcessResource) GetCreatedDateTime() *string { return this.CreatedDateTime }
func (this MicrosoftProcessResource) GetRemediationStatus() *RemediationStatusEnum {
	return this.RemediationStatus
}

func (MicrosoftProcessResource) IsMicrosoftEndpointResource() {}

func (this MicrosoftProcessResource) GetRemediationStatusDetails() *string {
	return this.RemediationStatusDetails
}
func (this MicrosoftProcessResource) GetTags() []string {
	if this.Tags == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.Tags))
	for _, concrete := range this.Tags {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this MicrosoftProcessResource) GetRoles() []ResourceRoleEnum {
	if this.Roles == nil {
		return nil
	}
	interfaceSlice := make([]ResourceRoleEnum, 0, len(this.Roles))
	for _, concrete := range this.Roles {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this MicrosoftProcessResource) GetVerdict() *MsResourceVerdictEnum { return this.Verdict }

func (MicrosoftProcessResource) IsProcessResource() {}

func (this MicrosoftProcessResource) GetProcessID() int64            { return this.ProcessID }
func (this MicrosoftProcessResource) GetProcessCommandLine() *string { return this.ProcessCommandLine }
func (this MicrosoftProcessResource) GetImageFile() *FileDetails     { return this.ImageFile }
func (this MicrosoftProcessResource) GetUserAccount() EndpointUser   { return this.UserAccount }

// The `MicrosoftRegistryResource` object represents a registry resource in a Microsoft environment, containing fields such as creation date, hive, key, remediation status, roles, tags, and verdict, which are used to manage and assess the resource's status and attributes.
type MicrosoftRegistryResource struct {
	CreatedDateTime          *string                `json:"createdDateTime,omitempty"`
	Hive                     *string                `json:"hive,omitempty"`
	ID                       string                 `json:"id"`
	Key                      *string                `json:"key,omitempty"`
	RemediationStatus        *RemediationStatusEnum `json:"remediationStatus,omitempty"`
	RemediationStatusDetails *string                `json:"remediationStatusDetails,omitempty"`
	Roles                    []ResourceRoleEnum     `json:"roles"`
	Tags                     []string               `json:"tags"`
	Value                    *string                `json:"value,omitempty"`
	ValueName                *string                `json:"valueName,omitempty"`
	ValueType                *string                `json:"valueType,omitempty"`
	Verdict                  *MsResourceVerdictEnum `json:"verdict,omitempty"`
}

func (MicrosoftRegistryResource) IsEndpointResource()              {}
func (this MicrosoftRegistryResource) GetID() string               { return this.ID }
func (this MicrosoftRegistryResource) GetCreatedDateTime() *string { return this.CreatedDateTime }
func (this MicrosoftRegistryResource) GetRemediationStatus() *RemediationStatusEnum {
	return this.RemediationStatus
}

func (MicrosoftRegistryResource) IsMicrosoftEndpointResource() {}

func (this MicrosoftRegistryResource) GetRemediationStatusDetails() *string {
	return this.RemediationStatusDetails
}
func (this MicrosoftRegistryResource) GetTags() []string {
	if this.Tags == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.Tags))
	for _, concrete := range this.Tags {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this MicrosoftRegistryResource) GetRoles() []ResourceRoleEnum {
	if this.Roles == nil {
		return nil
	}
	interfaceSlice := make([]ResourceRoleEnum, 0, len(this.Roles))
	for _, concrete := range this.Roles {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this MicrosoftRegistryResource) GetVerdict() *MsResourceVerdictEnum { return this.Verdict }

func (MicrosoftRegistryResource) IsRegistryResource() {}

func (this MicrosoftRegistryResource) GetHive() *string      { return this.Hive }
func (this MicrosoftRegistryResource) GetKey() *string       { return this.Key }
func (this MicrosoftRegistryResource) GetValue() *string     { return this.Value }
func (this MicrosoftRegistryResource) GetValueName() *string { return this.ValueName }
func (this MicrosoftRegistryResource) GetValueType() *string { return this.ValueType }

type Mitre struct {
	ID   *string `json:"id,omitempty"`
	Name *string `json:"name,omitempty"`
}

type Mutation struct {
}

// NOC as a Service (NOCaaS) service license details
type NOCaaSLicense struct {
	Description *string `json:"description,omitempty"`
	// License expiration date
	ExpirationDate string `json:"expirationDate"`
	// The unique identifier for the license. If this value is not available, you can contact Cato Support, who may be able to assist in retrieving it.
	ID *string `json:"id,omitempty"`
	// The date of the last update to the license
	LastUpdated *string `json:"lastUpdated,omitempty"`
	// License plan type
	Plan LicensePlan `json:"plan"`
	// The license SKU
	Sku LicenseSku `json:"sku"`
	// License start date
	StartDate *string `json:"startDate,omitempty"`
	// License activation status
	Status LicenseStatus `json:"status"`
}

func (NOCaaSLicense) IsLicense() {}

// The unique identifier for the license. If this value is not available, you can contact Cato Support, who may be able to assist in retrieving it.
func (this NOCaaSLicense) GetID() *string          { return this.ID }
func (this NOCaaSLicense) GetDescription() *string { return this.Description }

// License plan type
func (this NOCaaSLicense) GetPlan() LicensePlan { return this.Plan }

// The license SKU
func (this NOCaaSLicense) GetSku() LicenseSku { return this.Sku }

// License activation status
func (this NOCaaSLicense) GetStatus() LicenseStatus { return this.Status }

// License start date
func (this NOCaaSLicense) GetStartDate() *string { return this.StartDate }

// License expiration date
func (this NOCaaSLicense) GetExpirationDate() string { return this.ExpirationDate }

// The date of the last update to the license
func (this NOCaaSLicense) GetLastUpdated() *string { return this.LastUpdated }

type NetworkDhcpSettingsInput struct {
	// Only relevant for DHCP range
	DhcpMicrosegmentation *bool    `json:"dhcpMicrosegmentation,omitempty"`
	DhcpType              DhcpType `json:"dhcpType"`
	IPRange               *string  `json:"ipRange,omitempty"`
	RelayGroupID          *string  `json:"relayGroupId,omitempty"`
}

// A reference identifying the NetworkInterface object. ID: Unique NetworkInterface Identifier, Name: The NetworkInterface Name
type NetworkInterfaceRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (NetworkInterfaceRef) IsObjectRef() {}

// Object's unique identifier
func (this NetworkInterfaceRef) GetID() string { return this.ID }

// Object's unique name
func (this NetworkInterfaceRef) GetName() string { return this.Name }

type NetworkInterfaceRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

type NetworkTimelineEvent struct {
	Acknowledged         *bool                     `json:"acknowledged,omitempty"`
	BgpConnection        *BGPConnection            `json:"bgpConnection,omitempty"`
	Created              string                    `json:"created"`
	Description          *string                   `json:"description,omitempty"`
	DeviceConfigHaRole   *DeviceConfigHaRoleEnum   `json:"deviceConfigHaRole,omitempty"`
	DeviceHaRoleState    *DeviceHaRoleStateEnum    `json:"deviceHaRoleState,omitempty"`
	EventIds             []string                  `json:"eventIds"`
	EventType            *NetworkXDREventTypeEnum  `json:"eventType,omitempty"`
	HostIP               *string                   `json:"hostIp,omitempty"`
	IncidentID           *string                   `json:"incidentId,omitempty"`
	Isp                  *string                   `json:"isp,omitempty"`
	LinkConfigBandwidth  *string                   `json:"linkConfigBandwidth,omitempty"`
	LinkConfigPrecedence *LinkConfigPrecedenceEnum `json:"linkConfigPrecedence,omitempty"`
	LinkID               *string                   `json:"linkId,omitempty"`
	LinkName             *string                   `json:"linkName,omitempty"`
	LinkQualityIssue     *LinkQualityIssue         `json:"linkQualityIssue,omitempty"`
	LinkStatus           *LinkStatusEnum           `json:"linkStatus,omitempty"`
	Muted                *bool                     `json:"muted,omitempty"`
	NetworkEventSource   *NetworkEventSourceEnum   `json:"networkEventSource,omitempty"`
	Pop                  *string                   `json:"pop,omitempty"`
	RuleName             *string                   `json:"ruleName,omitempty"`
	SocketSerialID       *string                   `json:"socketSerialId,omitempty"`
	TunnelResetCount     *int64                    `json:"tunnelResetCount,omitempty"`
	Validated            string                    `json:"validated"`
}

// The `NetworkXDRIncident` object represents a detailed incident report within a network, containing various fields such as incident ID, description, criticality, timeline events, and associated metadata like connection type, site information, and predicted threat type, used for analyzing and managing network security incidents.
type NetworkXDRIncident struct {
	Acknowledged            *bool                     `json:"acknowledged,omitempty"`
	AnalystFeedback         *AnalystFeedback          `json:"analystFeedback,omitempty"`
	BgpConnection           *BGPConnection            `json:"bgpConnection,omitempty"`
	ConnectionType          *ConnectionTypeEnum       `json:"connectionType,omitempty"`
	Criticality             *int64                    `json:"criticality,omitempty"`
	Description             *string                   `json:"description,omitempty"`
	DeviceConfigHaRole      *DeviceConfigHaRoleEnum   `json:"deviceConfigHaRole,omitempty"`
	EngineType              *StoryEngineTypeEnum      `json:"engineType,omitempty"`
	FirstSignal             string                    `json:"firstSignal"`
	HostIP                  *string                   `json:"hostIp,omitempty"`
	ID                      string                    `json:"id"`
	IlmmDetails             *IlmmDetails              `json:"ilmmDetails,omitempty"`
	Indication              string                    `json:"indication"`
	Isp                     *string                   `json:"isp,omitempty"`
	LastSignal              string                    `json:"lastSignal"`
	LicenseBandwidth        *string                   `json:"licenseBandwidth,omitempty"`
	LicenseRegion           *string                   `json:"licenseRegion,omitempty"`
	LinkConfigPrecedence    *LinkConfigPrecedenceEnum `json:"linkConfigPrecedence,omitempty"`
	LinkID                  *string                   `json:"linkId,omitempty"`
	LinkName                *string                   `json:"linkName,omitempty"`
	Muted                   *bool                     `json:"muted,omitempty"`
	NetworkIncidentTimeline []*NetworkTimelineEvent   `json:"networkIncidentTimeline"`
	Occurrences             *int64                    `json:"occurrences,omitempty"`
	Pop                     *string                   `json:"pop,omitempty"`
	PredictedThreatType     *string                   `json:"predictedThreatType,omitempty"`
	PredictedVerdict        *StoryVerdictEnum         `json:"predictedVerdict,omitempty"`
	Producer                StoryProducerEnum         `json:"producer"`
	ProducerName            string                    `json:"producerName"`
	QueryName               *string                   `json:"queryName,omitempty"`
	Research                *bool                     `json:"research,omitempty"`
	RuleName                *string                   `json:"ruleName,omitempty"`
	SimilarStoriesData      []*SimilarStoryData       `json:"similarStoriesData"`
	Site                    *SiteRef                  `json:"site,omitempty"`
	SiteConfigLocation      *string                   `json:"siteConfigLocation,omitempty"`
	SiteConnectionType      *string                   `json:"siteConnectionType,omitempty"`
	SiteName                string                    `json:"siteName"`
	Source                  *string                   `json:"source,omitempty"`
	SourceIP                *string                   `json:"sourceIp,omitempty"`
	Status                  *StoryStatusEnum          `json:"status,omitempty"`
	StoryDuration           *int64                    `json:"storyDuration,omitempty"`
	StoryType               string                    `json:"storyType"`
	Ticket                  *string                   `json:"ticket,omitempty"`
	User                    *UserRef                  `json:"user,omitempty"`
	Vendor                  *VendorEnum               `json:"vendor,omitempty"`
}

func (NetworkXDRIncident) IsMergedIncident() {}

// Unique Cato ID for each story
func (this NetworkXDRIncident) GetID() string { return this.ID }

// Timestamp for the first incident signal related to this story
func (this NetworkXDRIncident) GetFirstSignal() string { return this.FirstSignal }

// Timestamp for the last (most recent) incident signal related to this story
func (this NetworkXDRIncident) GetLastSignal() string { return this.LastSignal }

// XDR engine involved with the incident
func (this NetworkXDRIncident) GetEngineType() *StoryEngineTypeEnum { return this.EngineType }

// Vendor that identified the incident, such as Cato or Microsoft
func (this NetworkXDRIncident) GetVendor() *VendorEnum { return this.Vendor }

// Producer (specific XDR engine and service) involved with the incident
func (this NetworkXDRIncident) GetProducer() StoryProducerEnum { return this.Producer }

// Full name of the Producer (specific XDR engine and service) involved with the incident
func (this NetworkXDRIncident) GetProducerName() string { return this.ProducerName }

// Connection for the incident
func (this NetworkXDRIncident) GetConnectionType() *ConnectionTypeEnum { return this.ConnectionType }

// An indication is a set of actions and behaviors for the Network or Security incident. Each producer has different indications.
func (this NetworkXDRIncident) GetIndication() string { return this.Indication }

// Category for the indication ID related to the story
func (this NetworkXDRIncident) GetQueryName() *string { return this.QueryName }

// For Network stories - The potential impact of the issue on your network. Values are from 1 (low impact) to 10 (high impact)
//
// For Security stories - Cato's risk analysis of the story. Values are from 1 (low risk) to 10 (high risk)
func (this NetworkXDRIncident) GetCriticality() *int64 { return this.Criticality }

// For Network stories - The site where the network issue is occurring
//
// For Security stories - IP address, name of device, or SDP user on your network involved in the story
func (this NetworkXDRIncident) GetSource() *string { return this.Source }

// The ticket an analyst created for this story
func (this NetworkXDRIncident) GetTicket() *string { return this.Ticket }

// Status for the story
func (this NetworkXDRIncident) GetStatus() *StoryStatusEnum { return this.Status }

// The value is TRUE when the story is currently being researched by Security Analysts
func (this NetworkXDRIncident) GetResearch() *bool { return this.Research }

// Site name related to the story
func (this NetworkXDRIncident) GetSiteName() *string { return &this.SiteName }

// Amount of time since the story was opened (no value for closed stories)
func (this NetworkXDRIncident) GetStoryDuration() *int64 { return this.StoryDuration }

// For Security stories, description of the threat
func (this NetworkXDRIncident) GetDescription() *string { return this.Description }

// The source IP address of the device in your network sending or receiving the flow
func (this NetworkXDRIncident) GetSourceIP() *string { return this.SourceIP }

// Fields related to analysts research of the threat incident
func (this NetworkXDRIncident) GetAnalystFeedback() *AnalystFeedback { return this.AnalystFeedback }

// Cato ID and name for the site
func (this NetworkXDRIncident) GetSite() *SiteRef { return this.Site }

// Cato ID and name for the user
func (this NetworkXDRIncident) GetUser() *UserRef                      { return this.User }
func (this NetworkXDRIncident) GetPredictedVerdict() *StoryVerdictEnum { return this.PredictedVerdict }
func (this NetworkXDRIncident) GetPredictedThreatType() *string        { return this.PredictedThreatType }

// NG Anti-Malware service license details (Legacy license, replaced by TP)
type NextGenMalwareProtectionLicense struct {
	Description *string `json:"description,omitempty"`
	// License expiration date
	ExpirationDate string `json:"expirationDate"`
	// The unique identifier for the license. If this value is not available, you can contact Cato Support, who may be able to assist in retrieving it.
	ID *string `json:"id,omitempty"`
	// The date of the last update to the license
	LastUpdated *string `json:"lastUpdated,omitempty"`
	// License plan type
	Plan LicensePlan `json:"plan"`
	// The license SKU
	Sku LicenseSku `json:"sku"`
	// License start date
	StartDate *string `json:"startDate,omitempty"`
	// License activation status
	Status LicenseStatus `json:"status"`
}

func (NextGenMalwareProtectionLicense) IsLicense() {}

// The unique identifier for the license. If this value is not available, you can contact Cato Support, who may be able to assist in retrieving it.
func (this NextGenMalwareProtectionLicense) GetID() *string          { return this.ID }
func (this NextGenMalwareProtectionLicense) GetDescription() *string { return this.Description }

// License plan type
func (this NextGenMalwareProtectionLicense) GetPlan() LicensePlan { return this.Plan }

// The license SKU
func (this NextGenMalwareProtectionLicense) GetSku() LicenseSku { return this.Sku }

// License activation status
func (this NextGenMalwareProtectionLicense) GetStatus() LicenseStatus { return this.Status }

// License start date
func (this NextGenMalwareProtectionLicense) GetStartDate() *string { return this.StartDate }

// License expiration date
func (this NextGenMalwareProtectionLicense) GetExpirationDate() string { return this.ExpirationDate }

// The date of the last update to the license
func (this NextGenMalwareProtectionLicense) GetLastUpdated() *string { return this.LastUpdated }

type OriginTypeFilterInput struct {
	// Has all - include devices that have all specified origin types
	HasAll []OriginType `json:"hasAll,omitempty"`
	// In - include devices that have any of the specified origin types
	In []OriginType `json:"in,omitempty"`
	// Not in - exclude devices that have any of the specified origin types
	Nin []OriginType `json:"nin,omitempty"`
}

type OsDetails struct {
	OsBuild   *int64  `json:"osBuild,omitempty"`
	OsType    string  `json:"osType"`
	OsVersion *string `json:"osVersion,omitempty"`
}

type PageInfo struct {
	Total int64 `json:"total"`
}

type Paging struct {
	// Based on the filter and sort parameters, the first story that is returned
	From int64 `json:"from"`
	// Based on the filter and sort parameters, the number of stories returned after the from. For example, the argument {from: 10, limit: 10} returns stories 10-20.
	Limit int64 `json:"limit"`
	// Total number of stories returned
	Total int64 `json:"total"`
}

type PagingInput struct {
	From  int64 `json:"from"`
	Limit int64 `json:"limit"`
}

type PartnerPooledBandwidthLicenseAccount struct {
	// Identifying data for the account
	Account *AccountRef `json:"account"`
	// Allocated bandwidth for this account
	AllocatedBandwidth int64 `json:"allocatedBandwidth"`
}

// Represents available versions for a specific platform.
type PlatformVersions struct {
	// The platform for which versions are retrieved.
	Platform string `json:"platform"`
	// List of available socket versions for this platform.
	Versions []string `json:"versions"`
}

// Input for adding section info to a policy
type PolicyAddSectionInfoInput struct {
	Name string `json:"name"`
}

// Input for adding a section to a policy
type PolicyAddSectionInput struct {
	At      *PolicySectionPositionInput `json:"at"`
	Section *PolicyAddSectionInfoInput  `json:"section"`
}

type PolicyAudit struct {
	PublishedBy   string `json:"publishedBy"`
	PublishedTime string `json:"publishedTime"`
}

type PolicyCreateRevisionInput struct {
	Description string `json:"description"`
	Name        string `json:"name"`
}

// Returns data for a custom recurring time range that a rule is active
type PolicyCustomRecurring struct {
	Days []DayOfWeek  `json:"days"`
	From scalars.Time `json:"from"`
	To   scalars.Time `json:"to"`
}

// Input of data for a custom recurring time range that a rule is active
type PolicyCustomRecurringInput struct {
	Days []DayOfWeek  `json:"days"`
	From scalars.Time `json:"from"`
	To   scalars.Time `json:"to"`
}

// Input of data for a custom recurring time range that a rule is active
type PolicyCustomRecurringUpdateInput struct {
	Days []DayOfWeek   `json:"days,omitempty"`
	From *scalars.Time `json:"from,omitempty"`
	To   *scalars.Time `json:"to,omitempty"`
}

// Returns data for a custom one-time time range that a rule is active
type PolicyCustomTimeframe struct {
	From string `json:"from"`
	To   string `json:"to"`
}

// Input of data for a custom one-time time range that a rule is active
type PolicyCustomTimeframeInput struct {
	From string `json:"from"`
	To   string `json:"to"`
}

// Input of data for a custom one-time time range that a rule is active
type PolicyCustomTimeframeUpdateInput struct {
	From *string `json:"from,omitempty"`
	To   *string `json:"to,omitempty"`
}

// Discards unpublished revision for the policy and reverts to the settings for the published policy.
type PolicyDiscardRevisionInput struct {
	ID *string `json:"id,omitempty"`
}

type PolicyElementAudit struct {
	// The admin, or the API-key, that performed the last update
	UpdatedBy string `json:"updatedBy"`
	// The last date and time the rule was updated
	UpdatedTime string `json:"updatedTime"`
}

// Move the rule to a different position in the policy
type PolicyMoveRuleInput struct {
	ID string                   `json:"id"`
	To *PolicyRulePositionInput `json:"to,omitempty"`
}

// Input for moving a section within a policy
type PolicyMoveSectionInput struct {
	ID string                      `json:"id"`
	To *PolicySectionPositionInput `json:"to,omitempty"`
}

// Move the sub rule to a different position in the policy
type PolicyMoveSubRuleInput struct {
	ID string                      `json:"id"`
	To *PolicySubRulePositionInput `json:"to"`
}

// The `PolicyMutationError` enum defines various error messages related to policy publishing in the policy platform service.
//
// ## Policy Errors
//
// ### `ConcurrentPolicyPublish`
// - **Error Message:** "Another policy is currently publishing"
//
// ### `PolicyRevisionMismatch`
// - **Error Message:** "Revision is not owned by the admin"
//
// ### `PolicyRevisionNotFound`
// - **Error Message:** "Revision was not found"
//
// ### `PolicyInvalidEntity`
// - **Error Message:** "Invalid entity"
//
// ### `DuplicateRuleName`
// - **Error Message:** "Rule with the same name already exists"
//
// ### `DuplicateSectionName`
// - **Error Message:** "Section with the same name already exists"
//
// ### `PolicyFailure`
// - **Error Message:** "Can’t publish policy due to an internal error. Please try again in a few minutes"
//
// ## Rule Errors
//
// ### `ruleIsLocked`
// - **Error Message:** "Rule is locked by another revision"
//
// ### `ruleWasRemoved`
// - **Error Message:** "Rule was already removed"
//
// ### `ruleNotExist`
// - **Error Message:** "Rule does not exist"
//
// ### `ruleSectionNotExist`
// - **Error Message:** "Section does not exist"
//
// ### `ruleSectionIsLocked`
// - **Error Message:** "Section is locked by another revision"
//
// ### `rulePositionInvalid`
// - **Error Message:** "Rule position is invalid"
//
// ### `ruleNameIsEmpty`
// - **Error Message:** "Rule name can't be empty"
//
// ### `ruleNameAlreadyExists`
// - **Error Message:** "Rule with the same name already exists"
//
// ### `ruleSystemModification`
// - **Error Message:** "Can't modify a system rule"
//
// ### `ruleSystemMove`
// - **Error Message:** "Can't add a rule above the system rules"
//
// ### `ruleHasInvalidEntity`
// - **Error Message:** "Rule has an invalid entity"
//
// ### `failedValidatingRule`
// - **Error Message:** "Something went wrong, couldn't validate rule"
//
// ## Section Errors
//
// ### `sectionIsLocked`
// - **Error Message:** "Section is locked by another revision"
//
// ### `sectionSystemMove`
// - **Error Message:** "Section with system rules cannot be moved or removed"
//
// ### `sectionNotExist`
// - **Error Message:** "Section does not exist"
//
// ### `sectionPositionInvalid`
// - **Error Message:** "Section position is invalid"
type PolicyMutationError struct {
	ErrorCode    *string `json:"errorCode,omitempty"`
	ErrorMessage *string `json:"errorMessage,omitempty"`
}

type PolicyMutationRevisionInput struct {
	ID *string `json:"id,omitempty"`
}

type PolicyMutations struct {
	AntiMalwareFileHash  *AntiMalwareFileHashPolicyMutations  `json:"antiMalwareFileHash,omitempty"`
	ApplicationControl   *ApplicationControlPolicyMutations   `json:"applicationControl,omitempty"`
	AppTenantRestriction *AppTenantRestrictionPolicyMutations `json:"appTenantRestriction,omitempty"`
	DynamicIPAllocation  *DynamicIPAllocationPolicyMutations  `json:"dynamicIpAllocation,omitempty"`
	InternetFirewall     *InternetFirewallPolicyMutations     `json:"internetFirewall,omitempty"`
	RemotePortFwd        *RemotePortFwdPolicyMutations        `json:"remotePortFwd,omitempty"`
	SocketLan            *SocketLanPolicyMutations            `json:"socketLan,omitempty"`
	TerminalServer       *TerminalServerPolicyMutations       `json:"terminalServer,omitempty"`
	TLSInspect           *TLSInspectPolicyMutations           `json:"tlsInspect,omitempty"`
	WanFirewall          *WanFirewallPolicyMutations          `json:"wanFirewall,omitempty"`
	WanNetwork           *WanNetworkPolicyMutations           `json:"wanNetwork,omitempty"`
}

// Published revision is the active policy
// applied on the traffic.
// In addition, when a policy is published, revision changes become visible
// to other admins, and rules locked by the revision become unlocked
type PolicyPublishRevisionInput struct {
	Description *string `json:"description,omitempty"`
	Name        *string `json:"name,omitempty"`
}

// policies which configuration can be read with query APIs.
type PolicyQueries struct {
	AntiMalwareFileHash  *AntiMalwareFileHashPolicyQueries  `json:"antiMalwareFileHash,omitempty"`
	ApplicationControl   *ApplicationControlPolicyQueries   `json:"applicationControl,omitempty"`
	AppTenantRestriction *AppTenantRestrictionPolicyQueries `json:"appTenantRestriction,omitempty"`
	DynamicIPAllocation  *DynamicIPAllocationPolicyQueries  `json:"dynamicIpAllocation,omitempty"`
	InternetFirewall     *InternetFirewallPolicyQueries     `json:"internetFirewall,omitempty"`
	RemotePortFwd        *RemotePortFwdPolicyQueries        `json:"remotePortFwd,omitempty"`
	SocketLan            *SocketLanPolicyQueries            `json:"socketLan,omitempty"`
	TerminalServer       *TerminalServerPolicyQueries       `json:"terminalServer,omitempty"`
	TLSInspect           *TLSInspectPolicyQueries           `json:"tlsInspect,omitempty"`
	WanFirewall          *WanFirewallPolicyQueries          `json:"wanFirewall,omitempty"`
	WanNetwork           *WanNetworkPolicyQueries           `json:"wanNetwork,omitempty"`
}

// Input for removing a section from a policy
type PolicyRemoveSectionInput struct {
	ID string `json:"id"`
}

// Returns data about the policy revision, such as when the change was made, how many rules were changed, etc.
type PolicyRevision struct {
	Changes     int64  `json:"changes"`
	CreatedTime string `json:"createdTime"`
	Description string `json:"description"`
	ID          string `json:"id"`
	Name        string `json:"name"`
	UpdatedTime string `json:"updatedTime"`
}

// Input for specifying a policy revision
type PolicyRevisionInput struct {
	ID   *string             `json:"id,omitempty"`
	Type *PolicyRevisionType `json:"type,omitempty"`
}

// Returns data for publishing the policy
type PolicyRevisionsPayload struct {
	Revision []*PolicyRevision `json:"revision"`
}

// Returns the time period during which the rule is active, outside this period, the rule is inactive
type PolicyRuleActivePeriod struct {
	// The time the rule becomes active, if not used, default null
	EffectiveFrom *string `json:"effectiveFrom,omitempty"`
	// The time the rule expires, if not used, default null
	ExpiresAt        *string `json:"expiresAt,omitempty"`
	UseEffectiveFrom bool    `json:"useEffectiveFrom"`
	UseExpiresAt     bool    `json:"useExpiresAt"`
}

// Input of the time period during which the rule is active, outside this period, the rule is inactive
type PolicyRuleActivePeriodInput struct {
	// The time the rule becomes active, if not used, default null
	EffectiveFrom *string `json:"effectiveFrom,omitempty"`
	// The time the rule expires, if not used, default null
	ExpiresAt        *string `json:"expiresAt,omitempty"`
	UseEffectiveFrom bool    `json:"useEffectiveFrom"`
	UseExpiresAt     bool    `json:"useExpiresAt"`
}

// Input of the time period during which the rule is active, outside this period, the rule is inactive
type PolicyRuleActivePeriodUpdateInput struct {
	// The time the rule becomes active, if not used, default null
	EffectiveFrom *string `json:"effectiveFrom,omitempty"`
	// The time the rule expires, if not used, default null
	ExpiresAt        *string `json:"expiresAt,omitempty"`
	UseEffectiveFrom *bool   `json:"useEffectiveFrom,omitempty"`
	UseExpiresAt     *bool   `json:"useExpiresAt,omitempty"`
}

// Parameters required to define the rule position
type PolicyRulePositionInput struct {
	// Position relative to a policy, a section or another rule
	Position *PolicyRulePositionEnum `json:"position,omitempty"`
	// The identifier of the object (e.g. a rule, a section) relative to which the position of the added rule is defined
	Ref *string `json:"ref,omitempty"`
}

// Returns data for the alert settings for the rule
type PolicyRuleTrackingAlert struct {
	// TRUE – send alerts when the rule is matched, FALSE – don’t send alerts when the rule is matched
	Enabled bool `json:"enabled"`
	// Returns data for the alert frequency
	Frequency PolicyRuleTrackingFrequencyEnum `json:"frequency"`
	// Returns data for the Mailing List that receives the alert
	MailingList []*SubscriptionMailingListRef `json:"mailingList"`
	// Returns data for the Subscription Group that receives the alert
	SubscriptionGroup []*SubscriptionGroupRef `json:"subscriptionGroup"`
	// Returns data for the Webhook that receives the alert
	Webhook []*SubscriptionWebhookRef `json:"webhook"`
}

// Input of data for the alert settings for the rule
type PolicyRuleTrackingAlertInput struct {
	// TRUE – send alerts when the rule is matched, FALSE – don’t send alerts when the rule is matched
	Enabled bool `json:"enabled"`
	// Returns data for the alert frequency
	Frequency PolicyRuleTrackingFrequencyEnum `json:"frequency"`
	// Returns data for the Mailing List that receives the alert
	MailingList []*SubscriptionMailingListRefInput `json:"mailingList"`
	// Returns data for the Subscription Group that receives the alert
	SubscriptionGroup []*SubscriptionGroupRefInput `json:"subscriptionGroup"`
	// Returns data for the Webhook that receives the alert
	Webhook []*SubscriptionWebhookRefInput `json:"webhook"`
}

// Input of data for the alert settings for the rule
type PolicyRuleTrackingAlertUpdateInput struct {
	// TRUE – send alerts when the rule is matched, FALSE – don’t send alerts when the rule is matched
	Enabled *bool `json:"enabled,omitempty"`
	// Returns data for the alert frequency
	Frequency *PolicyRuleTrackingFrequencyEnum `json:"frequency,omitempty"`
	// Returns data for the Mailing List that receives the alert
	MailingList []*SubscriptionMailingListRefInput `json:"mailingList,omitempty"`
	// Returns data for the Subscription Group that receives the alert
	SubscriptionGroup []*SubscriptionGroupRefInput `json:"subscriptionGroup,omitempty"`
	// Returns data for the Webhook that receives the alert
	Webhook []*SubscriptionWebhookRefInput `json:"webhook,omitempty"`
}

// Returns data if an alert is sent for a rule
type PolicyRuleTrackingEvent struct {
	Enabled bool `json:"enabled"`
}

// Input of data if an alert is sent for a rule
type PolicyRuleTrackingEventInput struct {
	Enabled bool `json:"enabled"`
}

// Input of data if an alert is sent for a rule
type PolicyRuleTrackingEventUpdateInput struct {
	Enabled *bool `json:"enabled,omitempty"`
}

type PolicySchedule struct {
	ActiveOn        PolicyActiveOnEnum     `json:"activeOn"`
	CustomRecurring *PolicyCustomRecurring `json:"customRecurring,omitempty"`
	CustomTimeframe *PolicyCustomTimeframe `json:"customTimeframe,omitempty"`
}

type PolicyScheduleInput struct {
	ActiveOn        PolicyActiveOnEnum          `json:"activeOn"`
	CustomRecurring *PolicyCustomRecurringInput `json:"customRecurring,omitempty"`
	CustomTimeframe *PolicyCustomTimeframeInput `json:"customTimeframe,omitempty"`
}

type PolicyScheduleUpdateInput struct {
	ActiveOn        *PolicyActiveOnEnum               `json:"activeOn,omitempty"`
	CustomRecurring *PolicyCustomRecurringUpdateInput `json:"customRecurring,omitempty"`
	CustomTimeframe *PolicyCustomTimeframeUpdateInput `json:"customTimeframe,omitempty"`
}

// Define settings for a policy section
type PolicySectionInfo struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

type PolicySectionMutationPayload struct {
	Errors  []*PolicyMutationError `json:"errors"`
	Section *PolicySectionPayload  `json:"section,omitempty"`
	Status  PolicyMutationStatus   `json:"status"`
}

type PolicySectionPayload struct {
	Audit      *PolicyElementAudit           `json:"audit"`
	Properties []PolicyElementPropertiesEnum `json:"properties"`
	Section    *PolicySectionInfo            `json:"section"`
}

type PolicySectionPositionInput struct {
	Position PolicySectionPositionEnum `json:"position"`
	Ref      *string                   `json:"ref,omitempty"`
}

// Parameters required to define the rule position
type PolicySubRulePositionInput struct {
	// Position relative to a policy, a section or another rule
	Position PolicySubRulePositionEnum `json:"position"`
	// The identifier of the sub-rule relative to which the position of the added rule is defined
	Ref string `json:"ref"`
}

type PolicyTracking struct {
	Alert *PolicyRuleTrackingAlert `json:"alert"`
	Event *PolicyRuleTrackingEvent `json:"event"`
}

type PolicyTrackingInput struct {
	Alert *PolicyRuleTrackingAlertInput `json:"alert"`
	Event *PolicyRuleTrackingEventInput `json:"event"`
}

type PolicyTrackingUpdateInput struct {
	Alert *PolicyRuleTrackingAlertUpdateInput `json:"alert,omitempty"`
	Event *PolicyRuleTrackingEventUpdateInput `json:"event,omitempty"`
}

type PolicyUpdateSectionInfoInput struct {
	Name *string `json:"name,omitempty"`
}

type PolicyUpdateSectionInput struct {
	ID      string                        `json:"id"`
	Section *PolicyUpdateSectionInfoInput `json:"section"`
}

type PooledBandwidthLicense struct {
	// Accounts that this license is assigned to (and the license usage within each account)
	Accounts []*PartnerPooledBandwidthLicenseAccount `json:"accounts"`
	// allocated bandwidth, in Mbps, for all the sites assigned to this license.
	AllocatedBandwidth int64   `json:"allocatedBandwidth"`
	Description        *string `json:"description,omitempty"`
	// License expiration date
	ExpirationDate string `json:"expirationDate"`
	// The unique identifier for the license. If this value is not available, you can contact Cato Support, who may be able to assist in retrieving it.
	ID *string `json:"id,omitempty"`
	// The date of the last update to the license
	LastUpdated *string `json:"lastUpdated,omitempty"`
	// License plan type
	Plan LicensePlan `json:"plan"`
	// Regional license group
	SiteLicenseGroup SiteLicenseGroup `json:"siteLicenseGroup"`
	// The selected service type, e.g SASE or SSE.
	SiteLicenseType SiteLicenseType `json:"siteLicenseType"`
	// Sites that this license is assigned to (and the license usage within each site)
	Sites []*PooledBandwidthLicenseSite `json:"sites"`
	// The license SKU
	Sku LicenseSku `json:"sku"`
	// License start date
	StartDate *string `json:"startDate,omitempty"`
	// License activation status
	Status LicenseStatus `json:"status"`
	// Maximum available bandwidth, in Mbps, for all the sites under this license. This constitutes the bandwidth pool that is allocated to different sites.
	Total int64 `json:"total"`
}

func (PooledBandwidthLicense) IsLicense() {}

// The unique identifier for the license. If this value is not available, you can contact Cato Support, who may be able to assist in retrieving it.
func (this PooledBandwidthLicense) GetID() *string          { return this.ID }
func (this PooledBandwidthLicense) GetDescription() *string { return this.Description }

// License plan type
func (this PooledBandwidthLicense) GetPlan() LicensePlan { return this.Plan }

// The license SKU
func (this PooledBandwidthLicense) GetSku() LicenseSku { return this.Sku }

// License activation status
func (this PooledBandwidthLicense) GetStatus() LicenseStatus { return this.Status }

// License start date
func (this PooledBandwidthLicense) GetStartDate() *string { return this.StartDate }

// License expiration date
func (this PooledBandwidthLicense) GetExpirationDate() string { return this.ExpirationDate }

// The date of the last update to the license
func (this PooledBandwidthLicense) GetLastUpdated() *string { return this.LastUpdated }

func (PooledBandwidthLicense) IsQuantifiableLicense() {}

// The unique identifier for the license. If this value is not available, you can contact Cato Support, who may be able to assist in retrieving it.

// License plan type

// The license SKU

// License activation status

// License initiation date

// License expiration date

// The date of the last update to the license

// license quantity
func (this PooledBandwidthLicense) GetTotal() int64 { return this.Total }

type PooledBandwidthLicenseSite struct {
	// Allocated bandwidth for this site
	AllocatedBandwidth int64 `json:"allocatedBandwidth"`
	// Identifying data for the site
	Site *SiteRef `json:"site"`
}

type PopLocation struct {
	// Lists the available cloud interconnect options (e.g., AWS Direct Connect, Azure ExpressRoute) at this PoP.
	// Each entry in the list is a PopLocationCloudInterconnect object describing interconnect capabilities.
	CloudInterconnect []*PopLocationCloudInterconnect `json:"cloudInterconnect"`
	// Reference to the country where the PoP resides. Links to a CountryRef object that may contain name, ISO code, or additional geopolitical metadata
	Country *CountryRef `json:"country"`
	// User-facing name of the PoP (e.g., for dashboards or UI displays). Often formatted for readability
	DisplayName string `json:"displayName"`
	// Unique identifier for the PoP location. Globally unique across the Cato platform
	ID string `json:"id"`
	// indicates whether the PoP is a private location (customer-owned or dedicated) as opposed to part of the public/shared Cato cloud
	IsPrivate bool `json:"isPrivate"`
	// Internal name of the PoP location, used for system-level identification. Usually the city of the PoP
	Name string `json:"name"`
}

type PopLocationCloudInterconnect struct {
	ProviderName  string        `json:"providerName"`
	TaggingMethod TaggingMethod `json:"taggingMethod"`
}

type PopLocationCloudInterconnectFilterInput struct {
	TaggingMethod *TaggingMethodFilterInput `json:"taggingMethod,omitempty"`
}

type PopLocationFilterInput struct {
	// Filters PoPs based on their geographical country. Useful for regional filtering or compliance.
	Country *CountryRefFilterInput `json:"country,omitempty"`
	// PoP location's unique identifier (ID).
	ID *IDFilterInput `json:"id,omitempty"`
	// Filter by setting - cloud interconnect tags (e.g.,1Q or QinQ).
	InterconnectTagging *PopLocationCloudInterconnectFilterInput `json:"interconnectTagging,omitempty"`
	// Filters based on whether a PoP is private or public and a part of the Cato Cloud (public or reserved for a specific partner/customer).
	IsPrivate *BooleanFilterInput `json:"isPrivate,omitempty"`
	// Filter by name of the PoP Location, usually represented by the city.
	Name *StringFilterInput `json:"name,omitempty"`
	// Filters for PoPs marked as “primary,” likely signifying main or preferred locations in a geographic area.
	Primary *BooleanFilterInput `json:"primary,omitempty"`
	// Filters PoPs based on regional licensing rules or designations, possibly aligning with regional compliance or pricing.
	SiteLicenseRegion *StringFilterInput `json:"siteLicenseRegion,omitempty"`
}

type PopLocationPayload struct {
	// The actual list of PoP locations matching the given filter criteria. Each entry is a non-null PopLocation object.
	Items []*PopLocation `json:"items"`
}

type PopLocationQueries struct {
	PopLocationList *PopLocationPayload `json:"popLocationList,omitempty"`
}

// A reference identifying the PopLocation object. ID: Unique PopLocation Identifier, Name: The PopLocation Name
type PopLocationRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (PopLocationRef) IsObjectRef() {}

// Object's unique identifier
func (this PopLocationRef) GetID() string { return this.ID }

// Object's unique name
func (this PopLocationRef) GetName() string { return this.Name }

type PopLocationRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

// Inclusive network port range
type PortRange struct {
	From scalars.Port `json:"from"`
	To   scalars.Port `json:"to"`
}

// Inclusive network port range
type PortRangeInput struct {
	From scalars.Port `json:"from"`
	To   scalars.Port `json:"to"`
}

type PortRangeUpdateInput struct {
	From *scalars.Port `json:"from,omitempty"`
	To   *scalars.Port `json:"to,omitempty"`
}

type PostalAddress struct {
	// Address validation status
	AddressValidated AddressValidationStatus `json:"addressValidated"`
	// City
	CityName *string `json:"cityName,omitempty"`
	// Country
	Country *CountryRef `json:"country"`
	// State (only for USA)
	StateName *string `json:"stateName,omitempty"`
	// Street name and number
	Street *string `json:"street,omitempty"`
	// Zip Code
	ZipCode *string `json:"zipCode,omitempty"`
}

type PostalAddressInput struct {
	// City
	CityName *string `json:"cityName,omitempty"`
	// Country
	Country *CountryRefInput `json:"country"`
	// State (only for USA)
	StateName *string `json:"stateName,omitempty"`
	// Street name and number
	Street *string `json:"street,omitempty"`
	// Zip Code
	ZipCode *string `json:"zipCode,omitempty"`
}

// Public IP address license
type PublicIpsLicense struct {
	Description *string `json:"description,omitempty"`
	// License expiration date
	ExpirationDate string `json:"expirationDate"`
	// The unique identifier for the license. If this value is not available, you can contact Cato Support, who may be able to assist in retrieving it.
	ID *string `json:"id,omitempty"`
	// The date of the last update to the license
	LastUpdated *string `json:"lastUpdated,omitempty"`
	// License plan type
	Plan LicensePlan `json:"plan"`
	// The license SKU
	Sku LicenseSku `json:"sku"`
	// License start date
	StartDate *string `json:"startDate,omitempty"`
	// License activation status
	Status LicenseStatus `json:"status"`
	// The number of public IPs available in the licenses
	Total int64 `json:"total"`
}

func (PublicIpsLicense) IsLicense() {}

// The unique identifier for the license. If this value is not available, you can contact Cato Support, who may be able to assist in retrieving it.
func (this PublicIpsLicense) GetID() *string          { return this.ID }
func (this PublicIpsLicense) GetDescription() *string { return this.Description }

// License plan type
func (this PublicIpsLicense) GetPlan() LicensePlan { return this.Plan }

// The license SKU
func (this PublicIpsLicense) GetSku() LicenseSku { return this.Sku }

// License activation status
func (this PublicIpsLicense) GetStatus() LicenseStatus { return this.Status }

// License start date
func (this PublicIpsLicense) GetStartDate() *string { return this.StartDate }

// License expiration date
func (this PublicIpsLicense) GetExpirationDate() string { return this.ExpirationDate }

// The date of the last update to the license
func (this PublicIpsLicense) GetLastUpdated() *string { return this.LastUpdated }

func (PublicIpsLicense) IsQuantifiableLicense() {}

// The unique identifier for the license. If this value is not available, you can contact Cato Support, who may be able to assist in retrieving it.

// License plan type

// The license SKU

// License activation status

// License initiation date

// License expiration date

// The date of the last update to the license

// license quantity
func (this PublicIpsLicense) GetTotal() int64 { return this.Total }

// IP addresses license usage and allocation across all accounts
type PublicIpsLicenseAllocations struct {
	Allocated int64 `json:"allocated"`
	Available int64 `json:"available"`
	Total     int64 `json:"total"`
}

type Query struct {
}

type RBACRole struct {
	Description  *string `json:"description,omitempty"`
	ID           string  `json:"id"`
	IsPredefined bool    `json:"isPredefined"`
	Name         string  `json:"name"`
}

type RbacGroup struct {
	ID   string  `json:"id"`
	Name *string `json:"name,omitempty"`
}

// Remote Browser Isolation (RBI) service license details
type RbiLicense struct {
	Description *string `json:"description,omitempty"`
	// License expiration date
	ExpirationDate string `json:"expirationDate"`
	// The unique identifier for the license. If this value is not available, you can contact Cato Support, who may be able to assist in retrieving it.
	ID *string `json:"id,omitempty"`
	// The date of the last update to the license
	LastUpdated *string `json:"lastUpdated,omitempty"`
	// License plan type
	Plan LicensePlan `json:"plan"`
	// The license SKU
	Sku LicenseSku `json:"sku"`
	// License start date
	StartDate *string `json:"startDate,omitempty"`
	// License activation status
	Status LicenseStatus `json:"status"`
}

func (RbiLicense) IsLicense() {}

// The unique identifier for the license. If this value is not available, you can contact Cato Support, who may be able to assist in retrieving it.
func (this RbiLicense) GetID() *string          { return this.ID }
func (this RbiLicense) GetDescription() *string { return this.Description }

// License plan type
func (this RbiLicense) GetPlan() LicensePlan { return this.Plan }

// The license SKU
func (this RbiLicense) GetSku() LicenseSku { return this.Sku }

// License activation status
func (this RbiLicense) GetStatus() LicenseStatus { return this.Status }

// License start date
func (this RbiLicense) GetStartDate() *string { return this.StartDate }

// License expiration date
func (this RbiLicense) GetExpirationDate() string { return this.ExpirationDate }

// The date of the last update to the license
func (this RbiLicense) GetLastUpdated() *string { return this.LastUpdated }

type RecentConnection struct {
	// Serial number for the Device
	DeviceName *string `json:"deviceName,omitempty"`
	// The duration of the connection
	Duration *int64 `json:"duration,omitempty"`
	// Name for the port in the Cato Management Application
	InterfaceName *string `json:"interfaceName,omitempty"`
	// The last time this connection was detected (so lastConnected - duration is the start of the connection
	LastConnected *string `json:"lastConnected,omitempty"`
	// The name of the PoP that the traffic flow was connected to
	PopName *string `json:"popName,omitempty"`
	// IP address the ISP allocates to the WAN link
	RemoteIP *string `json:"remoteIP,omitempty"`
	// IP address, ISP, and geographical information related to the PoP that the traffic flow was connected to
	RemoteIPInfo *IPInfo `json:"remoteIPInfo,omitempty"`
}

type RemotePortFwdAddRuleDataInput struct {
	Description       string                        `json:"description"`
	Enabled           bool                          `json:"enabled"`
	ExternalIP        *AllocatedIPRefInput          `json:"externalIp"`
	ExternalPortRange *PortRangeInput               `json:"externalPortRange"`
	ForwardICMP       bool                          `json:"forwardIcmp"`
	InternalIP        string                        `json:"internalIp"`
	InternalPortRange *PortRangeInput               `json:"internalPortRange"`
	Name              string                        `json:"name"`
	RemoteIPs         *RemotePortFwdRemoteIpsInput  `json:"remoteIPs"`
	RestrictionType   RemotePortFwdRestrictionType  `json:"restrictionType"`
	Tracking          *PolicyRuleTrackingAlertInput `json:"tracking"`
}

// Rule parameters and relevant position
type RemotePortFwdAddRuleInput struct {
	// Position of the rule in the policy
	At *PolicyRulePositionInput `json:"at,omitempty"`
	// Parameters for the rule you are adding
	Rule *RemotePortFwdAddRuleDataInput `json:"rule"`
}

type RemotePortFwdPolicy struct {
	Audit    *PolicyAudit                `json:"audit,omitempty"`
	Enabled  bool                        `json:"enabled"`
	Revision *PolicyRevision             `json:"revision,omitempty"`
	Rules    []*RemotePortFwdRulePayload `json:"rules"`
	Sections []*PolicySectionPayload     `json:"sections"`
}

func (RemotePortFwdPolicy) IsIPolicy() {}

// TRUE = Policy is enabled, FALSE = Policy is disabled
func (this RemotePortFwdPolicy) GetEnabled() bool { return this.Enabled }

// Return list of rules in the policy
func (this RemotePortFwdPolicy) GetRules() []IPolicyRulePayload {
	if this.Rules == nil {
		return nil
	}
	interfaceSlice := make([]IPolicyRulePayload, 0, len(this.Rules))
	for _, concrete := range this.Rules {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

// Return sections in the policy
func (this RemotePortFwdPolicy) GetSections() []*PolicySectionPayload {
	if this.Sections == nil {
		return nil
	}
	interfaceSlice := make([]*PolicySectionPayload, 0, len(this.Sections))
	for _, concrete := range this.Sections {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

// Audit data for the policy
func (this RemotePortFwdPolicy) GetAudit() *PolicyAudit { return this.Audit }

// Return data for the Policy revision
func (this RemotePortFwdPolicy) GetRevision() *PolicyRevision { return this.Revision }

type RemotePortFwdPolicyInput struct {
	// A revision is a specific instance of the policy.
	//  Unpublished revisions are working copies of the policy available to a specific
	//  admin or a set of admins
	//  Published revisions are revisions that were applied to the account network.
	//  The last published revision is the active policy.
	Revision *PolicyRevisionInput `json:"revision,omitempty"`
}

type RemotePortFwdPolicyMutationInput struct {
	Revision *PolicyMutationRevisionInput `json:"revision,omitempty"`
}

// Remote port forwarding policy information provided in the API response
type RemotePortFwdPolicyMutationPayload struct {
	Errors []*PolicyMutationError `json:"errors"`
	Policy *RemotePortFwdPolicy   `json:"policy,omitempty"`
	Status PolicyMutationStatus   `json:"status"`
}

func (RemotePortFwdPolicyMutationPayload) IsIPolicyMutationPayload() {}

// Data for the policy
func (this RemotePortFwdPolicyMutationPayload) GetPolicy() IPolicy { return *this.Policy }

// Enum for the status of the policy change
func (this RemotePortFwdPolicyMutationPayload) GetStatus() PolicyMutationStatus { return this.Status }

// List of errors related to the policy change
func (this RemotePortFwdPolicyMutationPayload) GetErrors() []*PolicyMutationError {
	if this.Errors == nil {
		return nil
	}
	interfaceSlice := make([]*PolicyMutationError, 0, len(this.Errors))
	for _, concrete := range this.Errors {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

// The Remote Port Forwarding Policy information returned to the caller in the API response.
type RemotePortFwdPolicyMutations struct {
	// Add a new port forwarding rule to enable remote access to internal services.
	AddRule *RemotePortFwdRuleMutationPayload `json:"addRule"`
	// Add a new section to the policy.
	// First section behaves as follows:
	// When the first section is created, all the rules in the policy, including the default system rules, are automatically added to it.
	// The first section containing the default system rules can be modified but not deleted.
	// The first section will always remain first-in-policy, i.e. it cannot be moved, and not other sections can be moved or created before it.
	AddSection *PolicySectionMutationPayload `json:"addSection"`
	// Create a new empty policy revision for port forwarding rules.
	CreatePolicyRevision *RemotePortFwdPolicyMutationPayload `json:"createPolicyRevision"`
	// Discard the policy revision. All changes in this revision are discarded and the revision is deleted.
	DiscardPolicyRevision *RemotePortFwdPolicyMutationPayload `json:"discardPolicyRevision"`
	// Change the priority/position of an existing port forwarding rule.
	MoveRule *RemotePortFwdRuleMutationPayload `json:"moveRule"`
	// Move a section to a new position within the policy.
	// The section will be anchored in the new position, i.e. other admins will not be able to move it, or reference it when moving other sections, until the modified policy revision is published.
	MoveSection *PolicySectionMutationPayload `json:"moveSection"`
	// Publish the policy revision. Published revision becomes the active policy and its rules are merged with unpublished revisions from other admins.
	PublishPolicyRevision *RemotePortFwdPolicyMutationPayload `json:"publishPolicyRevision"`
	// Remove an existing port forwarding rule from the policy.
	RemoveRule *RemotePortFwdRuleMutationPayload `json:"removeRule"`
	// Delete an existing section. The first section in policy cannot be deleted.
	RemoveSection *PolicySectionMutationPayload `json:"removeSection"`
	// Change the state of the port forwarding policy (enable/disable). Changes are applied immediately and not as part of policy revision publishing.
	UpdatePolicy *RemotePortFwdPolicyMutationPayload `json:"updatePolicy"`
	// Update an existing port forwarding rule configuration.
	UpdateRule *RemotePortFwdRuleMutationPayload `json:"updateRule"`
	// Update policy section attributes
	UpdateSection *PolicySectionMutationPayload `json:"updateSection"`
}

type RemotePortFwdPolicyQueries struct {
	Policy    *RemotePortFwdPolicy    `json:"policy"`
	Revisions *PolicyRevisionsPayload `json:"revisions,omitempty"`
}

type RemotePortFwdPolicyUpdateInput struct {
	State *PolicyToggleState `json:"state,omitempty"`
}

type RemotePortFwdRemoteIps struct {
	GlobalIPRange []*GlobalIPRangeRef `json:"globalIpRange"`
	IP            []string            `json:"ip"`
	IPRange       []*IPAddressRange   `json:"ipRange"`
	Subnet        []string            `json:"subnet"`
}

type RemotePortFwdRemoteIpsInput struct {
	GlobalIPRange []*GlobalIPRangeRefInput `json:"globalIpRange"`
	IP            []string                 `json:"ip"`
	IPRange       []*IPAddressRangeInput   `json:"ipRange"`
	Subnet        []string                 `json:"subnet"`
}

type RemotePortFwdRemoteIpsUpdateInput struct {
	GlobalIPRange []*GlobalIPRangeRefInput `json:"globalIpRange,omitempty"`
	IP            []string                 `json:"ip,omitempty"`
	IPRange       []*IPAddressRangeInput   `json:"ipRange,omitempty"`
	Subnet        []string                 `json:"subnet,omitempty"`
}

type RemotePortFwdRemoveRuleInput struct {
	ID string `json:"id"`
}

type RemotePortFwdRule struct {
	// Description for the rule
	Description string `json:"description"`
	// TRUE = Rule is enabled
	//  FALSE = Rule is disabled
	Enabled           bool            `json:"enabled"`
	ExternalIP        *AllocatedIPRef `json:"externalIp"`
	ExternalPortRange *PortRange      `json:"externalPortRange"`
	ForwardICMP       bool            `json:"forwardIcmp"`
	// Rule ID
	ID string `json:"id"`
	// Position / priority of rule
	Index             int64      `json:"index"`
	InternalIP        string     `json:"internalIp"`
	InternalPortRange *PortRange `json:"internalPortRange"`
	// Name of the rule
	Name            string                       `json:"name"`
	RemoteIPs       *RemotePortFwdRemoteIps      `json:"remoteIPs"`
	RestrictionType RemotePortFwdRestrictionType `json:"restrictionType"`
	// Policy section where the rule is located
	Section  *PolicySectionInfo       `json:"section"`
	Tracking *PolicyRuleTrackingAlert `json:"tracking"`
}

func (RemotePortFwdRule) IsIPolicyRule() {}

// Rule ID
func (this RemotePortFwdRule) GetID() string { return this.ID }

// Name of the rule
func (this RemotePortFwdRule) GetName() string { return this.Name }

// Description for the rule
func (this RemotePortFwdRule) GetDescription() *string { return &this.Description }

// Position / priority of rule
func (this RemotePortFwdRule) GetIndex() int64 { return this.Index }

// TRUE = Rule is enabled, FALSE = Rule is disabled
func (this RemotePortFwdRule) GetEnabled() bool { return this.Enabled }

// Policy section where the rule is located
func (this RemotePortFwdRule) GetSection() *PolicySectionInfo { return this.Section }

type RemotePortFwdRuleMutationPayload struct {
	Errors []*PolicyMutationError    `json:"errors"`
	Rule   *RemotePortFwdRulePayload `json:"rule,omitempty"`
	Status PolicyMutationStatus      `json:"status"`
}

func (RemotePortFwdRuleMutationPayload) IsIPolicyRuleMutationPayload() {}

// Returns settings for the rule
func (this RemotePortFwdRuleMutationPayload) GetRule() IPolicyRulePayload { return *this.Rule }

// Enum for the status of the policy change
func (this RemotePortFwdRuleMutationPayload) GetStatus() PolicyMutationStatus { return this.Status }

// List of errors related to the policy change
func (this RemotePortFwdRuleMutationPayload) GetErrors() []*PolicyMutationError {
	if this.Errors == nil {
		return nil
	}
	interfaceSlice := make([]*PolicyMutationError, 0, len(this.Errors))
	for _, concrete := range this.Errors {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

type RemotePortFwdRulePayload struct {
	Audit      *PolicyElementAudit           `json:"audit"`
	Properties []PolicyElementPropertiesEnum `json:"properties"`
	Rule       *RemotePortFwdRule            `json:"rule"`
}

func (RemotePortFwdRulePayload) IsIPolicyRulePayload()              {}
func (this RemotePortFwdRulePayload) GetAudit() *PolicyElementAudit { return this.Audit }

// Rule that was changed
func (this RemotePortFwdRulePayload) GetRule() IPolicyRule { return *this.Rule }

// Summary of rule change, (ie. ADDED, UPDATED)
func (this RemotePortFwdRulePayload) GetProperties() []PolicyElementPropertiesEnum {
	if this.Properties == nil {
		return nil
	}
	interfaceSlice := make([]PolicyElementPropertiesEnum, 0, len(this.Properties))
	for _, concrete := range this.Properties {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

type RemotePortFwdUpdateRuleDataInput struct {
	Description       *string                             `json:"description,omitempty"`
	Enabled           *bool                               `json:"enabled,omitempty"`
	ExternalIP        *AllocatedIPRefInput                `json:"externalIp,omitempty"`
	ExternalPortRange *PortRangeUpdateInput               `json:"externalPortRange,omitempty"`
	ForwardICMP       *bool                               `json:"forwardIcmp,omitempty"`
	InternalIP        *string                             `json:"internalIp,omitempty"`
	InternalPortRange *PortRangeUpdateInput               `json:"internalPortRange,omitempty"`
	Name              *string                             `json:"name,omitempty"`
	RemoteIPs         *RemotePortFwdRemoteIpsUpdateInput  `json:"remoteIPs,omitempty"`
	RestrictionType   *RemotePortFwdRestrictionType       `json:"restrictionType,omitempty"`
	Tracking          *PolicyRuleTrackingAlertUpdateInput `json:"tracking,omitempty"`
}

type RemotePortFwdUpdateRuleInput struct {
	ID   string                            `json:"id"`
	Rule *RemotePortFwdUpdateRuleDataInput `json:"rule"`
}

type RemoveAccountPayload struct {
	// General info of the removed account
	AccountInfo *AccountInfo `json:"accountInfo"`
}

type RemoveAdminPayload struct {
	AdminID string `json:"adminID"`
}

type RemoveBgpPeerInput struct {
	// Unique identifier of the BGP peer to be removed.
	ID string `json:"id"`
}

type RemoveBgpPeerPayload struct {
	// The BGP peer that was successfully removed.
	BgpPeer *BgpPeer `json:"bgpPeer"`
}

// Input for removing a physical connection from a cloud interconnect site.
type RemoveCloudInterconnectPhysicalConnectionInput struct {
	// ID of the connection to be removed.
	ID string `json:"id"`
}

// Payload for removing a physical connection from a cloud interconnect site.
type RemoveCloudInterconnectPhysicalConnectionPayload struct {
	// ID of the removed connection.
	ID string `json:"id"`
}

type RemoveIpsecIkeV2SiteMultiTunnelPayload struct {
	// Cato’s FQDN for the multi-tunnel
	Fqdn    *string                              `json:"fqdn,omitempty"`
	Tunnels []*RemoveIpsecIkeV2SiteTunnelPayload `json:"tunnels"`
}

type RemoveIpsecIkeV2SiteTunnelPayload struct {
	// The local ID for the tunnel
	LocalID *string `json:"localId,omitempty"`
	// The ID of the tunnel
	TunnelID *IPSecV2InterfaceID `json:"tunnelId,omitempty"`
}

type RemoveIpsecIkeV2SiteTunnelsInput struct {
	// The IDs of the tunnels
	TunnelID []IPSecV2InterfaceID `json:"tunnelId"`
}

type RemoveIpsecIkeV2SiteTunnelsPayload struct {
	// Cato’s FQDN for the primary tunnel
	Primary *RemoveIpsecIkeV2SiteMultiTunnelPayload `json:"primary,omitempty"`
	// Cato’s FQDN for the secondary tunnel
	Secondary *RemoveIpsecIkeV2SiteMultiTunnelPayload `json:"secondary,omitempty"`
	// The ID of the site
	SiteID string `json:"siteId"`
}

type RemoveNetworkRangePayload struct {
	NetworkRangeID string `json:"networkRangeId"`
}

type RemoveSecondaryAWSVSocketPayload struct {
	SecondaryAWSVSocket *SecondaryAWSVSocket `json:"secondaryAwsVSocket"`
}

type RemoveSecondaryAzureVSocketPayload struct {
	SecondaryAzureVSocket *SecondaryAzureVSocket `json:"secondaryAzureVSocket"`
}

type RemoveServicePrincipalAdminPayload struct {
	AdminID string `json:"adminID"`
}

type RemoveSiteBwLicenseInput struct {
	// The license that is being removed
	LicenseID string `json:"licenseId"`
	// The site to remove the licenses from
	Site *SiteRefInput `json:"site"`
}

type RemoveSiteBwLicensePayload struct {
	License License `json:"license"`
}

type RemoveSitePayload struct {
	SiteID string `json:"siteId"`
}

type RemoveSocketAddOnCardInput struct {
	ExpansionSlotNumbers []SocketAddOnExpansionSlotNumber `json:"expansionSlotNumbers"`
	Site                 *SiteRefInput                    `json:"site"`
}

type RemoveSocketAddOnCardPayload struct {
	AddOns []*SocketAddOnCard `json:"addOns"`
}

type RemoveStaticHostPayload struct {
	HostID string `json:"hostId"`
}

type ReplaceSiteBwLicenseInput struct {
	// Specifies the bandwidth (in Mbps) to allocate to the site when using a pooled bandwidth license.
	// This field should not be used if a site license is used.
	Bw *int64 `json:"bw,omitempty"`
	// The license that is being assigned
	LicenseIDToAdd string `json:"licenseIdToAdd"`
	// The license that is being removed
	LicenseIDToRemove string `json:"licenseIdToRemove"`
	// The site to replace the licenses for
	Site *SiteRefInput `json:"site"`
}

type ReplaceSiteBwLicensePayload struct {
	License License `json:"license"`
}

// SaaS Security API service license details
type SaasSecurityAPILicense struct {
	Description *string `json:"description,omitempty"`
	// License expiration date
	ExpirationDate string `json:"expirationDate"`
	// The unique identifier for the license. If this value is not available, you can contact Cato Support, who may be able to assist in retrieving it.
	ID *string `json:"id,omitempty"`
	// The date of the last update to the license
	LastUpdated *string `json:"lastUpdated,omitempty"`
	// License plan type
	Plan LicensePlan `json:"plan"`
	// The license SKU
	Sku LicenseSku `json:"sku"`
	// License start date
	StartDate *string `json:"startDate,omitempty"`
	// License activation status
	Status LicenseStatus `json:"status"`
	// license quantity
	Total int64 `json:"total"`
}

func (SaasSecurityAPILicense) IsLicense() {}

// The unique identifier for the license. If this value is not available, you can contact Cato Support, who may be able to assist in retrieving it.
func (this SaasSecurityAPILicense) GetID() *string          { return this.ID }
func (this SaasSecurityAPILicense) GetDescription() *string { return this.Description }

// License plan type
func (this SaasSecurityAPILicense) GetPlan() LicensePlan { return this.Plan }

// The license SKU
func (this SaasSecurityAPILicense) GetSku() LicenseSku { return this.Sku }

// License activation status
func (this SaasSecurityAPILicense) GetStatus() LicenseStatus { return this.Status }

// License start date
func (this SaasSecurityAPILicense) GetStartDate() *string { return this.StartDate }

// License expiration date
func (this SaasSecurityAPILicense) GetExpirationDate() string { return this.ExpirationDate }

// The date of the last update to the license
func (this SaasSecurityAPILicense) GetLastUpdated() *string { return this.LastUpdated }

func (SaasSecurityAPILicense) IsQuantifiableLicense() {}

// The unique identifier for the license. If this value is not available, you can contact Cato Support, who may be able to assist in retrieving it.

// License plan type

// The license SKU

// License activation status

// License initiation date

// License expiration date

// The date of the last update to the license

// license quantity
func (this SaasSecurityAPILicense) GetTotal() int64 { return this.Total }

// A reference identifying the SanctionedAppsCategory object. ID: Unique SanctionedAppsCategory Identifier, Name: The SanctionedAppsCategory Name
type SanctionedAppsCategoryRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (SanctionedAppsCategoryRef) IsObjectRef() {}

// Object's unique identifier
func (this SanctionedAppsCategoryRef) GetID() string { return this.ID }

// Object's unique name
func (this SanctionedAppsCategoryRef) GetName() string { return this.Name }

type SanctionedAppsCategoryRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

type SandboxMutations struct {
	//  Delete a sandbox report
	DeleteReport *DeleteReportPayload `json:"deleteReport"`
	//  Upload a file for sandbox analysis
	UploadFile *UploadFilePayload `json:"uploadFile"`
}

type SandboxQueries struct {
	//  Get a list of sandbox reports
	Reports *SandboxReportsPayload `json:"reports"`
}

// Sandbox report meta-data
type SandboxReport struct {
	//  Report creation date
	CreationDate string `json:"creationDate"`
	//  Report download URL (if ready)
	DownloadURL *string `json:"downloadUrl,omitempty"`
	//  Report expiration date
	ExpirationDate *string `json:"expirationDate,omitempty"`
	//  Sandbox analysis failure reason (if any)
	FailureReason *SandboxFailureReason `json:"failureReason,omitempty"`
	//  File hash (SHA-256)
	FileHash string `json:"fileHash"`
	//  File name
	FileName *string `json:"fileName,omitempty"`
	//  Sandbox analysis status
	Status SandboxStatus `json:"status"`
	//  Sandbox verdict
	Verdict *SandboxVerdict `json:"verdict,omitempty"`
}

// Sandbox reports query filter
type SandboxReportsFilterInput struct {
	//  File hash filter
	FileHash []*StringFilterInput `json:"fileHash,omitempty"`
	//  File name filter
	FileName []*StringFilterInput `json:"fileName,omitempty"`
	//  Report creation date filter
	ReportCreateDate []*DateTimeFilterInput `json:"reportCreateDate,omitempty"`
}

// Sandbox reports query input
type SandboxReportsInput struct {
	//  Query filter criteria
	Filter *SandboxReportsFilterInput `json:"filter,omitempty"`
	//  Query pagination criteria
	Paging *PagingInput `json:"paging"`
	//  Query sorting criteria
	Sort *SandboxReportsSortInput `json:"sort"`
}

// Output of sandbox reports query
type SandboxReportsPayload struct {
	//  Pagination information
	PageInfo *PageInfo `json:"pageInfo"`
	//  List of sandbox reports
	Report []*SandboxReport `json:"report"`
}

// Sandbox reports query sorting
type SandboxReportsSortInput struct {
	//  Sort by file name
	FileName *SortOrderInput `json:"fileName,omitempty"`
	//  Sort by report creation date
	ReportCreateDate *SortOrderInput `json:"reportCreateDate,omitempty"`
}

type SecondaryAWSVSocket struct {
	// The ID of the secondary vSocket
	ID string `json:"id"`
	// The IP address of the secondary vSocket
	IPAddress string `json:"ipAddress"`
	// The ID of the secondary vSocket route table
	RouteTableID string `json:"routeTableId"`
	// Site associated with this secondary vSocket.
	Site *SiteRef `json:"site"`
	// The subnet of the secondary vSocket
	Subnet string `json:"subnet"`
}

type SecondaryAzureVSocket struct {
	// The floating IP address
	FloatingIP string `json:"floatingIp"`
	// The ID of the secondary vSocket
	ID string `json:"id"`
	// The IP address of the interface
	InterfaceIP string `json:"interfaceIp"`
	// Information about the site where the secondary Azure vSocket is being added.
	Site *SiteRef `json:"site"`
}

// A reference identifying the Service object. ID: Unique Service Identifier, Name: The Service Name
type ServiceRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (ServiceRef) IsObjectRef() {}

// Object's unique identifier
func (this ServiceRef) GetID() string { return this.ID }

// Object's unique name
func (this ServiceRef) GetName() string { return this.Name }

type ServiceRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

type ShippingDetails struct {
	// City
	CityName *string `json:"cityName,omitempty"`
	// Comment
	Comment *string `json:"comment,omitempty"`
	// Company name (recipient)
	CompanyName *string `json:"companyName,omitempty"`
	// Delivery contact detail
	Contact *ContactDetails `json:"contact,omitempty"`
	// Country
	CountryName *string `json:"countryName,omitempty"`
	// Shipping method
	Incoterms *string `json:"incoterms,omitempty"`
	// Delivery instruction (required for EXW incoterms)
	Instruction *string `json:"instruction,omitempty"`
	// Power cable type (for sockets only)
	PowerCable *string `json:"powerCable,omitempty"`
	// State (required only for USA)
	StateName *string `json:"stateName,omitempty"`
	// Street name and number
	Street *string `json:"street,omitempty"`
	// Vat id (required for Brazil)
	VatID *string `json:"vatId,omitempty"`
	// Zip Code
	ZipCode *string `json:"zipCode,omitempty"`
}

type ShippingDetailsInput struct {
	// Address for delivery
	Address *AddressInput `json:"address,omitempty"`
	// Comment
	Comment *string `json:"comment,omitempty"`
	// Delivery contact detail
	Contact *ContactDetailsInput `json:"contact,omitempty"`
	// Shipping method
	Incoterms *string `json:"incoterms,omitempty"`
	// Delivery instruction (required for EXW incoterms)
	Instruction *string `json:"instruction,omitempty"`
	// Vat id (required for Brazil)
	VatID *string `json:"vatId,omitempty"`
}

type ShippingStatusFilterInput struct {
	Eq  *ShippingStatus  `json:"eq,omitempty"`
	In  []ShippingStatus `json:"in,omitempty"`
	Neq *ShippingStatus  `json:"neq,omitempty"`
	Nin []ShippingStatus `json:"nin,omitempty"`
}

type ShippingTracking struct {
	// Carrier (shipping company)
	Carrier *string `json:"carrier,omitempty"`
	// Shipping date
	ShippingDate *time.Time `json:"shippingDate,omitempty"`
	// Shipping status
	ShippingStatus *ShippingStatus `json:"shippingStatus,omitempty"`
	// Tracking number
	TrackingNumber *string `json:"trackingNumber,omitempty"`
	// Tracking url
	TrackingURL *string `json:"trackingUrl,omitempty"`
}

type SimilarStoryData struct {
	Indication           *string  `json:"indication,omitempty"`
	SimilarityPercentage *float64 `json:"similarityPercentage,omitempty"`
	StoryID              *string  `json:"storyId,omitempty"`
	ThreatClassification *string  `json:"threatClassification,omitempty"`
	ThreatTypeName       *string  `json:"threatTypeName,omitempty"`
	Verdict              *string  `json:"verdict,omitempty"`
}

type SimpleService struct {
	Name SimpleServiceType `json:"name"`
}

type SimpleServiceInput struct {
	Name SimpleServiceType `json:"name"`
}

type SiteBgpStatus struct {
	// Raw BGP status information.
	RawStatus []string `json:"rawStatus"`
	// Detailed BGP status, including session and route details.
	Status []*BgpDetailedStatus `json:"status"`
}

type SiteBgpStatusInput struct {
	// Identifying data for the site whose BGP status is being queried.
	Site *SiteRefInput `json:"site"`
}

type SiteGeneralDetailsPayload struct {
	Description *string `json:"description,omitempty"`
	// Only relevant for socket sites
	PreferredPopLocation *SitePreferredPopLocation `json:"preferredPopLocation,omitempty"`
	Site                 *SiteRef                  `json:"site"`
	SiteLocation         *SiteLocation             `json:"siteLocation"`
	SiteType             SiteType                  `json:"siteType"`
}

// Basic Site configuration information
type SiteInfo struct {
	// Address of the physical site location
	Address *string `json:"address,omitempty"`
	// City of the physical site location
	CityName *string `json:"cityName,omitempty"`
	// The Connection Type field defines how the site connects to the Cato Cloud, such as X1500 Socket or AWS vSocket (array with nested fields)
	ConnType *ProtoType `json:"connType,omitempty"`
	// Code for the Country that is the physical location of the site
	CountryCode *string `json:"countryCode,omitempty"`
	// Country that is the physical location of the site
	CountryName *string `json:"countryName,omitempty"`
	// State of the country that is the physical site location
	CountryStateName *string `json:"countryStateName,omitempty"`
	// Timestamp for when the site was created
	CreationTime *string `json:"creationTime,omitempty"`
	// User defined description of the site
	Description *string `json:"description,omitempty"`
	// Basic configuration information about the Socket interface
	Interfaces []*InterfaceInfo `json:"interfaces,omitempty"`
	// data related to IPsec sites, such as IKE version
	Ipsec []*IPSecInfo `json:"ipsec,omitempty"`
	// When this boolean value is true, the site is enabled for high availability
	IsHa *bool `json:"isHA,omitempty"`
	// Name for the site
	Name *string `json:"name,omitempty"`
	// Geographical PoP region that the site is licensed to use
	Region *string `json:"region,omitempty"`
	// Data related to Socket and vSocket sites, such as serial number and Socket version (array with nested fields)
	Sockets []*SocketInfo `json:"sockets,omitempty"`
	// Site type in the Cato Management Application, such as branch office or datacenter
	Type *SiteType `json:"type,omitempty"`
}

// Site bandwidth license
type SiteLicense struct {
	Description *string `json:"description,omitempty"`
	// License expiration date
	ExpirationDate string `json:"expirationDate"`
	// The unique identifier for the license. If this value is not available, you can contact Cato Support, who may be able to assist in retrieving it.
	ID *string `json:"id,omitempty"`
	// The date of the last update to the license
	LastUpdated *string `json:"lastUpdated,omitempty"`
	// License plan type
	Plan LicensePlan `json:"plan"`
	// For the relevant license groups, indicates whether this is a global or regional license. For other regions, the value is set to ‘NA’ (not applicable).
	Regionality *Regionality `json:"regionality,omitempty"`
	// Identifying data for the site the license is assigned to
	Site *SiteRef `json:"site,omitempty"`
	// The license group.
	SiteLicenseGroup SiteLicenseGroup `json:"siteLicenseGroup"`
	// The selected service type, e.g SASE or SSE.
	SiteLicenseType SiteLicenseType `json:"siteLicenseType"`
	// The license SKU
	Sku LicenseSku `json:"sku"`
	// License start date
	StartDate *string `json:"startDate,omitempty"`
	// License activation status
	Status LicenseStatus `json:"status"`
	// Maximum available bandwidth for the site, in Mbps
	Total int64 `json:"total"`
}

func (SiteLicense) IsLicense() {}

// The unique identifier for the license. If this value is not available, you can contact Cato Support, who may be able to assist in retrieving it.
func (this SiteLicense) GetID() *string          { return this.ID }
func (this SiteLicense) GetDescription() *string { return this.Description }

// License plan type
func (this SiteLicense) GetPlan() LicensePlan { return this.Plan }

// The license SKU
func (this SiteLicense) GetSku() LicenseSku { return this.Sku }

// License activation status
func (this SiteLicense) GetStatus() LicenseStatus { return this.Status }

// License start date
func (this SiteLicense) GetStartDate() *string { return this.StartDate }

// License expiration date
func (this SiteLicense) GetExpirationDate() string { return this.ExpirationDate }

// The date of the last update to the license
func (this SiteLicense) GetLastUpdated() *string { return this.LastUpdated }

func (SiteLicense) IsQuantifiableLicense() {}

// The unique identifier for the license. If this value is not available, you can contact Cato Support, who may be able to assist in retrieving it.

// License plan type

// The license SKU

// License activation status

// License initiation date

// License expiration date

// The date of the last update to the license

// license quantity
func (this SiteLicense) GetTotal() int64 { return this.Total }

type SiteLocation struct {
	Address     *string `json:"address,omitempty"`
	CityName    *string `json:"cityName,omitempty"`
	CountryCode string  `json:"countryCode"`
	StateCode   *string `json:"stateCode,omitempty"`
	Timezone    string  `json:"timezone"`
}

type SiteMetrics struct {
	// Timeseries with the number of flows (connections) in the site. Applicable only for site
	FlowCount *Timeseries `json:"flowCount,omitempty"`
	// Timeseries with the number of hosts in the site. Applicable only for site
	HostCount *Timeseries `json:"hostCount,omitempty"`
	// Timeseries with the configurable limit of the number of hosts in the site. Applicable only for site
	HostLimit *Timeseries `json:"hostLimit,omitempty"`
	// Site ID
	ID *string `json:"id,omitempty"`
	// Shows general information about the site (array with nested fields). Applicable only for site
	Info *SiteInfo `json:"info,omitempty"`
	// Analytics that are returned for the links for a site
	Interfaces []*InterfaceMetrics `json:"interfaces,omitempty"`
	// Traffic metrics and data for sites
	Metrics *Metrics `json:"metrics,omitempty"`
	// Site names
	Name    *string `json:"name,omitempty"`
	Samples *int64  `json:"samples,omitempty"`
}

type SiteMutations struct {
	// Adds a new BGP peer to the specified site.
	AddBgpPeer *AddBgpPeerPayload `json:"addBgpPeer,omitempty"`
	// Add a new physical connection to a cloud interconnect site.Either connect to a partner, or a non-supported public provider
	AddCloudInterconnectPhysicalConnection *AddCloudInterconnectPhysicalConnectionPayload `json:"addCloudInterconnectPhysicalConnection,omitempty"`
	// Add a new cloud interconnect site.
	AddCloudInterconnectSite *AddCloudInterconnectSitePayload `json:"addCloudInterconnectSite,omitempty"`
	AddIpsecIkeV2Site        *AddIpsecIkeV2SitePayload        `json:"addIpsecIkeV2Site,omitempty"`
	AddIpsecIkeV2SiteTunnels *AddIpsecIkeV2SiteTunnelsPayload `json:"addIpsecIkeV2SiteTunnels,omitempty"`
	AddNetworkRange          *AddNetworkRangePayload          `json:"addNetworkRange,omitempty"`
	// Add a secondary AWS vSocket to an existing site
	AddSecondaryAWSVSocket *AddSecondaryAWSVSocketPayload `json:"addSecondaryAwsVSocket,omitempty"`
	// Add a secondary Azure vSocket to an existing site
	AddSecondaryAzureVSocket *AddSecondaryAzureVSocketPayload `json:"addSecondaryAzureVSocket,omitempty"`
	AddSocketAddOnCard       *AddSocketAddOnCardPayload       `json:"addSocketAddOnCard,omitempty"`
	AddSocketSite            *AddSocketSitePayload            `json:"addSocketSite,omitempty"`
	AddStaticHost            *AddStaticHostPayload            `json:"addStaticHost,omitempty"`
	// Assign a license to an existing site // License-to-site assignment will be removed starting in 2026 with the transition to a new pricing model.
	AssignSiteBwLicense *AssignSiteBwLicensePayload `json:"assignSiteBwLicense,omitempty"`
	// Removes an existing BGP peer configuration from a site.
	RemoveBgpPeer *RemoveBgpPeerPayload `json:"removeBgpPeer,omitempty"`
	// Remove a physical connection from a cloud interconnect site.
	RemoveCloudInterconnectPhysicalConnection *RemoveCloudInterconnectPhysicalConnectionPayload `json:"removeCloudInterconnectPhysicalConnection,omitempty"`
	RemoveIpsecIkeV2SiteTunnels               *RemoveIpsecIkeV2SiteTunnelsPayload               `json:"removeIpsecIkeV2SiteTunnels,omitempty"`
	RemoveNetworkRange                        *RemoveNetworkRangePayload                        `json:"removeNetworkRange,omitempty"`
	// Remove the secondary AWS vSocket from an existing site
	RemoveSecondaryAWSVSocket *RemoveSecondaryAWSVSocketPayload `json:"removeSecondaryAwsVSocket,omitempty"`
	// Remove the secondary Azure vSocket from an existing site
	RemoveSecondaryAzureVSocket *RemoveSecondaryAzureVSocketPayload `json:"removeSecondaryAzureVSocket,omitempty"`
	RemoveSite                  *RemoveSitePayload                  `json:"removeSite,omitempty"`
	// Remove a license from a site // License-to-site assignment will be removed starting in 2026 with the transition to a new pricing model.
	RemoveSiteBwLicense   *RemoveSiteBwLicensePayload   `json:"removeSiteBwLicense,omitempty"`
	RemoveSocketAddOnCard *RemoveSocketAddOnCardPayload `json:"removeSocketAddOnCard,omitempty"`
	RemoveStaticHost      *RemoveStaticHostPayload      `json:"removeStaticHost,omitempty"`
	// Replace an existing license of a site. This API is used to make sure the site
	// will always have a license to avoid traffic drop for sites without licenses. // License-to-site assignment will be removed starting in 2026 with the transition to a new pricing model.
	ReplaceSiteBwLicense *ReplaceSiteBwLicensePayload `json:"replaceSiteBwLicense,omitempty"`
	// Requests an upgrade for multiple sites to specific versions.
	// Returns the result of the request.
	StartSiteUpgrade *StartSiteUpgradePayload `json:"startSiteUpgrade,omitempty"`
	// Updates an existing BGP peer configuration.
	UpdateBgpPeer *UpdateBgpPeerPayload `json:"updateBgpPeer,omitempty"`
	// Update an existing physical connection at a cloud interconnect site.
	UpdateCloudInterconnectPhysicalConnection *UpdateCloudInterconnectPhysicalConnectionPayload `json:"updateCloudInterconnectPhysicalConnection,omitempty"`
	UpdateHa                                  *UpdateHaPayload                                  `json:"updateHa,omitempty"`
	UpdateIpsecIkeV2SiteGeneralDetails        *UpdateIpsecIkeV2SiteGeneralDetailsPayload        `json:"updateIpsecIkeV2SiteGeneralDetails,omitempty"`
	UpdateIpsecIkeV2SiteTunnels               *UpdateIpsecIkeV2SiteTunnelsPayload               `json:"updateIpsecIkeV2SiteTunnels,omitempty"`
	UpdateNetworkRange                        *UpdateNetworkRangePayload                        `json:"updateNetworkRange,omitempty"`
	// Update the secondary AWS vSocket from in an existing site
	UpdateSecondaryAWSVSocket *UpdateSecondaryAWSVSocketPayload `json:"updateSecondaryAwsVSocket,omitempty"`
	// Update the secondary Azure vSocket in an existing site
	UpdateSecondaryAzureVSocket *UpdateSecondaryAzureVSocketPayload `json:"updateSecondaryAzureVSocket,omitempty"`
	// Update the bandwidth allocation of an assigned pool license of an existing site (does not apply for site license allocation) // License-to-site assignment will be removed starting in 2026 with the transition to a new pricing model.
	UpdateSiteBwLicense      *UpdateSiteBwLicensePayload      `json:"updateSiteBwLicense,omitempty"`
	UpdateSiteGeneralDetails *UpdateSiteGeneralDetailsPayload `json:"updateSiteGeneralDetails,omitempty"`
	UpdateSocketInterface    *UpdateSocketInterfacePayload    `json:"updateSocketInterface,omitempty"`
	UpdateStaticHost         *UpdateStaticHostPayload         `json:"updateStaticHost,omitempty"`
}

// A reference identifying the SiteNetworkSubnet object. ID: Unique SiteNetworkSubnet Identifier, Name: The SiteNetworkSubnet Name
type SiteNetworkSubnetRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (SiteNetworkSubnetRef) IsDeviceNetworkRef() {}

func (SiteNetworkSubnetRef) IsObjectRef() {}

// Object's unique identifier
func (this SiteNetworkSubnetRef) GetID() string { return this.ID }

// Object's unique name
func (this SiteNetworkSubnetRef) GetName() string { return this.Name }

type SiteNetworkSubnetRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

type SitePreferredPopLocation struct {
	// Forces the socket to connect exclusively to the configured PoP locations
	PreferredOnly bool            `json:"preferredOnly"`
	Primary       *PopLocationRef `json:"primary,omitempty"`
	Secondary     *PopLocationRef `json:"secondary,omitempty"`
}

type SiteQueries struct {
	// Retrieves available socket versions for the specified platforms.
	AvailableVersionList *AvailableVersionListPayload `json:"availableVersionList,omitempty"`
	// Retrieves details of a specific BGP peer by reference.
	BgpPeer *BgpPeer `json:"bgpPeer,omitempty"`
	// Retrieves a list of all BGP peers associated with the specified site.
	BgpPeerList *BgpPeerListPayload `json:"bgpPeerList,omitempty"`
	// Check the L2 connectivity status of a cloud interconnect connection using ICMP.
	CloudInterconnectConnectionConnectivity *CloudInterconnectConnectionConnectivity `json:"cloudInterconnectConnectionConnectivity,omitempty"`
	// Get details of a physical connection at a cloud interconnect site.
	CloudInterconnectPhysicalConnection *CloudInterconnectPhysicalConnection `json:"cloudInterconnectPhysicalConnection,omitempty"`
	// Get the ID of a physical connection at a cloud interconnect site.
	CloudInterconnectPhysicalConnectionID *CloudInterconnectPhysicalConnectionID `json:"cloudInterconnectPhysicalConnectionId,omitempty"`
	// Retrieves details of a specific secondary AWS vSocket.
	SecondaryAWSVSocket *SecondaryAWSVSocket `json:"secondaryAwsVSocket,omitempty"`
	// Retrieves details of a specific secondary Azure vSocket.
	SecondaryAzureVSocket *SecondaryAzureVSocket `json:"secondaryAzureVSocket,omitempty"`
	// Provides the BGP status of the specified site, including session and route details.
	SiteBgpStatus      *SiteBgpStatus             `json:"siteBgpStatus,omitempty"`
	SiteGeneralDetails *SiteGeneralDetailsPayload `json:"siteGeneralDetails,omitempty"`
}

// A reference identifying the Site object. ID: Unique Site Identifier, Name: The Site Name
type SiteRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (SiteRef) IsObjectRef() {}

// Object's unique identifier
func (this SiteRef) GetID() string { return this.ID }

// Object's unique name
func (this SiteRef) GetName() string { return this.Name }

type SiteRefFilterInput struct {
	Eq  *SiteRefInput   `json:"eq,omitempty"`
	In  []*SiteRefInput `json:"in,omitempty"`
	Neq *SiteRefInput   `json:"neq,omitempty"`
	Nin []*SiteRefInput `json:"nin,omitempty"`
}

type SiteRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

type SiteSnapshot struct {
	// Alternative WAN connectivity status
	AltWanStatus *string `json:"altWanStatus,omitempty"`
	// For connected sites, since when are they connected
	ConnectedSince *string `json:"connectedSince,omitempty"`
	// Connectivity to the Cato Cloud
	ConnectivityStatus *ConnectivityStatus `json:"connectivityStatus,omitempty"`
	// Degraded status and details
	DegradedStatus *DegradedStatus `json:"degradedStatus,omitempty"`
	// Data related to the Sockets for a site
	Devices []*DeviceSnapshot `json:"devices,omitempty"`
	// Site HA readiness information
	HaStatus *HaStatus `json:"haStatus,omitempty"`
	// Number of hosts connected to a site
	HostCount *int64 `json:"hostCount,omitempty"`
	// site ID
	ID *string `json:"id,omitempty"`
	// General real-time information about the site
	Info *SiteInfo `json:"info,omitempty"`
	// Relevant when the site is disconnected - the last time the device was connected
	LastConnected *string `json:"lastConnected,omitempty"`
	// Status for a site or VPN user
	OperationalStatus *scalars.OperationalStatus `json:"operationalStatus,omitempty"`
	// Name of the PoP that the site is connected to
	PopName *string `json:"popName,omitempty"`
	ProtoID *int64  `json:"protoId,omitempty"`
}

// Information about a site upgrade.
type SiteUpgradeInfo struct {
	// The scheduled UTC time for the upgrade.
	ScheduledAt string   `json:"scheduledAt"`
	Site        *SiteRef `json:"site"`
	// The requested version for this site.
	TargetVersion string `json:"targetVersion"`
}

// Represents a single site upgrade request.
type SiteUpgradeRequest struct {
	Site *SiteRefInput `json:"site"`
	// Target version to upgrade the site's sockets to.
	TargetVersion string `json:"targetVersion"`
}

// Represents the result of an upgrade request.
type SiteUpgradeResult struct {
	Site *BulkUpgradeSiteInfo `json:"site"`
	// The requested version for this site.
	TargetVersion string `json:"targetVersion"`
}

type SocketAddOnCard struct {
	ExpansionSlotNumber SocketAddOnExpansionSlotNumber `json:"expansionSlotNumber"`
	Type                SocketAddOnType                `json:"type"`
}

type SocketAddOnCardInput struct {
	ExpansionSlotNumber SocketAddOnExpansionSlotNumber `json:"expansionSlotNumber"`
	Type                SocketAddOnType                `json:"type"`
}

// Basic information about socket
type SocketInfo struct {
	// Unique ID for Socket
	ID *string `json:"id,omitempty"`
	// For HA configurations, when this boolean value is true, this the primary Socket
	IsPrimary *bool `json:"isPrimary,omitempty"`
	// Shows Socket type
	Platform *SocketPlatform `json:"platform,omitempty"`
	// Serial number for the Socket
	Serial *string `json:"serial,omitempty"`
	// Software version number that is currently installed on the Socket
	Version *string `json:"version,omitempty"`
	// Timestamp when the Socket upgraded to the current hardware version
	VersionUpdateTime *string `json:"versionUpdateTime,omitempty"`
}

type SocketInterfaceAltWanInput struct {
	PrivateGatewayIP   string  `json:"privateGatewayIp"`
	PrivateInterfaceIP string  `json:"privateInterfaceIp"`
	PrivateNetwork     string  `json:"privateNetwork"`
	PrivateVlanTag     *int64  `json:"privateVlanTag,omitempty"`
	PublicGatewayIP    *string `json:"publicGatewayIp,omitempty"`
	PublicInterfaceIP  *string `json:"publicInterfaceIp,omitempty"`
	PublicNetwork      *string `json:"publicNetwork,omitempty"`
	PublicVlanTag      *int64  `json:"publicVlanTag,omitempty"`
}

type SocketInterfaceBandwidthInput struct {
	DownstreamBandwidth              *int64   `json:"downstreamBandwidth,omitempty"`
	DownstreamBandwidthMbpsPrecision *float64 `json:"downstreamBandwidthMbpsPrecision,omitempty"`
	UpstreamBandwidth                *int64   `json:"upstreamBandwidth,omitempty"`
	UpstreamBandwidthMbpsPrecision   *float64 `json:"upstreamBandwidthMbpsPrecision,omitempty"`
}

type SocketInterfaceLagInput struct {
	MinLinks int64 `json:"minLinks"`
}

type SocketInterfaceLanInput struct {
	LocalIP          string  `json:"localIp"`
	Subnet           string  `json:"subnet"`
	TranslatedSubnet *string `json:"translatedSubnet,omitempty"`
}

type SocketInterfaceOffCloudInput struct {
	Enabled          bool    `json:"enabled"`
	PublicIP         *string `json:"publicIp,omitempty"`
	PublicStaticPort *int64  `json:"publicStaticPort,omitempty"`
}

type SocketInterfaceVrrpInput struct {
	VrrpType *VrrpType `json:"vrrpType,omitempty"`
}

type SocketInterfaceWanInput struct {
	Precedence SocketInterfacePrecedenceEnum `json:"precedence"`
	Role       SocketInterfaceRole           `json:"role"`
}

type SocketInventoryFilterInput struct {
	// Will run contains operation for the provided text on the following fields serialNumber,socketMac,socketVersion,installedSite,
	// shippingCompany,trackingNumber,deliverySiteName,description,hardwareVersion with OR between them
	FreeText *FreeTextFilterInput `json:"freeText,omitempty"`
}

type SocketInventoryInput struct {
	Filter *SocketInventoryFilterInput `json:"filter,omitempty"`
	Paging *PagingInput                `json:"paging,omitempty"`
	Sort   *SocketInventoryOrderInput  `json:"sort,omitempty"`
}

type SocketInventoryItem struct {
	// Socket account
	Account *AccountRef `json:"account"`
	// Available upgrade versions
	AvailableUpgradeVersions []string `json:"availableUpgradeVersions"`
	// Name of the delivery site
	DeliverySiteName *string `json:"deliverySiteName,omitempty"`
	// Description
	Description *string `json:"description,omitempty"`
	// Hardware Version
	HardwareVersion *string `json:"hardwareVersion,omitempty"`
	// ID
	ID string `json:"id"`
	// Is primary socket
	IsPrimary bool `json:"isPrimary"`
	// Registration status
	RegistrationStatus *SocketRegistrationStatus `json:"registrationStatus,omitempty"`
	// Serial number (unique)
	SerialNumber *string `json:"serialNumber,omitempty"`
	// Shipping company
	ShippingCompany *string `json:"shippingCompany,omitempty"`
	// Shipping date
	ShippingDate *string `json:"shippingDate,omitempty"`
	// Socket's site
	Site *SiteRef `json:"site,omitempty"`
	// Mac address
	SocketMac *string `json:"socketMac,omitempty"`
	// Socket Type
	SocketType *SocketPlatform `json:"socketType,omitempty"`
	// Socket version
	SocketVersion *string `json:"socketVersion,omitempty"`
	// Socket status (see SocketInventoryItemStatus)
	Status *SocketInventoryItemStatus `json:"status,omitempty"`
	// tracking number from the shipping company
	TrackingNumber *string `json:"trackingNumber,omitempty"`
	// tracking url from the shipping company
	TrackingURL *string `json:"trackingUrl,omitempty"`
	// Are automatic upgrade paused
	UpgradesPaused bool `json:"upgradesPaused"`
	// Upgrade status
	UpgradeStatus *SocketUpgradeStatus `json:"upgradeStatus,omitempty"`
}

type SocketInventoryOrderInput struct {
	AccountName      *SortOrderInput `json:"accountName,omitempty"`
	DeliverySiteName *SortOrderInput `json:"deliverySiteName,omitempty"`
	Description      *SortOrderInput `json:"description,omitempty"`
	HardwareVersion  *SortOrderInput `json:"hardwareVersion,omitempty"`
	InstalledSite    *SortOrderInput `json:"installedSite,omitempty"`
	SerialNumber     *SortOrderInput `json:"serialNumber,omitempty"`
	ShippingCompany  *SortOrderInput `json:"shippingCompany,omitempty"`
	ShippingDate     *SortOrderInput `json:"shippingDate,omitempty"`
	SocketType       *SortOrderInput `json:"socketType,omitempty"`
	// Default sort field
	Status *SortOrderInput `json:"status,omitempty"`
}

type SocketInventoryPayload struct {
	Items    []*SocketInventoryItem `json:"items"`
	PageInfo *PageInfo              `json:"pageInfo"`
}

type SocketLanAddRuleDataInput struct {
	Description string `json:"description"`
	// Destination traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Destination *SocketLanDestinationInput `json:"destination"`
	// Direction of the traffic initiator matching criteria.
	Direction SocketLanDirection `json:"direction"`
	Enabled   bool               `json:"enabled"`
	Name      string             `json:"name"`
	// Optionally, enable NAT on the outgoing interface. This translates all originating IPs to one NAT IP.
	Nat *SocketLanNatSettingsInput `json:"nat"`
	// Destination service matching criteria for the rule. Port/Protocol based.
	Service *SocketLanServiceInput `json:"service"`
	// The sites the policy will be enforced on.
	// Socket sites only, with Socket v22 onwards.
	Site *SocketLanSiteInput `json:"site"`
	// Source traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Source *SocketLanSourceInput `json:"source"`
	// The transport of the matching traffic.
	// Either govern traffic to be routed locally (LAN), or to the PoP(WAN).
	// Traffic is send to the WAN by default.
	// Traffic routed in the LAN, enforced by the LAN Firewall rules.
	Transport SocketLanTransportType `json:"transport"`
}

type SocketLanAddRuleInput struct {
	// Position of the rule in the policy
	At *PolicyRulePositionInput `json:"at,omitempty"`
	// Parameters for the rule you are adding
	Rule *SocketLanAddRuleDataInput `json:"rule"`
}

// Returns the settings for Destination of a Wan Firewall rule.
type SocketLanDestination struct {
	FloatingSubnet    []*FloatingSubnetRef    `json:"floatingSubnet"`
	GlobalIPRange     []*GlobalIPRangeRef     `json:"globalIpRange"`
	Group             []*GroupRef             `json:"group"`
	Host              []*HostRef              `json:"host"`
	IP                []string                `json:"ip"`
	IPRange           []*IPAddressRange       `json:"ipRange"`
	NetworkInterface  []*NetworkInterfaceRef  `json:"networkInterface"`
	SiteNetworkSubnet []*SiteNetworkSubnetRef `json:"siteNetworkSubnet"`
	Subnet            []string                `json:"subnet"`
	SystemGroup       []*SystemGroupRef       `json:"systemGroup"`
	Vlan              []scalars.Vlan          `json:"vlan"`
}

// Input of the settings for Destination of a Wan Firewall rule.
type SocketLanDestinationInput struct {
	FloatingSubnet    []*FloatingSubnetRefInput    `json:"floatingSubnet"`
	GlobalIPRange     []*GlobalIPRangeRefInput     `json:"globalIpRange"`
	Group             []*GroupRefInput             `json:"group"`
	Host              []*HostRefInput              `json:"host"`
	IP                []string                     `json:"ip"`
	IPRange           []*IPAddressRangeInput       `json:"ipRange"`
	NetworkInterface  []*NetworkInterfaceRefInput  `json:"networkInterface"`
	SiteNetworkSubnet []*SiteNetworkSubnetRefInput `json:"siteNetworkSubnet"`
	Subnet            []string                     `json:"subnet"`
	SystemGroup       []*SystemGroupRefInput       `json:"systemGroup"`
	Vlan              []scalars.Vlan               `json:"vlan"`
}

// Input of the settings for Destination of a Wan Firewall rule.
type SocketLanDestinationUpdateInput struct {
	FloatingSubnet    []*FloatingSubnetRefInput    `json:"floatingSubnet,omitempty"`
	GlobalIPRange     []*GlobalIPRangeRefInput     `json:"globalIpRange,omitempty"`
	Group             []*GroupRefInput             `json:"group,omitempty"`
	Host              []*HostRefInput              `json:"host,omitempty"`
	IP                []string                     `json:"ip,omitempty"`
	IPRange           []*IPAddressRangeInput       `json:"ipRange,omitempty"`
	NetworkInterface  []*NetworkInterfaceRefInput  `json:"networkInterface,omitempty"`
	SiteNetworkSubnet []*SiteNetworkSubnetRefInput `json:"siteNetworkSubnet,omitempty"`
	Subnet            []string                     `json:"subnet,omitempty"`
	SystemGroup       []*SystemGroupRefInput       `json:"systemGroup,omitempty"`
	Vlan              []scalars.Vlan               `json:"vlan,omitempty"`
}

type SocketLanFirewallAddRuleDataInput struct {
	// Action to take when the rule is matched (ALLOW or BLOCK).
	Action SocketLanFirewallAction `json:"action"`
	// Application traffic matching criteria.
	Application *SocketLanFirewallApplicationInput `json:"application"`
	Description string                             `json:"description"`
	// Defines destinations for the socket LAN firewall.
	// Also, inherited by Network Rule above.
	Destination *SocketLanFirewallDestinationInput `json:"destination"`
	// Direction of the traffic (TO or BOTH).
	Direction SocketLanFirewallDirection `json:"direction"`
	Enabled   bool                       `json:"enabled"`
	Name      string                     `json:"name"`
	// Service traffic matching criteria.
	Service *SocketLanFirewallServiceTypeInput `json:"service"`
	// Defines sources for the socket LAN firewall.
	// Also, inherited by Network Rule above.
	Source *SocketLanFirewallSourceInput `json:"source"`
	// Tracking information when the rule is matched, such as events and notifications.
	Tracking *PolicyTrackingInput `json:"tracking"`
}

type SocketLanFirewallAddRuleInput struct {
	// Position of the rule in the policy
	At *PolicySubRulePositionInput `json:"at,omitempty"`
	// Parameters for the rule you are adding
	Rule *SocketLanFirewallAddRuleDataInput `json:"rule"`
}

// Defines applications for the socket LAN firewall.
type SocketLanFirewallApplication struct {
	// Applications matching criteria for this rule.
	Application []*ApplicationRef `json:"application"`
	// Custom applications that can be matched by
	CustomApp     []*CustomApplicationRef `json:"customApp"`
	Domain        []string                `json:"domain"`
	Fqdn          []string                `json:"fqdn"`
	GlobalIPRange []*GlobalIPRangeRef     `json:"globalIpRange"`
	IP            []string                `json:"ip"`
	IPRange       []*IPAddressRange       `json:"ipRange"`
	Subnet        []string                `json:"subnet"`
}

// Defines applications for the socket LAN firewall.
type SocketLanFirewallApplicationInput struct {
	// Applications matching criteria for this rule.
	Application []*ApplicationRefInput `json:"application"`
	// Custom applications that can be matched by
	CustomApp     []*CustomApplicationRefInput `json:"customApp"`
	Domain        []string                     `json:"domain"`
	Fqdn          []string                     `json:"fqdn"`
	GlobalIPRange []*GlobalIPRangeRefInput     `json:"globalIpRange"`
	IP            []string                     `json:"ip"`
	IPRange       []*IPAddressRangeInput       `json:"ipRange"`
	Subnet        []string                     `json:"subnet"`
}

// Defines applications for the socket LAN firewall.
type SocketLanFirewallApplicationUpdateInput struct {
	// Applications matching criteria for this rule.
	Application []*ApplicationRefInput `json:"application,omitempty"`
	// Custom applications that can be matched by
	CustomApp     []*CustomApplicationRefInput `json:"customApp,omitempty"`
	Domain        []string                     `json:"domain,omitempty"`
	Fqdn          []string                     `json:"fqdn,omitempty"`
	GlobalIPRange []*GlobalIPRangeRefInput     `json:"globalIpRange,omitempty"`
	IP            []string                     `json:"ip,omitempty"`
	IPRange       []*IPAddressRangeInput       `json:"ipRange,omitempty"`
	Subnet        []string                     `json:"subnet,omitempty"`
}

// Defines destinations for the socket LAN firewall.
type SocketLanFirewallDestination struct {
	// Floating subnets used to identify traffic based on specific criteria.
	FloatingSubnet []*FloatingSubnetRef `json:"floatingSubnet"`
	// Global IP ranges defined for your account.
	GlobalIPRange []*GlobalIPRangeRef `json:"globalIpRange"`
	// Groups defined for your account.
	Group []*GroupRef `json:"group"`
	// Hosts and servers defined for your account.
	Host []*HostRef `json:"host"`
	// IPv4 addresses.
	IP []string `json:"ip"`
	// Multiple separate IP addresses or an IP range.
	IPRange []*IPAddressRange `json:"ipRange"`
	// Network interfaces defined for your site.
	NetworkInterface []*NetworkInterfaceRef `json:"networkInterface"`
	// Sites defined for your account.
	Site []*SiteRef `json:"site"`
	// Subnets specific to a site defined for your account.
	SiteNetworkSubnet []*SiteNetworkSubnetRef `json:"siteNetworkSubnet"`
	// Subnets to which traffic is directed.
	Subnet []string `json:"subnet"`
	// Predefined system groups in your account.
	SystemGroup []*SystemGroupRef `json:"systemGroup"`
	// VLAN ID matching criteria.
	Vlan []scalars.Vlan `json:"vlan"`
}

// Defines destinations for the socket LAN firewall.
type SocketLanFirewallDestinationInput struct {
	// Floating subnets used to identify traffic based on specific criteria.
	FloatingSubnet []*FloatingSubnetRefInput `json:"floatingSubnet"`
	// Global IP ranges defined for your account.
	GlobalIPRange []*GlobalIPRangeRefInput `json:"globalIpRange"`
	// Groups defined for your account.
	Group []*GroupRefInput `json:"group"`
	// Hosts and servers defined for your account.
	Host []*HostRefInput `json:"host"`
	// IPv4 addresses.
	IP []string `json:"ip"`
	// Multiple separate IP addresses or an IP range.
	IPRange []*IPAddressRangeInput `json:"ipRange"`
	// Network interfaces defined for your site.
	NetworkInterface []*NetworkInterfaceRefInput `json:"networkInterface"`
	// Sites defined for your account.
	Site []*SiteRefInput `json:"site"`
	// Subnets specific to a site defined for your account.
	SiteNetworkSubnet []*SiteNetworkSubnetRefInput `json:"siteNetworkSubnet"`
	// Subnets to which traffic is directed.
	Subnet []string `json:"subnet"`
	// Predefined system groups in your account.
	SystemGroup []*SystemGroupRefInput `json:"systemGroup"`
	// VLAN ID matching criteria.
	Vlan []scalars.Vlan `json:"vlan"`
}

// Defines destinations for the socket LAN firewall.
type SocketLanFirewallDestinationUpdateInput struct {
	// Floating subnets used to identify traffic based on specific criteria.
	FloatingSubnet []*FloatingSubnetRefInput `json:"floatingSubnet,omitempty"`
	// Global IP ranges defined for your account.
	GlobalIPRange []*GlobalIPRangeRefInput `json:"globalIpRange,omitempty"`
	// Groups defined for your account.
	Group []*GroupRefInput `json:"group,omitempty"`
	// Hosts and servers defined for your account.
	Host []*HostRefInput `json:"host,omitempty"`
	// IPv4 addresses.
	IP []string `json:"ip,omitempty"`
	// Multiple separate IP addresses or an IP range.
	IPRange []*IPAddressRangeInput `json:"ipRange,omitempty"`
	// Network interfaces defined for your site.
	NetworkInterface []*NetworkInterfaceRefInput `json:"networkInterface,omitempty"`
	// Sites defined for your account.
	Site []*SiteRefInput `json:"site,omitempty"`
	// Subnets specific to a site defined for your account.
	SiteNetworkSubnet []*SiteNetworkSubnetRefInput `json:"siteNetworkSubnet,omitempty"`
	// Subnets to which traffic is directed.
	Subnet []string `json:"subnet,omitempty"`
	// Predefined system groups in your account.
	SystemGroup []*SystemGroupRefInput `json:"systemGroup,omitempty"`
	// VLAN ID matching criteria.
	Vlan []scalars.Vlan `json:"vlan,omitempty"`
}

type SocketLanFirewallPolicyMutations struct {
	AddRule    *SocketLanFirewallRuleMutationPayload `json:"addRule"`
	MoveRule   *SocketLanFirewallRuleMutationPayload `json:"moveRule"`
	RemoveRule *SocketLanFirewallRuleMutationPayload `json:"removeRule"`
	UpdateRule *SocketLanFirewallRuleMutationPayload `json:"updateRule"`
}

type SocketLanFirewallRemoveRuleInput struct {
	ID string `json:"id"`
}

type SocketLanFirewallRule struct {
	// Action to take when the rule is matched (ALLOW or BLOCK).
	Action SocketLanFirewallAction `json:"action"`
	// Application traffic matching criteria.
	Application *SocketLanFirewallApplication `json:"application"`
	// Description for the rule
	Description string `json:"description"`
	// Defines destinations for the socket LAN firewall.
	// Also, inherited by Network Rule above.
	Destination *SocketLanFirewallDestination `json:"destination"`
	// Direction of the traffic (TO or BOTH).
	Direction SocketLanFirewallDirection `json:"direction"`
	// TRUE = Rule is enabled
	//  FALSE = Rule is disabled
	Enabled bool `json:"enabled"`
	// Rule ID
	ID string `json:"id"`
	// Position / priority of rule
	Index int64 `json:"index"`
	// Name of the rule
	Name string `json:"name"`
	// Policy section where the rule is located
	Section *PolicySectionInfo `json:"section"`
	// Service traffic matching criteria.
	Service *SocketLanFirewallServiceType `json:"service"`
	// Defines sources for the socket LAN firewall.
	// Also, inherited by Network Rule above.
	Source *SocketLanFirewallSource `json:"source"`
	// Tracking information when the rule is matched, such as events and notifications.
	Tracking *PolicyTracking `json:"tracking"`
}

func (SocketLanFirewallRule) IsIPolicyRule() {}

// Rule ID
func (this SocketLanFirewallRule) GetID() string { return this.ID }

// Name of the rule
func (this SocketLanFirewallRule) GetName() string { return this.Name }

// Description for the rule
func (this SocketLanFirewallRule) GetDescription() *string { return &this.Description }

// Position / priority of rule
func (this SocketLanFirewallRule) GetIndex() int64 { return this.Index }

// TRUE = Rule is enabled, FALSE = Rule is disabled
func (this SocketLanFirewallRule) GetEnabled() bool { return this.Enabled }

// Policy section where the rule is located
func (this SocketLanFirewallRule) GetSection() *PolicySectionInfo { return this.Section }

type SocketLanFirewallRuleMutationPayload struct {
	Errors []*PolicyMutationError        `json:"errors"`
	Rule   *SocketLanFirewallRulePayload `json:"rule,omitempty"`
	Status PolicyMutationStatus          `json:"status"`
}

func (SocketLanFirewallRuleMutationPayload) IsIPolicyRuleMutationPayload() {}

// Returns settings for the rule
func (this SocketLanFirewallRuleMutationPayload) GetRule() IPolicyRulePayload { return *this.Rule }

// Enum for the status of the policy change
func (this SocketLanFirewallRuleMutationPayload) GetStatus() PolicyMutationStatus { return this.Status }

// List of errors related to the policy change
func (this SocketLanFirewallRuleMutationPayload) GetErrors() []*PolicyMutationError {
	if this.Errors == nil {
		return nil
	}
	interfaceSlice := make([]*PolicyMutationError, 0, len(this.Errors))
	for _, concrete := range this.Errors {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

type SocketLanFirewallRulePayload struct {
	Audit      *PolicyElementAudit           `json:"audit"`
	Properties []PolicyElementPropertiesEnum `json:"properties"`
	Rule       *SocketLanFirewallRule        `json:"rule"`
}

func (SocketLanFirewallRulePayload) IsIPolicyRulePayload()              {}
func (this SocketLanFirewallRulePayload) GetAudit() *PolicyElementAudit { return this.Audit }

// Rule that was changed
func (this SocketLanFirewallRulePayload) GetRule() IPolicyRule { return *this.Rule }

// Summary of rule change, (ie. ADDED, UPDATED)
func (this SocketLanFirewallRulePayload) GetProperties() []PolicyElementPropertiesEnum {
	if this.Properties == nil {
		return nil
	}
	interfaceSlice := make([]PolicyElementPropertiesEnum, 0, len(this.Properties))
	for _, concrete := range this.Properties {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

// Defines services used in the socket LAN firewall.
type SocketLanFirewallServiceType struct {
	// Custom services defined for this rule.
	Custom []*CustomService `json:"custom"`
	// Simple services allowed by the firewall rule.
	Simple []*SimpleService `json:"simple"`
	// Standard services allowed by the firewall rule.
	Standard []*ServiceRef `json:"standard"`
}

// Defines services used in the socket LAN firewall.
type SocketLanFirewallServiceTypeInput struct {
	// Custom services defined for this rule.
	Custom []*CustomServiceInput `json:"custom"`
	// Simple services allowed by the firewall rule.
	Simple []*SimpleServiceInput `json:"simple"`
	// Standard services allowed by the firewall rule.
	Standard []*ServiceRefInput `json:"standard"`
}

// Defines services used in the socket LAN firewall.
type SocketLanFirewallServiceTypeUpdateInput struct {
	// Custom services defined for this rule.
	Custom []*CustomServiceInput `json:"custom,omitempty"`
	// Simple services allowed by the firewall rule.
	Simple []*SimpleServiceInput `json:"simple,omitempty"`
	// Standard services allowed by the firewall rule.
	Standard []*ServiceRefInput `json:"standard,omitempty"`
}

// Defines sources for the socket LAN firewall.
type SocketLanFirewallSource struct {
	// Floating subnets used to identify traffic based on specific criteria.
	FloatingSubnet []*FloatingSubnetRef `json:"floatingSubnet"`
	// Global IP ranges defined for your account.
	GlobalIPRange []*GlobalIPRangeRef `json:"globalIpRange"`
	// Groups defined for your account.
	Group []*GroupRef `json:"group"`
	// Hosts and servers defined for your account.
	Host []*HostRef `json:"host"`
	// IPv4 addresses.
	IP []string `json:"ip"`
	// Multiple separate IP addresses or an IP range.
	IPRange []*IPAddressRange `json:"ipRange"`
	// MAC addresses of devices matching criteria.
	Mac []string `json:"mac"`
	// Network interfaces defined for your site.
	NetworkInterface []*NetworkInterfaceRef `json:"networkInterface"`
	// Sites defined for your account.
	Site []*SiteRef `json:"site"`
	// Subnets specific to a site defined for your account.
	SiteNetworkSubnet []*SiteNetworkSubnetRef `json:"siteNetworkSubnet"`
	// Subnets from which traffic originates.
	Subnet []string `json:"subnet"`
	// Predefined system groups in your account.
	SystemGroup []*SystemGroupRef `json:"systemGroup"`
	// VLAN ID matching criteria.
	Vlan []scalars.Vlan `json:"vlan"`
}

// Defines sources for the socket LAN firewall.
type SocketLanFirewallSourceInput struct {
	// Floating subnets used to identify traffic based on specific criteria.
	FloatingSubnet []*FloatingSubnetRefInput `json:"floatingSubnet"`
	// Global IP ranges defined for your account.
	GlobalIPRange []*GlobalIPRangeRefInput `json:"globalIpRange"`
	// Groups defined for your account.
	Group []*GroupRefInput `json:"group"`
	// Hosts and servers defined for your account.
	Host []*HostRefInput `json:"host"`
	// IPv4 addresses.
	IP []string `json:"ip"`
	// Multiple separate IP addresses or an IP range.
	IPRange []*IPAddressRangeInput `json:"ipRange"`
	// MAC addresses of devices matching criteria.
	Mac []string `json:"mac"`
	// Network interfaces defined for your site.
	NetworkInterface []*NetworkInterfaceRefInput `json:"networkInterface"`
	// Sites defined for your account.
	Site []*SiteRefInput `json:"site"`
	// Subnets specific to a site defined for your account.
	SiteNetworkSubnet []*SiteNetworkSubnetRefInput `json:"siteNetworkSubnet"`
	// Subnets from which traffic originates.
	Subnet []string `json:"subnet"`
	// Predefined system groups in your account.
	SystemGroup []*SystemGroupRefInput `json:"systemGroup"`
	// VLAN ID matching criteria.
	Vlan []scalars.Vlan `json:"vlan"`
}

// Defines sources for the socket LAN firewall.
type SocketLanFirewallSourceUpdateInput struct {
	// Floating subnets used to identify traffic based on specific criteria.
	FloatingSubnet []*FloatingSubnetRefInput `json:"floatingSubnet,omitempty"`
	// Global IP ranges defined for your account.
	GlobalIPRange []*GlobalIPRangeRefInput `json:"globalIpRange,omitempty"`
	// Groups defined for your account.
	Group []*GroupRefInput `json:"group,omitempty"`
	// Hosts and servers defined for your account.
	Host []*HostRefInput `json:"host,omitempty"`
	// IPv4 addresses.
	IP []string `json:"ip,omitempty"`
	// Multiple separate IP addresses or an IP range.
	IPRange []*IPAddressRangeInput `json:"ipRange,omitempty"`
	// MAC addresses of devices matching criteria.
	Mac []string `json:"mac,omitempty"`
	// Network interfaces defined for your site.
	NetworkInterface []*NetworkInterfaceRefInput `json:"networkInterface,omitempty"`
	// Sites defined for your account.
	Site []*SiteRefInput `json:"site,omitempty"`
	// Subnets specific to a site defined for your account.
	SiteNetworkSubnet []*SiteNetworkSubnetRefInput `json:"siteNetworkSubnet,omitempty"`
	// Subnets from which traffic originates.
	Subnet []string `json:"subnet,omitempty"`
	// Predefined system groups in your account.
	SystemGroup []*SystemGroupRefInput `json:"systemGroup,omitempty"`
	// VLAN ID matching criteria.
	Vlan []scalars.Vlan `json:"vlan,omitempty"`
}

type SocketLanFirewallUpdateRuleDataInput struct {
	// Action to take when the rule is matched (ALLOW or BLOCK).
	Action *SocketLanFirewallAction `json:"action,omitempty"`
	// Application traffic matching criteria.
	Application *SocketLanFirewallApplicationUpdateInput `json:"application,omitempty"`
	Description *string                                  `json:"description,omitempty"`
	// Defines destinations for the socket LAN firewall.
	// Also, inherited by Network Rule above.
	Destination *SocketLanFirewallDestinationUpdateInput `json:"destination,omitempty"`
	// Direction of the traffic (TO or BOTH).
	Direction *SocketLanFirewallDirection `json:"direction,omitempty"`
	Enabled   *bool                       `json:"enabled,omitempty"`
	Name      *string                     `json:"name,omitempty"`
	// Service traffic matching criteria.
	Service *SocketLanFirewallServiceTypeUpdateInput `json:"service,omitempty"`
	// Defines sources for the socket LAN firewall.
	// Also, inherited by Network Rule above.
	Source *SocketLanFirewallSourceUpdateInput `json:"source,omitempty"`
	// Tracking information when the rule is matched, such as events and notifications.
	Tracking *PolicyTrackingUpdateInput `json:"tracking,omitempty"`
}

type SocketLanFirewallUpdateRuleInput struct {
	ID   string                                `json:"id"`
	Rule *SocketLanFirewallUpdateRuleDataInput `json:"rule"`
}

// Defines NAT settings for the socket LAN policy.
type SocketLanNatSettings struct {
	// Indicates if NAT is enabled.
	Enabled bool             `json:"enabled"`
	NatType SocketLanNatType `json:"natType"`
}

// Defines NAT settings for the socket LAN policy.
type SocketLanNatSettingsInput struct {
	// Indicates if NAT is enabled.
	Enabled bool             `json:"enabled"`
	NatType SocketLanNatType `json:"natType"`
}

// Defines NAT settings for the socket LAN policy.
type SocketLanNatSettingsUpdateInput struct {
	// Indicates if NAT is enabled.
	Enabled *bool             `json:"enabled,omitempty"`
	NatType *SocketLanNatType `json:"natType,omitempty"`
}

type SocketLanPolicy struct {
	Audit    *PolicyAudit            `json:"audit,omitempty"`
	Enabled  bool                    `json:"enabled"`
	Revision *PolicyRevision         `json:"revision,omitempty"`
	Rules    []*SocketLanRulePayload `json:"rules"`
	Sections []*PolicySectionPayload `json:"sections"`
}

func (SocketLanPolicy) IsIPolicy() {}

// TRUE = Policy is enabled, FALSE = Policy is disabled
func (this SocketLanPolicy) GetEnabled() bool { return this.Enabled }

// Return list of rules in the policy
func (this SocketLanPolicy) GetRules() []IPolicyRulePayload {
	if this.Rules == nil {
		return nil
	}
	interfaceSlice := make([]IPolicyRulePayload, 0, len(this.Rules))
	for _, concrete := range this.Rules {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

// Return sections in the policy
func (this SocketLanPolicy) GetSections() []*PolicySectionPayload {
	if this.Sections == nil {
		return nil
	}
	interfaceSlice := make([]*PolicySectionPayload, 0, len(this.Sections))
	for _, concrete := range this.Sections {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

// Audit data for the policy
func (this SocketLanPolicy) GetAudit() *PolicyAudit { return this.Audit }

// Return data for the Policy revision
func (this SocketLanPolicy) GetRevision() *PolicyRevision { return this.Revision }

type SocketLanPolicyInput struct {
	// A revision is a specific instance of the policy.
	//  Unpublished revisions are working copies of the policy available to a specific
	//  admin or a set of admins
	//  Published revisions are revisions that were applied to the account network.
	//  The last published revision is the active policy.
	Revision *PolicyRevisionInput `json:"revision,omitempty"`
}

type SocketLanPolicyMutationInput struct {
	Revision *PolicyMutationRevisionInput `json:"revision,omitempty"`
}

type SocketLanPolicyMutationPayload struct {
	Errors []*PolicyMutationError `json:"errors"`
	Policy *SocketLanPolicy       `json:"policy,omitempty"`
	Status PolicyMutationStatus   `json:"status"`
}

func (SocketLanPolicyMutationPayload) IsIPolicyMutationPayload() {}

// Data for the policy
func (this SocketLanPolicyMutationPayload) GetPolicy() IPolicy { return *this.Policy }

// Enum for the status of the policy change
func (this SocketLanPolicyMutationPayload) GetStatus() PolicyMutationStatus { return this.Status }

// List of errors related to the policy change
func (this SocketLanPolicyMutationPayload) GetErrors() []*PolicyMutationError {
	if this.Errors == nil {
		return nil
	}
	interfaceSlice := make([]*PolicyMutationError, 0, len(this.Errors))
	for _, concrete := range this.Errors {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

type SocketLanPolicyMutations struct {
	AddRule               *SocketLanRuleMutationPayload     `json:"addRule"`
	AddSection            *PolicySectionMutationPayload     `json:"addSection"`
	CreatePolicyRevision  *SocketLanPolicyMutationPayload   `json:"createPolicyRevision"`
	DiscardPolicyRevision *SocketLanPolicyMutationPayload   `json:"discardPolicyRevision"`
	Firewall              *SocketLanFirewallPolicyMutations `json:"firewall"`
	MoveRule              *SocketLanRuleMutationPayload     `json:"moveRule"`
	MoveSection           *PolicySectionMutationPayload     `json:"moveSection"`
	PublishPolicyRevision *SocketLanPolicyMutationPayload   `json:"publishPolicyRevision"`
	RemoveRule            *SocketLanRuleMutationPayload     `json:"removeRule"`
	RemoveSection         *PolicySectionMutationPayload     `json:"removeSection"`
	UpdatePolicy          *SocketLanPolicyMutationPayload   `json:"updatePolicy"`
	UpdateRule            *SocketLanRuleMutationPayload     `json:"updateRule"`
	UpdateSection         *PolicySectionMutationPayload     `json:"updateSection"`
}

type SocketLanPolicyQueries struct {
	Policy    *SocketLanPolicy        `json:"policy"`
	Revisions *PolicyRevisionsPayload `json:"revisions,omitempty"`
}

type SocketLanPolicyUpdateInput struct {
	State *PolicyToggleState `json:"state,omitempty"`
}

type SocketLanRemoveRuleInput struct {
	ID string `json:"id"`
}

type SocketLanRule struct {
	// Description for the rule
	Description string `json:"description"`
	// Destination traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Destination *SocketLanDestination `json:"destination"`
	// Direction of the traffic initiator matching criteria.
	Direction SocketLanDirection `json:"direction"`
	// TRUE = Rule is enabled
	//  FALSE = Rule is disabled
	Enabled  bool                            `json:"enabled"`
	Firewall []*SocketLanFirewallRulePayload `json:"firewall"`
	// Rule ID
	ID string `json:"id"`
	// Position / priority of rule
	Index int64 `json:"index"`
	// Name of the rule
	Name string `json:"name"`
	// Optionally, enable NAT on the outgoing interface. This translates all originating IPs to one NAT IP.
	Nat *SocketLanNatSettings `json:"nat"`
	// Policy section where the rule is located
	Section *PolicySectionInfo `json:"section"`
	// Destination service matching criteria for the rule. Port/Protocol based.
	Service *SocketLanService `json:"service"`
	// The sites the policy will be enforced on.
	// Socket sites only, with Socket v22 onwards.
	Site *SocketLanSite `json:"site"`
	// Source traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Source *SocketLanSource `json:"source"`
	// The transport of the matching traffic.
	// Either govern traffic to be routed locally (LAN), or to the PoP(WAN).
	// Traffic is send to the WAN by default.
	// Traffic routed in the LAN, enforced by the LAN Firewall rules.
	Transport SocketLanTransportType `json:"transport"`
}

func (SocketLanRule) IsIPolicyRule() {}

// Rule ID
func (this SocketLanRule) GetID() string { return this.ID }

// Name of the rule
func (this SocketLanRule) GetName() string { return this.Name }

// Description for the rule
func (this SocketLanRule) GetDescription() *string { return &this.Description }

// Position / priority of rule
func (this SocketLanRule) GetIndex() int64 { return this.Index }

// TRUE = Rule is enabled, FALSE = Rule is disabled
func (this SocketLanRule) GetEnabled() bool { return this.Enabled }

// Policy section where the rule is located
func (this SocketLanRule) GetSection() *PolicySectionInfo { return this.Section }

type SocketLanRuleMutationPayload struct {
	Errors []*PolicyMutationError `json:"errors"`
	Rule   *SocketLanRulePayload  `json:"rule,omitempty"`
	Status PolicyMutationStatus   `json:"status"`
}

func (SocketLanRuleMutationPayload) IsIPolicyRuleMutationPayload() {}

// Returns settings for the rule
func (this SocketLanRuleMutationPayload) GetRule() IPolicyRulePayload { return *this.Rule }

// Enum for the status of the policy change
func (this SocketLanRuleMutationPayload) GetStatus() PolicyMutationStatus { return this.Status }

// List of errors related to the policy change
func (this SocketLanRuleMutationPayload) GetErrors() []*PolicyMutationError {
	if this.Errors == nil {
		return nil
	}
	interfaceSlice := make([]*PolicyMutationError, 0, len(this.Errors))
	for _, concrete := range this.Errors {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

type SocketLanRulePayload struct {
	Audit      *PolicyElementAudit           `json:"audit"`
	Properties []PolicyElementPropertiesEnum `json:"properties"`
	Rule       *SocketLanRule                `json:"rule"`
}

func (SocketLanRulePayload) IsIPolicyRulePayload()              {}
func (this SocketLanRulePayload) GetAudit() *PolicyElementAudit { return this.Audit }

// Rule that was changed
func (this SocketLanRulePayload) GetRule() IPolicyRule { return *this.Rule }

// Summary of rule change, (ie. ADDED, UPDATED)
func (this SocketLanRulePayload) GetProperties() []PolicyElementPropertiesEnum {
	if this.Properties == nil {
		return nil
	}
	interfaceSlice := make([]PolicyElementPropertiesEnum, 0, len(this.Properties))
	for _, concrete := range this.Properties {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

// Defines services used in the socket LAN policy.
type SocketLanService struct {
	// Custom Port/Protocol service.
	Custom []*CustomService `json:"custom"`
	// List of L4 based services.
	Simple []*SimpleService `json:"simple"`
}

// Defines services used in the socket LAN policy.
type SocketLanServiceInput struct {
	// Custom Port/Protocol service.
	Custom []*CustomServiceInput `json:"custom"`
	// List of L4 based services.
	Simple []*SimpleServiceInput `json:"simple"`
}

// Defines services used in the socket LAN policy.
type SocketLanServiceUpdateInput struct {
	// Custom Port/Protocol service.
	Custom []*CustomServiceInput `json:"custom,omitempty"`
	// List of L4 based services.
	Simple []*SimpleServiceInput `json:"simple,omitempty"`
}

// Represents the site configurations in the socket LAN policy.
type SocketLanSite struct {
	// The group of sites the policy will be enforced on.
	// Socket sites only, with Socket v22 onwards.
	Group []*GroupRef `json:"group"`
	// The sites the policy will be enforced on.
	// Socket sites only, with Socket v22 onwards.
	Site []*SiteRef `json:"site"`
}

// Represents the site configurations in the socket LAN policy.
type SocketLanSiteInput struct {
	// The group of sites the policy will be enforced on.
	// Socket sites only, with Socket v22 onwards.
	Group []*GroupRefInput `json:"group"`
	// The sites the policy will be enforced on.
	// Socket sites only, with Socket v22 onwards.
	Site []*SiteRefInput `json:"site"`
}

// Represents the site configurations in the socket LAN policy.
type SocketLanSiteUpdateInput struct {
	// The group of sites the policy will be enforced on.
	// Socket sites only, with Socket v22 onwards.
	Group []*GroupRefInput `json:"group,omitempty"`
	// The sites the policy will be enforced on.
	// Socket sites only, with Socket v22 onwards.
	Site []*SiteRefInput `json:"site,omitempty"`
}

// Defines sources for the socket LAN policy.
type SocketLanSource struct {
	// Floating Subnets (ie. Floating Ranges) are used to identify traffic exactly matched to the route advertised by BGP.
	// They are not associated with a specific site.
	// This is useful in scenarios such as active-standby high availability routed via BGP.
	FloatingSubnet []*FloatingSubnetRef `json:"floatingSubnet"`
	// Globally defined IP range, IP and subnet objects.
	GlobalIPRange []*GlobalIPRangeRef `json:"globalIpRange"`
	// Predefined Cato groups, Socket sites/objects only.
	Group []*GroupRef `json:"group"`
	// Hosts and servers defined for your under Socket sites.
	Host []*HostRef `json:"host"`
	// IP address.
	IP []string `json:"ip"`
	// Multiple separate IP addresses or an IP range.
	IPRange []*IPAddressRange `json:"ipRange"`
	// Network range defined for a site.
	NetworkInterface []*NetworkInterfaceRef `json:"networkInterface"`
	// GlobalRange + InterfaceSubnet
	SiteNetworkSubnet []*SiteNetworkSubnetRef `json:"siteNetworkSubnet"`
	// Subnets and network ranges defined for the LAN interfaces of a site.
	Subnet []string `json:"subnet"`
	// Predefined Cato groups.
	SystemGroup []*SystemGroupRef `json:"systemGroup"`
	// VLAN ID matching criteria.
	Vlan []scalars.Vlan `json:"vlan"`
}

// Defines sources for the socket LAN policy.
type SocketLanSourceInput struct {
	// Floating Subnets (ie. Floating Ranges) are used to identify traffic exactly matched to the route advertised by BGP.
	// They are not associated with a specific site.
	// This is useful in scenarios such as active-standby high availability routed via BGP.
	FloatingSubnet []*FloatingSubnetRefInput `json:"floatingSubnet"`
	// Globally defined IP range, IP and subnet objects.
	GlobalIPRange []*GlobalIPRangeRefInput `json:"globalIpRange"`
	// Predefined Cato groups, Socket sites/objects only.
	Group []*GroupRefInput `json:"group"`
	// Hosts and servers defined for your under Socket sites.
	Host []*HostRefInput `json:"host"`
	// IP address.
	IP []string `json:"ip"`
	// Multiple separate IP addresses or an IP range.
	IPRange []*IPAddressRangeInput `json:"ipRange"`
	// Network range defined for a site.
	NetworkInterface []*NetworkInterfaceRefInput `json:"networkInterface"`
	// GlobalRange + InterfaceSubnet
	SiteNetworkSubnet []*SiteNetworkSubnetRefInput `json:"siteNetworkSubnet"`
	// Subnets and network ranges defined for the LAN interfaces of a site.
	Subnet []string `json:"subnet"`
	// Predefined Cato groups.
	SystemGroup []*SystemGroupRefInput `json:"systemGroup"`
	// VLAN ID matching criteria.
	Vlan []scalars.Vlan `json:"vlan"`
}

// Defines sources for the socket LAN policy.
type SocketLanSourceUpdateInput struct {
	// Floating Subnets (ie. Floating Ranges) are used to identify traffic exactly matched to the route advertised by BGP.
	// They are not associated with a specific site.
	// This is useful in scenarios such as active-standby high availability routed via BGP.
	FloatingSubnet []*FloatingSubnetRefInput `json:"floatingSubnet,omitempty"`
	// Globally defined IP range, IP and subnet objects.
	GlobalIPRange []*GlobalIPRangeRefInput `json:"globalIpRange,omitempty"`
	// Predefined Cato groups, Socket sites/objects only.
	Group []*GroupRefInput `json:"group,omitempty"`
	// Hosts and servers defined for your under Socket sites.
	Host []*HostRefInput `json:"host,omitempty"`
	// IP address.
	IP []string `json:"ip,omitempty"`
	// Multiple separate IP addresses or an IP range.
	IPRange []*IPAddressRangeInput `json:"ipRange,omitempty"`
	// Network range defined for a site.
	NetworkInterface []*NetworkInterfaceRefInput `json:"networkInterface,omitempty"`
	// GlobalRange + InterfaceSubnet
	SiteNetworkSubnet []*SiteNetworkSubnetRefInput `json:"siteNetworkSubnet,omitempty"`
	// Subnets and network ranges defined for the LAN interfaces of a site.
	Subnet []string `json:"subnet,omitempty"`
	// Predefined Cato groups.
	SystemGroup []*SystemGroupRefInput `json:"systemGroup,omitempty"`
	// VLAN ID matching criteria.
	Vlan []scalars.Vlan `json:"vlan,omitempty"`
}

type SocketLanUpdateRuleDataInput struct {
	Description *string `json:"description,omitempty"`
	// Destination traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Destination *SocketLanDestinationUpdateInput `json:"destination,omitempty"`
	// Direction of the traffic initiator matching criteria.
	Direction *SocketLanDirection `json:"direction,omitempty"`
	Enabled   *bool               `json:"enabled,omitempty"`
	Name      *string             `json:"name,omitempty"`
	// Optionally, enable NAT on the outgoing interface. This translates all originating IPs to one NAT IP.
	Nat *SocketLanNatSettingsUpdateInput `json:"nat,omitempty"`
	// Destination service matching criteria for the rule. Port/Protocol based.
	Service *SocketLanServiceUpdateInput `json:"service,omitempty"`
	// The sites the policy will be enforced on.
	// Socket sites only, with Socket v22 onwards.
	Site *SocketLanSiteUpdateInput `json:"site,omitempty"`
	// Source traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Source *SocketLanSourceUpdateInput `json:"source,omitempty"`
	// The transport of the matching traffic.
	// Either govern traffic to be routed locally (LAN), or to the PoP(WAN).
	// Traffic is send to the WAN by default.
	// Traffic routed in the LAN, enforced by the LAN Firewall rules.
	Transport *SocketLanTransportType `json:"transport,omitempty"`
}

type SocketLanUpdateRuleInput struct {
	ID   string                        `json:"id"`
	Rule *SocketLanUpdateRuleDataInput `json:"rule"`
}

type SocketPortMetrics struct {
	From    *string                    `json:"from,omitempty"`
	ID      *string                    `json:"id,omitempty"`
	Records []*SocketPortMetricsRecord `json:"records,omitempty"`
	To      *string                    `json:"to,omitempty"`
	Total   *int64                     `json:"total,omitempty"`
	Totals  map[string]any             `json:"totals,omitempty"`
}

type SocketPortMetricsDimension struct {
	FieldName SocketPortMetricsFieldName `json:"fieldName"`
}

type SocketPortMetricsField struct {
	Name  SocketPortMetricsFieldName `json:"name"`
	Value Value                      `json:"value"`
}

type SocketPortMetricsFilter struct {
	FieldName SocketPortMetricsFieldName `json:"fieldName"`
	Operator  FilterOperator             `json:"operator"`
	Values    []string                   `json:"values"`
}

type SocketPortMetricsMeasure struct {
	AggType   AggregationType            `json:"aggType"`
	FieldName SocketPortMetricsFieldName `json:"fieldName"`
	Trend     *bool                      `json:"trend,omitempty"`
}

type SocketPortMetricsRecord struct {
	Fields []*SocketPortMetricsField `json:"fields,omitempty"`
	// fields in map format (see Map scalar)
	FieldsMap       map[string]any `json:"fieldsMap,omitempty"`
	FieldsUnitTypes []UnitType     `json:"fieldsUnitTypes,omitempty"`
	PrevTimeFrame   map[string]any `json:"prevTimeFrame,omitempty"`
	Trends          map[string]any `json:"trends,omitempty"`
}

type SocketPortMetricsSort struct {
	FieldName SocketPortMetricsFieldName `json:"fieldName"`
	Order     DirectionEnum              `json:"order"`
}

type SocketPortMetricsTimeSeries struct {
	From        *string       `json:"from,omitempty"`
	Granularity *int64        `json:"granularity,omitempty"`
	ID          *string       `json:"id,omitempty"`
	Timeseries  []*Timeseries `json:"timeseries,omitempty"`
	To          *string       `json:"to,omitempty"`
}

type SortInput struct {
	Field *string         `json:"field,omitempty"`
	Order *DirectionInput `json:"order,omitempty"`
}

type SortOrderInput struct {
	Direction SortOrder `json:"direction"`
	Priority  int64     `json:"priority"`
}

// Input for bulk site upgrade requests.
type StartSiteUpgradeInput struct {
	Upgrades []*SiteUpgradeRequest `json:"upgrades"`
}

// Wrapper for site upgrade response.
type StartSiteUpgradePayload struct {
	// List of individual site upgrade results.
	Results []*SiteUpgradeInfo `json:"results"`
}

type StoriesData struct {
	// Fields returned from the Story query
	Items []*Story `json:"items"`
	// Define the stories that are returned, similar to a page of stories in the Cato Management Application
	Paging *Paging `json:"paging"`
}

type Story struct {
	// ID for your Cato account
	AccountID int64 `json:"accountId"`
	// Name of the account in the Cato Management Application
	AccountName *string `json:"accountName,omitempty"`
	// Email address of the analyst working on the story
	AnalystEmail *string `json:"analystEmail,omitempty"`
	// Name of analyst working on the story
	AnalystName *string `json:"analystName,omitempty"`
	// Timestamp when the story was created
	CreatedAt string `json:"createdAt"`
	// Unique Cato ID for each story
	ID string `json:"id"`
	// Data related to the fields and incidents that were merged to create or update the story
	Incident MergedIncident `json:"incident"`
	// URL for the playbook in the Knowledge Base to help troubleshoot the story
	Playbook *string `json:"playbook,omitempty"`
	// Summary of the story
	Summary *string `json:"summary,omitempty"`
	// Data for the story timeline
	Timeline []*TimelineItem `json:"timeline"`
	// Timestamp when the story was most recently updated
	UpdatedAt string `json:"updatedAt"`
}

type StoryComment struct {
	Actor     ActorRef     `json:"actor"`
	CreatedAt scalars.Time `json:"createdAt"`
	ID        string       `json:"id"`
	Text      string       `json:"text"`
}

type StoryDrillDownFilter struct {
	Name   string   `json:"name"`
	Value  string   `json:"value"`
	Values []string `json:"values"`
}

type StoryFilterInput struct {
	AccountID   *AccountIDPredicate     `json:"accountId,omitempty"`
	Criticality *IntPredicate           `json:"criticality,omitempty"`
	EngineType  *EngineTypePredicate    `json:"engineType,omitempty"`
	IncidentID  *StringPredicate        `json:"incidentId,omitempty"`
	Ioa         *StringPredicate        `json:"ioa,omitempty"`
	Muted       *BooleanPredicate       `json:"muted,omitempty"`
	Producer    *StoryProducerPredicate `json:"producer,omitempty"`
	QueryName   *StringPredicate        `json:"queryName,omitempty"`
	Severity    *StorySeverityPredicate `json:"severity,omitempty"`
	Source      *StringPredicate        `json:"source,omitempty"`
	SourceIP    *StringPredicate        `json:"sourceIp,omitempty"`
	Status      *StoryStatusPredicate   `json:"status,omitempty"`
	StoryID     *StoryIDPredicate       `json:"storyId,omitempty"`
	TimeFrame   *TimeFramePredicate     `json:"timeFrame"`
	Vendor      *VendorPredicate        `json:"vendor,omitempty"`
	Verdict     *StoryVerdictPredicate  `json:"verdict,omitempty"`
}

type StoryIDPredicate struct {
	In    []string `json:"in,omitempty"`
	NotIn []string `json:"not_in,omitempty"`
}

type StoryInput struct {
	Filter []*StoryFilterInput `json:"filter"`
	Paging *PagingInput        `json:"paging"`
	Sort   []*StorySortInput   `json:"sort,omitempty"`
}

type StoryProducerPredicate struct {
	In    []StoryProducerEnum `json:"in,omitempty"`
	NotIn []StoryProducerEnum `json:"not_in,omitempty"`
}

type StorySeverityPredicate struct {
	In    []SeverityEnum `json:"in,omitempty"`
	NotIn []SeverityEnum `json:"not_in,omitempty"`
}

type StorySortInput struct {
	FieldName StorySortFieldName `json:"fieldName"`
	Order     *SortDirectionEnum `json:"order,omitempty"`
}

type StoryStatusPredicate struct {
	In    []StoryStatusEnum `json:"in,omitempty"`
	NotIn []StoryStatusEnum `json:"not_in,omitempty"`
}

type StoryThreatType struct {
	Details           *string `json:"details,omitempty"`
	Name              string  `json:"name"`
	RecommendedAction *string `json:"recommendedAction,omitempty"`
}

type StoryVerdictPredicate struct {
	In    []StoryVerdictEnum `json:"in,omitempty"`
	NotIn []StoryVerdictEnum `json:"not_in,omitempty"`
}

type StringFilterInput struct {
	Eq  *string  `json:"eq,omitempty"`
	In  []string `json:"in,omitempty"`
	Neq *string  `json:"neq,omitempty"`
	Nin []string `json:"nin,omitempty"`
}

type StringPredicate struct {
	Contains *string   `json:"contains,omitempty"`
	In       []*string `json:"in,omitempty"`
	NotIn    []*string `json:"not_in,omitempty"`
}

type StringValue struct {
	String *string `json:"string,omitempty"`
}

func (StringValue) IsValue() {}

type StringValueSetRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (StringValueSetRef) IsObjectRef() {}

// Object's unique identifier
func (this StringValueSetRef) GetID() string { return this.ID }

// Object's unique name
func (this StringValueSetRef) GetName() string { return this.Name }

type StringValueSetRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

type SubDomain struct {
	AccountID   string `json:"accountId"`
	AccountName string `json:"accountName"`
	AccountType string `json:"accountType"`
	SubDomain   string `json:"subDomain"`
}

// A reference identifying the SubscriptionGroup object. ID: Unique SubscriptionGroup Identifier, Name: The SubscriptionGroup Name
type SubscriptionGroupRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (SubscriptionGroupRef) IsObjectRef() {}

// Object's unique identifier
func (this SubscriptionGroupRef) GetID() string { return this.ID }

// Object's unique name
func (this SubscriptionGroupRef) GetName() string { return this.Name }

type SubscriptionGroupRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

// A reference identifying the SubscriptionMailingList object. ID: Unique SubscriptionMailingList Identifier, Name: The SubscriptionMailingList Name
type SubscriptionMailingListRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (SubscriptionMailingListRef) IsObjectRef() {}

// Object's unique identifier
func (this SubscriptionMailingListRef) GetID() string { return this.ID }

// Object's unique name
func (this SubscriptionMailingListRef) GetName() string { return this.Name }

type SubscriptionMailingListRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

// A reference identifying the SubscriptionWebhook object. ID: Unique SubscriptionWebhook Identifier, Name: The SubscriptionWebhook Name
type SubscriptionWebhookRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (SubscriptionWebhookRef) IsObjectRef() {}

// Object's unique identifier
func (this SubscriptionWebhookRef) GetID() string { return this.ID }

// Object's unique name
func (this SubscriptionWebhookRef) GetName() string { return this.Name }

type SubscriptionWebhookRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

// A reference identifying the SystemGroup object. ID: Unique SystemGroup Identifier, Name: The SystemGroup Name
type SystemGroupRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (SystemGroupRef) IsObjectRef() {}

// Object's unique identifier
func (this SystemGroupRef) GetID() string { return this.ID }

// Object's unique name
func (this SystemGroupRef) GetName() string { return this.Name }

type SystemGroupRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

type TaggingMethodFilterInput struct {
	Eq  *TaggingMethod  `json:"eq,omitempty"`
	In  []TaggingMethod `json:"in,omitempty"`
	Neq *TaggingMethod  `json:"neq,omitempty"`
	Nin []TaggingMethod `json:"nin,omitempty"`
}

type TerminalServerAddRuleDataInput struct {
	// Allowed Host IP range.
	// all the other IPs will be blocked by the pop.
	// Globally defined IP range
	AllowedHostIP *GlobalIPRangeRefInput `json:"allowedHostIP"`
	Description   string                 `json:"description"`
	Enabled       bool                   `json:"enabled"`
	// Exclude traffic IP Range.
	// all traffic to those Ips will be excluded from the GRE tunnel.
	// Globally defined IP range
	ExcludeTraffic []*GlobalIPRangeRefInput `json:"excludeTraffic"`
	Name           string                   `json:"name"`
}

type TerminalServerAddRuleInput struct {
	// Position of the rule in the policy
	At *PolicyRulePositionInput `json:"at,omitempty"`
	// Parameters for the rule you are adding
	Rule *TerminalServerAddRuleDataInput `json:"rule"`
}

type TerminalServerPolicy struct {
	Audit    *PolicyAudit                 `json:"audit,omitempty"`
	Enabled  bool                         `json:"enabled"`
	Revision *PolicyRevision              `json:"revision,omitempty"`
	Rules    []*TerminalServerRulePayload `json:"rules"`
	Sections []*PolicySectionPayload      `json:"sections"`
}

func (TerminalServerPolicy) IsIPolicy() {}

// TRUE = Policy is enabled, FALSE = Policy is disabled
func (this TerminalServerPolicy) GetEnabled() bool { return this.Enabled }

// Return list of rules in the policy
func (this TerminalServerPolicy) GetRules() []IPolicyRulePayload {
	if this.Rules == nil {
		return nil
	}
	interfaceSlice := make([]IPolicyRulePayload, 0, len(this.Rules))
	for _, concrete := range this.Rules {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

// Return sections in the policy
func (this TerminalServerPolicy) GetSections() []*PolicySectionPayload {
	if this.Sections == nil {
		return nil
	}
	interfaceSlice := make([]*PolicySectionPayload, 0, len(this.Sections))
	for _, concrete := range this.Sections {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

// Audit data for the policy
func (this TerminalServerPolicy) GetAudit() *PolicyAudit { return this.Audit }

// Return data for the Policy revision
func (this TerminalServerPolicy) GetRevision() *PolicyRevision { return this.Revision }

type TerminalServerPolicyInput struct {
	// A revision is a specific instance of the policy.
	//  Unpublished revisions are working copies of the policy available to a specific
	//  admin or a set of admins
	//  Published revisions are revisions that were applied to the account network.
	//  The last published revision is the active policy.
	Revision *PolicyRevisionInput `json:"revision,omitempty"`
}

type TerminalServerPolicyMutationInput struct {
	Revision *PolicyMutationRevisionInput `json:"revision,omitempty"`
}

type TerminalServerPolicyMutationPayload struct {
	Errors []*PolicyMutationError `json:"errors"`
	Policy *TerminalServerPolicy  `json:"policy,omitempty"`
	Status PolicyMutationStatus   `json:"status"`
}

func (TerminalServerPolicyMutationPayload) IsIPolicyMutationPayload() {}

// Data for the policy
func (this TerminalServerPolicyMutationPayload) GetPolicy() IPolicy { return *this.Policy }

// Enum for the status of the policy change
func (this TerminalServerPolicyMutationPayload) GetStatus() PolicyMutationStatus { return this.Status }

// List of errors related to the policy change
func (this TerminalServerPolicyMutationPayload) GetErrors() []*PolicyMutationError {
	if this.Errors == nil {
		return nil
	}
	interfaceSlice := make([]*PolicyMutationError, 0, len(this.Errors))
	for _, concrete := range this.Errors {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

type TerminalServerPolicyMutations struct {
	AddRule               *TerminalServerRuleMutationPayload   `json:"addRule"`
	AddSection            *PolicySectionMutationPayload        `json:"addSection"`
	CreatePolicyRevision  *TerminalServerPolicyMutationPayload `json:"createPolicyRevision"`
	DiscardPolicyRevision *TerminalServerPolicyMutationPayload `json:"discardPolicyRevision"`
	MoveRule              *TerminalServerRuleMutationPayload   `json:"moveRule"`
	MoveSection           *PolicySectionMutationPayload        `json:"moveSection"`
	PublishPolicyRevision *TerminalServerPolicyMutationPayload `json:"publishPolicyRevision"`
	RemoveRule            *TerminalServerRuleMutationPayload   `json:"removeRule"`
	RemoveSection         *PolicySectionMutationPayload        `json:"removeSection"`
	UpdatePolicy          *TerminalServerPolicyMutationPayload `json:"updatePolicy"`
	UpdateRule            *TerminalServerRuleMutationPayload   `json:"updateRule"`
	UpdateSection         *PolicySectionMutationPayload        `json:"updateSection"`
}

type TerminalServerPolicyQueries struct {
	Policy    *TerminalServerPolicy   `json:"policy"`
	Revisions *PolicyRevisionsPayload `json:"revisions,omitempty"`
}

type TerminalServerPolicyUpdateInput struct {
	State *PolicyToggleState `json:"state,omitempty"`
}

type TerminalServerRemoveRuleInput struct {
	ID string `json:"id"`
}

type TerminalServerRule struct {
	// Allowed Host IP range.
	// all the other IPs will be blocked by the pop.
	// Globally defined IP range
	AllowedHostIP *GlobalIPRangeRef `json:"allowedHostIP"`
	// Description for the rule
	Description string `json:"description"`
	// TRUE = Rule is enabled
	//  FALSE = Rule is disabled
	Enabled bool `json:"enabled"`
	// Exclude traffic IP Range.
	// all traffic to those Ips will be excluded from the GRE tunnel.
	// Globally defined IP range
	ExcludeTraffic []*GlobalIPRangeRef `json:"excludeTraffic"`
	// Rule ID
	ID string `json:"id"`
	// Position / priority of rule
	Index int64 `json:"index"`
	// Name of the rule
	Name string `json:"name"`
	// Policy section where the rule is located
	Section *PolicySectionInfo `json:"section"`
}

func (TerminalServerRule) IsIPolicyRule() {}

// Rule ID
func (this TerminalServerRule) GetID() string { return this.ID }

// Name of the rule
func (this TerminalServerRule) GetName() string { return this.Name }

// Description for the rule
func (this TerminalServerRule) GetDescription() *string { return &this.Description }

// Position / priority of rule
func (this TerminalServerRule) GetIndex() int64 { return this.Index }

// TRUE = Rule is enabled, FALSE = Rule is disabled
func (this TerminalServerRule) GetEnabled() bool { return this.Enabled }

// Policy section where the rule is located
func (this TerminalServerRule) GetSection() *PolicySectionInfo { return this.Section }

type TerminalServerRuleMutationPayload struct {
	Errors []*PolicyMutationError     `json:"errors"`
	Rule   *TerminalServerRulePayload `json:"rule,omitempty"`
	Status PolicyMutationStatus       `json:"status"`
}

func (TerminalServerRuleMutationPayload) IsIPolicyRuleMutationPayload() {}

// Returns settings for the rule
func (this TerminalServerRuleMutationPayload) GetRule() IPolicyRulePayload { return *this.Rule }

// Enum for the status of the policy change
func (this TerminalServerRuleMutationPayload) GetStatus() PolicyMutationStatus { return this.Status }

// List of errors related to the policy change
func (this TerminalServerRuleMutationPayload) GetErrors() []*PolicyMutationError {
	if this.Errors == nil {
		return nil
	}
	interfaceSlice := make([]*PolicyMutationError, 0, len(this.Errors))
	for _, concrete := range this.Errors {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

type TerminalServerRulePayload struct {
	Audit      *PolicyElementAudit           `json:"audit"`
	Properties []PolicyElementPropertiesEnum `json:"properties"`
	Rule       *TerminalServerRule           `json:"rule"`
}

func (TerminalServerRulePayload) IsIPolicyRulePayload()              {}
func (this TerminalServerRulePayload) GetAudit() *PolicyElementAudit { return this.Audit }

// Rule that was changed
func (this TerminalServerRulePayload) GetRule() IPolicyRule { return *this.Rule }

// Summary of rule change, (ie. ADDED, UPDATED)
func (this TerminalServerRulePayload) GetProperties() []PolicyElementPropertiesEnum {
	if this.Properties == nil {
		return nil
	}
	interfaceSlice := make([]PolicyElementPropertiesEnum, 0, len(this.Properties))
	for _, concrete := range this.Properties {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

type TerminalServerUpdateRuleDataInput struct {
	// Allowed Host IP range.
	// all the other IPs will be blocked by the pop.
	// Globally defined IP range
	AllowedHostIP *GlobalIPRangeRefInput `json:"allowedHostIP,omitempty"`
	Description   *string                `json:"description,omitempty"`
	Enabled       *bool                  `json:"enabled,omitempty"`
	// Exclude traffic IP Range.
	// all traffic to those Ips will be excluded from the GRE tunnel.
	// Globally defined IP range
	ExcludeTraffic []*GlobalIPRangeRefInput `json:"excludeTraffic,omitempty"`
	Name           *string                  `json:"name,omitempty"`
}

type TerminalServerUpdateRuleInput struct {
	ID   string                             `json:"id"`
	Rule *TerminalServerUpdateRuleDataInput `json:"rule"`
}

// The "Threat" object represents a comprehensive data structure used in GraphQL queries or mutations to encapsulate various attributes and metadata related to a threat incident, including details about the threat's origin, nature, risk assessment, and associated network traffic flows.
type Threat struct {
	// Fields related to analysts research of the threat incident
	AnalystFeedback *AnalystFeedback `json:"analystFeedback,omitempty"`
	// Client Class for the traffic flow
	ClientClass []string `json:"clientClass"`
	// Connection for this incident
	ConnectionType *ConnectionTypeEnum `json:"connectionType,omitempty"`
	// Cato's risk analysis of the story. Values are from 1 (low risk) to 10 (high risk)
	Criticality *int64 `json:"criticality,omitempty"`
	// Description of the threat
	Description *string `json:"description,omitempty"`
	// Name of the device
	DeviceName *string `json:"deviceName,omitempty"`
	// Traffic direction for the threat
	Direction *string `json:"direction,omitempty"`
	// XDR engine involved with the incident
	EngineType *StoryEngineTypeEnum `json:"engineType,omitempty"`
	// Data for the Cato event for this story
	Events []*Event `json:"events,omitempty"`
	// Timestamp for the first incident signal related to this story
	FirstSignal string `json:"firstSignal"`
	// Data about the traffic flow for the threat
	Flows []*IncidentFlow `json:"flows,omitempty"`
	// Cardinality of traffic flows for the threat
	FlowsCardinality *int64 `json:"flowsCardinality,omitempty"`
	// Unique Cato ID for this threat
	ID string `json:"id"`
	// An indication is a set of actions and behaviors for the Network or Security incident. Each producer has different indications.
	Indication string `json:"indication"`
	// Timestamp for the first incident signal related to this story
	LastSignal string `json:"lastSignal"`
	// Username for the device
	LogonName *string `json:"logonName,omitempty"`
	// MAC address of the device
	MacAddress *string `json:"macAddress,omitempty"`
	// Mitre data for the story (ie. ID, name)
	Mitres []*Mitre `json:"mitres,omitempty"`
	// OS for device or host that is the threat target
	Os *string `json:"os,omitempty"`
	// Predicted threat type for the story based on Cato algorithm
	PredictedThreatType *string `json:"predictedThreatType,omitempty"`
	// Predicted verdict of the story based on Cato algorithm
	PredictedVerdict *StoryVerdictEnum `json:"predictedVerdict,omitempty"`
	// Producer (specific XDR engine and service) involved with the incident
	Producer StoryProducerEnum `json:"producer"`
	// Full name of the Producer (specific XDR engine and service) involved with the incident
	ProducerName string `json:"producerName"`
	// Category for the indication ID related to the story
	QueryName *string `json:"queryName,omitempty"`
	// The value is TRUE when the story is currently being researched by Security Analysts
	Research *bool `json:"research,omitempty"`
	// The estimated risk level of the threat (ie. Malicious, High, Low)
	RiskLevel *RiskLevelEnum `json:"riskLevel,omitempty"`
	// Data for stories that are similar
	SimilarStoriesData []*SimilarStoryData `json:"similarStoriesData"`
	// Cato ID and name for the site
	Site *SiteRef `json:"site,omitempty"`
	// Site name related to the story
	SiteName *string `json:"siteName,omitempty"`
	// IP address, name of device, or SDP user on your network involved in the story
	Source *string `json:"source,omitempty"`
	// The source IP address of the device in your network sending or receiving the flow
	SourceIP *string `json:"sourceIp,omitempty"`
	// Cato ID for the site that is the source of the threat
	SrcSiteID *string `json:"srcSiteId,omitempty"`
	// Status of this story
	Status *StoryStatusEnum `json:"status,omitempty"`
	// Amount of time since the story was opened (no value for closed stories)
	StoryDuration *int64 `json:"storyDuration,omitempty"`
	// Data about the target of the threat
	Targets []*IncidentTargetRep `json:"targets"`
	// The ticket an analyst created for this story
	Ticket *string `json:"ticket,omitempty"`
	// Timeseries data for the incident
	TimeSeries []*IncidentTimeseries `json:"timeSeries,omitempty"`
	// Cato ID and name for the user
	User *UserRef `json:"user,omitempty"`
	// Vendor that identified the incident, such as Cato or Microsoft
	Vendor *VendorEnum `json:"vendor,omitempty"`
}

func (Threat) IsMergedIncident() {}

// Unique Cato ID for each story
func (this Threat) GetID() string { return this.ID }

// Timestamp for the first incident signal related to this story
func (this Threat) GetFirstSignal() string { return this.FirstSignal }

// Timestamp for the last (most recent) incident signal related to this story
func (this Threat) GetLastSignal() string { return this.LastSignal }

// XDR engine involved with the incident
func (this Threat) GetEngineType() *StoryEngineTypeEnum { return this.EngineType }

// Vendor that identified the incident, such as Cato or Microsoft
func (this Threat) GetVendor() *VendorEnum { return this.Vendor }

// Producer (specific XDR engine and service) involved with the incident
func (this Threat) GetProducer() StoryProducerEnum { return this.Producer }

// Full name of the Producer (specific XDR engine and service) involved with the incident
func (this Threat) GetProducerName() string { return this.ProducerName }

// Connection for the incident
func (this Threat) GetConnectionType() *ConnectionTypeEnum { return this.ConnectionType }

// An indication is a set of actions and behaviors for the Network or Security incident. Each producer has different indications.
func (this Threat) GetIndication() string { return this.Indication }

// Category for the indication ID related to the story
func (this Threat) GetQueryName() *string { return this.QueryName }

// For Network stories - The potential impact of the issue on your network. Values are from 1 (low impact) to 10 (high impact)
//
// For Security stories - Cato's risk analysis of the story. Values are from 1 (low risk) to 10 (high risk)
func (this Threat) GetCriticality() *int64 { return this.Criticality }

// For Network stories - The site where the network issue is occurring
//
// For Security stories - IP address, name of device, or SDP user on your network involved in the story
func (this Threat) GetSource() *string { return this.Source }

// The ticket an analyst created for this story
func (this Threat) GetTicket() *string { return this.Ticket }

// Status for the story
func (this Threat) GetStatus() *StoryStatusEnum { return this.Status }

// The value is TRUE when the story is currently being researched by Security Analysts
func (this Threat) GetResearch() *bool { return this.Research }

// Site name related to the story
func (this Threat) GetSiteName() *string { return this.SiteName }

// Amount of time since the story was opened (no value for closed stories)
func (this Threat) GetStoryDuration() *int64 { return this.StoryDuration }

// For Security stories, description of the threat
func (this Threat) GetDescription() *string { return this.Description }

// The source IP address of the device in your network sending or receiving the flow
func (this Threat) GetSourceIP() *string { return this.SourceIP }

// Fields related to analysts research of the threat incident
func (this Threat) GetAnalystFeedback() *AnalystFeedback { return this.AnalystFeedback }

// Cato ID and name for the site
func (this Threat) GetSite() *SiteRef { return this.Site }

// Cato ID and name for the user
func (this Threat) GetUser() *UserRef                      { return this.User }
func (this Threat) GetPredictedVerdict() *StoryVerdictEnum { return this.PredictedVerdict }
func (this Threat) GetPredictedThreatType() *string        { return this.PredictedThreatType }

// The `ThreatPrevention` object is a GraphQL type that represents the details of a threat prevention incident, including fields such as analyst feedback, client class, connection type, criticality, description, device name, and various other attributes related to the incident's signals, events, and status.
type ThreatPrevention struct {
	AnalystFeedback         *AnalystFeedback          `json:"analystFeedback,omitempty"`
	ClientClass             []string                  `json:"clientClass"`
	ConnectionType          *ConnectionTypeEnum       `json:"connectionType,omitempty"`
	Criticality             *int64                    `json:"criticality,omitempty"`
	Description             *string                   `json:"description,omitempty"`
	DeviceName              *string                   `json:"deviceName,omitempty"`
	Direction               *string                   `json:"direction,omitempty"`
	EngineType              *StoryEngineTypeEnum      `json:"engineType,omitempty"`
	Events                  []*Event                  `json:"events,omitempty"`
	FirstSignal             string                    `json:"firstSignal"`
	FlowsCardinality        *int64                    `json:"flowsCardinality,omitempty"`
	ID                      string                    `json:"id"`
	Indication              string                    `json:"indication"`
	LastSignal              string                    `json:"lastSignal"`
	LogonName               *string                   `json:"logonName,omitempty"`
	MacAddress              *string                   `json:"macAddress,omitempty"`
	Mitres                  []*Mitre                  `json:"mitres,omitempty"`
	Os                      *string                   `json:"os,omitempty"`
	PredictedThreatType     *string                   `json:"predictedThreatType,omitempty"`
	PredictedVerdict        *StoryVerdictEnum         `json:"predictedVerdict,omitempty"`
	Producer                StoryProducerEnum         `json:"producer"`
	ProducerName            string                    `json:"producerName"`
	QueryName               *string                   `json:"queryName,omitempty"`
	Research                *bool                     `json:"research,omitempty"`
	RiskLevel               *RiskLevelEnum            `json:"riskLevel,omitempty"`
	SimilarStoriesData      []*SimilarStoryData       `json:"similarStoriesData"`
	Site                    *SiteRef                  `json:"site,omitempty"`
	SiteName                *string                   `json:"siteName,omitempty"`
	Source                  *string                   `json:"source,omitempty"`
	SourceIP                *string                   `json:"sourceIp,omitempty"`
	SrcSiteID               *string                   `json:"srcSiteId,omitempty"`
	Status                  *StoryStatusEnum          `json:"status,omitempty"`
	StoryDuration           *int64                    `json:"storyDuration,omitempty"`
	Targets                 []*IncidentTargetRep      `json:"targets"`
	ThreatPreventionsEvents []*ThreatPreventionEvents `json:"threatPreventionsEvents,omitempty"`
	Ticket                  *string                   `json:"ticket,omitempty"`
	TimeSeries              []*IncidentTimeseries     `json:"timeSeries,omitempty"`
	User                    *UserRef                  `json:"user,omitempty"`
	Vendor                  *VendorEnum               `json:"vendor,omitempty"`
}

func (ThreatPrevention) IsMergedIncident() {}

// Unique Cato ID for each story
func (this ThreatPrevention) GetID() string { return this.ID }

// Timestamp for the first incident signal related to this story
func (this ThreatPrevention) GetFirstSignal() string { return this.FirstSignal }

// Timestamp for the last (most recent) incident signal related to this story
func (this ThreatPrevention) GetLastSignal() string { return this.LastSignal }

// XDR engine involved with the incident
func (this ThreatPrevention) GetEngineType() *StoryEngineTypeEnum { return this.EngineType }

// Vendor that identified the incident, such as Cato or Microsoft
func (this ThreatPrevention) GetVendor() *VendorEnum { return this.Vendor }

// Producer (specific XDR engine and service) involved with the incident
func (this ThreatPrevention) GetProducer() StoryProducerEnum { return this.Producer }

// Full name of the Producer (specific XDR engine and service) involved with the incident
func (this ThreatPrevention) GetProducerName() string { return this.ProducerName }

// Connection for the incident
func (this ThreatPrevention) GetConnectionType() *ConnectionTypeEnum { return this.ConnectionType }

// An indication is a set of actions and behaviors for the Network or Security incident. Each producer has different indications.
func (this ThreatPrevention) GetIndication() string { return this.Indication }

// Category for the indication ID related to the story
func (this ThreatPrevention) GetQueryName() *string { return this.QueryName }

// For Network stories - The potential impact of the issue on your network. Values are from 1 (low impact) to 10 (high impact)
//
// For Security stories - Cato's risk analysis of the story. Values are from 1 (low risk) to 10 (high risk)
func (this ThreatPrevention) GetCriticality() *int64 { return this.Criticality }

// For Network stories - The site where the network issue is occurring
//
// For Security stories - IP address, name of device, or SDP user on your network involved in the story
func (this ThreatPrevention) GetSource() *string { return this.Source }

// The ticket an analyst created for this story
func (this ThreatPrevention) GetTicket() *string { return this.Ticket }

// Status for the story
func (this ThreatPrevention) GetStatus() *StoryStatusEnum { return this.Status }

// The value is TRUE when the story is currently being researched by Security Analysts
func (this ThreatPrevention) GetResearch() *bool { return this.Research }

// Site name related to the story
func (this ThreatPrevention) GetSiteName() *string { return this.SiteName }

// Amount of time since the story was opened (no value for closed stories)
func (this ThreatPrevention) GetStoryDuration() *int64 { return this.StoryDuration }

// For Security stories, description of the threat
func (this ThreatPrevention) GetDescription() *string { return this.Description }

// The source IP address of the device in your network sending or receiving the flow
func (this ThreatPrevention) GetSourceIP() *string { return this.SourceIP }

// Fields related to analysts research of the threat incident
func (this ThreatPrevention) GetAnalystFeedback() *AnalystFeedback { return this.AnalystFeedback }

// Cato ID and name for the site
func (this ThreatPrevention) GetSite() *SiteRef { return this.Site }

// Cato ID and name for the user
func (this ThreatPrevention) GetUser() *UserRef                      { return this.User }
func (this ThreatPrevention) GetPredictedVerdict() *StoryVerdictEnum { return this.PredictedVerdict }
func (this ThreatPrevention) GetPredictedThreatType() *string        { return this.PredictedThreatType }

type ThreatPreventionEvents struct {
	AppName                *string `json:"appName,omitempty"`
	ClientClass            *string `json:"clientClass,omitempty"`
	CreatedAt              *string `json:"createdAt,omitempty"`
	DestinationCountry     *string `json:"destinationCountry,omitempty"`
	DestinationGeolocation *string `json:"destinationGeolocation,omitempty"`
	DestinationIP          *string `json:"destinationIp,omitempty"`
	DestinationPort        *int64  `json:"destinationPort,omitempty"`
	Direction              *string `json:"direction,omitempty"`
	DNSResponseIP          *string `json:"dnsResponseIP,omitempty"`
	Domain                 *string `json:"domain,omitempty"`
	FileHash               *string `json:"fileHash,omitempty"`
	HTTPResponseCode       *int64  `json:"httpResponseCode,omitempty"`
	Ja3                    *string `json:"ja3,omitempty"`
	Method                 *string `json:"method,omitempty"`
	Referrer               *string `json:"referrer,omitempty"`
	SmbFileName            *string `json:"smbFileName,omitempty"`
	SourceGeolocation      *string `json:"sourceGeolocation,omitempty"`
	SourceIP               *string `json:"sourceIp,omitempty"`
	SourcePort             *int64  `json:"sourcePort,omitempty"`
	Target                 *string `json:"target,omitempty"`
	TunnelGeolocation      *string `json:"tunnelGeolocation,omitempty"`
	URL                    *string `json:"url,omitempty"`
	User                   *string `json:"user,omitempty"`
	UserAgent              *string `json:"userAgent,omitempty"`
}

// Threat Prevention (TP) license details
type ThreatPreventionLicense struct {
	Description *string `json:"description,omitempty"`
	// License expiration date
	ExpirationDate string `json:"expirationDate"`
	// The unique identifier for the license. If this value is not available, you can contact Cato Support, who may be able to assist in retrieving it.
	ID *string `json:"id,omitempty"`
	// The date of the last update to the license
	LastUpdated *string `json:"lastUpdated,omitempty"`
	// License plan type
	Plan LicensePlan `json:"plan"`
	// The license SKU
	Sku LicenseSku `json:"sku"`
	// License start date
	StartDate *string `json:"startDate,omitempty"`
	// License activation status
	Status LicenseStatus `json:"status"`
}

func (ThreatPreventionLicense) IsLicense() {}

// The unique identifier for the license. If this value is not available, you can contact Cato Support, who may be able to assist in retrieving it.
func (this ThreatPreventionLicense) GetID() *string          { return this.ID }
func (this ThreatPreventionLicense) GetDescription() *string { return this.Description }

// License plan type
func (this ThreatPreventionLicense) GetPlan() LicensePlan { return this.Plan }

// The license SKU
func (this ThreatPreventionLicense) GetSku() LicenseSku { return this.Sku }

// License activation status
func (this ThreatPreventionLicense) GetStatus() LicenseStatus { return this.Status }

// License start date
func (this ThreatPreventionLicense) GetStartDate() *string { return this.StartDate }

// License expiration date
func (this ThreatPreventionLicense) GetExpirationDate() string { return this.ExpirationDate }

// The date of the last update to the license
func (this ThreatPreventionLicense) GetLastUpdated() *string { return this.LastUpdated }

// An object for marking specific events in time.
type TimeAnnotation struct {
	// Description of the event
	Label string `json:"label"`
	// Brief description of the event
	ShortLabel string `json:"shortLabel"`
	// Timestamp of the event
	Time float64 `json:"time"`
	// Type identifies which annotation this is: e.g. connectivity, rolechange, missingdata, which allows
	// charts to attach to it.
	Type AnnotationType `json:"type"`
}

type TimeFramePredicate struct {
	Time              string             `json:"time"`
	TimeFrameModifier *TimeFrameModifier `json:"timeFrameModifier,omitempty"`
}

// An object for marking durations!
type TimePeriod struct {
	// An tuple of two numbers representing  start time, end time in ms since epoch, start bucket index, end bucket index
	Duration []float64 `json:"duration"`
	// Label that describes the metrics
	Title string `json:"title"`
	// Type identifies which annotation this is: e.g. connectivity, rolechange, missingdata, which allows
	// charts to attach to it.
	Type PeriodType `json:"type"`
}

type TimeSeriesEvents struct {
	AccountID  string                  `json:"accountID"`
	Buckets    int64                   `json:"buckets"`
	Dimensions []*GraphEventsDimension `json:"dimensions"`
	Filters    []*GraphEventsFilter    `json:"filters"`
	Measures   []*GraphEventsMeasure   `json:"measures"`
	TimeFrame  string                  `json:"timeFrame"`
}

// For XDR stories, items that happened during the lifetime of the story
type TimelineItem struct {
	// Additional information about this timeline item
	AdditionalInfo *string `json:"additionalInfo,omitempty"`
	// Data about the analyst for this timeline item (ie. name, email)
	AnalystInfo *AnalystInfo `json:"analystInfo,omitempty"`
	// Icon for the timeline item
	Category *TimelineItemCategoryEnum `json:"category,omitempty"`
	// Brief summary of action related to the timeline item (ie. Story created, Status update to)
	Context string `json:"context"`
	// Timestamp the timeline item was created
	CreatedAt string `json:"createdAt"`
	// Description of the timeline item
	Description string `json:"description"`
	// Description of the timeline item
	Descriptions []string `json:"descriptions"`
	// Type of threat assigned by the analyst
	Type TimelineTypeEnum `json:"type"`
}

type Timeseries struct {
	// Data is an array of tuples, each containing two values:  [timestamp, metric], where the timestamp is in
	// milliseconds from the epoch (1.1.1970), and the metric is a number (according to the unit type)
	Data [][]float64 `json:"data,omitempty"`
	// List of dimension values for this timeseries
	Dimensions []*DimensionData `json:"dimensions,omitempty"`
	// Specific information about the timeseries, used to build its name, title etc
	Info []string `json:"info,omitempty"`
	// Timeseries key: measure and dimension values
	Key *TimeseriesKey `json:"key,omitempty"`
	// Indicates the type of the timeseries
	Label string `json:"label"`
	// Summary of the metrics over the given time frame
	Sum *float64 `json:"sum,omitempty"`
	// Identifies what unit of data this timeseries represents. Note that toRate is only available for particular types
	// of data to make sense.
	Units *UnitType `json:"units,omitempty"`
}

type TimeseriesKey struct {
	// List of dimension key-value pair for this timeseries key
	Dimensions []*DimensionKey `json:"dimensions,omitempty"`
	// Measure field
	MeasureFieldName string `json:"measureFieldName"`
}

type TLSInspectAddRuleDataInput struct {
	// Action to be taken on the traffic.
	Action TLSInspectAction `json:"action"`
	// Application matching criteria for.
	Application *TLSInspectApplicationInput `json:"application"`
	// Connection origin of the traffic
	ConnectionOrigin ConnectionOriginEnum `json:"connectionOrigin"`
	// Country traffic matching criteria.
	Country     []*CountryRefInput `json:"country"`
	Description string             `json:"description"`
	// Device Profile traffic matching criteria.
	DevicePostureProfile []*DeviceProfileRefInput `json:"devicePostureProfile"`
	Enabled              bool                     `json:"enabled"`
	Name                 string                   `json:"name"`
	// Operating System traffic matching criteria.
	Platform []OperatingSystem `json:"platform"`
	// Source traffic matching criteria.
	Source *TLSInspectSourceInput `json:"source"`
	// Action to be taken on the traffic when an untrusted certificate is detected.
	UntrustedCertificateAction TLSInspectUntrustedCertificateAction `json:"untrustedCertificateAction"`
}

type TLSInspectAddRuleInput struct {
	// Position of the rule in the policy
	At *PolicyRulePositionInput `json:"at,omitempty"`
	// Parameters for the rule you are adding
	Rule *TLSInspectAddRuleDataInput `json:"rule"`
}

// Application match criteria set
type TLSInspectApplication struct {
	// Cato category of applications which are dynamically updated by Cato
	AppCategory []*ApplicationCategoryRef `json:"appCategory"`
	// Applications for the rule (pre-defined)
	Application []*ApplicationRef `json:"application"`
	// Countries matching criteria for the rule
	Country []*CountryRef `json:"country"`
	// Custom (user-defined) applications
	CustomApp []*CustomApplicationRef `json:"customApp"`
	// Custom Categories – Groups of objects such as predefined and custom applications, predefined and custom services, domains, FQDNs etc.
	CustomCategory []*CustomCategoryRef `json:"customCategory"`
	// Returns data for Custom Service defined by a combination of L4 ports and an IP Protocol Example: TCP/80, UDP/53
	CustomService []*CustomService `json:"customService"`
	// Returns data for Custom Service defined by a combination of L4 ports and an IP Protocol Example: google:8.8.8.8
	CustomServiceIP []*CustomServiceIP `json:"customServiceIp"`
	// A Second-Level Domain (SLD).
	// It matches all Top-Level Domains (TLD), and subdomains that include the Domain.
	// Example: example.com.
	Domain []string `json:"domain"`
	// An exact match of the fully qualified domain (FQDN). Example: www.my.example.com.
	Fqdn []string `json:"fqdn"`
	// Globally defined IP range, IP and subnet objects
	GlobalIPRange []*GlobalIPRangeRef `json:"globalIpRange"`
	// IPv4 addresses
	IP []string `json:"ip"`
	// A range of IPs. Every IP within the range will be matched
	IPRange []*IPAddressRange `json:"ipRange"`
	// Remote Autonomous System Number (ASN)
	RemoteAsn []scalars.Asn32 `json:"remoteAsn"`
	// Add the Service Type to which this TLS inspection rule applies
	Service []*ServiceRef `json:"service"`
	// Subnets and network ranges defined for the LAN interfaces of a site
	Subnet []string `json:"subnet"`
	// System categories for TLS inspection policy
	TLSInspectCategory []TLSInspectSystemCategory `json:"tlsInspectCategory"`
}

// Application match criteria set
type TLSInspectApplicationInput struct {
	// Cato category of applications which are dynamically updated by Cato
	AppCategory []*ApplicationCategoryRefInput `json:"appCategory"`
	// Applications for the rule (pre-defined)
	Application []*ApplicationRefInput `json:"application"`
	// Countries matching criteria for the rule
	Country []*CountryRefInput `json:"country"`
	// Custom (user-defined) applications
	CustomApp []*CustomApplicationRefInput `json:"customApp"`
	// Custom Categories – Groups of objects such as predefined and custom applications, predefined and custom services, domains, FQDNs etc.
	CustomCategory []*CustomCategoryRefInput `json:"customCategory"`
	// Returns data for Custom Service defined by a combination of L4 ports and an IP Protocol Example: TCP/80, UDP/53
	CustomService []*CustomServiceInput `json:"customService"`
	// Returns data for Custom Service defined by a combination of L4 ports and an IP Protocol Example: google:8.8.8.8
	CustomServiceIP []*CustomServiceIPInput `json:"customServiceIp"`
	// A Second-Level Domain (SLD).
	// It matches all Top-Level Domains (TLD), and subdomains that include the Domain.
	// Example: example.com.
	Domain []string `json:"domain"`
	// An exact match of the fully qualified domain (FQDN). Example: www.my.example.com.
	Fqdn []string `json:"fqdn"`
	// Globally defined IP range, IP and subnet objects
	GlobalIPRange []*GlobalIPRangeRefInput `json:"globalIpRange"`
	// IPv4 addresses
	IP []string `json:"ip"`
	// A range of IPs. Every IP within the range will be matched
	IPRange []*IPAddressRangeInput `json:"ipRange"`
	// Remote Autonomous System Number (ASN)
	RemoteAsn []scalars.Asn32 `json:"remoteAsn"`
	// Add the Service Type to which this TLS inspection rule applies
	Service []*ServiceRefInput `json:"service"`
	// Subnets and network ranges defined for the LAN interfaces of a site
	Subnet []string `json:"subnet"`
	// System categories for TLS inspection policy
	TLSInspectCategory []TLSInspectSystemCategory `json:"tlsInspectCategory"`
}

// Application match criteria set
type TLSInspectApplicationUpdateInput struct {
	// Cato category of applications which are dynamically updated by Cato
	AppCategory []*ApplicationCategoryRefInput `json:"appCategory,omitempty"`
	// Applications for the rule (pre-defined)
	Application []*ApplicationRefInput `json:"application,omitempty"`
	// Countries matching criteria for the rule
	Country []*CountryRefInput `json:"country,omitempty"`
	// Custom (user-defined) applications
	CustomApp []*CustomApplicationRefInput `json:"customApp,omitempty"`
	// Custom Categories – Groups of objects such as predefined and custom applications, predefined and custom services, domains, FQDNs etc.
	CustomCategory []*CustomCategoryRefInput `json:"customCategory,omitempty"`
	// Returns data for Custom Service defined by a combination of L4 ports and an IP Protocol Example: TCP/80, UDP/53
	CustomService []*CustomServiceInput `json:"customService,omitempty"`
	// Returns data for Custom Service defined by a combination of L4 ports and an IP Protocol Example: google:8.8.8.8
	CustomServiceIP []*CustomServiceIPInput `json:"customServiceIp,omitempty"`
	// A Second-Level Domain (SLD).
	// It matches all Top-Level Domains (TLD), and subdomains that include the Domain.
	// Example: example.com.
	Domain []string `json:"domain,omitempty"`
	// An exact match of the fully qualified domain (FQDN). Example: www.my.example.com.
	Fqdn []string `json:"fqdn,omitempty"`
	// Globally defined IP range, IP and subnet objects
	GlobalIPRange []*GlobalIPRangeRefInput `json:"globalIpRange,omitempty"`
	// IPv4 addresses
	IP []string `json:"ip,omitempty"`
	// A range of IPs. Every IP within the range will be matched
	IPRange []*IPAddressRangeInput `json:"ipRange,omitempty"`
	// Remote Autonomous System Number (ASN)
	RemoteAsn []scalars.Asn32 `json:"remoteAsn,omitempty"`
	// Add the Service Type to which this TLS inspection rule applies
	Service []*ServiceRefInput `json:"service,omitempty"`
	// Subnets and network ranges defined for the LAN interfaces of a site
	Subnet []string `json:"subnet,omitempty"`
	// System categories for TLS inspection policy
	TLSInspectCategory []TLSInspectSystemCategory `json:"tlsInspectCategory,omitempty"`
}

// Default rule settings for the TLS Inspection policy
type TLSInspectConfig struct {
	// Action to take on traffic that matches the default rule
	DefaultRuleAction TLSInspectAction `json:"defaultRuleAction"`
	// Action to take when an untrusted certificate is detected for traffic matching the default rule
	DefaultRuleUntrustedCertificateAction TLSInspectUntrustedCertificateAction `json:"defaultRuleUntrustedCertificateAction"`
}

type TLSInspectConfigInput struct {
	// Action to take on traffic that matches the default rule
	DefaultRuleAction TLSInspectAction `json:"defaultRuleAction"`
	// Action to take when an untrusted certificate is detected for traffic matching the default rule
	DefaultRuleUntrustedCertificateAction TLSInspectUntrustedCertificateAction `json:"defaultRuleUntrustedCertificateAction"`
}

type TLSInspectPolicy struct {
	AdditionalAttributes *TLSInspectConfig        `json:"additionalAttributes,omitempty"`
	Audit                *PolicyAudit             `json:"audit,omitempty"`
	Enabled              bool                     `json:"enabled"`
	Revision             *PolicyRevision          `json:"revision,omitempty"`
	Rules                []*TLSInspectRulePayload `json:"rules"`
	Sections             []*PolicySectionPayload  `json:"sections"`
}

func (TLSInspectPolicy) IsIPolicy() {}

// TRUE = Policy is enabled, FALSE = Policy is disabled
func (this TLSInspectPolicy) GetEnabled() bool { return this.Enabled }

// Return list of rules in the policy
func (this TLSInspectPolicy) GetRules() []IPolicyRulePayload {
	if this.Rules == nil {
		return nil
	}
	interfaceSlice := make([]IPolicyRulePayload, 0, len(this.Rules))
	for _, concrete := range this.Rules {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

// Return sections in the policy
func (this TLSInspectPolicy) GetSections() []*PolicySectionPayload {
	if this.Sections == nil {
		return nil
	}
	interfaceSlice := make([]*PolicySectionPayload, 0, len(this.Sections))
	for _, concrete := range this.Sections {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

// Audit data for the policy
func (this TLSInspectPolicy) GetAudit() *PolicyAudit { return this.Audit }

// Return data for the Policy revision
func (this TLSInspectPolicy) GetRevision() *PolicyRevision { return this.Revision }

type TLSInspectPolicyInput struct {
	// A revision is a specific instance of the policy.
	//  Unpublished revisions are working copies of the policy available to a specific
	//  admin or a set of admins
	//  Published revisions are revisions that were applied to the account network.
	//  The last published revision is the active policy.
	Revision *PolicyRevisionInput `json:"revision,omitempty"`
}

type TLSInspectPolicyMutationInput struct {
	Revision *PolicyMutationRevisionInput `json:"revision,omitempty"`
}

type TLSInspectPolicyMutationPayload struct {
	Errors []*PolicyMutationError `json:"errors"`
	Policy *TLSInspectPolicy      `json:"policy,omitempty"`
	Status PolicyMutationStatus   `json:"status"`
}

func (TLSInspectPolicyMutationPayload) IsIPolicyMutationPayload() {}

// Data for the policy
func (this TLSInspectPolicyMutationPayload) GetPolicy() IPolicy { return *this.Policy }

// Enum for the status of the policy change
func (this TLSInspectPolicyMutationPayload) GetStatus() PolicyMutationStatus { return this.Status }

// List of errors related to the policy change
func (this TLSInspectPolicyMutationPayload) GetErrors() []*PolicyMutationError {
	if this.Errors == nil {
		return nil
	}
	interfaceSlice := make([]*PolicyMutationError, 0, len(this.Errors))
	for _, concrete := range this.Errors {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

type TLSInspectPolicyMutations struct {
	AddRule               *TLSInspectRuleMutationPayload   `json:"addRule"`
	AddSection            *PolicySectionMutationPayload    `json:"addSection"`
	CreatePolicyRevision  *TLSInspectPolicyMutationPayload `json:"createPolicyRevision"`
	DiscardPolicyRevision *TLSInspectPolicyMutationPayload `json:"discardPolicyRevision"`
	MoveRule              *TLSInspectRuleMutationPayload   `json:"moveRule"`
	MoveSection           *PolicySectionMutationPayload    `json:"moveSection"`
	PublishPolicyRevision *TLSInspectPolicyMutationPayload `json:"publishPolicyRevision"`
	RemoveRule            *TLSInspectRuleMutationPayload   `json:"removeRule"`
	RemoveSection         *PolicySectionMutationPayload    `json:"removeSection"`
	UpdatePolicy          *TLSInspectPolicyMutationPayload `json:"updatePolicy"`
	UpdateRule            *TLSInspectRuleMutationPayload   `json:"updateRule"`
	UpdateSection         *PolicySectionMutationPayload    `json:"updateSection"`
}

type TLSInspectPolicyQueries struct {
	Policy    *TLSInspectPolicy       `json:"policy"`
	Revisions *PolicyRevisionsPayload `json:"revisions,omitempty"`
}

type TLSInspectPolicyUpdateInput struct {
	AdditionalAttributes *TLSInspectConfigInput `json:"additionalAttributes,omitempty"`
	State                *PolicyToggleState     `json:"state,omitempty"`
}

type TLSInspectRemoveRuleInput struct {
	ID string `json:"id"`
}

type TLSInspectRule struct {
	// Action to be taken on the traffic.
	Action TLSInspectAction `json:"action"`
	// Application matching criteria for.
	Application *TLSInspectApplication `json:"application"`
	// Connection origin of the traffic
	ConnectionOrigin ConnectionOriginEnum `json:"connectionOrigin"`
	// Country traffic matching criteria.
	Country []*CountryRef `json:"country"`
	// Description for the rule
	Description string `json:"description"`
	// Device Profile traffic matching criteria.
	DevicePostureProfile []*DeviceProfileRef `json:"devicePostureProfile"`
	// TRUE = Rule is enabled
	//  FALSE = Rule is disabled
	Enabled bool `json:"enabled"`
	// Rule ID
	ID string `json:"id"`
	// Position / priority of rule
	Index int64 `json:"index"`
	// Name of the rule
	Name string `json:"name"`
	// Operating System traffic matching criteria.
	Platform []OperatingSystem `json:"platform"`
	// Policy section where the rule is located
	Section *PolicySectionInfo `json:"section"`
	// Source traffic matching criteria.
	Source *TLSInspectSource `json:"source"`
	// Action to be taken on the traffic when an untrusted certificate is detected.
	UntrustedCertificateAction TLSInspectUntrustedCertificateAction `json:"untrustedCertificateAction"`
}

func (TLSInspectRule) IsIPolicyRule() {}

// Rule ID
func (this TLSInspectRule) GetID() string { return this.ID }

// Name of the rule
func (this TLSInspectRule) GetName() string { return this.Name }

// Description for the rule
func (this TLSInspectRule) GetDescription() *string { return &this.Description }

// Position / priority of rule
func (this TLSInspectRule) GetIndex() int64 { return this.Index }

// TRUE = Rule is enabled, FALSE = Rule is disabled
func (this TLSInspectRule) GetEnabled() bool { return this.Enabled }

// Policy section where the rule is located
func (this TLSInspectRule) GetSection() *PolicySectionInfo { return this.Section }

type TLSInspectRuleMutationPayload struct {
	Errors []*PolicyMutationError `json:"errors"`
	Rule   *TLSInspectRulePayload `json:"rule,omitempty"`
	Status PolicyMutationStatus   `json:"status"`
}

func (TLSInspectRuleMutationPayload) IsIPolicyRuleMutationPayload() {}

// Returns settings for the rule
func (this TLSInspectRuleMutationPayload) GetRule() IPolicyRulePayload { return *this.Rule }

// Enum for the status of the policy change
func (this TLSInspectRuleMutationPayload) GetStatus() PolicyMutationStatus { return this.Status }

// List of errors related to the policy change
func (this TLSInspectRuleMutationPayload) GetErrors() []*PolicyMutationError {
	if this.Errors == nil {
		return nil
	}
	interfaceSlice := make([]*PolicyMutationError, 0, len(this.Errors))
	for _, concrete := range this.Errors {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

type TLSInspectRulePayload struct {
	Audit      *PolicyElementAudit           `json:"audit"`
	Properties []PolicyElementPropertiesEnum `json:"properties"`
	Rule       *TLSInspectRule               `json:"rule"`
}

func (TLSInspectRulePayload) IsIPolicyRulePayload()              {}
func (this TLSInspectRulePayload) GetAudit() *PolicyElementAudit { return this.Audit }

// Rule that was changed
func (this TLSInspectRulePayload) GetRule() IPolicyRule { return *this.Rule }

// Summary of rule change, (ie. ADDED, UPDATED)
func (this TLSInspectRulePayload) GetProperties() []PolicyElementPropertiesEnum {
	if this.Properties == nil {
		return nil
	}
	interfaceSlice := make([]PolicyElementPropertiesEnum, 0, len(this.Properties))
	for _, concrete := range this.Properties {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

// Returns the settings for Source of an TLS inspection rule
type TLSInspectSource struct {
	// Floating Subnets (ie. Floating Ranges) are used to identify traffic exactly matched to the route advertised by BGP.
	// They are not associated with a specific site.
	// This is useful in scenarios such as active-standby high availability routed via BGP.
	FloatingSubnet []*FloatingSubnetRef `json:"floatingSubnet"`
	// Globally defined IP range, IP and subnet objects
	GlobalIPRange []*GlobalIPRangeRef `json:"globalIpRange"`
	// Groups defined for your account
	Group []*GroupRef `json:"group"`
	// Hosts and servers defined for your account
	Host []*HostRef `json:"host"`
	// IPv4 addresses
	IP []string `json:"ip"`
	// Multiple separate IP addresses or an IP range
	IPRange []*IPAddressRange `json:"ipRange"`
	// Network range defined for a site
	NetworkInterface []*NetworkInterfaceRef `json:"networkInterface"`
	// Site defined for the account
	Site []*SiteRef `json:"site"`
	// GlobalRange + InterfaceSubnet
	SiteNetworkSubnet []*SiteNetworkSubnetRef `json:"siteNetworkSubnet"`
	// Subnets and network ranges defined for the LAN interfaces of a site
	Subnet []string `json:"subnet"`
	// Predefined Cato groups
	SystemGroup []*SystemGroupRef `json:"systemGroup"`
	// Individual users defined for the account
	User []*UserRef `json:"user"`
	// Group of users
	UsersGroup []*UsersGroupRef `json:"usersGroup"`
}

// Input of the settings for Source of an TLS inspection rule
type TLSInspectSourceInput struct {
	// Floating Subnets (ie. Floating Ranges) are used to identify traffic exactly matched to the route advertised by BGP.
	// They are not associated with a specific site.
	// This is useful in scenarios such as active-standby high availability routed via BGP.
	FloatingSubnet []*FloatingSubnetRefInput `json:"floatingSubnet"`
	// Globally defined IP range, IP and subnet objects
	GlobalIPRange []*GlobalIPRangeRefInput `json:"globalIpRange"`
	// Groups defined for your account
	Group []*GroupRefInput `json:"group"`
	// Hosts and servers defined for your account
	Host []*HostRefInput `json:"host"`
	// IPv4 addresses
	IP []string `json:"ip"`
	// Multiple separate IP addresses or an IP range
	IPRange []*IPAddressRangeInput `json:"ipRange"`
	// Network range defined for a site
	NetworkInterface []*NetworkInterfaceRefInput `json:"networkInterface"`
	// Site defined for the account
	Site []*SiteRefInput `json:"site"`
	// GlobalRange + InterfaceSubnet
	SiteNetworkSubnet []*SiteNetworkSubnetRefInput `json:"siteNetworkSubnet"`
	// Subnets and network ranges defined for the LAN interfaces of a site
	Subnet []string `json:"subnet"`
	// Predefined Cato groups
	SystemGroup []*SystemGroupRefInput `json:"systemGroup"`
	// Individual users defined for the account
	User []*UserRefInput `json:"user"`
	// Group of users
	UsersGroup []*UsersGroupRefInput `json:"usersGroup"`
}

// Input of the settings for Source of an TLS inspection rule
type TLSInspectSourceUpdateInput struct {
	// Floating Subnets (ie. Floating Ranges) are used to identify traffic exactly matched to the route advertised by BGP.
	// They are not associated with a specific site.
	// This is useful in scenarios such as active-standby high availability routed via BGP.
	FloatingSubnet []*FloatingSubnetRefInput `json:"floatingSubnet,omitempty"`
	// Globally defined IP range, IP and subnet objects
	GlobalIPRange []*GlobalIPRangeRefInput `json:"globalIpRange,omitempty"`
	// Groups defined for your account
	Group []*GroupRefInput `json:"group,omitempty"`
	// Hosts and servers defined for your account
	Host []*HostRefInput `json:"host,omitempty"`
	// IPv4 addresses
	IP []string `json:"ip,omitempty"`
	// Multiple separate IP addresses or an IP range
	IPRange []*IPAddressRangeInput `json:"ipRange,omitempty"`
	// Network range defined for a site
	NetworkInterface []*NetworkInterfaceRefInput `json:"networkInterface,omitempty"`
	// Site defined for the account
	Site []*SiteRefInput `json:"site,omitempty"`
	// GlobalRange + InterfaceSubnet
	SiteNetworkSubnet []*SiteNetworkSubnetRefInput `json:"siteNetworkSubnet,omitempty"`
	// Subnets and network ranges defined for the LAN interfaces of a site
	Subnet []string `json:"subnet,omitempty"`
	// Predefined Cato groups
	SystemGroup []*SystemGroupRefInput `json:"systemGroup,omitempty"`
	// Individual users defined for the account
	User []*UserRefInput `json:"user,omitempty"`
	// Group of users
	UsersGroup []*UsersGroupRefInput `json:"usersGroup,omitempty"`
}

type TLSInspectUpdateRuleDataInput struct {
	// Action to be taken on the traffic.
	Action *TLSInspectAction `json:"action,omitempty"`
	// Application matching criteria for.
	Application *TLSInspectApplicationUpdateInput `json:"application,omitempty"`
	// Connection origin of the traffic
	ConnectionOrigin *ConnectionOriginEnum `json:"connectionOrigin,omitempty"`
	// Country traffic matching criteria.
	Country     []*CountryRefInput `json:"country,omitempty"`
	Description *string            `json:"description,omitempty"`
	// Device Profile traffic matching criteria.
	DevicePostureProfile []*DeviceProfileRefInput `json:"devicePostureProfile,omitempty"`
	Enabled              *bool                    `json:"enabled,omitempty"`
	Name                 *string                  `json:"name,omitempty"`
	// Operating System traffic matching criteria.
	Platform []OperatingSystem `json:"platform,omitempty"`
	// Source traffic matching criteria.
	Source *TLSInspectSourceUpdateInput `json:"source,omitempty"`
	// Action to be taken on the traffic when an untrusted certificate is detected.
	UntrustedCertificateAction *TLSInspectUntrustedCertificateAction `json:"untrustedCertificateAction,omitempty"`
}

type TLSInspectUpdateRuleInput struct {
	ID   string                         `json:"id"`
	Rule *TLSInspectUpdateRuleDataInput `json:"rule"`
}

type TunnelConfig struct {
	// The Local ID of the IPsec tunnel, specific to this tunnel
	LocalID *string `json:"localId,omitempty"`
	// Unique identifier for each tunnel
	TunnelID *string `json:"tunnelId,omitempty"`
	// The destination IP address for the IPsec tunnel (in the site), specific to this tunnel
	TunnelRemoteIdentifier *string `json:"tunnelRemoteIdentifier,omitempty"`
}

type UpdateAccountInput struct {
	// Account description
	Description *string `json:"description,omitempty"`
}

type UpdateAccountRoleInput struct {
	ID   string  `json:"id"`
	Name *string `json:"name,omitempty"`
}

type UpdateAdminInput struct {
	FirstName            *string                 `json:"firstName,omitempty"`
	LastName             *string                 `json:"lastName,omitempty"`
	ManagedRoles         []*UpdateAdminRoleInput `json:"managedRoles,omitempty"`
	MfaEnabled           *bool                   `json:"mfaEnabled,omitempty"`
	PasswordNeverExpires *bool                   `json:"passwordNeverExpires,omitempty"`
	ResellerRoles        []*UpdateAdminRoleInput `json:"resellerRoles,omitempty"`
}

type UpdateAdminPayload struct {
	AdminID string `json:"adminID"`
}

type UpdateAdminRoleInput struct {
	AllowedAccounts []string                `json:"allowedAccounts,omitempty"`
	AllowedEntities []*EntityInput          `json:"allowedEntities,omitempty"`
	Role            *UpdateAccountRoleInput `json:"role"`
}

type UpdateBgpPeerInput struct {
	// Update for all route advertisements.
	AdvertiseAllRoutes *bool `json:"advertiseAllRoutes,omitempty"`
	// Update for default route advertisement.
	AdvertiseDefaultRoute *bool `json:"advertiseDefaultRoute,omitempty"`
	// Update for summary route advertisement.
	AdvertiseSummaryRoutes *bool `json:"advertiseSummaryRoutes,omitempty"`
	// Update to enable or disable BFD.
	BfdEnabled *bool `json:"bfdEnabled,omitempty"`
	// Updated BFD settings.
	BfdSettings *BfdSettingsInput `json:"bfdSettings,omitempty"`
	// Updated AS number of Cato's BGP endpoint.
	CatoAsn *scalars.Asn16 `json:"catoAsn,omitempty"`
	// Update for the default action on unmatched routes.
	DefaultAction *BgpDefaultAction `json:"defaultAction,omitempty"`
	// Updated rules excluded from the default action.
	DefaultActionExclusion []*BgpFilterRuleInput `json:"defaultActionExclusion,omitempty"`
	// Updated hold time for the BGP session.
	HoldTime *int64 `json:"holdTime,omitempty"`
	// Unique identifier of the BGP peer to be updated.
	ID string `json:"id"`
	// Updated keepalive interval for the BGP session.
	KeepaliveInterval *int64 `json:"keepaliveInterval,omitempty"`
	// Updated MD5 authentication key.
	Md5AuthKey *string `json:"md5AuthKey,omitempty"`
	// Updated metric value for route preferences.
	Metric *int64 `json:"metric,omitempty"`
	// Updated name of the BGP configuration entity.
	Name *string `json:"name,omitempty"`
	// Updated AS number of the peer BGP endpoint.
	PeerAsn *scalars.Asn32 `json:"peerAsn,omitempty"`
	// Updated IP address of the peer BGP endpoint.
	PeerIP *string `json:"peerIp,omitempty"`
	// Update for NAT configuration.
	PerformNat *bool `json:"performNat,omitempty"`
	// Updated summarized routes to advertise.
	SummaryRoute []*BgpSummaryRouteInput `json:"summaryRoute,omitempty"`
	// Updated tracking configuration for the BGP peer.
	Tracking *BgpTrackingInput `json:"tracking,omitempty"`
}

type UpdateBgpPeerPayload struct {
	// The updated BGP peer object.
	BgpPeer *BgpPeer `json:"bgpPeer"`
}

// Input for updating an existing physical connection at a cloud interconnect site.
type UpdateCloudInterconnectPhysicalConnectionInput struct {
	// Downstream bandwidth limit.
	DownstreamBwLimit *string `json:"downstreamBwLimit,omitempty"`
	// Method of encapsulation.
	EncapsulationMethod *TaggingMethod `json:"encapsulationMethod,omitempty"`
	// ID of the connection to be updated.
	ID string `json:"id"`
	// Identifying data for the POP location.
	PopLocation *PopLocationRefInput `json:"popLocation,omitempty"`
	// Private IP address of Cato.
	PrivateCatoIP *string `json:"privateCatoIp,omitempty"`
	// Private IP address of the site.
	PrivateSiteIP *string `json:"privateSiteIp,omitempty"`
	// Name of the service provider.
	ServiceProviderName *string `json:"serviceProviderName,omitempty"`
	// Subnet for the connection.
	Subnet *string `json:"subnet,omitempty"`
	// Upstream bandwidth limit.
	UpstreamBwLimit *string `json:"upstreamBwLimit,omitempty"`
}

// Payload for updating an existing physical connection at a cloud interconnect site.
type UpdateCloudInterconnectPhysicalConnectionPayload struct {
	// ID of the updated connection.
	ID string `json:"id"`
}

type UpdateCommercialLicenseInput struct {
	// The unique identifier of the license to update
	LicenseID string `json:"licenseId"`
	// The desired start date for the license activation
	StartDate *string `json:"startDate,omitempty"`
}

type UpdateCommercialLicensePayload struct {
	// The license that was modified
	License License `json:"license"`
}

// Input for updating FQDN typed container from file
type UpdateFqdnContainerFromFileInput struct {
	// Description for the container
	Description *string `json:"description,omitempty"`
	// File type that will be uploaded
	FileType ContainerFileType `json:"fileType"`
	// Reference to existing container by container ID or container name
	Ref *ContainerRefInput `json:"ref"`
	// Multipart file containing FQDNs with fileType delimiter
	UploadFile *graphql.Upload `json:"uploadFile,omitempty"`
}

// Payload of UpdateFromFile operation on FQDN typed container
type UpdateFqdnContainerFromFilePayload struct {
	// Container with members of type FQDN
	Container *FqdnContainer `json:"container"`
}

type UpdateFqdnContainerFromListInput struct {
	Description string             `json:"description"`
	Ref         *ContainerRefInput `json:"ref"`
	Values      []string           `json:"values,omitempty"`
}

// Payload of UpdateFromList operation on FQDN typed container
type UpdateFqdnContainerFromListPayload struct {
	// Container with members of type FQDN
	Container *FqdnContainer `json:"container"`
}

// Update attributes for a group. Only the provided fields are updated - the other fields are not changed
// Note: You can only update a total of 500 group members at one time, this means 'membersToAdd + membersToRemove' or 'members' must be less than 500
type UpdateGroupInput struct {
	// New description for the group, if changing
	Description *string `json:"description,omitempty"`
	// Specify the group you’re updating
	Group *GroupRefInput `json:"group"`
	// Replaces all members in the group with this list of members
	Members []*GroupMemberRefTypedInput `json:"members,omitempty"`
	// Adds members to the existing set of members. Can't be used together with the 'members' field
	MembersToAdd []*GroupMemberRefTypedInput `json:"membersToAdd,omitempty"`
	// Removes members from the group. Can't be used together with the 'members' field
	MembersToRemove []*GroupMemberRefTypedInput `json:"membersToRemove,omitempty"`
	// New name for the group, if changing
	Name *string `json:"name,omitempty"`
}

// The updated group object
type UpdateGroupPayload struct {
	// Updated group
	Group *Group `json:"group"`
}

type UpdateHaInput struct {
	PrimaryManagementIP   *string `json:"primaryManagementIp,omitempty"`
	SecondaryManagementIP *string `json:"secondaryManagementIp,omitempty"`
	Vrid                  *int64  `json:"vrid,omitempty"`
}

type UpdateHaPayload struct {
	SiteID string `json:"siteId"`
}

type UpdateHardwareShippingInput struct {
	//  The shipping details to update
	Details *HardwareShippingDetailsInput `json:"details"`
	//  The ids of items to update
	Ids []string `json:"ids"`
}

// Input for updating existing IPAddressRange typed container from file
type UpdateIPAddressRangeContainerFromFileInput struct {
	// Description for the container
	Description *string `json:"description,omitempty"`
	// File type that will be uploaded
	FileType ContainerFileType `json:"fileType"`
	// Reference to existing container by container ID or container name
	Ref *ContainerRefInput `json:"ref"`
	// Multipart file containing IPAddressRanges with fileType delimiter
	UploadFile *graphql.Upload `json:"uploadFile,omitempty"`
}

// Payload of UpdateFromFile operation on IPAddressRange typed container
type UpdateIPAddressRangeContainerFromFilePayload struct {
	// Container with members of type IPAddressRange
	Container *IPAddressRangeContainer `json:"container"`
}

type UpdateIPAddressRangeContainerFromListInput struct {
	Description string                 `json:"description"`
	Ref         *ContainerRefInput     `json:"ref"`
	Values      []*IPAddressRangeInput `json:"values,omitempty"`
}

// Payload of UpdateFromList operation on IPAddressRange typed container
type UpdateIPAddressRangeContainerFromListPayload struct {
	// Container with members of type IPAddressRange
	Container *IPAddressRangeContainer `json:"container"`
}

type UpdateIpsecIkeV2SiteGeneralDetailsInput struct {
	// The auth message parameters.
	AuthMessage *IpsecIkeV2MessageInput `json:"authMessage,omitempty"`
	// Determines the protocol for establishing the Security Association (SA) Tunnel. Valid values are:
	// Responder-Only Mode: Cato Cloud only responds to incoming requests by the initiator (e.g. a Firewall device) to establish a security association.
	// Bidirectional Mode: Both Cato Cloud and the peer device on customer site can initiate the IPSec SA establishment.
	ConnectionMode *ConnectionMode `json:"connectionMode,omitempty"`
	// The authentication identification type used for SA authentication. When using “BIDIRECTIONAL”, it is set to “IPv4” by default. Other methods are available in Responder mode only.
	IdentificationType *IdentificationType `json:"identificationType,omitempty"`
	// The init message parameters
	InitMessage *IpsecIkeV2MessageInput `json:"initMessage,omitempty"`
	// The local IP ranges for the SAs
	NetworkRanges []*string `json:"networkRanges,omitempty"`
}

type UpdateIpsecIkeV2SiteGeneralDetailsPayload struct {
	// The local ID for the site
	LocalID *string `json:"localId,omitempty"`
	// The ID of the site
	SiteID string `json:"siteId"`
}

type UpdateIpsecIkeV2SiteMultiTunnelPayload struct {
	// Cato’s FQDN for the multi-tunnel
	Fqdn    *string                              `json:"fqdn,omitempty"`
	Tunnels []*UpdateIpsecIkeV2SiteTunnelPayload `json:"tunnels"`
}

type UpdateIpsecIkeV2SiteTunnelPayload struct {
	// The local ID for the tunnel
	LocalID *string `json:"localId,omitempty"`
	// The ID of the tunnel
	TunnelID *IPSecV2InterfaceID `json:"tunnelId,omitempty"`
}

type UpdateIpsecIkeV2SiteTunnelsInput struct {
	// The configuration of the site’s primary tunnel
	Primary *UpdateIpsecIkeV2TunnelsInput `json:"primary,omitempty"`
	// The configuration of the site’s secondary tunnel
	Secondary *UpdateIpsecIkeV2TunnelsInput `json:"secondary,omitempty"`
}

type UpdateIpsecIkeV2SiteTunnelsPayload struct {
	// The primary multi-tunnel
	Primary *UpdateIpsecIkeV2SiteMultiTunnelPayload `json:"primary,omitempty"`
	// The secondary multi-tunnel
	Secondary *UpdateIpsecIkeV2SiteMultiTunnelPayload `json:"secondary,omitempty"`
	// The ID of the site
	SiteID string `json:"siteId"`
}

type UpdateIpsecIkeV2TunnelInput struct {
	// The maximum allowed bandwidth for the site. If not specified, it will be set according to the site license. If the ISP provided bandwidth is below the site bandwidth, set this parameter to the ISP bandwidth or below
	LastMileBw *LastMileBwInput `json:"lastMileBw,omitempty"`
	// Tunnel name
	Name *string `json:"name,omitempty"`
	// Cato’s private IP, used for BGP routing. Applicable for sites using BGP only
	PrivateCatoIP *string `json:"privateCatoIp,omitempty"`
	// Site private IP, used for BGP routing. Applicable for sites using BGP only
	PrivateSiteIP *string `json:"privateSiteIp,omitempty"`
	// Pre-shared key. This field is write-only.
	Psk *string `json:"psk,omitempty"`
	// The public IP address where the IPsec tunnel is initiated
	PublicSiteIP *string `json:"publicSiteIp,omitempty"`
	// Tunnel role
	Role *IPSecV2TunnelRole `json:"role,omitempty"`
	// The ID of the tunnel
	TunnelID IPSecV2InterfaceID `json:"tunnelId"`
}

type UpdateIpsecIkeV2TunnelsInput struct {
	// The destination type of the IPsec tunnel
	DestinationType *DestinationType `json:"destinationType,omitempty"`
	// The PoP location ID
	PopLocationID *string `json:"popLocationId,omitempty"`
	// The ID of the public IP (Allocated IP) of the Cato PoP to which the tunnel will connect. This will be the source-IP of the traffic transmitted to the Cato cloud over this tunnel when egressing the Cato Cloud
	PublicCatoIPID *string                        `json:"publicCatoIpId,omitempty"`
	Tunnels        []*UpdateIpsecIkeV2TunnelInput `json:"tunnels"`
}

type UpdateLocationDetailsInput struct {
	// Company name (recipient)
	CompanyName *string `json:"companyName,omitempty"`
	// Delivery contact detail
	Contact *ContactDetailsInput `json:"contact,omitempty"`
	// Postal location
	PostalAddress *PostalAddressInput `json:"postalAddress,omitempty"`
	// Vat id (required for Brazil)
	VatID *string `json:"vatId,omitempty"`
}

type UpdateNetworkRangeInput struct {
	// Only relevant for AZURE HA sites
	AzureFloatingIP *string `json:"azureFloatingIp,omitempty"`
	// Only relevant for NATIVE, VLAN rangeType
	DhcpSettings *NetworkDhcpSettingsInput `json:"dhcpSettings,omitempty"`
	// Only relevant for ROUTED_ROUTE rangeType
	Gateway      *string `json:"gateway,omitempty"`
	InternetOnly *bool   `json:"internetOnly,omitempty"`
	// Only relevant for NATIVE, SECONDARY_NATIVE, DIRECT_ROUTE, VLAN rangeType
	LocalIP *string `json:"localIp,omitempty"`
	// BETA - Only relevant for NATIVE, DIRECT_ROUTE and VLAN rangeType
	MdnsReflector    *bool       `json:"mdnsReflector,omitempty"`
	Name             *string     `json:"name,omitempty"`
	RangeType        *SubnetType `json:"rangeType,omitempty"`
	Subnet           *string     `json:"subnet,omitempty"`
	TranslatedSubnet *string     `json:"translatedSubnet,omitempty"`
	// Only relevant for NATIVE and VLAN network rangeType
	Vlan *int64 `json:"vlan,omitempty"`
}

type UpdateNetworkRangePayload struct {
	NetworkRangeID string `json:"networkRangeId"`
}

type UpdateSecondaryAWSVSocketInput struct {
	// The ID of the secondary vSocket
	ID string `json:"id"`
	// The IP address of the secondary vSocket
	IPAddress *string `json:"ipAddress,omitempty"`
	// The ID of the secondary vSocket route table
	RouteTableID *string `json:"routeTableId,omitempty"`
	// The subnet of the secondary vSocket
	Subnet *string `json:"subnet,omitempty"`
}

type UpdateSecondaryAWSVSocketPayload struct {
	// The updated secondary AWS vSocket object.
	SecondaryAWSVSocket *SecondaryAWSVSocket `json:"secondaryAwsVSocket"`
}

type UpdateSecondaryAzureVSocketInput struct {
	// The floating IP address
	FloatingIP *string `json:"floatingIp,omitempty"`
	// The ID of the secondary vSocket
	ID string `json:"id"`
	// The IP address of the interface
	InterfaceIP *string `json:"interfaceIp,omitempty"`
}

type UpdateSecondaryAzureVSocketPayload struct {
	// The updated secondary Azure vSocket object.
	SecondaryAzureVSocket *SecondaryAzureVSocket `json:"secondaryAzureVSocket"`
}

type UpdateServicePrincipalAdminInput struct {
	ManagedRoles  []*UpdateAdminRoleInput `json:"managedRoles,omitempty"`
	Name          *string                 `json:"name,omitempty"`
	ResellerRoles []*UpdateAdminRoleInput `json:"resellerRoles,omitempty"`
}

type UpdateServicePrincipalAdminPayload struct {
	AdminID string `json:"adminID"`
}

type UpdateSiteBwLicenseInput struct {
	// Specifies the bandwidth (in Mbps) to allocate to the site when using a pooled bandwidth license.
	Bw int64 `json:"bw"`
	// The license that is being assigned
	LicenseID string `json:"licenseId"`
	// The site the license is being assigned to
	Site *SiteRefInput `json:"site"`
}

type UpdateSiteBwLicensePayload struct {
	License License `json:"license"`
}

type UpdateSiteGeneralDetailsInput struct {
	Description *string `json:"description,omitempty"`
	Name        *string `json:"name,omitempty"`
	// Only relevant for socket sites
	PreferredPopLocation *UpdateSitePreferredPopLocationInput `json:"preferredPopLocation,omitempty"`
	SiteLocation         *UpdateSiteLocationInput             `json:"siteLocation,omitempty"`
	SiteType             *SiteType                            `json:"siteType,omitempty"`
}

type UpdateSiteGeneralDetailsPayload struct {
	SiteID string `json:"siteId"`
}

type UpdateSiteLocationInput struct {
	Address     *string `json:"address,omitempty"`
	CityName    *string `json:"cityName,omitempty"`
	CountryCode *string `json:"countryCode,omitempty"`
	StateCode   *string `json:"stateCode,omitempty"`
	Timezone    *string `json:"timezone,omitempty"`
}

type UpdateSitePreferredPopLocationInput struct {
	// Forces the socket to connect exclusively to the configured PoP locations
	PreferredOnly bool `json:"preferredOnly"`
	// Set the location reference to -1, `Automatic`, or null to enable automatic selection.
	// Set the location reference to -2 or `None` to disable the preferred PoP location (only allowed for secondary).
	Primary   *PopLocationRefInput `json:"primary,omitempty"`
	Secondary *PopLocationRefInput `json:"secondary,omitempty"`
}

type UpdateSocketInterfaceInput struct {
	// Only relevant for ALTERNATIVE, LAYER_2_WAN
	AltWan *SocketInterfaceAltWanInput `json:"altWan,omitempty"`
	// Only relevant for CATO, ALTERNATIVE, LAYER_2_WAN
	Bandwidth *SocketInterfaceBandwidthInput `json:"bandwidth,omitempty"`
	DestType  SocketInterfaceDestType        `json:"destType"`
	// Only relevant for LAN_LAG_MASTER, LAN_LAG_MASTER_AND_VRRP
	Lag *SocketInterfaceLagInput `json:"lag,omitempty"`
	// Only relevant for LAN, VRRP_AND_LAN, LAN_LAG_MASTER, LAN_LAG_MASTER_AND_VRRP
	Lan  *SocketInterfaceLanInput `json:"lan,omitempty"`
	Name *string                  `json:"name,omitempty"`
	// Only relevant for CATO
	OffCloud *SocketInterfaceOffCloudInput `json:"offCloud,omitempty"`
	// Only relevant for VRRP
	Vrrp *SocketInterfaceVrrpInput `json:"vrrp,omitempty"`
	// Only relevant for CATO
	Wan *SocketInterfaceWanInput `json:"wan,omitempty"`
}

type UpdateSocketInterfacePayload struct {
	SiteID            string                `json:"siteId"`
	SocketInterfaceID SocketInterfaceIDEnum `json:"socketInterfaceId"`
}

type UpdateStaticHostInput struct {
	IP         *string `json:"ip,omitempty"`
	MacAddress *string `json:"macAddress,omitempty"`
	Name       *string `json:"name,omitempty"`
}

type UpdateStaticHostPayload struct {
	HostID string `json:"hostId"`
}

// Upload file input
type UploadFileInput struct {
	//  Uploaded file name
	FileName string `json:"fileName"`
}

// Upload file response
type UploadFilePayload struct {
	//  Upload URL (HTTP PUT)
	UploadURL *string `json:"uploadUrl,omitempty"`
}

// Basic User configuration information
type UserInfo struct {
	// Additional authentication mechanism, currently MFA or NONE
	AuthMethod *string `json:"authMethod,omitempty"`
	// Timestamp when the VPN user was created in the account
	CreationTime *string `json:"creationTime,omitempty"`
	// Email address of the VPN user
	Email *string `json:"email,omitempty"`
	// Name of the VPN user
	Name *string `json:"name,omitempty"`
	// User creation mechanism, current supported REGULAR or LDAP
	Origin *string `json:"origin,omitempty"`
	// Phone number for the VPN user
	PhoneNumber *string `json:"phoneNumber,omitempty"`
	// Status of the Client as the type STRING
	Status *scalars.OperationalStatus `json:"status,omitempty"`
}

// A reference identifying the User object. ID: Unique User Identifier, Name: The User Name
type UserRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (UserRef) IsObjectRef() {}

// Object's unique identifier
func (this UserRef) GetID() string { return this.ID }

// Object's unique name
func (this UserRef) GetName() string { return this.Name }

type UserRefFilterInput struct {
	Eq  *UserRefInput   `json:"eq,omitempty"`
	In  []*UserRefInput `json:"in,omitempty"`
	Neq *UserRefInput   `json:"neq,omitempty"`
	Nin []*UserRefInput `json:"nin,omitempty"`
}

type UserRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

type UserSnapshot struct {
	// In this state the client does not create its own connection, but reuses
	// the Office's socket connection
	ConnectedInOffice *bool `json:"connectedInOffice,omitempty"`
	// Connectivity to the Cato Cloud
	ConnectivityStatus *ConnectivityStatus `json:"connectivityStatus,omitempty"`
	// The host name of the device
	DeviceName *string `json:"deviceName,omitempty"`
	// Data related to the Client
	Devices []*DeviceSnapshot `json:"devices,omitempty"`
	// VPN user ID
	ID *string `json:"id,omitempty"`
	// General information about the VPN user
	Info *UserInfo `json:"info,omitempty"`
	// IP address of the PoP that the Client is connected to
	InternalIP *string `json:"internalIP,omitempty"`
	// Last time the user was connected (relevant if not currently connected)
	LastConnected *string `json:"lastConnected,omitempty"`
	// User name from configuration, same as info.name
	Name *string `json:"name,omitempty"`
	// Status for a site or VPN user
	OperationalStatus *scalars.OperationalStatus `json:"operationalStatus,omitempty"`
	// Operating system of the device the Client is running on
	OsType *string `json:"osType,omitempty"`
	// Version of the operating system for the device
	OsVersion *string `json:"osVersion,omitempty"`
	// ID of the PoP that the Client is connected to
	PopID *int64 `json:"popID,omitempty"`
	// Name of the PoP that the VPN user is connected to
	PopName *string `json:"popName,omitempty"`
	// Data related to the most recent completed VPN connections
	RecentConnections []*RecentConnection `json:"recentConnections,omitempty"`
	// IP address of the Client
	RemoteIP *string `json:"remoteIP,omitempty"`
	// IP address, ISP, and geographical information related to the Client
	RemoteIPInfo *IPInfo `json:"remoteIPInfo,omitempty"`
	// How long has the user been connected (in seconds)
	Uptime *int64 `json:"uptime,omitempty"`
	// VPN client version string
	Version *string `json:"version,omitempty"`
	// VPN client version number
	VersionNumber *int64 `json:"versionNumber,omitempty"`
}

// A reference identifying the UsersGroup object. ID: Unique UsersGroup Identifier, Name: The UsersGroup Name
type UsersGroupRef struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (UsersGroupRef) IsObjectRef() {}

// Object's unique identifier
func (this UsersGroupRef) GetID() string { return this.ID }

// Object's unique name
func (this UsersGroupRef) GetName() string { return this.Name }

type UsersGroupRefInput struct {
	By    ObjectRefBy `json:"by"`
	Input string      `json:"input"`
}

type VendorPredicate struct {
	In    []VendorEnum `json:"in,omitempty"`
	NotIn []VendorEnum `json:"not_in,omitempty"`
}

type WanFirewallAddRuleDataInput struct {
	// The action applied by the Internet Firewall if the rule is matched
	Action WanFirewallActionEnum `json:"action"`
	// The time period during which the rule is active, outside this period, the rule is inactive
	ActivePeriod *PolicyRuleActivePeriodInput `json:"activePeriod"`
	// Application traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Application *WanFirewallApplicationInput `json:"application"`
	// Connection origin of the traffic
	ConnectionOrigin ConnectionOriginEnum `json:"connectionOrigin"`
	// Source country traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Country     []*CountryRefInput `json:"country"`
	Description string             `json:"description"`
	// Destination traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Destination *WanFirewallDestinationInput `json:"destination"`
	// Source Device Profile traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Device []*DeviceProfileRefInput `json:"device"`
	// Additional device attributes such as category, type, model, and manufacturer.
	// Logical 'OR' is applied within the criteria set.
	// Logical 'AND' is applied between criteria sets.
	DeviceAttributes *DeviceAttributesInput `json:"deviceAttributes"`
	// Source device Operating System traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	DeviceOs  []OperatingSystem        `json:"deviceOS"`
	Direction WanFirewallDirectionEnum `json:"direction"`
	Enabled   bool                     `json:"enabled"`
	// The set of exceptions for the rule.
	// Exceptions define when the rule will be ignored and the firewall evaluation will continue with the lower priority rules.
	Exceptions []*WanFirewallRuleExceptionInput `json:"exceptions"`
	Name       string                           `json:"name"`
	// The time period specifying when the rule is enabled, otherwise it is disabled.
	Schedule *PolicyScheduleInput `json:"schedule"`
	// Destination service traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Service *WanFirewallServiceTypeInput `json:"service"`
	// Source traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Source *WanFirewallSourceInput `json:"source"`
	// Tracking information when the rule is matched, such as events and notifications
	Tracking *PolicyTrackingInput `json:"tracking"`
}

// Rule parameters and relevant position
type WanFirewallAddRuleInput struct {
	// Position of the rule in the policy
	At *PolicyRulePositionInput `json:"at,omitempty"`
	// Parameters for the rule you are adding
	Rule *WanFirewallAddRuleDataInput `json:"rule"`
}

// Application match criteria set
type WanFirewallApplication struct {
	// Cato category of applications which are dynamically updated by Cato
	AppCategory []*ApplicationCategoryRef `json:"appCategory"`
	// Applications for the rule (pre-defined)
	Application []*ApplicationRef `json:"application"`
	// Custom (user-defined) applications
	CustomApp []*CustomApplicationRef `json:"customApp"`
	// Custom Categories – Groups of objects such as predefined and custom applications, predefined and custom services, domains, FQDNs etc.
	CustomCategory []*CustomCategoryRef `json:"customCategory"`
	// A Second-Level Domain (SLD).
	// It matches all Top-Level Domains (TLD), and subdomains that include the Domain.
	// Example: example.com.
	Domain []string `json:"domain"`
	// An exact match of the fully qualified domain (FQDN). Example: www.my.example.com.
	Fqdn []string `json:"fqdn"`
	// Globally defined IP range, IP and subnet objects
	GlobalIPRange []*GlobalIPRangeRef `json:"globalIpRange"`
	// IPv4 addresses
	IP []string `json:"ip"`
	// A range of IPs. Every IP within the range will be matched
	IPRange []*IPAddressRange `json:"ipRange"`
	// Sanctioned Cloud Applications - apps that are approved and generally represent an understood and acceptable level of risk in your organization.
	SanctionedAppsCategory []*SanctionedAppsCategoryRef `json:"sanctionedAppsCategory"`
	// Subnets and network ranges defined for the LAN interfaces of a site
	Subnet []string `json:"subnet"`
}

// Application match criteria set
type WanFirewallApplicationInput struct {
	// Cato category of applications which are dynamically updated by Cato
	AppCategory []*ApplicationCategoryRefInput `json:"appCategory"`
	// Applications for the rule (pre-defined)
	Application []*ApplicationRefInput `json:"application"`
	// Custom (user-defined) applications
	CustomApp []*CustomApplicationRefInput `json:"customApp"`
	// Custom Categories – Groups of objects such as predefined and custom applications, predefined and custom services, domains, FQDNs etc.
	CustomCategory []*CustomCategoryRefInput `json:"customCategory"`
	// A Second-Level Domain (SLD).
	// It matches all Top-Level Domains (TLD), and subdomains that include the Domain.
	// Example: example.com.
	Domain []string `json:"domain"`
	// An exact match of the fully qualified domain (FQDN). Example: www.my.example.com.
	Fqdn []string `json:"fqdn"`
	// Globally defined IP range, IP and subnet objects
	GlobalIPRange []*GlobalIPRangeRefInput `json:"globalIpRange"`
	// IPv4 addresses
	IP []string `json:"ip"`
	// A range of IPs. Every IP within the range will be matched
	IPRange []*IPAddressRangeInput `json:"ipRange"`
	// Sanctioned Cloud Applications - apps that are approved and generally represent an understood and acceptable level of risk in your organization.
	SanctionedAppsCategory []*SanctionedAppsCategoryRefInput `json:"sanctionedAppsCategory"`
	// Subnets and network ranges defined for the LAN interfaces of a site
	Subnet []string `json:"subnet"`
}

// Application match criteria set
type WanFirewallApplicationUpdateInput struct {
	// Cato category of applications which are dynamically updated by Cato
	AppCategory []*ApplicationCategoryRefInput `json:"appCategory,omitempty"`
	// Applications for the rule (pre-defined)
	Application []*ApplicationRefInput `json:"application,omitempty"`
	// Custom (user-defined) applications
	CustomApp []*CustomApplicationRefInput `json:"customApp,omitempty"`
	// Custom Categories – Groups of objects such as predefined and custom applications, predefined and custom services, domains, FQDNs etc.
	CustomCategory []*CustomCategoryRefInput `json:"customCategory,omitempty"`
	// A Second-Level Domain (SLD).
	// It matches all Top-Level Domains (TLD), and subdomains that include the Domain.
	// Example: example.com.
	Domain []string `json:"domain,omitempty"`
	// An exact match of the fully qualified domain (FQDN). Example: www.my.example.com.
	Fqdn []string `json:"fqdn,omitempty"`
	// Globally defined IP range, IP and subnet objects
	GlobalIPRange []*GlobalIPRangeRefInput `json:"globalIpRange,omitempty"`
	// IPv4 addresses
	IP []string `json:"ip,omitempty"`
	// A range of IPs. Every IP within the range will be matched
	IPRange []*IPAddressRangeInput `json:"ipRange,omitempty"`
	// Sanctioned Cloud Applications - apps that are approved and generally represent an understood and acceptable level of risk in your organization.
	SanctionedAppsCategory []*SanctionedAppsCategoryRefInput `json:"sanctionedAppsCategory,omitempty"`
	// Subnets and network ranges defined for the LAN interfaces of a site
	Subnet []string `json:"subnet,omitempty"`
}

// Returns the settings for Destination of a Wan Firewall rule
type WanFirewallDestination struct {
	// Floating Subnets (ie. Floating Ranges) are used to identify traffic exactly matched to the route advertised by BGP.
	// They are not associated with a specific site.
	// This is useful in scenarios such as active-standby high availability routed via BGP.
	FloatingSubnet []*FloatingSubnetRef `json:"floatingSubnet"`
	// Globally defined IP range, IP and subnet objects
	GlobalIPRange []*GlobalIPRangeRef `json:"globalIpRange"`
	// Groups defined for your account
	Group []*GroupRef `json:"group"`
	// Hosts and servers defined for your account
	Host []*HostRef `json:"host"`
	// IPv4 address
	IP []string `json:"ip"`
	// Multiple separate IP addresses or an IP range
	IPRange []*IPAddressRange `json:"ipRange"`
	// Network range defined for a site
	NetworkInterface []*NetworkInterfaceRef `json:"networkInterface"`
	// Site defined for the account
	Site []*SiteRef `json:"site"`
	// GlobalRange + InterfaceSubnet
	SiteNetworkSubnet []*SiteNetworkSubnetRef `json:"siteNetworkSubnet"`
	// Subnets and network ranges defined for the LAN interfaces of a site
	Subnet []string `json:"subnet"`
	// Predefined Cato groups
	SystemGroup []*SystemGroupRef `json:"systemGroup"`
	// Individual users defined for the account
	User []*UserRef `json:"user"`
	// Group of users
	UsersGroup []*UsersGroupRef `json:"usersGroup"`
}

// Input of the settings for Destination of a Wan Firewall rule. To specify 'ANY' destination, an empty list must be provided for each match criteria field (e.g. ip: [], group: [], etc...)
type WanFirewallDestinationInput struct {
	// Floating Subnets (ie. Floating Ranges) are used to identify traffic exactly matched to the route advertised by BGP.
	// They are not associated with a specific site.
	// This is useful in scenarios such as active-standby high availability routed via BGP.
	FloatingSubnet []*FloatingSubnetRefInput `json:"floatingSubnet"`
	// Globally defined IP range, IP and subnet objects
	GlobalIPRange []*GlobalIPRangeRefInput `json:"globalIpRange"`
	// Groups defined for your account
	Group []*GroupRefInput `json:"group"`
	// Hosts and servers defined for your account
	Host []*HostRefInput `json:"host"`
	// IPv4 address
	IP []string `json:"ip"`
	// Multiple separate IP addresses or an IP range
	IPRange []*IPAddressRangeInput `json:"ipRange"`
	// Network range defined for a site
	NetworkInterface []*NetworkInterfaceRefInput `json:"networkInterface"`
	// Site defined for the account
	Site []*SiteRefInput `json:"site"`
	// GlobalRange + InterfaceSubnet
	SiteNetworkSubnet []*SiteNetworkSubnetRefInput `json:"siteNetworkSubnet"`
	// Subnets and network ranges defined for the LAN interfaces of a site
	Subnet []string `json:"subnet"`
	// Predefined Cato groups
	SystemGroup []*SystemGroupRefInput `json:"systemGroup"`
	// Individual users defined for the account
	User []*UserRefInput `json:"user"`
	// Group of users
	UsersGroup []*UsersGroupRefInput `json:"usersGroup"`
}

// Input of the settings for Destination of a Wan Firewall rule. To specify 'ANY' destination, an empty list must be provided for each match criteria field (e.g. ip: [], group: [], etc...)
type WanFirewallDestinationUpdateInput struct {
	// Floating Subnets (ie. Floating Ranges) are used to identify traffic exactly matched to the route advertised by BGP.
	// They are not associated with a specific site.
	// This is useful in scenarios such as active-standby high availability routed via BGP.
	FloatingSubnet []*FloatingSubnetRefInput `json:"floatingSubnet,omitempty"`
	// Globally defined IP range, IP and subnet objects
	GlobalIPRange []*GlobalIPRangeRefInput `json:"globalIpRange,omitempty"`
	// Groups defined for your account
	Group []*GroupRefInput `json:"group,omitempty"`
	// Hosts and servers defined for your account
	Host []*HostRefInput `json:"host,omitempty"`
	// IPv4 address
	IP []string `json:"ip,omitempty"`
	// Multiple separate IP addresses or an IP range
	IPRange []*IPAddressRangeInput `json:"ipRange,omitempty"`
	// Network range defined for a site
	NetworkInterface []*NetworkInterfaceRefInput `json:"networkInterface,omitempty"`
	// Site defined for the account
	Site []*SiteRefInput `json:"site,omitempty"`
	// GlobalRange + InterfaceSubnet
	SiteNetworkSubnet []*SiteNetworkSubnetRefInput `json:"siteNetworkSubnet,omitempty"`
	// Subnets and network ranges defined for the LAN interfaces of a site
	Subnet []string `json:"subnet,omitempty"`
	// Predefined Cato groups
	SystemGroup []*SystemGroupRefInput `json:"systemGroup,omitempty"`
	// Individual users defined for the account
	User []*UserRefInput `json:"user,omitempty"`
	// Group of users
	UsersGroup []*UsersGroupRefInput `json:"usersGroup,omitempty"`
}

type WanFirewallPolicy struct {
	Audit    *PolicyAudit              `json:"audit,omitempty"`
	Enabled  bool                      `json:"enabled"`
	Revision *PolicyRevision           `json:"revision,omitempty"`
	Rules    []*WanFirewallRulePayload `json:"rules"`
	Sections []*PolicySectionPayload   `json:"sections"`
}

func (WanFirewallPolicy) IsIPolicy() {}

// TRUE = Policy is enabled, FALSE = Policy is disabled
func (this WanFirewallPolicy) GetEnabled() bool { return this.Enabled }

// Return list of rules in the policy
func (this WanFirewallPolicy) GetRules() []IPolicyRulePayload {
	if this.Rules == nil {
		return nil
	}
	interfaceSlice := make([]IPolicyRulePayload, 0, len(this.Rules))
	for _, concrete := range this.Rules {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

// Return sections in the policy
func (this WanFirewallPolicy) GetSections() []*PolicySectionPayload {
	if this.Sections == nil {
		return nil
	}
	interfaceSlice := make([]*PolicySectionPayload, 0, len(this.Sections))
	for _, concrete := range this.Sections {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

// Audit data for the policy
func (this WanFirewallPolicy) GetAudit() *PolicyAudit { return this.Audit }

// Return data for the Policy revision
func (this WanFirewallPolicy) GetRevision() *PolicyRevision { return this.Revision }

type WanFirewallPolicyInput struct {
	// A revision is a specific instance of the policy.
	//  Unpublished revisions are working copies of the policy available to a specific
	//  admin or a set of admins
	//  Published revisions are revisions that were applied to the account network.
	//  The last published revision is the active policy.
	Revision *PolicyRevisionInput `json:"revision,omitempty"`
}

type WanFirewallPolicyMutationInput struct {
	Revision *PolicyMutationRevisionInput `json:"revision,omitempty"`
}

// Wan Firewall policy information provided in the API response
type WanFirewallPolicyMutationPayload struct {
	Errors []*PolicyMutationError `json:"errors"`
	Policy *WanFirewallPolicy     `json:"policy,omitempty"`
	Status PolicyMutationStatus   `json:"status"`
}

func (WanFirewallPolicyMutationPayload) IsIPolicyMutationPayload() {}

// Data for the policy
func (this WanFirewallPolicyMutationPayload) GetPolicy() IPolicy { return *this.Policy }

// Enum for the status of the policy change
func (this WanFirewallPolicyMutationPayload) GetStatus() PolicyMutationStatus { return this.Status }

// List of errors related to the policy change
func (this WanFirewallPolicyMutationPayload) GetErrors() []*PolicyMutationError {
	if this.Errors == nil {
		return nil
	}
	interfaceSlice := make([]*PolicyMutationError, 0, len(this.Errors))
	for _, concrete := range this.Errors {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

// The Wan Firewall Policy information returned to the caller in the API response.
type WanFirewallPolicyMutations struct {
	// Add a new rule to the Wan Firewall policy.
	AddRule *WanFirewallRuleMutationPayload `json:"addRule"`
	// Add a new section to the policy.
	// First section behaves as follows:
	// When the first section is created,  all the rules in the policy, including the default system rules, are automatically added to it.
	// The first section containing the default system rules can be modified but not deleted.
	// The first section will always remain first-in-policy, i.e. it cannot be moved, and not other sections can be moved or created before it.
	AddSection            *PolicySectionMutationPayload     `json:"addSection"`
	CreatePolicyRevision  *WanFirewallPolicyMutationPayload `json:"createPolicyRevision"`
	DiscardPolicyRevision *WanFirewallPolicyMutationPayload `json:"discardPolicyRevision"`
	// Change the relative location of an existing rule within the Wan Firewall policy.
	MoveRule *WanFirewallRuleMutationPayload `json:"moveRule"`
	// Move a section to a new position within the policy.
	//  The section will be anchored in the new position, i.e. other admins will not be able to move it, or reference it when moving other sections, until the modified policy revision is published.
	MoveSection           *PolicySectionMutationPayload     `json:"moveSection"`
	PublishPolicyRevision *WanFirewallPolicyMutationPayload `json:"publishPolicyRevision"`
	// Remove an existing rule from the Wan Firewall policy.
	RemoveRule *WanFirewallRuleMutationPayload `json:"removeRule"`
	// Delete an existing section. The first section in policy cannot be deleted.
	RemoveSection *PolicySectionMutationPayload `json:"removeSection"`
	// Change the state of the policy, e.g. enable or disable the policy.
	// Applicable to the published policy only. State changes are applied immediately and not as part of publishing a policy revision.
	UpdatePolicy *WanFirewallPolicyMutationPayload `json:"updatePolicy"`
	// Update an existing rule of the Wan Firewall policy.
	UpdateRule *WanFirewallRuleMutationPayload `json:"updateRule"`
	// Update policy section attributes
	UpdateSection *PolicySectionMutationPayload `json:"updateSection"`
}

type WanFirewallPolicyQueries struct {
	Policy    *WanFirewallPolicy      `json:"policy"`
	Revisions *PolicyRevisionsPayload `json:"revisions,omitempty"`
}

type WanFirewallPolicyUpdateInput struct {
	State *PolicyToggleState `json:"state,omitempty"`
}

type WanFirewallRemoveRuleInput struct {
	ID string `json:"id"`
}

type WanFirewallRule struct {
	// The action applied by the Internet Firewall if the rule is matched
	Action WanFirewallActionEnum `json:"action"`
	// The time period during which the rule is active, outside this period, the rule is inactive
	ActivePeriod *PolicyRuleActivePeriod `json:"activePeriod"`
	// Application traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Application *WanFirewallApplication `json:"application"`
	// Connection origin of the traffic
	ConnectionOrigin ConnectionOriginEnum `json:"connectionOrigin"`
	// Source country traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Country []*CountryRef `json:"country"`
	// Description for the rule
	Description string `json:"description"`
	// Destination traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Destination *WanFirewallDestination `json:"destination"`
	// Source Device Profile traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Device []*DeviceProfileRef `json:"device"`
	// Additional device attributes such as category, type, model, and manufacturer.
	// Logical 'OR' is applied within the criteria set.
	// Logical 'AND' is applied between criteria sets.
	DeviceAttributes *DeviceAttributes `json:"deviceAttributes"`
	// Source device Operating System traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	DeviceOs  []OperatingSystem        `json:"deviceOS"`
	Direction WanFirewallDirectionEnum `json:"direction"`
	// TRUE = Rule is enabled
	//  FALSE = Rule is disabled
	Enabled bool `json:"enabled"`
	// The set of exceptions for the rule.
	// Exceptions define when the rule will be ignored and the firewall evaluation will continue with the lower priority rules.
	Exceptions []*WanFirewallRuleException `json:"exceptions"`
	// Rule ID
	ID string `json:"id"`
	// Position / priority of rule
	Index int64 `json:"index"`
	// Name of the rule
	Name string `json:"name"`
	// The time period specifying when the rule is enabled, otherwise it is disabled.
	Schedule *PolicySchedule `json:"schedule"`
	// Policy section where the rule is located
	Section *PolicySectionInfo `json:"section"`
	// Destination service traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Service *WanFirewallServiceType `json:"service"`
	// Source traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Source *WanFirewallSource `json:"source"`
	// Tracking information when the rule is matched, such as events and notifications
	Tracking *PolicyTracking `json:"tracking"`
}

func (WanFirewallRule) IsIPolicyRule() {}

// Rule ID
func (this WanFirewallRule) GetID() string { return this.ID }

// Name of the rule
func (this WanFirewallRule) GetName() string { return this.Name }

// Description for the rule
func (this WanFirewallRule) GetDescription() *string { return &this.Description }

// Position / priority of rule
func (this WanFirewallRule) GetIndex() int64 { return this.Index }

// TRUE = Rule is enabled, FALSE = Rule is disabled
func (this WanFirewallRule) GetEnabled() bool { return this.Enabled }

// Policy section where the rule is located
func (this WanFirewallRule) GetSection() *PolicySectionInfo { return this.Section }

// Exceptions define when a rule is ignored, and the firewall policy evaluation continues with the lower priority rules.
type WanFirewallRuleException struct {
	// Application matching criteria for the exception.
	Application *WanFirewallApplication `json:"application"`
	// Connection origin matching criteria for the exception.
	ConnectionOrigin ConnectionOriginEnum `json:"connectionOrigin"`
	// Source country matching criteria for the exception.
	Country []*CountryRef `json:"country"`
	// Destination matching criteria for the exception.
	Destination *WanFirewallDestination `json:"destination"`
	// Source Device Profile matching criteria for the exception.
	Device []*DeviceProfileRef `json:"device"`
	// Source Device Attributes matching criteria for the exception.
	DeviceAttributes *DeviceAttributes `json:"deviceAttributes"`
	// Source device OS matching criteria for the exception.
	DeviceOs []OperatingSystem `json:"deviceOS"`
	// Direction origin matching criteria for the exception
	Direction WanFirewallDirectionEnum `json:"direction"`
	// A unique name of the rule exception.
	Name string `json:"name"`
	// Destination service matching criteria for the exception.
	Service *WanFirewallServiceType `json:"service"`
	// Source matching criteria for the exception.
	Source *WanFirewallSource `json:"source"`
}

// Exceptions define when a rule is ignored, and the firewall policy evaluation continues with the lower priority rules.
type WanFirewallRuleExceptionInput struct {
	// Application matching criteria for the exception.
	Application *WanFirewallApplicationInput `json:"application"`
	// Connection origin matching criteria for the exception.
	ConnectionOrigin ConnectionOriginEnum `json:"connectionOrigin"`
	// Source country matching criteria for the exception.
	Country []*CountryRefInput `json:"country"`
	// Destination matching criteria for the exception.
	Destination *WanFirewallDestinationInput `json:"destination"`
	// Source Device Profile matching criteria for the exception.
	Device []*DeviceProfileRefInput `json:"device"`
	// Source Device Attributes matching criteria for the exception.
	DeviceAttributes *DeviceAttributesInput `json:"deviceAttributes"`
	// Source device OS matching criteria for the exception.
	DeviceOs []OperatingSystem `json:"deviceOS"`
	// Direction origin matching criteria for the exception
	Direction WanFirewallDirectionEnum `json:"direction"`
	// A unique name of the rule exception.
	Name string `json:"name"`
	// Destination service matching criteria for the exception.
	Service *WanFirewallServiceTypeInput `json:"service"`
	// Source matching criteria for the exception.
	Source *WanFirewallSourceInput `json:"source"`
}

type WanFirewallRuleMutationPayload struct {
	Errors []*PolicyMutationError  `json:"errors"`
	Rule   *WanFirewallRulePayload `json:"rule,omitempty"`
	Status PolicyMutationStatus    `json:"status"`
}

func (WanFirewallRuleMutationPayload) IsIPolicyRuleMutationPayload() {}

// Returns settings for the rule
func (this WanFirewallRuleMutationPayload) GetRule() IPolicyRulePayload { return *this.Rule }

// Enum for the status of the policy change
func (this WanFirewallRuleMutationPayload) GetStatus() PolicyMutationStatus { return this.Status }

// List of errors related to the policy change
func (this WanFirewallRuleMutationPayload) GetErrors() []*PolicyMutationError {
	if this.Errors == nil {
		return nil
	}
	interfaceSlice := make([]*PolicyMutationError, 0, len(this.Errors))
	for _, concrete := range this.Errors {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

// Wan Firewall policy information for a specific revision
type WanFirewallRulePayload struct {
	Audit      *PolicyElementAudit           `json:"audit"`
	Properties []PolicyElementPropertiesEnum `json:"properties"`
	Rule       *WanFirewallRule              `json:"rule"`
}

func (WanFirewallRulePayload) IsIPolicyRulePayload()              {}
func (this WanFirewallRulePayload) GetAudit() *PolicyElementAudit { return this.Audit }

// Rule that was changed
func (this WanFirewallRulePayload) GetRule() IPolicyRule { return *this.Rule }

// Summary of rule change, (ie. ADDED, UPDATED)
func (this WanFirewallRulePayload) GetProperties() []PolicyElementPropertiesEnum {
	if this.Properties == nil {
		return nil
	}
	interfaceSlice := make([]PolicyElementPropertiesEnum, 0, len(this.Properties))
	for _, concrete := range this.Properties {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

// Returns the Service Type to which this Wan Firewall rule applies
type WanFirewallServiceType struct {
	Custom   []*CustomService `json:"custom"`
	Standard []*ServiceRef    `json:"standard"`
}

// Input of the Service Type to which this Wan Firewall rule applies. To specify 'ANY' source, an empty list must be provided for each match criteria field (e.g. standard: [], custom: [], etc...)
type WanFirewallServiceTypeInput struct {
	Custom   []*CustomServiceInput `json:"custom"`
	Standard []*ServiceRefInput    `json:"standard"`
}

// Input of the Service Type to which this Wan Firewall rule applies. To specify 'ANY' source, an empty list must be provided for each match criteria field (e.g. standard: [], custom: [], etc...)
type WanFirewallServiceTypeUpdateInput struct {
	Custom   []*CustomServiceInput `json:"custom,omitempty"`
	Standard []*ServiceRefInput    `json:"standard,omitempty"`
}

// Returns the settings for Source of an Wan Firewall rule
type WanFirewallSource struct {
	// Floating Subnets (ie. Floating Ranges) are used to identify traffic exactly matched to the route advertised by BGP.
	// They are not associated with a specific site.
	// This is useful in scenarios such as active-standby high availability routed via BGP.
	FloatingSubnet []*FloatingSubnetRef `json:"floatingSubnet"`
	// Globally defined IP range, IP and subnet objects
	GlobalIPRange []*GlobalIPRangeRef `json:"globalIpRange"`
	// Groups defined for your account
	Group []*GroupRef `json:"group"`
	// Hosts and servers defined for your account
	Host []*HostRef `json:"host"`
	// IPv4 address
	IP []string `json:"ip"`
	// Multiple separate IP addresses or an IP range
	IPRange []*IPAddressRange `json:"ipRange"`
	// Network range defined for a site
	NetworkInterface []*NetworkInterfaceRef `json:"networkInterface"`
	// Site defined for the account
	Site []*SiteRef `json:"site"`
	// GlobalRange + InterfaceSubnet
	SiteNetworkSubnet []*SiteNetworkSubnetRef `json:"siteNetworkSubnet"`
	// Subnets and network ranges defined for the LAN interfaces of a site
	Subnet []string `json:"subnet"`
	// Predefined Cato groups
	SystemGroup []*SystemGroupRef `json:"systemGroup"`
	// Individual users defined for the account
	User []*UserRef `json:"user"`
	// Group of users
	UsersGroup []*UsersGroupRef `json:"usersGroup"`
}

// Input of the settings for Source of an Wan Firewall rule. To specify 'ANY' source, an empty list must be provided for each match criteria field (e.g. ip: [], group: [], etc...)
type WanFirewallSourceInput struct {
	// Floating Subnets (ie. Floating Ranges) are used to identify traffic exactly matched to the route advertised by BGP.
	// They are not associated with a specific site.
	// This is useful in scenarios such as active-standby high availability routed via BGP.
	FloatingSubnet []*FloatingSubnetRefInput `json:"floatingSubnet"`
	// Globally defined IP range, IP and subnet objects
	GlobalIPRange []*GlobalIPRangeRefInput `json:"globalIpRange"`
	// Groups defined for your account
	Group []*GroupRefInput `json:"group"`
	// Hosts and servers defined for your account
	Host []*HostRefInput `json:"host"`
	// IPv4 address
	IP []string `json:"ip"`
	// Multiple separate IP addresses or an IP range
	IPRange []*IPAddressRangeInput `json:"ipRange"`
	// Network range defined for a site
	NetworkInterface []*NetworkInterfaceRefInput `json:"networkInterface"`
	// Site defined for the account
	Site []*SiteRefInput `json:"site"`
	// GlobalRange + InterfaceSubnet
	SiteNetworkSubnet []*SiteNetworkSubnetRefInput `json:"siteNetworkSubnet"`
	// Subnets and network ranges defined for the LAN interfaces of a site
	Subnet []string `json:"subnet"`
	// Predefined Cato groups
	SystemGroup []*SystemGroupRefInput `json:"systemGroup"`
	// Individual users defined for the account
	User []*UserRefInput `json:"user"`
	// Group of users
	UsersGroup []*UsersGroupRefInput `json:"usersGroup"`
}

// Input of the settings for Source of an Wan Firewall rule. To specify 'ANY' source, an empty list must be provided for each match criteria field (e.g. ip: [], group: [], etc...)
type WanFirewallSourceUpdateInput struct {
	// Floating Subnets (ie. Floating Ranges) are used to identify traffic exactly matched to the route advertised by BGP.
	// They are not associated with a specific site.
	// This is useful in scenarios such as active-standby high availability routed via BGP.
	FloatingSubnet []*FloatingSubnetRefInput `json:"floatingSubnet,omitempty"`
	// Globally defined IP range, IP and subnet objects
	GlobalIPRange []*GlobalIPRangeRefInput `json:"globalIpRange,omitempty"`
	// Groups defined for your account
	Group []*GroupRefInput `json:"group,omitempty"`
	// Hosts and servers defined for your account
	Host []*HostRefInput `json:"host,omitempty"`
	// IPv4 address
	IP []string `json:"ip,omitempty"`
	// Multiple separate IP addresses or an IP range
	IPRange []*IPAddressRangeInput `json:"ipRange,omitempty"`
	// Network range defined for a site
	NetworkInterface []*NetworkInterfaceRefInput `json:"networkInterface,omitempty"`
	// Site defined for the account
	Site []*SiteRefInput `json:"site,omitempty"`
	// GlobalRange + InterfaceSubnet
	SiteNetworkSubnet []*SiteNetworkSubnetRefInput `json:"siteNetworkSubnet,omitempty"`
	// Subnets and network ranges defined for the LAN interfaces of a site
	Subnet []string `json:"subnet,omitempty"`
	// Predefined Cato groups
	SystemGroup []*SystemGroupRefInput `json:"systemGroup,omitempty"`
	// Individual users defined for the account
	User []*UserRefInput `json:"user,omitempty"`
	// Group of users
	UsersGroup []*UsersGroupRefInput `json:"usersGroup,omitempty"`
}

type WanFirewallUpdateRuleDataInput struct {
	// The action applied by the Internet Firewall if the rule is matched
	Action *WanFirewallActionEnum `json:"action,omitempty"`
	// The time period during which the rule is active, outside this period, the rule is inactive
	ActivePeriod *PolicyRuleActivePeriodUpdateInput `json:"activePeriod,omitempty"`
	// Application traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Application *WanFirewallApplicationUpdateInput `json:"application,omitempty"`
	// Connection origin of the traffic
	ConnectionOrigin *ConnectionOriginEnum `json:"connectionOrigin,omitempty"`
	// Source country traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Country     []*CountryRefInput `json:"country,omitempty"`
	Description *string            `json:"description,omitempty"`
	// Destination traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Destination *WanFirewallDestinationUpdateInput `json:"destination,omitempty"`
	// Source Device Profile traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Device []*DeviceProfileRefInput `json:"device,omitempty"`
	// Additional device attributes such as category, type, model, and manufacturer.
	// Logical 'OR' is applied within the criteria set.
	// Logical 'AND' is applied between criteria sets.
	DeviceAttributes *DeviceAttributesUpdateInput `json:"deviceAttributes,omitempty"`
	// Source device Operating System traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	DeviceOs  []OperatingSystem         `json:"deviceOS,omitempty"`
	Direction *WanFirewallDirectionEnum `json:"direction,omitempty"`
	Enabled   *bool                     `json:"enabled,omitempty"`
	// The set of exceptions for the rule.
	// Exceptions define when the rule will be ignored and the firewall evaluation will continue with the lower priority rules.
	Exceptions []*WanFirewallRuleExceptionInput `json:"exceptions,omitempty"`
	Name       *string                          `json:"name,omitempty"`
	// The time period specifying when the rule is enabled, otherwise it is disabled.
	Schedule *PolicyScheduleUpdateInput `json:"schedule,omitempty"`
	// Destination service traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Service *WanFirewallServiceTypeUpdateInput `json:"service,omitempty"`
	// Source traffic matching criteria.
	// Logical ‘OR’ is applied within the criteria set.
	// Logical ‘AND’ is applied between criteria sets.
	Source *WanFirewallSourceUpdateInput `json:"source,omitempty"`
	// Tracking information when the rule is matched, such as events and notifications
	Tracking *PolicyTrackingUpdateInput `json:"tracking,omitempty"`
}

type WanFirewallUpdateRuleInput struct {
	ID   string                          `json:"id"`
	Rule *WanFirewallUpdateRuleDataInput `json:"rule"`
}

type WanNetworkAddRuleDataInput struct {
	// The application or category of traffic for the rule.
	Application *WanNetworkRuleApplicationInput `json:"application"`
	// The bandwidth priority (QoS) for the rule.
	BandwidthPriority *BandwidthManagementRefInput `json:"bandwidthPriority"`
	// The configuration of the rule.
	Configuration *WanNetworkRuleConfigurationInput `json:"configuration"`
	Description   string                            `json:"description"`
	// The destination of the traffic for the rule.
	Destination *WanNetworkRuleDestinationInput `json:"destination"`
	Enabled     bool                            `json:"enabled"`
	// Exceptions to the rule.
	Exceptions []*WanNetworkRuleExceptionInput `json:"exceptions"`
	Name       string                          `json:"name"`
	// Defines the routing method for the rule. By default, traffic will egress from connected PoP.
	RouteType WanNetworkRuleRouteType `json:"routeType"`
	// Specifies if the rule is for Internet (outbound) or WAN (wanbound) traffic.
	RuleType WanNetworkRuleType `json:"ruleType"`
	// The source of the traffic for the rule.
	Source *WanNetworkRuleSourceInput `json:"source"`
}

type WanNetworkAddRuleInput struct {
	// Position of the rule in the policy
	At *PolicyRulePositionInput `json:"at,omitempty"`
	// Parameters for the rule you are adding
	Rule *WanNetworkAddRuleDataInput `json:"rule"`
}

type WanNetworkPolicy struct {
	Audit    *PolicyAudit             `json:"audit,omitempty"`
	Enabled  bool                     `json:"enabled"`
	Revision *PolicyRevision          `json:"revision,omitempty"`
	Rules    []*WanNetworkRulePayload `json:"rules"`
	Sections []*PolicySectionPayload  `json:"sections"`
}

func (WanNetworkPolicy) IsIPolicy() {}

// TRUE = Policy is enabled, FALSE = Policy is disabled
func (this WanNetworkPolicy) GetEnabled() bool { return this.Enabled }

// Return list of rules in the policy
func (this WanNetworkPolicy) GetRules() []IPolicyRulePayload {
	if this.Rules == nil {
		return nil
	}
	interfaceSlice := make([]IPolicyRulePayload, 0, len(this.Rules))
	for _, concrete := range this.Rules {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

// Return sections in the policy
func (this WanNetworkPolicy) GetSections() []*PolicySectionPayload {
	if this.Sections == nil {
		return nil
	}
	interfaceSlice := make([]*PolicySectionPayload, 0, len(this.Sections))
	for _, concrete := range this.Sections {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

// Audit data for the policy
func (this WanNetworkPolicy) GetAudit() *PolicyAudit { return this.Audit }

// Return data for the Policy revision
func (this WanNetworkPolicy) GetRevision() *PolicyRevision { return this.Revision }

type WanNetworkPolicyInput struct {
	// A revision is a specific instance of the policy.
	//  Unpublished revisions are working copies of the policy available to a specific
	//  admin or a set of admins
	//  Published revisions are revisions that were applied to the account network.
	//  The last published revision is the active policy.
	Revision *PolicyRevisionInput `json:"revision,omitempty"`
}

type WanNetworkPolicyMutationInput struct {
	Revision *PolicyMutationRevisionInput `json:"revision,omitempty"`
}

type WanNetworkPolicyMutationPayload struct {
	Errors []*PolicyMutationError `json:"errors"`
	Policy *WanNetworkPolicy      `json:"policy,omitempty"`
	Status PolicyMutationStatus   `json:"status"`
}

func (WanNetworkPolicyMutationPayload) IsIPolicyMutationPayload() {}

// Data for the policy
func (this WanNetworkPolicyMutationPayload) GetPolicy() IPolicy { return *this.Policy }

// Enum for the status of the policy change
func (this WanNetworkPolicyMutationPayload) GetStatus() PolicyMutationStatus { return this.Status }

// List of errors related to the policy change
func (this WanNetworkPolicyMutationPayload) GetErrors() []*PolicyMutationError {
	if this.Errors == nil {
		return nil
	}
	interfaceSlice := make([]*PolicyMutationError, 0, len(this.Errors))
	for _, concrete := range this.Errors {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

type WanNetworkPolicyMutations struct {
	AddRule               *WanNetworkRuleMutationPayload   `json:"addRule"`
	AddSection            *PolicySectionMutationPayload    `json:"addSection"`
	CreatePolicyRevision  *WanNetworkPolicyMutationPayload `json:"createPolicyRevision"`
	DiscardPolicyRevision *WanNetworkPolicyMutationPayload `json:"discardPolicyRevision"`
	MoveRule              *WanNetworkRuleMutationPayload   `json:"moveRule"`
	MoveSection           *PolicySectionMutationPayload    `json:"moveSection"`
	PublishPolicyRevision *WanNetworkPolicyMutationPayload `json:"publishPolicyRevision"`
	RemoveRule            *WanNetworkRuleMutationPayload   `json:"removeRule"`
	RemoveSection         *PolicySectionMutationPayload    `json:"removeSection"`
	UpdatePolicy          *WanNetworkPolicyMutationPayload `json:"updatePolicy"`
	UpdateRule            *WanNetworkRuleMutationPayload   `json:"updateRule"`
	UpdateSection         *PolicySectionMutationPayload    `json:"updateSection"`
}

type WanNetworkPolicyQueries struct {
	Policy    *WanNetworkPolicy       `json:"policy"`
	Revisions *PolicyRevisionsPayload `json:"revisions,omitempty"`
}

type WanNetworkPolicyUpdateInput struct {
	State *PolicyToggleState `json:"state,omitempty"`
}

type WanNetworkRemoveRuleInput struct {
	ID string `json:"id"`
}

type WanNetworkRule struct {
	// The application or category of traffic for the rule.
	Application *WanNetworkRuleApplication `json:"application"`
	// The bandwidth priority (QoS) for the rule.
	BandwidthPriority *BandwidthManagementRef `json:"bandwidthPriority"`
	// The configuration of the rule.
	Configuration *WanNetworkRuleConfiguration `json:"configuration"`
	// Description for the rule
	Description string `json:"description"`
	// The destination of the traffic for the rule.
	Destination *WanNetworkRuleDestination `json:"destination"`
	// TRUE = Rule is enabled
	//  FALSE = Rule is disabled
	Enabled bool `json:"enabled"`
	// Exceptions to the rule.
	Exceptions []*WanNetworkRuleException `json:"exceptions"`
	// Rule ID
	ID string `json:"id"`
	// Position / priority of rule
	Index int64 `json:"index"`
	// Name of the rule
	Name string `json:"name"`
	// Defines the routing method for the rule. By default, traffic will egress from connected PoP.
	RouteType WanNetworkRuleRouteType `json:"routeType"`
	// Specifies if the rule is for Internet (outbound) or WAN (wanbound) traffic.
	RuleType WanNetworkRuleType `json:"ruleType"`
	// Policy section where the rule is located
	Section *PolicySectionInfo `json:"section"`
	// The source of the traffic for the rule.
	Source *WanNetworkRuleSource `json:"source"`
}

func (WanNetworkRule) IsIPolicyRule() {}

// Rule ID
func (this WanNetworkRule) GetID() string { return this.ID }

// Name of the rule
func (this WanNetworkRule) GetName() string { return this.Name }

// Description for the rule
func (this WanNetworkRule) GetDescription() *string { return &this.Description }

// Position / priority of rule
func (this WanNetworkRule) GetIndex() int64 { return this.Index }

// TRUE = Rule is enabled, FALSE = Rule is disabled
func (this WanNetworkRule) GetEnabled() bool { return this.Enabled }

// Policy section where the rule is located
func (this WanNetworkRule) GetSection() *PolicySectionInfo { return this.Section }

type WanNetworkRuleApplication struct {
	AppCategory     []*ApplicationCategoryRef `json:"appCategory"`
	Application     []*ApplicationRef         `json:"application"`
	CustomApp       []*CustomApplicationRef   `json:"customApp"`
	CustomCategory  []*CustomCategoryRef      `json:"customCategory"`
	CustomService   []*CustomService          `json:"customService"`
	CustomServiceIP []*CustomServiceIP        `json:"customServiceIp"`
	Domain          []string                  `json:"domain"`
	Fqdn            []string                  `json:"fqdn"`
	Service         []*ServiceRef             `json:"service"`
}

type WanNetworkRuleApplicationInput struct {
	AppCategory     []*ApplicationCategoryRefInput `json:"appCategory"`
	Application     []*ApplicationRefInput         `json:"application"`
	CustomApp       []*CustomApplicationRefInput   `json:"customApp"`
	CustomCategory  []*CustomCategoryRefInput      `json:"customCategory"`
	CustomService   []*CustomServiceInput          `json:"customService"`
	CustomServiceIP []*CustomServiceIPInput        `json:"customServiceIp"`
	Domain          []string                       `json:"domain"`
	Fqdn            []string                       `json:"fqdn"`
	Service         []*ServiceRefInput             `json:"service"`
}

type WanNetworkRuleApplicationUpdateInput struct {
	AppCategory     []*ApplicationCategoryRefInput `json:"appCategory,omitempty"`
	Application     []*ApplicationRefInput         `json:"application,omitempty"`
	CustomApp       []*CustomApplicationRefInput   `json:"customApp,omitempty"`
	CustomCategory  []*CustomCategoryRefInput      `json:"customCategory,omitempty"`
	CustomService   []*CustomServiceInput          `json:"customService,omitempty"`
	CustomServiceIP []*CustomServiceIPInput        `json:"customServiceIp,omitempty"`
	Domain          []string                       `json:"domain,omitempty"`
	Fqdn            []string                       `json:"fqdn,omitempty"`
	Service         []*ServiceRefInput             `json:"service,omitempty"`
}

type WanNetworkRuleConfiguration struct {
	// Indicates if TCP acceleration is enabled.
	ActiveTCPAcceleration bool `json:"activeTcpAcceleration"`
	// The allocated IP for NAT routing. Taken from IP Allocation, per PoP.
	AllocationIP []*AllocatedIPRef `json:"allocationIp"`
	// The site for backhaul routing option.
	BackhaulingSite []*SiteRef `json:"backhaulingSite"`
	// Indicates if packet loss mitigation is enabled.
	PacketLossMitigation bool `json:"packetLossMitigation"`
	// The PoP location for routing and egressing from Cato Cloud.
	PopLocation []*PopLocationRef `json:"popLocation"`
	// Indicates if the source port should be preserved.
	PreserveSourcePort bool `json:"preserveSourcePort"`
	// The primary transport method.
	PrimaryTransport *WanNetworkRuleTransport `json:"primaryTransport"`
	// The secondary transport method.
	SecondaryTransport *WanNetworkRuleTransport `json:"secondaryTransport"`
}

type WanNetworkRuleConfigurationInput struct {
	// Indicates if TCP acceleration is enabled.
	ActiveTCPAcceleration bool `json:"activeTcpAcceleration"`
	// The allocated IP for NAT routing. Taken from IP Allocation, per PoP.
	AllocationIP []*AllocatedIPRefInput `json:"allocationIp"`
	// The site for backhaul routing option.
	BackhaulingSite []*SiteRefInput `json:"backhaulingSite"`
	// Indicates if packet loss mitigation is enabled.
	PacketLossMitigation bool `json:"packetLossMitigation"`
	// The PoP location for routing and egressing from Cato Cloud.
	PopLocation []*PopLocationRefInput `json:"popLocation"`
	// Indicates if the source port should be preserved.
	PreserveSourcePort bool `json:"preserveSourcePort"`
	// The primary transport method.
	PrimaryTransport *WanNetworkRuleTransportInput `json:"primaryTransport"`
	// The secondary transport method.
	SecondaryTransport *WanNetworkRuleTransportInput `json:"secondaryTransport"`
}

type WanNetworkRuleConfigurationUpdateInput struct {
	// Indicates if TCP acceleration is enabled.
	ActiveTCPAcceleration *bool `json:"activeTcpAcceleration,omitempty"`
	// The allocated IP for NAT routing. Taken from IP Allocation, per PoP.
	AllocationIP []*AllocatedIPRefInput `json:"allocationIp,omitempty"`
	// The site for backhaul routing option.
	BackhaulingSite []*SiteRefInput `json:"backhaulingSite,omitempty"`
	// Indicates if packet loss mitigation is enabled.
	PacketLossMitigation *bool `json:"packetLossMitigation,omitempty"`
	// The PoP location for routing and egressing from Cato Cloud.
	PopLocation []*PopLocationRefInput `json:"popLocation,omitempty"`
	// Indicates if the source port should be preserved.
	PreserveSourcePort *bool `json:"preserveSourcePort,omitempty"`
	// The primary transport method.
	PrimaryTransport *WanNetworkRuleTransportUpdateInput `json:"primaryTransport,omitempty"`
	// The secondary transport method.
	SecondaryTransport *WanNetworkRuleTransportUpdateInput `json:"secondaryTransport,omitempty"`
}

type WanNetworkRuleDestination struct {
	FloatingSubnet    []*FloatingSubnetRef    `json:"floatingSubnet"`
	GlobalIPRange     []*GlobalIPRangeRef     `json:"globalIpRange"`
	Group             []*GroupRef             `json:"group"`
	Host              []*HostRef              `json:"host"`
	IP                []string                `json:"ip"`
	IPRange           []*IPAddressRange       `json:"ipRange"`
	NetworkInterface  []*NetworkInterfaceRef  `json:"networkInterface"`
	Site              []*SiteRef              `json:"site"`
	SiteNetworkSubnet []*SiteNetworkSubnetRef `json:"siteNetworkSubnet"`
	Subnet            []string                `json:"subnet"`
	SystemGroup       []*SystemGroupRef       `json:"systemGroup"`
	User              []*UserRef              `json:"user"`
	UsersGroup        []*UsersGroupRef        `json:"usersGroup"`
}

type WanNetworkRuleDestinationInput struct {
	FloatingSubnet    []*FloatingSubnetRefInput    `json:"floatingSubnet"`
	GlobalIPRange     []*GlobalIPRangeRefInput     `json:"globalIpRange"`
	Group             []*GroupRefInput             `json:"group"`
	Host              []*HostRefInput              `json:"host"`
	IP                []string                     `json:"ip"`
	IPRange           []*IPAddressRangeInput       `json:"ipRange"`
	NetworkInterface  []*NetworkInterfaceRefInput  `json:"networkInterface"`
	Site              []*SiteRefInput              `json:"site"`
	SiteNetworkSubnet []*SiteNetworkSubnetRefInput `json:"siteNetworkSubnet"`
	Subnet            []string                     `json:"subnet"`
	SystemGroup       []*SystemGroupRefInput       `json:"systemGroup"`
	User              []*UserRefInput              `json:"user"`
	UsersGroup        []*UsersGroupRefInput        `json:"usersGroup"`
}

type WanNetworkRuleDestinationUpdateInput struct {
	FloatingSubnet    []*FloatingSubnetRefInput    `json:"floatingSubnet,omitempty"`
	GlobalIPRange     []*GlobalIPRangeRefInput     `json:"globalIpRange,omitempty"`
	Group             []*GroupRefInput             `json:"group,omitempty"`
	Host              []*HostRefInput              `json:"host,omitempty"`
	IP                []string                     `json:"ip,omitempty"`
	IPRange           []*IPAddressRangeInput       `json:"ipRange,omitempty"`
	NetworkInterface  []*NetworkInterfaceRefInput  `json:"networkInterface,omitempty"`
	Site              []*SiteRefInput              `json:"site,omitempty"`
	SiteNetworkSubnet []*SiteNetworkSubnetRefInput `json:"siteNetworkSubnet,omitempty"`
	Subnet            []string                     `json:"subnet,omitempty"`
	SystemGroup       []*SystemGroupRefInput       `json:"systemGroup,omitempty"`
	User              []*UserRefInput              `json:"user,omitempty"`
	UsersGroup        []*UsersGroupRefInput        `json:"usersGroup,omitempty"`
}

type WanNetworkRuleException struct {
	// The application or category of traffic for the rule.
	Application *WanNetworkRuleApplication `json:"application"`
	// The destination of the traffic for the rule.
	Destination *WanNetworkRuleDestination `json:"destination"`
	// The name of the network rule.
	Name string `json:"name"`
	// The source of the traffic for the rule.
	Source *WanNetworkRuleSource `json:"source"`
}

type WanNetworkRuleExceptionInput struct {
	// The application or category of traffic for the rule.
	Application *WanNetworkRuleApplicationInput `json:"application"`
	// The destination of the traffic for the rule.
	Destination *WanNetworkRuleDestinationInput `json:"destination"`
	// The name of the network rule.
	Name string `json:"name"`
	// The source of the traffic for the rule.
	Source *WanNetworkRuleSourceInput `json:"source"`
}

type WanNetworkRuleMutationPayload struct {
	Errors []*PolicyMutationError `json:"errors"`
	Rule   *WanNetworkRulePayload `json:"rule,omitempty"`
	Status PolicyMutationStatus   `json:"status"`
}

func (WanNetworkRuleMutationPayload) IsIPolicyRuleMutationPayload() {}

// Returns settings for the rule
func (this WanNetworkRuleMutationPayload) GetRule() IPolicyRulePayload { return *this.Rule }

// Enum for the status of the policy change
func (this WanNetworkRuleMutationPayload) GetStatus() PolicyMutationStatus { return this.Status }

// List of errors related to the policy change
func (this WanNetworkRuleMutationPayload) GetErrors() []*PolicyMutationError {
	if this.Errors == nil {
		return nil
	}
	interfaceSlice := make([]*PolicyMutationError, 0, len(this.Errors))
	for _, concrete := range this.Errors {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

type WanNetworkRulePayload struct {
	Audit      *PolicyElementAudit           `json:"audit"`
	Properties []PolicyElementPropertiesEnum `json:"properties"`
	Rule       *WanNetworkRule               `json:"rule"`
}

func (WanNetworkRulePayload) IsIPolicyRulePayload()              {}
func (this WanNetworkRulePayload) GetAudit() *PolicyElementAudit { return this.Audit }

// Rule that was changed
func (this WanNetworkRulePayload) GetRule() IPolicyRule { return *this.Rule }

// Summary of rule change, (ie. ADDED, UPDATED)
func (this WanNetworkRulePayload) GetProperties() []PolicyElementPropertiesEnum {
	if this.Properties == nil {
		return nil
	}
	interfaceSlice := make([]PolicyElementPropertiesEnum, 0, len(this.Properties))
	for _, concrete := range this.Properties {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

type WanNetworkRuleSource struct {
	FloatingSubnet    []*FloatingSubnetRef    `json:"floatingSubnet"`
	GlobalIPRange     []*GlobalIPRangeRef     `json:"globalIpRange"`
	Group             []*GroupRef             `json:"group"`
	Host              []*HostRef              `json:"host"`
	IP                []string                `json:"ip"`
	IPRange           []*IPAddressRange       `json:"ipRange"`
	NetworkInterface  []*NetworkInterfaceRef  `json:"networkInterface"`
	Site              []*SiteRef              `json:"site"`
	SiteNetworkSubnet []*SiteNetworkSubnetRef `json:"siteNetworkSubnet"`
	Subnet            []string                `json:"subnet"`
	SystemGroup       []*SystemGroupRef       `json:"systemGroup"`
	User              []*UserRef              `json:"user"`
	UsersGroup        []*UsersGroupRef        `json:"usersGroup"`
}

type WanNetworkRuleSourceInput struct {
	FloatingSubnet    []*FloatingSubnetRefInput    `json:"floatingSubnet"`
	GlobalIPRange     []*GlobalIPRangeRefInput     `json:"globalIpRange"`
	Group             []*GroupRefInput             `json:"group"`
	Host              []*HostRefInput              `json:"host"`
	IP                []string                     `json:"ip"`
	IPRange           []*IPAddressRangeInput       `json:"ipRange"`
	NetworkInterface  []*NetworkInterfaceRefInput  `json:"networkInterface"`
	Site              []*SiteRefInput              `json:"site"`
	SiteNetworkSubnet []*SiteNetworkSubnetRefInput `json:"siteNetworkSubnet"`
	Subnet            []string                     `json:"subnet"`
	SystemGroup       []*SystemGroupRefInput       `json:"systemGroup"`
	User              []*UserRefInput              `json:"user"`
	UsersGroup        []*UsersGroupRefInput        `json:"usersGroup"`
}

type WanNetworkRuleSourceUpdateInput struct {
	FloatingSubnet    []*FloatingSubnetRefInput    `json:"floatingSubnet,omitempty"`
	GlobalIPRange     []*GlobalIPRangeRefInput     `json:"globalIpRange,omitempty"`
	Group             []*GroupRefInput             `json:"group,omitempty"`
	Host              []*HostRefInput              `json:"host,omitempty"`
	IP                []string                     `json:"ip,omitempty"`
	IPRange           []*IPAddressRangeInput       `json:"ipRange,omitempty"`
	NetworkInterface  []*NetworkInterfaceRefInput  `json:"networkInterface,omitempty"`
	Site              []*SiteRefInput              `json:"site,omitempty"`
	SiteNetworkSubnet []*SiteNetworkSubnetRefInput `json:"siteNetworkSubnet,omitempty"`
	Subnet            []string                     `json:"subnet,omitempty"`
	SystemGroup       []*SystemGroupRefInput       `json:"systemGroup,omitempty"`
	User              []*UserRefInput              `json:"user,omitempty"`
	UsersGroup        []*UsersGroupRefInput        `json:"usersGroup,omitempty"`
}

type WanNetworkRuleTransport struct {
	// The primary interface role.
	PrimaryInterfaceRole WanNetworkRuleInterfaceRole `json:"primaryInterfaceRole"`
	// The secondary interface role.
	SecondaryInterfaceRole WanNetworkRuleInterfaceRole `json:"secondaryInterfaceRole"`
	TransportType          WanNetworkRuleTransportType `json:"transportType"`
}

type WanNetworkRuleTransportInput struct {
	// The primary interface role.
	PrimaryInterfaceRole WanNetworkRuleInterfaceRole `json:"primaryInterfaceRole"`
	// The secondary interface role.
	SecondaryInterfaceRole WanNetworkRuleInterfaceRole `json:"secondaryInterfaceRole"`
	TransportType          WanNetworkRuleTransportType `json:"transportType"`
}

type WanNetworkRuleTransportUpdateInput struct {
	// The primary interface role.
	PrimaryInterfaceRole *WanNetworkRuleInterfaceRole `json:"primaryInterfaceRole,omitempty"`
	// The secondary interface role.
	SecondaryInterfaceRole *WanNetworkRuleInterfaceRole `json:"secondaryInterfaceRole,omitempty"`
	TransportType          *WanNetworkRuleTransportType `json:"transportType,omitempty"`
}

type WanNetworkUpdateRuleDataInput struct {
	// The application or category of traffic for the rule.
	Application *WanNetworkRuleApplicationUpdateInput `json:"application,omitempty"`
	// The bandwidth priority (QoS) for the rule.
	BandwidthPriority *BandwidthManagementRefInput `json:"bandwidthPriority,omitempty"`
	// The configuration of the rule.
	Configuration *WanNetworkRuleConfigurationUpdateInput `json:"configuration,omitempty"`
	Description   *string                                 `json:"description,omitempty"`
	// The destination of the traffic for the rule.
	Destination *WanNetworkRuleDestinationUpdateInput `json:"destination,omitempty"`
	Enabled     *bool                                 `json:"enabled,omitempty"`
	// Exceptions to the rule.
	Exceptions []*WanNetworkRuleExceptionInput `json:"exceptions,omitempty"`
	Name       *string                         `json:"name,omitempty"`
	// Defines the routing method for the rule. By default, traffic will egress from connected PoP.
	RouteType *WanNetworkRuleRouteType `json:"routeType,omitempty"`
	// Specifies if the rule is for Internet (outbound) or WAN (wanbound) traffic.
	RuleType *WanNetworkRuleType `json:"ruleType,omitempty"`
	// The source of the traffic for the rule.
	Source *WanNetworkRuleSourceUpdateInput `json:"source,omitempty"`
}

type WanNetworkUpdateRuleInput struct {
	ID   string                         `json:"id"`
	Rule *WanNetworkUpdateRuleDataInput `json:"rule"`
}

type Xdr struct {
	// Define the paging, sort, and filter arguments to define the XDR stories that are returned in the query
	Stories *StoriesData `json:"stories,omitempty"`
	// Define either the story ID, or the incident ID and producer arguments, to query the specific XDR story
	Story *Story `json:"story,omitempty"`
}

// XOps service license details
type XOpsLicense struct {
	Description *string `json:"description,omitempty"`
	// License expiration date
	ExpirationDate string `json:"expirationDate"`
	// The unique identifier for the license. If this value is not available, you can contact Cato Support, who may be able to assist in retrieving it.
	ID *string `json:"id,omitempty"`
	// The date of the last update to the license
	LastUpdated *string `json:"lastUpdated,omitempty"`
	// License plan type
	Plan LicensePlan `json:"plan"`
	// The license SKU
	Sku LicenseSku `json:"sku"`
	// License start date
	StartDate *string `json:"startDate,omitempty"`
	// License activation status
	Status LicenseStatus `json:"status"`
}

func (XOpsLicense) IsLicense() {}

// The unique identifier for the license. If this value is not available, you can contact Cato Support, who may be able to assist in retrieving it.
func (this XOpsLicense) GetID() *string          { return this.ID }
func (this XOpsLicense) GetDescription() *string { return this.Description }

// License plan type
func (this XOpsLicense) GetPlan() LicensePlan { return this.Plan }

// The license SKU
func (this XOpsLicense) GetSku() LicenseSku { return this.Sku }

// License activation status
func (this XOpsLicense) GetStatus() LicenseStatus { return this.Status }

// License start date
func (this XOpsLicense) GetStartDate() *string { return this.StartDate }

// License expiration date
func (this XOpsLicense) GetExpirationDate() string { return this.ExpirationDate }

// The date of the last update to the license
func (this XOpsLicense) GetLastUpdated() *string { return this.LastUpdated }

type XdrMutations struct {
	// Post comments that help track the story investigation
	AddStoryComment *AddStoryCommentPayload `json:"addStoryComment,omitempty"`
	// Manage Story Actions, such as the story Verdict, Type, and Classification. You can also enter Additional Info that is relevant to the story.
	AnalystFeedback *AnalystFeedbackPayload `json:"analystFeedback,omitempty"`
	// Delete a previously posted comment using the comment ID.
	DeleteStoryComment *DeleteStoryCommentPayload `json:"deleteStoryComment,omitempty"`
}

// XDR Pro (extended detection and response) service license details
type XdrProLicense struct {
	Description *string `json:"description,omitempty"`
	// License expiration date
	ExpirationDate string `json:"expirationDate"`
	// The unique identifier for the license. If this value is not available, you can contact Cato Support, who may be able to assist in retrieving it.
	ID *string `json:"id,omitempty"`
	// The date of the last update to the license
	LastUpdated *string `json:"lastUpdated,omitempty"`
	// License plan type
	Plan LicensePlan `json:"plan"`
	// The license SKU
	Sku LicenseSku `json:"sku"`
	// License start date
	StartDate *string `json:"startDate,omitempty"`
	// License activation status
	Status LicenseStatus `json:"status"`
	// The number of knowledge users that the XDR Pro service refers to
	Total int64 `json:"total"`
}

func (XdrProLicense) IsLicense() {}

// The unique identifier for the license. If this value is not available, you can contact Cato Support, who may be able to assist in retrieving it.
func (this XdrProLicense) GetID() *string          { return this.ID }
func (this XdrProLicense) GetDescription() *string { return this.Description }

// License plan type
func (this XdrProLicense) GetPlan() LicensePlan { return this.Plan }

// The license SKU
func (this XdrProLicense) GetSku() LicenseSku { return this.Sku }

// License activation status
func (this XdrProLicense) GetStatus() LicenseStatus { return this.Status }

// License start date
func (this XdrProLicense) GetStartDate() *string { return this.StartDate }

// License expiration date
func (this XdrProLicense) GetExpirationDate() string { return this.ExpirationDate }

// The date of the last update to the license
func (this XdrProLicense) GetLastUpdated() *string { return this.LastUpdated }

func (XdrProLicense) IsQuantifiableLicense() {}

// The unique identifier for the license. If this value is not available, you can contact Cato Support, who may be able to assist in retrieving it.

// License plan type

// The license SKU

// License activation status

// License initiation date

// License expiration date

// The date of the last update to the license

// license quantity
func (this XdrProLicense) GetTotal() int64 { return this.Total }

// ZTNA remote users license
type ZtnaUsersLicense struct {
	Description *string `json:"description,omitempty"`
	// License expiration date
	ExpirationDate string `json:"expirationDate"`
	// The unique identifier for the license. If this value is not available, you can contact Cato Support, who may be able to assist in retrieving it.
	ID *string `json:"id,omitempty"`
	// The date of the last update to the license
	LastUpdated *string `json:"lastUpdated,omitempty"`
	// License plan type
	Plan LicensePlan `json:"plan"`
	// The license SKU
	Sku LicenseSku `json:"sku"`
	// License start date
	StartDate *string `json:"startDate,omitempty"`
	// License activation status
	Status LicenseStatus `json:"status"`
	// The maximum amount of ZTNA users for the region.
	Total int64 `json:"total"`
	// Specify a license group that you are limiting the number of ZTNA users
	ZtnaUsersLicenseGroup ZtnaUsersLicenseGroup `json:"ztnaUsersLicenseGroup"`
}

func (ZtnaUsersLicense) IsLicense() {}

// The unique identifier for the license. If this value is not available, you can contact Cato Support, who may be able to assist in retrieving it.
func (this ZtnaUsersLicense) GetID() *string          { return this.ID }
func (this ZtnaUsersLicense) GetDescription() *string { return this.Description }

// License plan type
func (this ZtnaUsersLicense) GetPlan() LicensePlan { return this.Plan }

// The license SKU
func (this ZtnaUsersLicense) GetSku() LicenseSku { return this.Sku }

// License activation status
func (this ZtnaUsersLicense) GetStatus() LicenseStatus { return this.Status }

// License start date
func (this ZtnaUsersLicense) GetStartDate() *string { return this.StartDate }

// License expiration date
func (this ZtnaUsersLicense) GetExpirationDate() string { return this.ExpirationDate }

// The date of the last update to the license
func (this ZtnaUsersLicense) GetLastUpdated() *string { return this.LastUpdated }

func (ZtnaUsersLicense) IsQuantifiableLicense() {}

// The unique identifier for the license. If this value is not available, you can contact Cato Support, who may be able to assist in retrieving it.

// License plan type

// The license SKU

// License activation status

// License initiation date

// License expiration date

// The date of the last update to the license

// license quantity
func (this ZtnaUsersLicense) GetTotal() int64 { return this.Total }

// Global ZTNA license usage and allocation across all accounts
type ZtnaUsersLicenseAllocations struct {
	// Total users allocated a ZTNA license
	Allocated int64 `json:"allocated"`
	// Available users not yet allocated a license
	Available int64 `json:"available"`
	// Total ZTNA licenses for users
	Total int64 `json:"total"`
}

type AccountInclusion string

const (
	AccountInclusionAllAccounts         AccountInclusion = "ALL_ACCOUNTS"
	AccountInclusionManagedAccountsOnly AccountInclusion = "MANAGED_ACCOUNTS_ONLY"
)

var AllAccountInclusion = []AccountInclusion{
	AccountInclusionAllAccounts,
	AccountInclusionManagedAccountsOnly,
}

func (e AccountInclusion) IsValid() bool {
	switch e {
	case AccountInclusionAllAccounts, AccountInclusionManagedAccountsOnly:
		return true
	}
	return false
}

func (e AccountInclusion) String() string {
	return string(e)
}

func (e *AccountInclusion) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AccountInclusion(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AccountInclusion", str)
	}
	return nil
}

func (e AccountInclusion) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *AccountInclusion) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e AccountInclusion) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type AccountOperationsTimelineType string

const (
	AccountOperationsTimelineTypeAction AccountOperationsTimelineType = "Action"
	AccountOperationsTimelineTypeEvent  AccountOperationsTimelineType = "Event"
)

var AllAccountOperationsTimelineType = []AccountOperationsTimelineType{
	AccountOperationsTimelineTypeAction,
	AccountOperationsTimelineTypeEvent,
}

func (e AccountOperationsTimelineType) IsValid() bool {
	switch e {
	case AccountOperationsTimelineTypeAction, AccountOperationsTimelineTypeEvent:
		return true
	}
	return false
}

func (e AccountOperationsTimelineType) String() string {
	return string(e)
}

func (e *AccountOperationsTimelineType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AccountOperationsTimelineType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AccountOperationsTimelineType", str)
	}
	return nil
}

func (e AccountOperationsTimelineType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *AccountOperationsTimelineType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e AccountOperationsTimelineType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// enum that shows account license status
type AccountPlan string

const (
	AccountPlanCommercial AccountPlan = "COMMERCIAL"
	AccountPlanTrial      AccountPlan = "TRIAL"
)

var AllAccountPlan = []AccountPlan{
	AccountPlanCommercial,
	AccountPlanTrial,
}

func (e AccountPlan) IsValid() bool {
	switch e {
	case AccountPlanCommercial, AccountPlanTrial:
		return true
	}
	return false
}

func (e AccountPlan) String() string {
	return string(e)
}

func (e *AccountPlan) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AccountPlan(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AccountPlan", str)
	}
	return nil
}

func (e AccountPlan) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *AccountPlan) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e AccountPlan) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// enum for account type
type AccountProfileType string

const (
	// A customer account
	AccountProfileTypeCustomer AccountProfileType = "CUSTOMER"
	// A partner account
	AccountProfileTypePartner AccountProfileType = "PARTNER"
)

var AllAccountProfileType = []AccountProfileType{
	AccountProfileTypeCustomer,
	AccountProfileTypePartner,
}

func (e AccountProfileType) IsValid() bool {
	switch e {
	case AccountProfileTypeCustomer, AccountProfileTypePartner:
		return true
	}
	return false
}

func (e AccountProfileType) String() string {
	return string(e)
}

func (e *AccountProfileType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AccountProfileType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AccountProfileType", str)
	}
	return nil
}

func (e AccountProfileType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *AccountProfileType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e AccountProfileType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// enum that shows account license status
type AccountStatus string

const (
	AccountStatusActive   AccountStatus = "ACTIVE"
	AccountStatusDisabled AccountStatus = "DISABLED"
	AccountStatusLocked   AccountStatus = "LOCKED"
)

var AllAccountStatus = []AccountStatus{
	AccountStatusActive,
	AccountStatusDisabled,
	AccountStatusLocked,
}

func (e AccountStatus) IsValid() bool {
	switch e {
	case AccountStatusActive, AccountStatusDisabled, AccountStatusLocked:
		return true
	}
	return false
}

func (e AccountStatus) String() string {
	return string(e)
}

func (e *AccountStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AccountStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AccountStatus", str)
	}
	return nil
}

func (e AccountStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *AccountStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e AccountStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// enum for account tenancy
type AccountTenancy string

const (
	// Multi tenant account - default for partner accounts
	AccountTenancyMultiTenant AccountTenancy = "MULTI_TENANT"
	// Single tenant account - default for customer accounts
	AccountTenancySingleTenant AccountTenancy = "SINGLE_TENANT"
)

var AllAccountTenancy = []AccountTenancy{
	AccountTenancyMultiTenant,
	AccountTenancySingleTenant,
}

func (e AccountTenancy) IsValid() bool {
	switch e {
	case AccountTenancyMultiTenant, AccountTenancySingleTenant:
		return true
	}
	return false
}

func (e AccountTenancy) String() string {
	return string(e)
}

func (e *AccountTenancy) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AccountTenancy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AccountTenancy", str)
	}
	return nil
}

func (e AccountTenancy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *AccountTenancy) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e AccountTenancy) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type AccountType string

const (
	AccountTypeAll      AccountType = "ALL"
	AccountTypeRegular  AccountType = "REGULAR"
	AccountTypeReseller AccountType = "RESELLER"
	AccountTypeSystem   AccountType = "SYSTEM"
)

var AllAccountType = []AccountType{
	AccountTypeAll,
	AccountTypeRegular,
	AccountTypeReseller,
	AccountTypeSystem,
}

func (e AccountType) IsValid() bool {
	switch e {
	case AccountTypeAll, AccountTypeRegular, AccountTypeReseller, AccountTypeSystem:
		return true
	}
	return false
}

func (e AccountType) String() string {
	return string(e)
}

func (e *AccountType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AccountType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AccountType", str)
	}
	return nil
}

func (e AccountType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *AccountType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e AccountType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type AddressValidationStatus string

const (
	AddressValidationStatusInvalid AddressValidationStatus = "INVALID"
	AddressValidationStatusNa      AddressValidationStatus = "NA"
	AddressValidationStatusValid   AddressValidationStatus = "VALID"
)

var AllAddressValidationStatus = []AddressValidationStatus{
	AddressValidationStatusInvalid,
	AddressValidationStatusNa,
	AddressValidationStatusValid,
}

func (e AddressValidationStatus) IsValid() bool {
	switch e {
	case AddressValidationStatusInvalid, AddressValidationStatusNa, AddressValidationStatusValid:
		return true
	}
	return false
}

func (e AddressValidationStatus) String() string {
	return string(e)
}

func (e *AddressValidationStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AddressValidationStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AddressValidationStatus", str)
	}
	return nil
}

func (e AddressValidationStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *AddressValidationStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e AddressValidationStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type AdminType string

const (
	AdminTypeLogin            AdminType = "LOGIN"
	AdminTypeServicePrinciple AdminType = "SERVICE_PRINCIPLE"
)

var AllAdminType = []AdminType{
	AdminTypeLogin,
	AdminTypeServicePrinciple,
}

func (e AdminType) IsValid() bool {
	switch e {
	case AdminTypeLogin, AdminTypeServicePrinciple:
		return true
	}
	return false
}

func (e AdminType) String() string {
	return string(e)
}

func (e *AdminType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AdminType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AdminType", str)
	}
	return nil
}

func (e AdminType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *AdminType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e AdminType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type AggregationType string

const (
	AggregationTypeAny           AggregationType = "any"
	AggregationTypeAvg           AggregationType = "avg"
	AggregationTypeChanges       AggregationType = "changes"
	AggregationTypeCount         AggregationType = "count"
	AggregationTypeCountDistinct AggregationType = "count_distinct"
	AggregationTypeDistinct      AggregationType = "distinct"
	AggregationTypeMax           AggregationType = "max"
	AggregationTypeMin           AggregationType = "min"
	AggregationTypeSum           AggregationType = "sum"
	AggregationTypeUniqSet       AggregationType = "uniq_set"
)

var AllAggregationType = []AggregationType{
	AggregationTypeAny,
	AggregationTypeAvg,
	AggregationTypeChanges,
	AggregationTypeCount,
	AggregationTypeCountDistinct,
	AggregationTypeDistinct,
	AggregationTypeMax,
	AggregationTypeMin,
	AggregationTypeSum,
	AggregationTypeUniqSet,
}

func (e AggregationType) IsValid() bool {
	switch e {
	case AggregationTypeAny, AggregationTypeAvg, AggregationTypeChanges, AggregationTypeCount, AggregationTypeCountDistinct, AggregationTypeDistinct, AggregationTypeMax, AggregationTypeMin, AggregationTypeSum, AggregationTypeUniqSet:
		return true
	}
	return false
}

func (e AggregationType) String() string {
	return string(e)
}

func (e *AggregationType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AggregationType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AggregationType", str)
	}
	return nil
}

func (e AggregationType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *AggregationType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e AggregationType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type AiOperationsIncidentTypeEnum string

const (
	AiOperationsIncidentTypeEnumAccount AiOperationsIncidentTypeEnum = "Account"
)

var AllAiOperationsIncidentTypeEnum = []AiOperationsIncidentTypeEnum{
	AiOperationsIncidentTypeEnumAccount,
}

func (e AiOperationsIncidentTypeEnum) IsValid() bool {
	switch e {
	case AiOperationsIncidentTypeEnumAccount:
		return true
	}
	return false
}

func (e AiOperationsIncidentTypeEnum) String() string {
	return string(e)
}

func (e *AiOperationsIncidentTypeEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AiOperationsIncidentTypeEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AiOperationsIncidentTypeEnum", str)
	}
	return nil
}

func (e AiOperationsIncidentTypeEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *AiOperationsIncidentTypeEnum) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e AiOperationsIncidentTypeEnum) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type AlertClassificationEnum string

const (
	AlertClassificationEnumFalsePositive                 AlertClassificationEnum = "FALSE_POSITIVE"
	AlertClassificationEnumInformationalExpectedActivity AlertClassificationEnum = "INFORMATIONAL_EXPECTED_ACTIVITY"
	AlertClassificationEnumTruePositive                  AlertClassificationEnum = "TRUE_POSITIVE"
)

var AllAlertClassificationEnum = []AlertClassificationEnum{
	AlertClassificationEnumFalsePositive,
	AlertClassificationEnumInformationalExpectedActivity,
	AlertClassificationEnumTruePositive,
}

func (e AlertClassificationEnum) IsValid() bool {
	switch e {
	case AlertClassificationEnumFalsePositive, AlertClassificationEnumInformationalExpectedActivity, AlertClassificationEnumTruePositive:
		return true
	}
	return false
}

func (e AlertClassificationEnum) String() string {
	return string(e)
}

func (e *AlertClassificationEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AlertClassificationEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AlertClassificationEnum", str)
	}
	return nil
}

func (e AlertClassificationEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *AlertClassificationEnum) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e AlertClassificationEnum) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type AlertDeterminationEnum string

const (
	AlertDeterminationEnumApt                       AlertDeterminationEnum = "APT"
	AlertDeterminationEnumCompromisedAccount        AlertDeterminationEnum = "COMPROMISED_ACCOUNT"
	AlertDeterminationEnumConfirmedActivity         AlertDeterminationEnum = "CONFIRMED_ACTIVITY"
	AlertDeterminationEnumLineOfBusinessApplication AlertDeterminationEnum = "LINE_OF_BUSINESS_APPLICATION"
	AlertDeterminationEnumMaliciousUserActivity     AlertDeterminationEnum = "MALICIOUS_USER_ACTIVITY"
	AlertDeterminationEnumMalware                   AlertDeterminationEnum = "MALWARE"
	AlertDeterminationEnumMultiStagedAttack         AlertDeterminationEnum = "MULTI_STAGED_ATTACK"
	AlertDeterminationEnumNotEnoughDataToValidate   AlertDeterminationEnum = "NOT_ENOUGH_DATA_TO_VALIDATE"
	AlertDeterminationEnumNotMalicious              AlertDeterminationEnum = "NOT_MALICIOUS"
	AlertDeterminationEnumOther                     AlertDeterminationEnum = "OTHER"
	AlertDeterminationEnumPhishing                  AlertDeterminationEnum = "PHISHING"
	AlertDeterminationEnumSecurityPersonnel         AlertDeterminationEnum = "SECURITY_PERSONNEL"
	AlertDeterminationEnumSecurityTesting           AlertDeterminationEnum = "SECURITY_TESTING"
	AlertDeterminationEnumUnwantedSoftware          AlertDeterminationEnum = "UNWANTED_SOFTWARE"
)

var AllAlertDeterminationEnum = []AlertDeterminationEnum{
	AlertDeterminationEnumApt,
	AlertDeterminationEnumCompromisedAccount,
	AlertDeterminationEnumConfirmedActivity,
	AlertDeterminationEnumLineOfBusinessApplication,
	AlertDeterminationEnumMaliciousUserActivity,
	AlertDeterminationEnumMalware,
	AlertDeterminationEnumMultiStagedAttack,
	AlertDeterminationEnumNotEnoughDataToValidate,
	AlertDeterminationEnumNotMalicious,
	AlertDeterminationEnumOther,
	AlertDeterminationEnumPhishing,
	AlertDeterminationEnumSecurityPersonnel,
	AlertDeterminationEnumSecurityTesting,
	AlertDeterminationEnumUnwantedSoftware,
}

func (e AlertDeterminationEnum) IsValid() bool {
	switch e {
	case AlertDeterminationEnumApt, AlertDeterminationEnumCompromisedAccount, AlertDeterminationEnumConfirmedActivity, AlertDeterminationEnumLineOfBusinessApplication, AlertDeterminationEnumMaliciousUserActivity, AlertDeterminationEnumMalware, AlertDeterminationEnumMultiStagedAttack, AlertDeterminationEnumNotEnoughDataToValidate, AlertDeterminationEnumNotMalicious, AlertDeterminationEnumOther, AlertDeterminationEnumPhishing, AlertDeterminationEnumSecurityPersonnel, AlertDeterminationEnumSecurityTesting, AlertDeterminationEnumUnwantedSoftware:
		return true
	}
	return false
}

func (e AlertDeterminationEnum) String() string {
	return string(e)
}

func (e *AlertDeterminationEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AlertDeterminationEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AlertDeterminationEnum", str)
	}
	return nil
}

func (e AlertDeterminationEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *AlertDeterminationEnum) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e AlertDeterminationEnum) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type AnnotationType string

const (
	// Other events that are included in annotations
	AnnotationTypeGeneric AnnotationType = "generic"
	// The site connects to a different PoP
	AnnotationTypePopChange AnnotationType = "popChange"
	// The ISP IP address (remote IP) changed
	AnnotationTypeRemoteIPChange AnnotationType = "remoteIPChange"
	// Change for HA status role
	AnnotationTypeRoleChange AnnotationType = "roleChange"
)

var AllAnnotationType = []AnnotationType{
	AnnotationTypeGeneric,
	AnnotationTypePopChange,
	AnnotationTypeRemoteIPChange,
	AnnotationTypeRoleChange,
}

func (e AnnotationType) IsValid() bool {
	switch e {
	case AnnotationTypeGeneric, AnnotationTypePopChange, AnnotationTypeRemoteIPChange, AnnotationTypeRoleChange:
		return true
	}
	return false
}

func (e AnnotationType) String() string {
	return string(e)
}

func (e *AnnotationType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AnnotationType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AnnotationType", str)
	}
	return nil
}

func (e AnnotationType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *AnnotationType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e AnnotationType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type AntiMalwareFileHashAction string

const (
	// Block file download by filehash action
	AntiMalwareFileHashActionBlock AntiMalwareFileHashAction = "BLOCK"
	// Bypass file download by filehash action
	AntiMalwareFileHashActionBypass AntiMalwareFileHashAction = "BYPASS"
)

var AllAntiMalwareFileHashAction = []AntiMalwareFileHashAction{
	AntiMalwareFileHashActionBlock,
	AntiMalwareFileHashActionBypass,
}

func (e AntiMalwareFileHashAction) IsValid() bool {
	switch e {
	case AntiMalwareFileHashActionBlock, AntiMalwareFileHashActionBypass:
		return true
	}
	return false
}

func (e AntiMalwareFileHashAction) String() string {
	return string(e)
}

func (e *AntiMalwareFileHashAction) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AntiMalwareFileHashAction(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AntiMalwareFileHashAction", str)
	}
	return nil
}

func (e AntiMalwareFileHashAction) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *AntiMalwareFileHashAction) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e AntiMalwareFileHashAction) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type ApnMethod string

const (
	ApnMethodMethodAuto    ApnMethod = "METHOD_AUTO"
	ApnMethodMethodManual  ApnMethod = "METHOD_MANUAL"
	ApnMethodMethodUnknown ApnMethod = "METHOD_UNKNOWN"
)

var AllApnMethod = []ApnMethod{
	ApnMethodMethodAuto,
	ApnMethodMethodManual,
	ApnMethodMethodUnknown,
}

func (e ApnMethod) IsValid() bool {
	switch e {
	case ApnMethodMethodAuto, ApnMethodMethodManual, ApnMethodMethodUnknown:
		return true
	}
	return false
}

func (e ApnMethod) String() string {
	return string(e)
}

func (e *ApnMethod) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ApnMethod(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ApnMethod", str)
	}
	return nil
}

func (e ApnMethod) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ApnMethod) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ApnMethod) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type AppStatsFieldName string

const (
	// Active Directory name
	AppStatsFieldNameAdName AppStatsFieldName = "ad_name"
	// The application identifier
	AppStatsFieldNameApp AppStatsFieldName = "app"
	// The application name
	AppStatsFieldNameApplication AppStatsFieldName = "application"
	// Application description
	AppStatsFieldNameApplicationDescription AppStatsFieldName = "application_description"
	// The application identifier
	AppStatsFieldNameApplicationID AppStatsFieldName = "application_id"
	// The application name
	AppStatsFieldNameApplicationName      AppStatsFieldName = "application_name"
	AppStatsFieldNameApplicationRiskLevel AppStatsFieldName = "application_risk_level"
	// The application risk score assigned by Cato
	AppStatsFieldNameApplicationRiskScore AppStatsFieldName = "application_risk_score"
	// Cato system categories of the application
	AppStatsFieldNameCategories AppStatsFieldName = "categories"
	// Cato system category of the application
	AppStatsFieldNameCategory AppStatsFieldName = "category"
	// For hosts configured with a static IP in the Cato Management Application, the host name
	AppStatsFieldNameConfiguredHostName AppStatsFieldName = "configured_host_name"
	// Application description
	AppStatsFieldNameDescription AppStatsFieldName = "description"
	// IP for destination host or Cato Client
	AppStatsFieldNameDestIP AppStatsFieldName = "dest_ip"
	// Destination is site or remote user
	AppStatsFieldNameDestIsSiteOrVpn AppStatsFieldName = "dest_is_site_or_vpn"
	// Destination site or remote user identifier
	AppStatsFieldNameDestSite AppStatsFieldName = "dest_site"
	// Destination Site or remote user identifier
	AppStatsFieldNameDestSiteID AppStatsFieldName = "dest_site_id"
	// Destination Site or remote user name
	AppStatsFieldNameDestSiteName AppStatsFieldName = "dest_site_name"
	// Name for device related to the traffic
	AppStatsFieldNameDeviceName    AppStatsFieldName = "device_name"
	AppStatsFieldNameDiscoveredApp AppStatsFieldName = "discovered_app"
	AppStatsFieldNameDomain        AppStatsFieldName = "domain"
	// data downloaded from cloud applications
	AppStatsFieldNameDownstream   AppStatsFieldName = "downstream"
	AppStatsFieldNameFlowsCreated AppStatsFieldName = "flows_created"
	// the country in which the registered application headquarteres is located
	AppStatsFieldNameHqLocation AppStatsFieldName = "hq_location"
	AppStatsFieldNameIP         AppStatsFieldName = "ip"
	// indicates whether the application is considered cloud app/SaaS app
	AppStatsFieldNameIsCloudApp AppStatsFieldName = "is_cloud_app"
	// Is the application defined as sanctioned?
	AppStatsFieldNameIsSanctionedApp AppStatsFieldName = "is_sanctioned_app"
	// The ISP related to this event (when the IP address isn't provided by the ISP, then the event message is IP Addresses are assigned statically)
	AppStatsFieldNameIspName AppStatsFieldName = "ISP_name"
	// new cloud application identifier
	AppStatsFieldNameNewApp    AppStatsFieldName = "new_app"
	AppStatsFieldNameRiskLevel AppStatsFieldName = "risk_level"
	// the application risk score assigned by Cato
	AppStatsFieldNameRiskScore AppStatsFieldName = "risk_score"
	// Is the application defined as sanctioned?
	AppStatsFieldNameSanctioned AppStatsFieldName = "sanctioned"
	// Country in which the source host is located
	AppStatsFieldNameSiteCountry AppStatsFieldName = "site_country"
	// State in which the source host is located
	AppStatsFieldNameSiteState AppStatsFieldName = "site_state"
	// Name for Socket interface
	AppStatsFieldNameSocketInterface AppStatsFieldName = "socket_interface"
	// Country in which the source host is located (detected via public IP address)
	AppStatsFieldNameSrcCountry AppStatsFieldName = "src_country"
	// Country Code of country in which the source host is located (detected via public IP address)
	AppStatsFieldNameSrcCountryCode AppStatsFieldName = "src_country_code"
	// IP for source host or Cato Client
	AppStatsFieldNameSrcIP AppStatsFieldName = "src_ip"
	// Source is site or remote user
	AppStatsFieldNameSrcIsSiteOrVpn AppStatsFieldName = "src_is_site_or_vpn"
	// IP address provided by ISP to site or Client
	AppStatsFieldNameSrcIspIP AppStatsFieldName = "src_isp_ip"
	// Site country code alpha2
	AppStatsFieldNameSrcSiteCountryCode AppStatsFieldName = "src_site_country_code"
	// Source site or remote user identifier
	AppStatsFieldNameSrcSiteID AppStatsFieldName = "src_site_id"
	// Source site or remote user name
	AppStatsFieldNameSrcSiteName AppStatsFieldName = "src_site_name"
	// Site state code
	AppStatsFieldNameSrcSiteState AppStatsFieldName = "src_site_state"
	// Name of subnet as defined in Cato Management Application
	AppStatsFieldNameSubnet AppStatsFieldName = "subnet"
	// Name of subnet as defined in Cato Management Application
	AppStatsFieldNameSubnetName AppStatsFieldName = "subnet_name"
	// Top level domain
	AppStatsFieldNameTld AppStatsFieldName = "tld"
	// the total sum of upstream and downstream data in bytes
	AppStatsFieldNameTraffic AppStatsFieldName = "traffic"
	// Traffic direction
	AppStatsFieldNameTrafficDirection AppStatsFieldName = "traffic_direction"
	// data uploaded to cloud applications
	AppStatsFieldNameUpstream AppStatsFieldName = "upstream"
	// User identifier
	AppStatsFieldNameUserID AppStatsFieldName = "user_id"
	// User name
	AppStatsFieldNameUserName  AppStatsFieldName = "user_name"
	AppStatsFieldNameVpnUserID AppStatsFieldName = "vpn_user_id"
)

var AllAppStatsFieldName = []AppStatsFieldName{
	AppStatsFieldNameAdName,
	AppStatsFieldNameApp,
	AppStatsFieldNameApplication,
	AppStatsFieldNameApplicationDescription,
	AppStatsFieldNameApplicationID,
	AppStatsFieldNameApplicationName,
	AppStatsFieldNameApplicationRiskLevel,
	AppStatsFieldNameApplicationRiskScore,
	AppStatsFieldNameCategories,
	AppStatsFieldNameCategory,
	AppStatsFieldNameConfiguredHostName,
	AppStatsFieldNameDescription,
	AppStatsFieldNameDestIP,
	AppStatsFieldNameDestIsSiteOrVpn,
	AppStatsFieldNameDestSite,
	AppStatsFieldNameDestSiteID,
	AppStatsFieldNameDestSiteName,
	AppStatsFieldNameDeviceName,
	AppStatsFieldNameDiscoveredApp,
	AppStatsFieldNameDomain,
	AppStatsFieldNameDownstream,
	AppStatsFieldNameFlowsCreated,
	AppStatsFieldNameHqLocation,
	AppStatsFieldNameIP,
	AppStatsFieldNameIsCloudApp,
	AppStatsFieldNameIsSanctionedApp,
	AppStatsFieldNameIspName,
	AppStatsFieldNameNewApp,
	AppStatsFieldNameRiskLevel,
	AppStatsFieldNameRiskScore,
	AppStatsFieldNameSanctioned,
	AppStatsFieldNameSiteCountry,
	AppStatsFieldNameSiteState,
	AppStatsFieldNameSocketInterface,
	AppStatsFieldNameSrcCountry,
	AppStatsFieldNameSrcCountryCode,
	AppStatsFieldNameSrcIP,
	AppStatsFieldNameSrcIsSiteOrVpn,
	AppStatsFieldNameSrcIspIP,
	AppStatsFieldNameSrcSiteCountryCode,
	AppStatsFieldNameSrcSiteID,
	AppStatsFieldNameSrcSiteName,
	AppStatsFieldNameSrcSiteState,
	AppStatsFieldNameSubnet,
	AppStatsFieldNameSubnetName,
	AppStatsFieldNameTld,
	AppStatsFieldNameTraffic,
	AppStatsFieldNameTrafficDirection,
	AppStatsFieldNameUpstream,
	AppStatsFieldNameUserID,
	AppStatsFieldNameUserName,
	AppStatsFieldNameVpnUserID,
}

func (e AppStatsFieldName) IsValid() bool {
	switch e {
	case AppStatsFieldNameAdName, AppStatsFieldNameApp, AppStatsFieldNameApplication, AppStatsFieldNameApplicationDescription, AppStatsFieldNameApplicationID, AppStatsFieldNameApplicationName, AppStatsFieldNameApplicationRiskLevel, AppStatsFieldNameApplicationRiskScore, AppStatsFieldNameCategories, AppStatsFieldNameCategory, AppStatsFieldNameConfiguredHostName, AppStatsFieldNameDescription, AppStatsFieldNameDestIP, AppStatsFieldNameDestIsSiteOrVpn, AppStatsFieldNameDestSite, AppStatsFieldNameDestSiteID, AppStatsFieldNameDestSiteName, AppStatsFieldNameDeviceName, AppStatsFieldNameDiscoveredApp, AppStatsFieldNameDomain, AppStatsFieldNameDownstream, AppStatsFieldNameFlowsCreated, AppStatsFieldNameHqLocation, AppStatsFieldNameIP, AppStatsFieldNameIsCloudApp, AppStatsFieldNameIsSanctionedApp, AppStatsFieldNameIspName, AppStatsFieldNameNewApp, AppStatsFieldNameRiskLevel, AppStatsFieldNameRiskScore, AppStatsFieldNameSanctioned, AppStatsFieldNameSiteCountry, AppStatsFieldNameSiteState, AppStatsFieldNameSocketInterface, AppStatsFieldNameSrcCountry, AppStatsFieldNameSrcCountryCode, AppStatsFieldNameSrcIP, AppStatsFieldNameSrcIsSiteOrVpn, AppStatsFieldNameSrcIspIP, AppStatsFieldNameSrcSiteCountryCode, AppStatsFieldNameSrcSiteID, AppStatsFieldNameSrcSiteName, AppStatsFieldNameSrcSiteState, AppStatsFieldNameSubnet, AppStatsFieldNameSubnetName, AppStatsFieldNameTld, AppStatsFieldNameTraffic, AppStatsFieldNameTrafficDirection, AppStatsFieldNameUpstream, AppStatsFieldNameUserID, AppStatsFieldNameUserName, AppStatsFieldNameVpnUserID:
		return true
	}
	return false
}

func (e AppStatsFieldName) String() string {
	return string(e)
}

func (e *AppStatsFieldName) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AppStatsFieldName(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AppStatsFieldName", str)
	}
	return nil
}

func (e AppStatsFieldName) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *AppStatsFieldName) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e AppStatsFieldName) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Allowed actions
type AppTenantRestrictionActionEnum string

const (
	// Do not inject any Headers nor Values for outgoing traffic
	AppTenantRestrictionActionEnumBypass AppTenantRestrictionActionEnum = "BYPASS"
	// Inject Headers and Values for outgoing traffic
	AppTenantRestrictionActionEnumInjectHeaders AppTenantRestrictionActionEnum = "INJECT_HEADERS"
)

var AllAppTenantRestrictionActionEnum = []AppTenantRestrictionActionEnum{
	AppTenantRestrictionActionEnumBypass,
	AppTenantRestrictionActionEnumInjectHeaders,
}

func (e AppTenantRestrictionActionEnum) IsValid() bool {
	switch e {
	case AppTenantRestrictionActionEnumBypass, AppTenantRestrictionActionEnumInjectHeaders:
		return true
	}
	return false
}

func (e AppTenantRestrictionActionEnum) String() string {
	return string(e)
}

func (e *AppTenantRestrictionActionEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AppTenantRestrictionActionEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AppTenantRestrictionActionEnum", str)
	}
	return nil
}

func (e AppTenantRestrictionActionEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *AppTenantRestrictionActionEnum) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e AppTenantRestrictionActionEnum) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Severity options
type AppTenantRestrictionSeverityEnum string

const (
	// High severity
	AppTenantRestrictionSeverityEnumHigh AppTenantRestrictionSeverityEnum = "HIGH"
	// Low severity
	AppTenantRestrictionSeverityEnumLow AppTenantRestrictionSeverityEnum = "LOW"
	// Medium severity
	AppTenantRestrictionSeverityEnumMedium AppTenantRestrictionSeverityEnum = "MEDIUM"
)

var AllAppTenantRestrictionSeverityEnum = []AppTenantRestrictionSeverityEnum{
	AppTenantRestrictionSeverityEnumHigh,
	AppTenantRestrictionSeverityEnumLow,
	AppTenantRestrictionSeverityEnumMedium,
}

func (e AppTenantRestrictionSeverityEnum) IsValid() bool {
	switch e {
	case AppTenantRestrictionSeverityEnumHigh, AppTenantRestrictionSeverityEnumLow, AppTenantRestrictionSeverityEnumMedium:
		return true
	}
	return false
}

func (e AppTenantRestrictionSeverityEnum) String() string {
	return string(e)
}

func (e *AppTenantRestrictionSeverityEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AppTenantRestrictionSeverityEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AppTenantRestrictionSeverityEnum", str)
	}
	return nil
}

func (e AppTenantRestrictionSeverityEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *AppTenantRestrictionSeverityEnum) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e AppTenantRestrictionSeverityEnum) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Application Control Access Method Type
type ApplicationControlAccessMethodType string

const (
	// User agent identification method
	ApplicationControlAccessMethodTypeUserAgent ApplicationControlAccessMethodType = "USER_AGENT"
)

var AllApplicationControlAccessMethodType = []ApplicationControlAccessMethodType{
	ApplicationControlAccessMethodTypeUserAgent,
}

func (e ApplicationControlAccessMethodType) IsValid() bool {
	switch e {
	case ApplicationControlAccessMethodTypeUserAgent:
		return true
	}
	return false
}

func (e ApplicationControlAccessMethodType) String() string {
	return string(e)
}

func (e *ApplicationControlAccessMethodType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ApplicationControlAccessMethodType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ApplicationControlAccessMethodType", str)
	}
	return nil
}

func (e ApplicationControlAccessMethodType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ApplicationControlAccessMethodType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ApplicationControlAccessMethodType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Application Control Action
type ApplicationControlAction string

const (
	// Permit the action
	ApplicationControlActionAllow ApplicationControlAction = "ALLOW"
	// Prevent the action
	ApplicationControlActionBlock ApplicationControlAction = "BLOCK"
	// Log the action without enforcement
	ApplicationControlActionMonitor ApplicationControlAction = "MONITOR"
)

var AllApplicationControlAction = []ApplicationControlAction{
	ApplicationControlActionAllow,
	ApplicationControlActionBlock,
	ApplicationControlActionMonitor,
}

func (e ApplicationControlAction) IsValid() bool {
	switch e {
	case ApplicationControlActionAllow, ApplicationControlActionBlock, ApplicationControlActionMonitor:
		return true
	}
	return false
}

func (e ApplicationControlAction) String() string {
	return string(e)
}

func (e *ApplicationControlAction) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ApplicationControlAction(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ApplicationControlAction", str)
	}
	return nil
}

func (e ApplicationControlAction) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ApplicationControlAction) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ApplicationControlAction) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Attribute Value
type ApplicationControlAttributeValue string

const (
	// Any Value
	ApplicationControlAttributeValueAny ApplicationControlAttributeValue = "ANY"
	// Not Supported
	ApplicationControlAttributeValueNotSupported ApplicationControlAttributeValue = "NOT_SUPPORTED"
	// Supported
	ApplicationControlAttributeValueSupported ApplicationControlAttributeValue = "SUPPORTED"
)

var AllApplicationControlAttributeValue = []ApplicationControlAttributeValue{
	ApplicationControlAttributeValueAny,
	ApplicationControlAttributeValueNotSupported,
	ApplicationControlAttributeValueSupported,
}

func (e ApplicationControlAttributeValue) IsValid() bool {
	switch e {
	case ApplicationControlAttributeValueAny, ApplicationControlAttributeValueNotSupported, ApplicationControlAttributeValueSupported:
		return true
	}
	return false
}

func (e ApplicationControlAttributeValue) String() string {
	return string(e)
}

func (e *ApplicationControlAttributeValue) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ApplicationControlAttributeValue(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ApplicationControlAttributeValue", str)
	}
	return nil
}

func (e ApplicationControlAttributeValue) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ApplicationControlAttributeValue) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ApplicationControlAttributeValue) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Application Control File Attribute Type
type ApplicationControlFileAttributeType string

const (
	// File encryption status
	ApplicationControlFileAttributeTypeContentIsEncrypted ApplicationControlFileAttributeType = "CONTENT_IS_ENCRYPTED"
	// File Size
	ApplicationControlFileAttributeTypeContentSize ApplicationControlFileAttributeType = "CONTENT_SIZE"
	// File type classification
	ApplicationControlFileAttributeTypeContentType ApplicationControlFileAttributeType = "CONTENT_TYPE"
)

var AllApplicationControlFileAttributeType = []ApplicationControlFileAttributeType{
	ApplicationControlFileAttributeTypeContentIsEncrypted,
	ApplicationControlFileAttributeTypeContentSize,
	ApplicationControlFileAttributeTypeContentType,
}

func (e ApplicationControlFileAttributeType) IsValid() bool {
	switch e {
	case ApplicationControlFileAttributeTypeContentIsEncrypted, ApplicationControlFileAttributeTypeContentSize, ApplicationControlFileAttributeTypeContentType:
		return true
	}
	return false
}

func (e ApplicationControlFileAttributeType) String() string {
	return string(e)
}

func (e *ApplicationControlFileAttributeType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ApplicationControlFileAttributeType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ApplicationControlFileAttributeType", str)
	}
	return nil
}

func (e ApplicationControlFileAttributeType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ApplicationControlFileAttributeType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ApplicationControlFileAttributeType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Application Control Operator
type ApplicationControlOperator string

const (
	// Substring match comparison
	ApplicationControlOperatorContains ApplicationControlOperator = "CONTAINS"
	// Numerical greater than comparison
	ApplicationControlOperatorGreaterThan ApplicationControlOperator = "GREATER_THAN"
	// Set membership comparison
	ApplicationControlOperatorIn ApplicationControlOperator = "IN"
	// Exact match comparison
	ApplicationControlOperatorIs ApplicationControlOperator = "IS"
	// Numerical less than or equal comparison
	ApplicationControlOperatorLessThanOrEqual ApplicationControlOperator = "LESS_THAN_OR_EQUAL"
)

var AllApplicationControlOperator = []ApplicationControlOperator{
	ApplicationControlOperatorContains,
	ApplicationControlOperatorGreaterThan,
	ApplicationControlOperatorIn,
	ApplicationControlOperatorIs,
	ApplicationControlOperatorLessThanOrEqual,
}

func (e ApplicationControlOperator) IsValid() bool {
	switch e {
	case ApplicationControlOperatorContains, ApplicationControlOperatorGreaterThan, ApplicationControlOperatorIn, ApplicationControlOperatorIs, ApplicationControlOperatorLessThanOrEqual:
		return true
	}
	return false
}

func (e ApplicationControlOperator) String() string {
	return string(e)
}

func (e *ApplicationControlOperator) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ApplicationControlOperator(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ApplicationControlOperator", str)
	}
	return nil
}

func (e ApplicationControlOperator) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ApplicationControlOperator) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ApplicationControlOperator) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Application Control Rule Type
type ApplicationControlRuleType string

const (
	// Specifies an application control rule
	ApplicationControlRuleTypeApplication ApplicationControlRuleType = "APPLICATION"
	// Specifies an data control rule
	ApplicationControlRuleTypeData ApplicationControlRuleType = "DATA"
	// Specifies an file control rule
	ApplicationControlRuleTypeFile ApplicationControlRuleType = "FILE"
)

var AllApplicationControlRuleType = []ApplicationControlRuleType{
	ApplicationControlRuleTypeApplication,
	ApplicationControlRuleTypeData,
	ApplicationControlRuleTypeFile,
}

func (e ApplicationControlRuleType) IsValid() bool {
	switch e {
	case ApplicationControlRuleTypeApplication, ApplicationControlRuleTypeData, ApplicationControlRuleTypeFile:
		return true
	}
	return false
}

func (e ApplicationControlRuleType) String() string {
	return string(e)
}

func (e *ApplicationControlRuleType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ApplicationControlRuleType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ApplicationControlRuleType", str)
	}
	return nil
}

func (e ApplicationControlRuleType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ApplicationControlRuleType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ApplicationControlRuleType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Application Control Satisfy
type ApplicationControlSatisfy string

const (
	// Match only if all criteria are met
	ApplicationControlSatisfyAll ApplicationControlSatisfy = "ALL"
	// Match if any criteria are met
	ApplicationControlSatisfyAny ApplicationControlSatisfy = "ANY"
)

var AllApplicationControlSatisfy = []ApplicationControlSatisfy{
	ApplicationControlSatisfyAll,
	ApplicationControlSatisfyAny,
}

func (e ApplicationControlSatisfy) IsValid() bool {
	switch e {
	case ApplicationControlSatisfyAll, ApplicationControlSatisfyAny:
		return true
	}
	return false
}

func (e ApplicationControlSatisfy) String() string {
	return string(e)
}

func (e *ApplicationControlSatisfy) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ApplicationControlSatisfy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ApplicationControlSatisfy", str)
	}
	return nil
}

func (e ApplicationControlSatisfy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ApplicationControlSatisfy) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ApplicationControlSatisfy) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Severity level
type ApplicationControlSeverity string

const (
	// Indicates a high severity level
	ApplicationControlSeverityHigh ApplicationControlSeverity = "HIGH"
	// Indicates a low severity level
	ApplicationControlSeverityLow ApplicationControlSeverity = "LOW"
	// Indicates a medium severity level
	ApplicationControlSeverityMedium ApplicationControlSeverity = "MEDIUM"
)

var AllApplicationControlSeverity = []ApplicationControlSeverity{
	ApplicationControlSeverityHigh,
	ApplicationControlSeverityLow,
	ApplicationControlSeverityMedium,
}

func (e ApplicationControlSeverity) IsValid() bool {
	switch e {
	case ApplicationControlSeverityHigh, ApplicationControlSeverityLow, ApplicationControlSeverityMedium:
		return true
	}
	return false
}

func (e ApplicationControlSeverity) String() string {
	return string(e)
}

func (e *ApplicationControlSeverity) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ApplicationControlSeverity(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ApplicationControlSeverity", str)
	}
	return nil
}

func (e ApplicationControlSeverity) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ApplicationControlSeverity) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ApplicationControlSeverity) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Application Type
type ApplicationType string

const (
	// Application
	ApplicationTypeApplication ApplicationType = "APPLICATION"
	// Cloud Application type
	ApplicationTypeCloudApplication ApplicationType = "CLOUD_APPLICATION"
	// Service
	ApplicationTypeService ApplicationType = "SERVICE"
)

var AllApplicationType = []ApplicationType{
	ApplicationTypeApplication,
	ApplicationTypeCloudApplication,
	ApplicationTypeService,
}

func (e ApplicationType) IsValid() bool {
	switch e {
	case ApplicationTypeApplication, ApplicationTypeCloudApplication, ApplicationTypeService:
		return true
	}
	return false
}

func (e ApplicationType) String() string {
	return string(e)
}

func (e *ApplicationType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ApplicationType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ApplicationType", str)
	}
	return nil
}

func (e ApplicationType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ApplicationType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ApplicationType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type AuditFieldName string

const (
	// The name of the account on which the record was created
	AuditFieldNameAccount AuditFieldName = "account"
	// The id of the account on which the record was created
	AuditFieldNameAccountID AuditFieldName = "account_id"
	// The admin whose action generated the record
	AuditFieldNameAdmin AuditFieldName = "admin"
	// The ID of the admin whose action generated the record
	AuditFieldNameAdminID AuditFieldName = "admin_id"
	// The api key whose action generated the record
	AuditFieldNameAPIKey            AuditFieldName = "apiKey"
	AuditFieldNameAuditCreationType AuditFieldName = "audit_creation_type"
	// the nature of the change: `CREATED, DELETED, MODIFIED, ENABLED, DISABLED, SKIPPED`
	AuditFieldNameChangeType AuditFieldName = "change_type"
	// Time the record was created
	AuditFieldNameCreationDate AuditFieldName = "creation_date"
	// Time the record was committed to storage
	AuditFieldNameInsertionDate AuditFieldName = "insertion_date"
	// The name of the object that was affected, e.g. 'My Site'
	AuditFieldNameModelName AuditFieldName = "model_name"
	// The type of object that was affected. e.g. Site, Socket, SocketInterface
	AuditFieldNameModelType AuditFieldName = "model_type"
	// Less granular than model_name, a general marker of the modified area: administration, configuration, security
	AuditFieldNameModule AuditFieldName = "module"
)

var AllAuditFieldName = []AuditFieldName{
	AuditFieldNameAccount,
	AuditFieldNameAccountID,
	AuditFieldNameAdmin,
	AuditFieldNameAdminID,
	AuditFieldNameAPIKey,
	AuditFieldNameAuditCreationType,
	AuditFieldNameChangeType,
	AuditFieldNameCreationDate,
	AuditFieldNameInsertionDate,
	AuditFieldNameModelName,
	AuditFieldNameModelType,
	AuditFieldNameModule,
}

func (e AuditFieldName) IsValid() bool {
	switch e {
	case AuditFieldNameAccount, AuditFieldNameAccountID, AuditFieldNameAdmin, AuditFieldNameAdminID, AuditFieldNameAPIKey, AuditFieldNameAuditCreationType, AuditFieldNameChangeType, AuditFieldNameCreationDate, AuditFieldNameInsertionDate, AuditFieldNameModelName, AuditFieldNameModelType, AuditFieldNameModule:
		return true
	}
	return false
}

func (e AuditFieldName) String() string {
	return string(e)
}

func (e *AuditFieldName) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AuditFieldName(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AuditFieldName", str)
	}
	return nil
}

func (e AuditFieldName) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *AuditFieldName) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e AuditFieldName) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type BgpCommunityFilterPredicate string

const (
	// Matches exactly the specified community value.
	BgpCommunityFilterPredicateEqual BgpCommunityFilterPredicate = "EQUAL"
	// Matches any community value except the specified one.
	BgpCommunityFilterPredicateNotEqual BgpCommunityFilterPredicate = "NOT_EQUAL"
)

var AllBgpCommunityFilterPredicate = []BgpCommunityFilterPredicate{
	BgpCommunityFilterPredicateEqual,
	BgpCommunityFilterPredicateNotEqual,
}

func (e BgpCommunityFilterPredicate) IsValid() bool {
	switch e {
	case BgpCommunityFilterPredicateEqual, BgpCommunityFilterPredicateNotEqual:
		return true
	}
	return false
}

func (e BgpCommunityFilterPredicate) String() string {
	return string(e)
}

func (e *BgpCommunityFilterPredicate) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BgpCommunityFilterPredicate(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BgpCommunityFilterPredicate", str)
	}
	return nil
}

func (e BgpCommunityFilterPredicate) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *BgpCommunityFilterPredicate) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e BgpCommunityFilterPredicate) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type BgpDefaultAction string

const (
	// Default action to accept all unmatched routes.
	BgpDefaultActionAccept BgpDefaultAction = "ACCEPT"
	// Default action to drop all unmatched routes.
	BgpDefaultActionDrop BgpDefaultAction = "DROP"
)

var AllBgpDefaultAction = []BgpDefaultAction{
	BgpDefaultActionAccept,
	BgpDefaultActionDrop,
}

func (e BgpDefaultAction) IsValid() bool {
	switch e {
	case BgpDefaultActionAccept, BgpDefaultActionDrop:
		return true
	}
	return false
}

func (e BgpDefaultAction) String() string {
	return string(e)
}

func (e *BgpDefaultAction) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BgpDefaultAction(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BgpDefaultAction", str)
	}
	return nil
}

func (e BgpDefaultAction) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *BgpDefaultAction) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e BgpDefaultAction) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type BgpState string

const (
	BgpStateActive      BgpState = "Active"
	BgpStateConnect     BgpState = "Connect"
	BgpStateEstablished BgpState = "Established"
	BgpStateIdle        BgpState = "Idle"
	BgpStateOpenConfirm BgpState = "OpenConfirm"
	BgpStateOpenSent    BgpState = "OpenSent"
	BgpStateStateMax    BgpState = "StateMAX"
)

var AllBgpState = []BgpState{
	BgpStateActive,
	BgpStateConnect,
	BgpStateEstablished,
	BgpStateIdle,
	BgpStateOpenConfirm,
	BgpStateOpenSent,
	BgpStateStateMax,
}

func (e BgpState) IsValid() bool {
	switch e {
	case BgpStateActive, BgpStateConnect, BgpStateEstablished, BgpStateIdle, BgpStateOpenConfirm, BgpStateOpenSent, BgpStateStateMax:
		return true
	}
	return false
}

func (e BgpState) String() string {
	return string(e)
}

func (e *BgpState) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BgpState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BgpState", str)
	}
	return nil
}

func (e BgpState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *BgpState) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e BgpState) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type CatalogApplicationActivityFieldOperator string

const (
	CatalogApplicationActivityFieldOperatorContains    CatalogApplicationActivityFieldOperator = "CONTAINS"
	CatalogApplicationActivityFieldOperatorGreaterThan CatalogApplicationActivityFieldOperator = "GREATER_THAN"
	CatalogApplicationActivityFieldOperatorIn          CatalogApplicationActivityFieldOperator = "IN"
	CatalogApplicationActivityFieldOperatorIs          CatalogApplicationActivityFieldOperator = "IS"
	CatalogApplicationActivityFieldOperatorLessEquals  CatalogApplicationActivityFieldOperator = "LESS_EQUALS"
)

var AllCatalogApplicationActivityFieldOperator = []CatalogApplicationActivityFieldOperator{
	CatalogApplicationActivityFieldOperatorContains,
	CatalogApplicationActivityFieldOperatorGreaterThan,
	CatalogApplicationActivityFieldOperatorIn,
	CatalogApplicationActivityFieldOperatorIs,
	CatalogApplicationActivityFieldOperatorLessEquals,
}

func (e CatalogApplicationActivityFieldOperator) IsValid() bool {
	switch e {
	case CatalogApplicationActivityFieldOperatorContains, CatalogApplicationActivityFieldOperatorGreaterThan, CatalogApplicationActivityFieldOperatorIn, CatalogApplicationActivityFieldOperatorIs, CatalogApplicationActivityFieldOperatorLessEquals:
		return true
	}
	return false
}

func (e CatalogApplicationActivityFieldOperator) String() string {
	return string(e)
}

func (e *CatalogApplicationActivityFieldOperator) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CatalogApplicationActivityFieldOperator(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CatalogApplicationActivityFieldOperator", str)
	}
	return nil
}

func (e CatalogApplicationActivityFieldOperator) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *CatalogApplicationActivityFieldOperator) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e CatalogApplicationActivityFieldOperator) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type CatalogApplicationAttribute string

const (
	CatalogApplicationAttributeSupported   CatalogApplicationAttribute = "SUPPORTED"
	CatalogApplicationAttributeUnknown     CatalogApplicationAttribute = "UNKNOWN"
	CatalogApplicationAttributeUnsupported CatalogApplicationAttribute = "UNSUPPORTED"
)

var AllCatalogApplicationAttribute = []CatalogApplicationAttribute{
	CatalogApplicationAttributeSupported,
	CatalogApplicationAttributeUnknown,
	CatalogApplicationAttributeUnsupported,
}

func (e CatalogApplicationAttribute) IsValid() bool {
	switch e {
	case CatalogApplicationAttributeSupported, CatalogApplicationAttributeUnknown, CatalogApplicationAttributeUnsupported:
		return true
	}
	return false
}

func (e CatalogApplicationAttribute) String() string {
	return string(e)
}

func (e *CatalogApplicationAttribute) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CatalogApplicationAttribute(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CatalogApplicationAttribute", str)
	}
	return nil
}

func (e CatalogApplicationAttribute) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *CatalogApplicationAttribute) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e CatalogApplicationAttribute) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type CatalogApplicationCapability string

const (
	CatalogApplicationCapabilityAntiMalwareInline    CatalogApplicationCapability = "ANTI_MALWARE_INLINE"
	CatalogApplicationCapabilityAppControlAPI        CatalogApplicationCapability = "APP_CONTROL_API"
	CatalogApplicationCapabilityAppControlInline     CatalogApplicationCapability = "APP_CONTROL_INLINE"
	CatalogApplicationCapabilityDataProtectionAPI    CatalogApplicationCapability = "DATA_PROTECTION_API"
	CatalogApplicationCapabilityDataProtectionInline CatalogApplicationCapability = "DATA_PROTECTION_INLINE"
	CatalogApplicationCapabilityFileControlInline    CatalogApplicationCapability = "FILE_CONTROL_INLINE"
	CatalogApplicationCapabilityFirewallIntline      CatalogApplicationCapability = "FIREWALL_INTLINE"
	CatalogApplicationCapabilityLanFirewall          CatalogApplicationCapability = "LAN_FIREWALL"
)

var AllCatalogApplicationCapability = []CatalogApplicationCapability{
	CatalogApplicationCapabilityAntiMalwareInline,
	CatalogApplicationCapabilityAppControlAPI,
	CatalogApplicationCapabilityAppControlInline,
	CatalogApplicationCapabilityDataProtectionAPI,
	CatalogApplicationCapabilityDataProtectionInline,
	CatalogApplicationCapabilityFileControlInline,
	CatalogApplicationCapabilityFirewallIntline,
	CatalogApplicationCapabilityLanFirewall,
}

func (e CatalogApplicationCapability) IsValid() bool {
	switch e {
	case CatalogApplicationCapabilityAntiMalwareInline, CatalogApplicationCapabilityAppControlAPI, CatalogApplicationCapabilityAppControlInline, CatalogApplicationCapabilityDataProtectionAPI, CatalogApplicationCapabilityDataProtectionInline, CatalogApplicationCapabilityFileControlInline, CatalogApplicationCapabilityFirewallIntline, CatalogApplicationCapabilityLanFirewall:
		return true
	}
	return false
}

func (e CatalogApplicationCapability) String() string {
	return string(e)
}

func (e *CatalogApplicationCapability) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CatalogApplicationCapability(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CatalogApplicationCapability", str)
	}
	return nil
}

func (e CatalogApplicationCapability) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *CatalogApplicationCapability) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e CatalogApplicationCapability) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type CatalogApplicationType string

const (
	CatalogApplicationTypeApplication      CatalogApplicationType = "APPLICATION"
	CatalogApplicationTypeCloudApplication CatalogApplicationType = "CLOUD_APPLICATION"
	CatalogApplicationTypeService          CatalogApplicationType = "SERVICE"
)

var AllCatalogApplicationType = []CatalogApplicationType{
	CatalogApplicationTypeApplication,
	CatalogApplicationTypeCloudApplication,
	CatalogApplicationTypeService,
}

func (e CatalogApplicationType) IsValid() bool {
	switch e {
	case CatalogApplicationTypeApplication, CatalogApplicationTypeCloudApplication, CatalogApplicationTypeService:
		return true
	}
	return false
}

func (e CatalogApplicationType) String() string {
	return string(e)
}

func (e *CatalogApplicationType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CatalogApplicationType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CatalogApplicationType", str)
	}
	return nil
}

func (e CatalogApplicationType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *CatalogApplicationType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e CatalogApplicationType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type CatoEndpointEngineType string

const (
	CatoEndpointEngineTypeAntiMalware CatoEndpointEngineType = "AntiMalware"
	CatoEndpointEngineTypeBehavioral  CatoEndpointEngineType = "Behavioral"
)

var AllCatoEndpointEngineType = []CatoEndpointEngineType{
	CatoEndpointEngineTypeAntiMalware,
	CatoEndpointEngineTypeBehavioral,
}

func (e CatoEndpointEngineType) IsValid() bool {
	switch e {
	case CatoEndpointEngineTypeAntiMalware, CatoEndpointEngineTypeBehavioral:
		return true
	}
	return false
}

func (e CatoEndpointEngineType) String() string {
	return string(e)
}

func (e *CatoEndpointEngineType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CatoEndpointEngineType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CatoEndpointEngineType", str)
	}
	return nil
}

func (e CatoEndpointEngineType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *CatoEndpointEngineType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e CatoEndpointEngineType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type CellularDisconnectionReason string

const (
	CellularDisconnectionReasonReasonNone    CellularDisconnectionReason = "REASON_NONE"
	CellularDisconnectionReasonReasonTimeout CellularDisconnectionReason = "REASON_TIMEOUT"
)

var AllCellularDisconnectionReason = []CellularDisconnectionReason{
	CellularDisconnectionReasonReasonNone,
	CellularDisconnectionReasonReasonTimeout,
}

func (e CellularDisconnectionReason) IsValid() bool {
	switch e {
	case CellularDisconnectionReasonReasonNone, CellularDisconnectionReasonReasonTimeout:
		return true
	}
	return false
}

func (e CellularDisconnectionReason) String() string {
	return string(e)
}

func (e *CellularDisconnectionReason) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CellularDisconnectionReason(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CellularDisconnectionReason", str)
	}
	return nil
}

func (e CellularDisconnectionReason) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *CellularDisconnectionReason) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e CellularDisconnectionReason) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type CellularModemStatus string

const (
	CellularModemStatusStatusError   CellularModemStatus = "STATUS_ERROR"
	CellularModemStatusStatusOk      CellularModemStatus = "STATUS_OK"
	CellularModemStatusStatusUnknown CellularModemStatus = "STATUS_UNKNOWN"
)

var AllCellularModemStatus = []CellularModemStatus{
	CellularModemStatusStatusError,
	CellularModemStatusStatusOk,
	CellularModemStatusStatusUnknown,
}

func (e CellularModemStatus) IsValid() bool {
	switch e {
	case CellularModemStatusStatusError, CellularModemStatusStatusOk, CellularModemStatusStatusUnknown:
		return true
	}
	return false
}

func (e CellularModemStatus) String() string {
	return string(e)
}

func (e *CellularModemStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CellularModemStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CellularModemStatus", str)
	}
	return nil
}

func (e CellularModemStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *CellularModemStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e CellularModemStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type CellularNetworkType string

const (
	CellularNetworkTypeType2g      CellularNetworkType = "TYPE_2G"
	CellularNetworkTypeType3g      CellularNetworkType = "TYPE_3G"
	CellularNetworkTypeType4g      CellularNetworkType = "TYPE_4G"
	CellularNetworkTypeTypeUnknown CellularNetworkType = "TYPE_UNKNOWN"
)

var AllCellularNetworkType = []CellularNetworkType{
	CellularNetworkTypeType2g,
	CellularNetworkTypeType3g,
	CellularNetworkTypeType4g,
	CellularNetworkTypeTypeUnknown,
}

func (e CellularNetworkType) IsValid() bool {
	switch e {
	case CellularNetworkTypeType2g, CellularNetworkTypeType3g, CellularNetworkTypeType4g, CellularNetworkTypeTypeUnknown:
		return true
	}
	return false
}

func (e CellularNetworkType) String() string {
	return string(e)
}

func (e *CellularNetworkType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CellularNetworkType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CellularNetworkType", str)
	}
	return nil
}

func (e CellularNetworkType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *CellularNetworkType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e CellularNetworkType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type ConnectionMode string

const (
	ConnectionModeBidirectional ConnectionMode = "BIDIRECTIONAL"
	ConnectionModeResponderOnly ConnectionMode = "RESPONDER_ONLY"
)

var AllConnectionMode = []ConnectionMode{
	ConnectionModeBidirectional,
	ConnectionModeResponderOnly,
}

func (e ConnectionMode) IsValid() bool {
	switch e {
	case ConnectionModeBidirectional, ConnectionModeResponderOnly:
		return true
	}
	return false
}

func (e ConnectionMode) String() string {
	return string(e)
}

func (e *ConnectionMode) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ConnectionMode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ConnectionMode", str)
	}
	return nil
}

func (e ConnectionMode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ConnectionMode) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ConnectionMode) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type ConnectionOriginEnum string

const (
	ConnectionOriginEnumAny    ConnectionOriginEnum = "ANY"
	ConnectionOriginEnumRemote ConnectionOriginEnum = "REMOTE"
	ConnectionOriginEnumSite   ConnectionOriginEnum = "SITE"
)

var AllConnectionOriginEnum = []ConnectionOriginEnum{
	ConnectionOriginEnumAny,
	ConnectionOriginEnumRemote,
	ConnectionOriginEnumSite,
}

func (e ConnectionOriginEnum) IsValid() bool {
	switch e {
	case ConnectionOriginEnumAny, ConnectionOriginEnumRemote, ConnectionOriginEnumSite:
		return true
	}
	return false
}

func (e ConnectionOriginEnum) String() string {
	return string(e)
}

func (e *ConnectionOriginEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ConnectionOriginEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ConnectionOriginEnum", str)
	}
	return nil
}

func (e ConnectionOriginEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ConnectionOriginEnum) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ConnectionOriginEnum) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type ConnectionTypeEnum string

const (
	ConnectionTypeEnumHost ConnectionTypeEnum = "Host"
	ConnectionTypeEnumSite ConnectionTypeEnum = "Site"
	ConnectionTypeEnumUser ConnectionTypeEnum = "User"
)

var AllConnectionTypeEnum = []ConnectionTypeEnum{
	ConnectionTypeEnumHost,
	ConnectionTypeEnumSite,
	ConnectionTypeEnumUser,
}

func (e ConnectionTypeEnum) IsValid() bool {
	switch e {
	case ConnectionTypeEnumHost, ConnectionTypeEnumSite, ConnectionTypeEnumUser:
		return true
	}
	return false
}

func (e ConnectionTypeEnum) String() string {
	return string(e)
}

func (e *ConnectionTypeEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ConnectionTypeEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ConnectionTypeEnum", str)
	}
	return nil
}

func (e ConnectionTypeEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ConnectionTypeEnum) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ConnectionTypeEnum) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type ConnectivityStatus string

const (
	// Connected to the Cato Cloud
	ConnectivityStatusConnected ConnectivityStatus = "connected"
	// Disconnected from the Cato Cloud
	ConnectivityStatusDisconnected ConnectivityStatus = "disconnected"
)

var AllConnectivityStatus = []ConnectivityStatus{
	ConnectivityStatusConnected,
	ConnectivityStatusDisconnected,
}

func (e ConnectivityStatus) IsValid() bool {
	switch e {
	case ConnectivityStatusConnected, ConnectivityStatusDisconnected:
		return true
	}
	return false
}

func (e ConnectivityStatus) String() string {
	return string(e)
}

func (e *ConnectivityStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ConnectivityStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ConnectivityStatus", str)
	}
	return nil
}

func (e ConnectivityStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ConnectivityStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ConnectivityStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type ContainerFileType string

const (
	ContainerFileTypeCSV  ContainerFileType = "CSV"
	ContainerFileTypeStix ContainerFileType = "STIX"
)

var AllContainerFileType = []ContainerFileType{
	ContainerFileTypeCSV,
	ContainerFileTypeStix,
}

func (e ContainerFileType) IsValid() bool {
	switch e {
	case ContainerFileTypeCSV, ContainerFileTypeStix:
		return true
	}
	return false
}

func (e ContainerFileType) String() string {
	return string(e)
}

func (e *ContainerFileType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ContainerFileType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ContainerFileType", str)
	}
	return nil
}

func (e ContainerFileType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ContainerFileType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ContainerFileType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type ContainerType string

const (
	ContainerTypeFqdn    ContainerType = "FQDN"
	ContainerTypeIPRange ContainerType = "IP_RANGE"
)

var AllContainerType = []ContainerType{
	ContainerTypeFqdn,
	ContainerTypeIPRange,
}

func (e ContainerType) IsValid() bool {
	switch e {
	case ContainerTypeFqdn, ContainerTypeIPRange:
		return true
	}
	return false
}

func (e ContainerType) String() string {
	return string(e)
}

func (e *ContainerType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ContainerType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ContainerType", str)
	}
	return nil
}

func (e ContainerType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ContainerType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ContainerType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type DayOfWeek string

const (
	DayOfWeekFriday    DayOfWeek = "FRIDAY"
	DayOfWeekMonday    DayOfWeek = "MONDAY"
	DayOfWeekSaturday  DayOfWeek = "SATURDAY"
	DayOfWeekSunday    DayOfWeek = "SUNDAY"
	DayOfWeekThursday  DayOfWeek = "THURSDAY"
	DayOfWeekTuesday   DayOfWeek = "TUESDAY"
	DayOfWeekWednesday DayOfWeek = "WEDNESDAY"
)

var AllDayOfWeek = []DayOfWeek{
	DayOfWeekFriday,
	DayOfWeekMonday,
	DayOfWeekSaturday,
	DayOfWeekSunday,
	DayOfWeekThursday,
	DayOfWeekTuesday,
	DayOfWeekWednesday,
}

func (e DayOfWeek) IsValid() bool {
	switch e {
	case DayOfWeekFriday, DayOfWeekMonday, DayOfWeekSaturday, DayOfWeekSunday, DayOfWeekThursday, DayOfWeekTuesday, DayOfWeekWednesday:
		return true
	}
	return false
}

func (e DayOfWeek) String() string {
	return string(e)
}

func (e *DayOfWeek) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DayOfWeek(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DayOfWeek", str)
	}
	return nil
}

func (e DayOfWeek) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *DayOfWeek) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e DayOfWeek) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type DegradedStatusReason string

const (
	DegradedStatusReasonAltWanDisconnected                        DegradedStatusReason = "ALT_WAN_DISCONNECTED"
	DegradedStatusReasonCrossConnectCircuitDisconnected           DegradedStatusReason = "CROSS_CONNECT_CIRCUIT_DISCONNECTED"
	DegradedStatusReasonHaNotReadyIncompatibleMajorSocketVersions DegradedStatusReason = "HA_NOT_READY_INCOMPATIBLE_MAJOR_SOCKET_VERSIONS"
	DegradedStatusReasonHaNotReadyNoKeepalive                     DegradedStatusReason = "HA_NOT_READY_NO_KEEPALIVE"
	DegradedStatusReasonHaNotReadySocketDisconnected              DegradedStatusReason = "HA_NOT_READY_SOCKET_DISCONNECTED"
	DegradedStatusReasonIpsecMultiTunnelTunnelDisconnected        DegradedStatusReason = "IPSEC_MULTI_TUNNEL_TUNNEL_DISCONNECTED"
	DegradedStatusReasonIpsecTunnelDisconnected                   DegradedStatusReason = "IPSEC_TUNNEL_DISCONNECTED"
	DegradedStatusReasonLanDisconnected                           DegradedStatusReason = "LAN_DISCONNECTED"
	DegradedStatusReasonLanLagDisconnected                        DegradedStatusReason = "LAN_LAG_DISCONNECTED"
	DegradedStatusReasonLanLagMemberDisconnected                  DegradedStatusReason = "LAN_LAG_MEMBER_DISCONNECTED"
	DegradedStatusReasonWanDisconnected                           DegradedStatusReason = "WAN_DISCONNECTED"
	DegradedStatusReasonWanTunnelDisconnected                     DegradedStatusReason = "WAN_TUNNEL_DISCONNECTED"
)

var AllDegradedStatusReason = []DegradedStatusReason{
	DegradedStatusReasonAltWanDisconnected,
	DegradedStatusReasonCrossConnectCircuitDisconnected,
	DegradedStatusReasonHaNotReadyIncompatibleMajorSocketVersions,
	DegradedStatusReasonHaNotReadyNoKeepalive,
	DegradedStatusReasonHaNotReadySocketDisconnected,
	DegradedStatusReasonIpsecMultiTunnelTunnelDisconnected,
	DegradedStatusReasonIpsecTunnelDisconnected,
	DegradedStatusReasonLanDisconnected,
	DegradedStatusReasonLanLagDisconnected,
	DegradedStatusReasonLanLagMemberDisconnected,
	DegradedStatusReasonWanDisconnected,
	DegradedStatusReasonWanTunnelDisconnected,
}

func (e DegradedStatusReason) IsValid() bool {
	switch e {
	case DegradedStatusReasonAltWanDisconnected, DegradedStatusReasonCrossConnectCircuitDisconnected, DegradedStatusReasonHaNotReadyIncompatibleMajorSocketVersions, DegradedStatusReasonHaNotReadyNoKeepalive, DegradedStatusReasonHaNotReadySocketDisconnected, DegradedStatusReasonIpsecMultiTunnelTunnelDisconnected, DegradedStatusReasonIpsecTunnelDisconnected, DegradedStatusReasonLanDisconnected, DegradedStatusReasonLanLagDisconnected, DegradedStatusReasonLanLagMemberDisconnected, DegradedStatusReasonWanDisconnected, DegradedStatusReasonWanTunnelDisconnected:
		return true
	}
	return false
}

func (e DegradedStatusReason) String() string {
	return string(e)
}

func (e *DegradedStatusReason) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DegradedStatusReason(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DegradedStatusReason", str)
	}
	return nil
}

func (e DegradedStatusReason) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *DegradedStatusReason) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e DegradedStatusReason) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type DestinationType string

const (
	DestinationTypeFqdn DestinationType = "FQDN"
	DestinationTypeIPv4 DestinationType = "IPv4"
)

var AllDestinationType = []DestinationType{
	DestinationTypeFqdn,
	DestinationTypeIPv4,
}

func (e DestinationType) IsValid() bool {
	switch e {
	case DestinationTypeFqdn, DestinationTypeIPv4:
		return true
	}
	return false
}

func (e DestinationType) String() string {
	return string(e)
}

func (e *DestinationType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DestinationType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DestinationType", str)
	}
	return nil
}

func (e DestinationType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *DestinationType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e DestinationType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type DetectionSourceEnum string

const (
	DetectionSourceEnumAntivirus                     DetectionSourceEnum = "ANTIVIRUS"
	DetectionSourceEnumAppGovernanceDetection        DetectionSourceEnum = "APP_GOVERNANCE_DETECTION"
	DetectionSourceEnumAppGovernancePolicy           DetectionSourceEnum = "APP_GOVERNANCE_POLICY"
	DetectionSourceEnumAutomatedInvestigation        DetectionSourceEnum = "AUTOMATED_INVESTIGATION"
	DetectionSourceEnumAzureAdIdentityProtection     DetectionSourceEnum = "AZURE_AD_IDENTITY_PROTECTION"
	DetectionSourceEnumCloudAppSecurity              DetectionSourceEnum = "CLOUD_APP_SECURITY"
	DetectionSourceEnumCustomDetection               DetectionSourceEnum = "CUSTOM_DETECTION"
	DetectionSourceEnumCustomTi                      DetectionSourceEnum = "CUSTOM_TI"
	DetectionSourceEnumManual                        DetectionSourceEnum = "MANUAL"
	DetectionSourceEnumMicrosoftDataLossPrevention   DetectionSourceEnum = "MICROSOFT_DATA_LOSS_PREVENTION"
	DetectionSourceEnumMicrosoftDefenderForEndpoint  DetectionSourceEnum = "MICROSOFT_DEFENDER_FOR_ENDPOINT"
	DetectionSourceEnumMicrosoftDefenderForIdentity  DetectionSourceEnum = "MICROSOFT_DEFENDER_FOR_IDENTITY"
	DetectionSourceEnumMicrosoftDefenderForOffice365 DetectionSourceEnum = "MICROSOFT_DEFENDER_FOR_OFFICE365"
	DetectionSourceEnumMicrosoftThreatExperts        DetectionSourceEnum = "MICROSOFT_THREAT_EXPERTS"
	DetectionSourceEnumMicrosoft365Defender          DetectionSourceEnum = "MICROSOFT365_DEFENDER"
	DetectionSourceEnumSmartScreen                   DetectionSourceEnum = "SMART_SCREEN"
)

var AllDetectionSourceEnum = []DetectionSourceEnum{
	DetectionSourceEnumAntivirus,
	DetectionSourceEnumAppGovernanceDetection,
	DetectionSourceEnumAppGovernancePolicy,
	DetectionSourceEnumAutomatedInvestigation,
	DetectionSourceEnumAzureAdIdentityProtection,
	DetectionSourceEnumCloudAppSecurity,
	DetectionSourceEnumCustomDetection,
	DetectionSourceEnumCustomTi,
	DetectionSourceEnumManual,
	DetectionSourceEnumMicrosoftDataLossPrevention,
	DetectionSourceEnumMicrosoftDefenderForEndpoint,
	DetectionSourceEnumMicrosoftDefenderForIdentity,
	DetectionSourceEnumMicrosoftDefenderForOffice365,
	DetectionSourceEnumMicrosoftThreatExperts,
	DetectionSourceEnumMicrosoft365Defender,
	DetectionSourceEnumSmartScreen,
}

func (e DetectionSourceEnum) IsValid() bool {
	switch e {
	case DetectionSourceEnumAntivirus, DetectionSourceEnumAppGovernanceDetection, DetectionSourceEnumAppGovernancePolicy, DetectionSourceEnumAutomatedInvestigation, DetectionSourceEnumAzureAdIdentityProtection, DetectionSourceEnumCloudAppSecurity, DetectionSourceEnumCustomDetection, DetectionSourceEnumCustomTi, DetectionSourceEnumManual, DetectionSourceEnumMicrosoftDataLossPrevention, DetectionSourceEnumMicrosoftDefenderForEndpoint, DetectionSourceEnumMicrosoftDefenderForIdentity, DetectionSourceEnumMicrosoftDefenderForOffice365, DetectionSourceEnumMicrosoftThreatExperts, DetectionSourceEnumMicrosoft365Defender, DetectionSourceEnumSmartScreen:
		return true
	}
	return false
}

func (e DetectionSourceEnum) String() string {
	return string(e)
}

func (e *DetectionSourceEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DetectionSourceEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DetectionSourceEnum", str)
	}
	return nil
}

func (e DetectionSourceEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *DetectionSourceEnum) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e DetectionSourceEnum) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type DetectionStatusEnum string

const (
	DetectionStatusEnumBlocked   DetectionStatusEnum = "BLOCKED"
	DetectionStatusEnumDetected  DetectionStatusEnum = "DETECTED"
	DetectionStatusEnumPrevented DetectionStatusEnum = "PREVENTED"
)

var AllDetectionStatusEnum = []DetectionStatusEnum{
	DetectionStatusEnumBlocked,
	DetectionStatusEnumDetected,
	DetectionStatusEnumPrevented,
}

func (e DetectionStatusEnum) IsValid() bool {
	switch e {
	case DetectionStatusEnumBlocked, DetectionStatusEnumDetected, DetectionStatusEnumPrevented:
		return true
	}
	return false
}

func (e DetectionStatusEnum) String() string {
	return string(e)
}

func (e *DetectionStatusEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DetectionStatusEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DetectionStatusEnum", str)
	}
	return nil
}

func (e DetectionStatusEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *DetectionStatusEnum) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e DetectionStatusEnum) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type DeviceAvStatusEnum string

const (
	DeviceAvStatusEnumDisabled     DeviceAvStatusEnum = "DISABLED"
	DeviceAvStatusEnumNotReporting DeviceAvStatusEnum = "NOT_REPORTING"
	DeviceAvStatusEnumNotUpdated   DeviceAvStatusEnum = "NOT_UPDATED"
	DeviceAvStatusEnumUpdated      DeviceAvStatusEnum = "UPDATED"
)

var AllDeviceAvStatusEnum = []DeviceAvStatusEnum{
	DeviceAvStatusEnumDisabled,
	DeviceAvStatusEnumNotReporting,
	DeviceAvStatusEnumNotUpdated,
	DeviceAvStatusEnumUpdated,
}

func (e DeviceAvStatusEnum) IsValid() bool {
	switch e {
	case DeviceAvStatusEnumDisabled, DeviceAvStatusEnumNotReporting, DeviceAvStatusEnumNotUpdated, DeviceAvStatusEnumUpdated:
		return true
	}
	return false
}

func (e DeviceAvStatusEnum) String() string {
	return string(e)
}

func (e *DeviceAvStatusEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DeviceAvStatusEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DeviceAvStatusEnum", str)
	}
	return nil
}

func (e DeviceAvStatusEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *DeviceAvStatusEnum) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e DeviceAvStatusEnum) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type DeviceCategory string

const (
	DeviceCategoryIoT        DeviceCategory = "IoT"
	DeviceCategoryMobile     DeviceCategory = "Mobile"
	DeviceCategoryNetworking DeviceCategory = "Networking"
	DeviceCategoryOt         DeviceCategory = "OT"
	DeviceCategoryPc         DeviceCategory = "PC"
	DeviceCategoryServer     DeviceCategory = "Server"
)

var AllDeviceCategory = []DeviceCategory{
	DeviceCategoryIoT,
	DeviceCategoryMobile,
	DeviceCategoryNetworking,
	DeviceCategoryOt,
	DeviceCategoryPc,
	DeviceCategoryServer,
}

func (e DeviceCategory) IsValid() bool {
	switch e {
	case DeviceCategoryIoT, DeviceCategoryMobile, DeviceCategoryNetworking, DeviceCategoryOt, DeviceCategoryPc, DeviceCategoryServer:
		return true
	}
	return false
}

func (e DeviceCategory) String() string {
	return string(e)
}

func (e *DeviceCategory) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DeviceCategory(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DeviceCategory", str)
	}
	return nil
}

func (e DeviceCategory) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *DeviceCategory) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e DeviceCategory) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type DeviceConfidenceLevel string

const (
	// Device classification is strongly validated by multiple signals
	DeviceConfidenceLevelHigh DeviceConfidenceLevel = "HIGH"
	// Device classification has minimal supporting evidence
	DeviceConfidenceLevelLow DeviceConfidenceLevel = "LOW"
	// Device classification has moderate supporting signals
	DeviceConfidenceLevelMedium DeviceConfidenceLevel = "MEDIUM"
)

var AllDeviceConfidenceLevel = []DeviceConfidenceLevel{
	DeviceConfidenceLevelHigh,
	DeviceConfidenceLevelLow,
	DeviceConfidenceLevelMedium,
}

func (e DeviceConfidenceLevel) IsValid() bool {
	switch e {
	case DeviceConfidenceLevelHigh, DeviceConfidenceLevelLow, DeviceConfidenceLevelMedium:
		return true
	}
	return false
}

func (e DeviceConfidenceLevel) String() string {
	return string(e)
}

func (e *DeviceConfidenceLevel) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DeviceConfidenceLevel(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DeviceConfidenceLevel", str)
	}
	return nil
}

func (e DeviceConfidenceLevel) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *DeviceConfidenceLevel) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e DeviceConfidenceLevel) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type DeviceConfigHaRoleEnum string

const (
	DeviceConfigHaRoleEnumPrimary   DeviceConfigHaRoleEnum = "PRIMARY"
	DeviceConfigHaRoleEnumSecondary DeviceConfigHaRoleEnum = "SECONDARY"
)

var AllDeviceConfigHaRoleEnum = []DeviceConfigHaRoleEnum{
	DeviceConfigHaRoleEnumPrimary,
	DeviceConfigHaRoleEnumSecondary,
}

func (e DeviceConfigHaRoleEnum) IsValid() bool {
	switch e {
	case DeviceConfigHaRoleEnumPrimary, DeviceConfigHaRoleEnumSecondary:
		return true
	}
	return false
}

func (e DeviceConfigHaRoleEnum) String() string {
	return string(e)
}

func (e *DeviceConfigHaRoleEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DeviceConfigHaRoleEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DeviceConfigHaRoleEnum", str)
	}
	return nil
}

func (e DeviceConfigHaRoleEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *DeviceConfigHaRoleEnum) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e DeviceConfigHaRoleEnum) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type DeviceHaRoleStateEnum string

const (
	DeviceHaRoleStateEnumBackup DeviceHaRoleStateEnum = "BACKUP"
	DeviceHaRoleStateEnumMaster DeviceHaRoleStateEnum = "MASTER"
)

var AllDeviceHaRoleStateEnum = []DeviceHaRoleStateEnum{
	DeviceHaRoleStateEnumBackup,
	DeviceHaRoleStateEnumMaster,
}

func (e DeviceHaRoleStateEnum) IsValid() bool {
	switch e {
	case DeviceHaRoleStateEnumBackup, DeviceHaRoleStateEnumMaster:
		return true
	}
	return false
}

func (e DeviceHaRoleStateEnum) String() string {
	return string(e)
}

func (e *DeviceHaRoleStateEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DeviceHaRoleStateEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DeviceHaRoleStateEnum", str)
	}
	return nil
}

func (e DeviceHaRoleStateEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *DeviceHaRoleStateEnum) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e DeviceHaRoleStateEnum) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type DeviceHealthStatusEnum string

const (
	DeviceHealthStatusEnumActive                            DeviceHealthStatusEnum = "ACTIVE"
	DeviceHealthStatusEnumImpairedCommunication             DeviceHealthStatusEnum = "IMPAIRED_COMMUNICATION"
	DeviceHealthStatusEnumInactive                          DeviceHealthStatusEnum = "INACTIVE"
	DeviceHealthStatusEnumNoSensorData                      DeviceHealthStatusEnum = "NO_SENSOR_DATA"
	DeviceHealthStatusEnumNoSensorDataImpairedCommunication DeviceHealthStatusEnum = "NO_SENSOR_DATA_IMPAIRED_COMMUNICATION"
)

var AllDeviceHealthStatusEnum = []DeviceHealthStatusEnum{
	DeviceHealthStatusEnumActive,
	DeviceHealthStatusEnumImpairedCommunication,
	DeviceHealthStatusEnumInactive,
	DeviceHealthStatusEnumNoSensorData,
	DeviceHealthStatusEnumNoSensorDataImpairedCommunication,
}

func (e DeviceHealthStatusEnum) IsValid() bool {
	switch e {
	case DeviceHealthStatusEnumActive, DeviceHealthStatusEnumImpairedCommunication, DeviceHealthStatusEnumInactive, DeviceHealthStatusEnumNoSensorData, DeviceHealthStatusEnumNoSensorDataImpairedCommunication:
		return true
	}
	return false
}

func (e DeviceHealthStatusEnum) String() string {
	return string(e)
}

func (e *DeviceHealthStatusEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DeviceHealthStatusEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DeviceHealthStatusEnum", str)
	}
	return nil
}

func (e DeviceHealthStatusEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *DeviceHealthStatusEnum) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e DeviceHealthStatusEnum) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type DeviceV2Category string

const (
	DeviceV2CategoryIot        DeviceV2Category = "IOT"
	DeviceV2CategoryMobile     DeviceV2Category = "MOBILE"
	DeviceV2CategoryNetworking DeviceV2Category = "NETWORKING"
	DeviceV2CategoryOt         DeviceV2Category = "OT"
	DeviceV2CategoryPc         DeviceV2Category = "PC"
	DeviceV2CategoryServer     DeviceV2Category = "SERVER"
)

var AllDeviceV2Category = []DeviceV2Category{
	DeviceV2CategoryIot,
	DeviceV2CategoryMobile,
	DeviceV2CategoryNetworking,
	DeviceV2CategoryOt,
	DeviceV2CategoryPc,
	DeviceV2CategoryServer,
}

func (e DeviceV2Category) IsValid() bool {
	switch e {
	case DeviceV2CategoryIot, DeviceV2CategoryMobile, DeviceV2CategoryNetworking, DeviceV2CategoryOt, DeviceV2CategoryPc, DeviceV2CategoryServer:
		return true
	}
	return false
}

func (e DeviceV2Category) String() string {
	return string(e)
}

func (e *DeviceV2Category) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DeviceV2Category(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DeviceV2Category", str)
	}
	return nil
}

func (e DeviceV2Category) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *DeviceV2Category) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e DeviceV2Category) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type DhcpType string

const (
	DhcpTypeAccountDefault DhcpType = "ACCOUNT_DEFAULT"
	DhcpTypeDhcpDisabled   DhcpType = "DHCP_DISABLED"
	DhcpTypeDhcpRange      DhcpType = "DHCP_RANGE"
	DhcpTypeDhcpRelay      DhcpType = "DHCP_RELAY"
)

var AllDhcpType = []DhcpType{
	DhcpTypeAccountDefault,
	DhcpTypeDhcpDisabled,
	DhcpTypeDhcpRange,
	DhcpTypeDhcpRelay,
}

func (e DhcpType) IsValid() bool {
	switch e {
	case DhcpTypeAccountDefault, DhcpTypeDhcpDisabled, DhcpTypeDhcpRange, DhcpTypeDhcpRelay:
		return true
	}
	return false
}

func (e DhcpType) String() string {
	return string(e)
}

func (e *DhcpType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DhcpType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DhcpType", str)
	}
	return nil
}

func (e DhcpType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *DhcpType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e DhcpType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type DirectionEnum string

const (
	DirectionEnumAsc  DirectionEnum = "asc"
	DirectionEnumDesc DirectionEnum = "desc"
)

var AllDirectionEnum = []DirectionEnum{
	DirectionEnumAsc,
	DirectionEnumDesc,
}

func (e DirectionEnum) IsValid() bool {
	switch e {
	case DirectionEnumAsc, DirectionEnumDesc:
		return true
	}
	return false
}

func (e DirectionEnum) String() string {
	return string(e)
}

func (e *DirectionEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DirectionEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DirectionEnum", str)
	}
	return nil
}

func (e DirectionEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *DirectionEnum) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e DirectionEnum) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type DirectionInput string

const (
	DirectionInputAsc  DirectionInput = "asc"
	DirectionInputDesc DirectionInput = "desc"
)

var AllDirectionInput = []DirectionInput{
	DirectionInputAsc,
	DirectionInputDesc,
}

func (e DirectionInput) IsValid() bool {
	switch e {
	case DirectionInputAsc, DirectionInputDesc:
		return true
	}
	return false
}

func (e DirectionInput) String() string {
	return string(e)
}

func (e *DirectionInput) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DirectionInput(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DirectionInput", str)
	}
	return nil
}

func (e DirectionInput) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *DirectionInput) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e DirectionInput) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// The DPA agreement, based on your contract with Cato
type DpaVersion string

const (
	DpaVersionDpa2019_01 DpaVersion = "DPA_2019_01"
	DpaVersionDpa2021_01 DpaVersion = "DPA_2021_01"
	DpaVersionDpa2023_01 DpaVersion = "DPA_2023_01"
)

var AllDpaVersion = []DpaVersion{
	DpaVersionDpa2019_01,
	DpaVersionDpa2021_01,
	DpaVersionDpa2023_01,
}

func (e DpaVersion) IsValid() bool {
	switch e {
	case DpaVersionDpa2019_01, DpaVersionDpa2021_01, DpaVersionDpa2023_01:
		return true
	}
	return false
}

func (e DpaVersion) String() string {
	return string(e)
}

func (e *DpaVersion) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DpaVersion(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DpaVersion", str)
	}
	return nil
}

func (e DpaVersion) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *DpaVersion) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e DpaVersion) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Search operators on ElasticSearch. Between operators are applicable only to numeric fields
// Note that not operators are slower
type ElasticOperator string

const (
	ElasticOperatorBetween    ElasticOperator = "between"
	ElasticOperatorExists     ElasticOperator = "exists"
	ElasticOperatorIn         ElasticOperator = "in"
	ElasticOperatorIs         ElasticOperator = "is"
	ElasticOperatorIsNot      ElasticOperator = "is_not"
	ElasticOperatorNotBetween ElasticOperator = "not_between"
	ElasticOperatorNotExists  ElasticOperator = "not_exists"
	ElasticOperatorNotIn      ElasticOperator = "not_in"
)

var AllElasticOperator = []ElasticOperator{
	ElasticOperatorBetween,
	ElasticOperatorExists,
	ElasticOperatorIn,
	ElasticOperatorIs,
	ElasticOperatorIsNot,
	ElasticOperatorNotBetween,
	ElasticOperatorNotExists,
	ElasticOperatorNotIn,
}

func (e ElasticOperator) IsValid() bool {
	switch e {
	case ElasticOperatorBetween, ElasticOperatorExists, ElasticOperatorIn, ElasticOperatorIs, ElasticOperatorIsNot, ElasticOperatorNotBetween, ElasticOperatorNotExists, ElasticOperatorNotIn:
		return true
	}
	return false
}

func (e ElasticOperator) String() string {
	return string(e)
}

func (e *ElasticOperator) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ElasticOperator(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ElasticOperator", str)
	}
	return nil
}

func (e ElasticOperator) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ElasticOperator) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ElasticOperator) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type EmployeeRange string

const (
	// 1-10 employees
	EmployeeRangeBetween00001_00010 EmployeeRange = "BETWEEN_00001_00010"
	// 11-50 employees
	EmployeeRangeBetween00011_00050 EmployeeRange = "BETWEEN_00011_00050"
	// 51-100 employees
	EmployeeRangeBetween00051_00100 EmployeeRange = "BETWEEN_00051_00100"
	// 101-250 employees
	EmployeeRangeBetween00101_00250 EmployeeRange = "BETWEEN_00101_00250"
	// 251-500 employees
	EmployeeRangeBetween00251_00500 EmployeeRange = "BETWEEN_00251_00500"
	// 501-1,000 employees
	EmployeeRangeBetween00501_01000 EmployeeRange = "BETWEEN_00501_01000"
	// 1,001-5,000 employees
	EmployeeRangeBetween01001_05000 EmployeeRange = "BETWEEN_01001_05000"
	// 5,001-10,000 employees
	EmployeeRangeBetween05001_10000 EmployeeRange = "BETWEEN_05001_10000"
	// 10,000+ employees
	EmployeeRangeBetween10001Max EmployeeRange = "BETWEEN_10001_MAX"
)

var AllEmployeeRange = []EmployeeRange{
	EmployeeRangeBetween00001_00010,
	EmployeeRangeBetween00011_00050,
	EmployeeRangeBetween00051_00100,
	EmployeeRangeBetween00101_00250,
	EmployeeRangeBetween00251_00500,
	EmployeeRangeBetween00501_01000,
	EmployeeRangeBetween01001_05000,
	EmployeeRangeBetween05001_10000,
	EmployeeRangeBetween10001Max,
}

func (e EmployeeRange) IsValid() bool {
	switch e {
	case EmployeeRangeBetween00001_00010, EmployeeRangeBetween00011_00050, EmployeeRangeBetween00051_00100, EmployeeRangeBetween00101_00250, EmployeeRangeBetween00251_00500, EmployeeRangeBetween00501_01000, EmployeeRangeBetween01001_05000, EmployeeRangeBetween05001_10000, EmployeeRangeBetween10001Max:
		return true
	}
	return false
}

func (e EmployeeRange) String() string {
	return string(e)
}

func (e *EmployeeRange) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EmployeeRange(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EmployeeRange", str)
	}
	return nil
}

func (e EmployeeRange) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *EmployeeRange) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e EmployeeRange) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type EntityType string

const (
	// A reference to a configured Account under reseller
	EntityTypeAccount EntityType = "account"
	// An account administrator (user in Cato Console)
	EntityTypeAdmin EntityType = "admin"
	// An external IP address in a specific PoP reserved for the account
	EntityTypeAllocatedIP EntityType = "allocatedIP"
	// Any entity (matches everything)
	EntityTypeAny EntityType = "any"
	// Pooled licenses available for use
	EntityTypeAPIKey EntityType = "apiKey"
	// added by joe
	EntityTypeAvailablePooledUsage EntityType = "availablePooledUsage"
	// Site licenses available for use
	EntityTypeAvailableSiteUsage EntityType = "availableSiteUsage"
	// A settlement with over 1K population
	EntityTypeCity EntityType = "city"
	// Geographical and political entity recognized internationally
	EntityTypeCountry EntityType = "country"
	// Represents a state or territory within a country. It is a sub-division of the country
	EntityTypeCountryState EntityType = "countryState"
	// A reference to DHCP Relay Group within account
	EntityTypeDhcpRelayGroup    EntityType = "dhcpRelayGroup"
	EntityTypeGroupSubscription EntityType = "groupSubscription"
	// A reference to the configured Host within Site
	EntityTypeHost EntityType = "host"
	// A reference to LAN Firewall Rule within Site
	EntityTypeLanFirewall EntityType = "lanFirewall"
	// A reference to Local Routing Rule within Site
	EntityTypeLocalRouting            EntityType = "localRouting"
	EntityTypeLocation                EntityType = "location"
	EntityTypeMailingListSubscription EntityType = "mailingListSubscription"
	// A reference to the configured Network Interface within Site
	EntityTypeNetworkInterface EntityType = "networkInterface"
	// Combination of protocol (TCP, UDP, TCP/UDP, ICMP) and port number
	EntityTypePortProtocol EntityType = "portProtocol"
	// l4 services for LAN firewall rules
	EntityTypeSimpleService EntityType = "simpleService"
	// A reference to a configured Site within Account
	EntityTypeSite EntityType = "site"
	// union of the globalRange and a Subnet
	EntityTypeSiteRange EntityType = "siteRange"
	// added by joe
	EntityTypeSocketInterface EntityType = "socketInterface"
	// added by joe
	EntityTypeSubnet EntityType = "subnet"
	// added by joe
	EntityTypeCasbRule EntityType = "casbRule"
	// added by joe
	EntityTypeNetworkRule EntityType = "networkRule"
	// added by joe
	EntityTypeGroup EntityType = "group"
	// added by joe
	EntityTypeUsersGroup EntityType = "usersGroup"
	// added by joe
	EntityTypeIP EntityType = "ip"
	// added by joe
	EntityTypeInterfaceSubnet EntityType = "interfaceSubnet"
	// Time zone, which is a geographical region where clocks are set to the same time
	EntityTypeTimezone EntityType = "timezone"
	// A reference to the configured VPN User within Account
	EntityTypeVpnUser             EntityType = "vpnUser"
	EntityTypeWebhookSubscription EntityType = "webhookSubscription"
)

var AllEntityType = []EntityType{
	EntityTypeAccount,
	EntityTypeAdmin,
	EntityTypeAllocatedIP,
	EntityTypeAny,
	EntityTypeAPIKey,
	EntityTypeAvailablePooledUsage,
	EntityTypeAvailableSiteUsage,
	EntityTypeCity,
	EntityTypeCountry,
	EntityTypeCountryState,
	EntityTypeDhcpRelayGroup,
	EntityTypeGroupSubscription,
	EntityTypeHost,
	EntityTypeLanFirewall,
	EntityTypeLocalRouting,
	EntityTypeLocation,
	EntityTypeMailingListSubscription,
	EntityTypeNetworkInterface,
	EntityTypePortProtocol,
	EntityTypeSimpleService,
	EntityTypeSite,
	EntityTypeSiteRange,
	EntityTypeSocketInterface,
	EntityTypeSubnet,
	EntityTypeCasbRule,
	EntityTypeNetworkRule,
	EntityTypeGroup,
	EntityTypeUsersGroup,
	EntityTypeIP,
	EntityTypeInterfaceSubnet,
	EntityTypeTimezone,
	EntityTypeVpnUser,
	EntityTypeWebhookSubscription,
}

func (e EntityType) IsValid() bool {
	switch e {
	case EntityTypeAccount, EntityTypeAdmin, EntityTypeAllocatedIP, EntityTypeAny, EntityTypeAPIKey, EntityTypeAvailablePooledUsage, EntityTypeAvailableSiteUsage, EntityTypeCity, EntityTypeCountry, EntityTypeCountryState, EntityTypeDhcpRelayGroup, EntityTypeGroupSubscription, EntityTypeHost, EntityTypeLanFirewall, EntityTypeLocalRouting, EntityTypeLocation, EntityTypeMailingListSubscription, EntityTypeNetworkInterface, EntityTypePortProtocol, EntityTypeSimpleService, EntityTypeSite, EntityTypeSiteRange, EntityTypeSocketInterface, EntityTypeSubnet, EntityTypeCasbRule, EntityTypeNetworkRule, EntityTypeGroup, EntityTypeUsersGroup, EntityTypeIP, EntityTypeInterfaceSubnet, EntityTypeTimezone, EntityTypeVpnUser, EntityTypeWebhookSubscription:
		return true
	}
	return false
}

func (e EntityType) String() string {
	return string(e)
}

func (e *EntityType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EntityType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EntityType", str)
	}
	return nil
}

func (e EntityType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *EntityType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e EntityType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type EventFeedFilterFieldName string

const (
	// Sub-type for Routing, Security, Connectivity, System or Sockets Management event
	EventFeedFilterFieldNameEventSubType EventFeedFilterFieldName = "event_sub_type"
	// Routing, Security, Connectivity, System or Sockets Management event
	EventFeedFilterFieldNameEventType EventFeedFilterFieldName = "event_type"
)

var AllEventFeedFilterFieldName = []EventFeedFilterFieldName{
	EventFeedFilterFieldNameEventSubType,
	EventFeedFilterFieldNameEventType,
}

func (e EventFeedFilterFieldName) IsValid() bool {
	switch e {
	case EventFeedFilterFieldNameEventSubType, EventFeedFilterFieldNameEventType:
		return true
	}
	return false
}

func (e EventFeedFilterFieldName) String() string {
	return string(e)
}

func (e *EventFeedFilterFieldName) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EventFeedFilterFieldName(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EventFeedFilterFieldName", str)
	}
	return nil
}

func (e EventFeedFilterFieldName) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *EventFeedFilterFieldName) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e EventFeedFilterFieldName) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Search operators on Event Feed
type EventFeedFilterOperator string

const (
	EventFeedFilterOperatorIn    EventFeedFilterOperator = "in"
	EventFeedFilterOperatorIs    EventFeedFilterOperator = "is"
	EventFeedFilterOperatorIsNot EventFeedFilterOperator = "is_not"
	EventFeedFilterOperatorNotIn EventFeedFilterOperator = "not_in"
)

var AllEventFeedFilterOperator = []EventFeedFilterOperator{
	EventFeedFilterOperatorIn,
	EventFeedFilterOperatorIs,
	EventFeedFilterOperatorIsNot,
	EventFeedFilterOperatorNotIn,
}

func (e EventFeedFilterOperator) IsValid() bool {
	switch e {
	case EventFeedFilterOperatorIn, EventFeedFilterOperatorIs, EventFeedFilterOperatorIsNot, EventFeedFilterOperatorNotIn:
		return true
	}
	return false
}

func (e EventFeedFilterOperator) String() string {
	return string(e)
}

func (e *EventFeedFilterOperator) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EventFeedFilterOperator(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EventFeedFilterOperator", str)
	}
	return nil
}

func (e EventFeedFilterOperator) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *EventFeedFilterOperator) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e EventFeedFilterOperator) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type EventFieldName string

const (
	// Identifies system access software or device
	EventFieldNameAccessMethod EventFieldName = "access_method"
	// Account ID
	EventFieldNameAccountID EventFieldName = "account_id"
	// Firewall, QoS or LAG action
	EventFieldNameAction EventFieldName = "action"
	// A list of actions taken, if more than one action was taken as defined by a policy
	EventFieldNameActionsTaken EventFieldName = "actions_taken"
	// The activity resource ID being referenced with resource type.
	EventFieldNameActivityResourceID EventFieldName = "activity_resource_id"
	// Defines the type of entity performing the action, helping to distinguish between different categories of users.
	EventFieldNameActorType EventFieldName = "actor_type"
	// Active Directory name
	EventFieldNameAdName EventFieldName = "ad_name"
	// A unique identifier of the alert notification
	EventFieldNameAlertID EventFieldName = "alert_id"
	// Always-on Configuration
	EventFieldNameAlwaysOnConfiguration EventFieldName = "always_on_configuration"
	// Analyst Verdict
	EventFieldNameAnalystVerdict EventFieldName = "analyst_verdict"
	// The name of the API, e.g. eventsFeed
	EventFieldNameAPIName EventFieldName = "api_name"
	// Specifies whether the API is a query (read) or a mutation (create/update/delete)
	EventFieldNameAPIType EventFieldName = "api_type"
	// Name of application activity
	EventFieldNameAppActivity EventFieldName = "app_activity"
	// SaaS user activities into categories.
	EventFieldNameAppActivityCategory EventFieldName = "app_activity_category"
	// Activity type
	EventFieldNameAppActivityType EventFieldName = "app_activity_type"
	// Related Apps
	EventFieldNameAppStack EventFieldName = "app_stack"
	// Application ID of the flow
	EventFieldNameApplicationID EventFieldName = "application_id"
	// The name of the application associated with the flow
	EventFieldNameApplicationName EventFieldName = "application_name"
	// Application risk score
	EventFieldNameApplicationRisk EventFieldName = "application_risk"
	// Connectivity authentication method: unauthenticated, OATH2, LDAP or VPN
	EventFieldNameAuthMethod EventFieldName = "auth_method"
	// Examples: MFA or password
	EventFieldNameAuthenticationType EventFieldName = "authentication_type"
	// BGP ASN for Cato peer
	EventFieldNameBgpCatoAsn EventFieldName = "bgp_cato_asn"
	// BGP IP for Cato peer
	EventFieldNameBgpCatoIP EventFieldName = "bgp_cato_ip"
	// BGP disconnect error code
	EventFieldNameBgpErrorCode EventFieldName = "bgp_error_code"
	// BGP ASN for remote peer
	EventFieldNameBgpPeerAsn EventFieldName = "bgp_peer_asn"
	// BGP IP for remote peer
	EventFieldNameBgpPeerIP EventFieldName = "bgp_peer_ip"
	// CIDR for BGP route
	EventFieldNameBgpRouteCidr EventFieldName = "bgp_route_cidr"
	// BGP disconnect error message
	EventFieldNameBgpSuberrorCode EventFieldName = "bgp_suberror_code"
	// Always-On Bypass Duration In Seconds
	EventFieldNameBypassDurationSec EventFieldName = "bypass_duration_sec"
	// Always-On Bypass Method
	EventFieldNameBypassMethod EventFieldName = "bypass_method"
	// Always-On Bypass Reason
	EventFieldNameBypassReason EventFieldName = "bypass_reason"
	// Cato system category
	EventFieldNameCategories EventFieldName = "categories"
	// Cato application name
	EventFieldNameCatoApp EventFieldName = "cato_app"
	// Activity classification, e.g. FALSE_POSITIVE
	EventFieldNameClassification EventFieldName = "classification"
	// Expiration date for Client certificate
	EventFieldNameClientCertExpires EventFieldName = "client_cert_expires"
	// Name of Client certificate
	EventFieldNameClientCertName EventFieldName = "client_cert_name"
	// Type of process generating this traffic
	EventFieldNameClientClass EventFieldName = "client_class"
	// Admins can configure the Client connection mode to control which types of traffic are routed and protected by Cato. The available options are:
	// All Ports and Protocols – Secures all application traffic across any port or protocol.
	// Web-only (HTTPS) – Secures only browser-based traffic over HTTPS.
	EventFieldNameClientConnectionMode EventFieldName = "client_connection_mode"
	// Socket or SDP Client version
	EventFieldNameClientVersion EventFieldName = "client_version"
	// Shows the display name of the target user involved in an activity
	EventFieldNameCollaboratorName EventFieldName = "collaborator_name"
	// For SaaS Security API, email addresses of the users that received the file
	EventFieldNameCollaborators EventFieldName = "collaborators"
	// Confidence Level
	EventFieldNameConfidenceLevel EventFieldName = "confidence_level"
	// For hosts configured with a static IP in the Cato Management Application, the host name
	EventFieldNameConfiguredHostName EventFieldName = "configured_host_name"
	// The algorithm that is used (CUBIC /NewReno / BBR)
	EventFieldNameCongestionAlgorithm EventFieldName = "congestion_algorithm"
	// Connect on boot Enabled/Disabled
	EventFieldNameConnectOnBoot EventFieldName = "connect_on_boot"
	// Connection Origin
	EventFieldNameConnectionOrigin EventFieldName = "connection_origin"
	// For SaaS Security API, name of the connector
	EventFieldNameConnectorName EventFieldName = "connector_name"
	// For SaaS Security API, status of the connector
	EventFieldNameConnectorStatus EventFieldName = "connector_status"
	// For SaaS Security API, SaaS app for the connector
	EventFieldNameConnectorType EventFieldName = "connector_type"
	// IoC Container Name
	EventFieldNameContainerName EventFieldName = "container_name"
	// An external system identifier used for correlation between related Cato entities. Example: external ticket id that correlates Cato XDR stories.
	EventFieldNameCorrelationID EventFieldName = "correlation_id"
	// Criticality
	EventFieldNameCriticality EventFieldName = "criticality"
	// Custom category ID
	EventFieldNameCustomCategoryID EventFieldName = "custom_category_id"
	// Custom category name
	EventFieldNameCustomCategoryName EventFieldName = "custom_category_name"
	// For Internet traffic, country where the destination host is located
	EventFieldNameDestCountry EventFieldName = "dest_country"
	// For Internet traffic, the two letter country code where the destination host is located (based on ISO 3166-1 alpha-2)
	EventFieldNameDestCountryCode EventFieldName = "dest_country_code"
	// The unique identifier by the SaaS vendor for the target group in an activity.
	EventFieldNameDestGroupID EventFieldName = "dest_group_id"
	// Identifies the target group involved in an activity
	EventFieldNameDestGroupName EventFieldName = "dest_group_name"
	// Destination IP address
	EventFieldNameDestIP EventFieldName = "dest_ip"
	// For WAN traffic, destination is site or SDP user
	EventFieldNameDestIsSiteOrVpn EventFieldName = "dest_is_site_or_vpn"
	// The destination process ID
	EventFieldNameDestPid EventFieldName = "dest_pid"
	// Destination port
	EventFieldNameDestPort EventFieldName = "dest_port"
	// Destination process command line
	EventFieldNameDestProcessCmdline EventFieldName = "dest_process_cmdline"
	// Destination process parent file path
	EventFieldNameDestProcessParentPath EventFieldName = "dest_process_parent_path"
	// Destination process parent process ID
	EventFieldNameDestProcessParentPid EventFieldName = "dest_process_parent_pid"
	// Destination process file path
	EventFieldNameDestProcessPath EventFieldName = "dest_process_path"
	// Unique internal Cato ID for the destination site or remote user
	EventFieldNameDestSiteID EventFieldName = "dest_site_id"
	// The name of the destination site
	EventFieldNameDestSiteName EventFieldName = "dest_site_name"
	// Short description of the detection
	EventFieldNameDetectionName EventFieldName = "detection_name"
	// Triggered when malware has been detected EPP Behavioral engines and has been dealt with:
	// • on_detection: the event is triggered upon malware detection;
	// • on_end_disinfect: the event is triggered upon detection and followed disinfection;
	// • on_inject: the event is triggered upon code injection.
	EventFieldNameDetectionStage EventFieldName = "detection_stage"
	// Device Categories
	EventFieldNameDeviceCategories EventFieldName = "device_categories"
	// Device Certificate Validated/Not Validated
	EventFieldNameDeviceCertificate EventFieldName = "device_certificate"
	// Unique Cato ID for devices
	EventFieldNameDeviceID EventFieldName = "device_id"
	// Device Manufacturer
	EventFieldNameDeviceManufacturer EventFieldName = "device_manufacturer"
	// Device Model
	EventFieldNameDeviceModel EventFieldName = "device_model"
	// Name for device related to the event
	EventFieldNameDeviceName EventFieldName = "device_name"
	// Device OS Type
	EventFieldNameDeviceOsType EventFieldName = "device_os_type"
	// Device posture profiles
	EventFieldNameDevicePostureProfile EventFieldName = "device_posture_profile"
	// Device Type
	EventFieldNameDeviceType EventFieldName = "device_type"
	// Host name of Domain Controller that created LDAP event
	EventFieldNameDirectoryHostName EventFieldName = "directory_host_name"
	// IP address of Domain Controller that created LDAP event
	EventFieldNameDirectoryIP EventFieldName = "directory_ip"
	// Result of LDAP Domain Controller sync event
	EventFieldNameDirectorySyncResult EventFieldName = "directory_sync_result"
	// Type of LDAP Domain Controller sync event
	EventFieldNameDirectorySyncType EventFieldName = "directory_sync_type"
	// If policy is set to disinfect, return the result of this action
	EventFieldNameDisinfectResult EventFieldName = "disinfect_result"
	// Describes the behavior when the DLP system encounters a failure
	EventFieldNameDlpFailMode EventFieldName = "dlp_fail_mode"
	// DLP profiles related to the event
	EventFieldNameDlpProfiles EventFieldName = "dlp_profiles"
	// Defines the scanning methods used by the DLP system
	EventFieldNameDlpScanTypes EventFieldName = "dlp_scan_types"
	// Cato’s DNS Protection type that matched the DNS request
	EventFieldNameDNSProtectionCategory EventFieldName = "dns_protection_category"
	// Domain queried in the DNS request
	EventFieldNameDNSQuery EventFieldName = "dns_query"
	// Domain name based on the SSL SNI, HTTP host name, or DNS name
	EventFieldNameDomainName EventFieldName = "domain_name"
	// Egress PoP Name
	EventFieldNameEgressPopName EventFieldName = "egress_pop_name"
	// Egress Site Name for backhauling traffic
	EventFieldNameEgressSiteName EventFieldName = "egress_site_name"
	// Email Subject
	EventFieldNameEmailSubject EventFieldName = "email_subject"
	// The ID for the endpoint
	EventFieldNameEndpointID EventFieldName = "endpoint_id"
	// The engine type associated with the event
	EventFieldNameEngineType EventFieldName = "engine_type"
	// The Endpoint Protection Engine that detected the malware
	EventFieldNameEppEngineType EventFieldName = "epp_engine_type"
	// The profile assigned to the endpoint upon detection of the malware
	EventFieldNameEppProfile EventFieldName = "epp_profile"
	// Count for events that are repeated multiple times during one minute
	EventFieldNameEventCount EventFieldName = "event_count"
	// Event Id
	EventFieldNameEventID EventFieldName = "event_id"
	// Cato's description of the event
	EventFieldNameEventMessage EventFieldName = "event_message"
	// Sub-type for Routing, Security, Connectivity, System or Sockets Management event
	EventFieldNameEventSubType EventFieldName = "event_sub_type"
	// Routing, Security, Connectivity, System or Sockets Management event
	EventFieldNameEventType EventFieldName = "event_type"
	// Provides details about why a specific action or process failed
	EventFieldNameFailureReason EventFieldName = "failure_reason"
	// File hash
	EventFieldNameFileHash EventFieldName = "file_hash"
	// File name
	EventFieldNameFileName EventFieldName = "file_name"
	// The file operation when this event occurred
	EventFieldNameFileOperation EventFieldName = "file_operation"
	// File size
	EventFieldNameFileSize EventFieldName = "file_size"
	// File type
	EventFieldNameFileType EventFieldName = "file_type"
	// The final status for this object after performing actions as defined by the policy
	EventFieldNameFinalObjectStatus EventFieldName = "final_object_status"
	// Amount of flows for a given incident
	EventFieldNameFlowsCardinality EventFieldName = "flows_cardinality"
	// Full path URL application activity
	EventFieldNameFullPathURL EventFieldName = "full_path_url"
	// An identifier for a guest user using Cato through a Captive Portal
	EventFieldNameGuestUser EventFieldName = "guest_user"
	// IP address of host related to event
	EventFieldNameHostIP EventFieldName = "host_ip"
	// MAC address of host related to event
	EventFieldNameHostMac EventFieldName = "host_mac"
	// HTTP request method (ie. Get, Post)
	EventFieldNameHTTPRequestMethod EventFieldName = "http_request_method"
	// For MDR service, a true/false value that indicates if this event is: A summary that aggregates many events (true) Raw network flows for a single event (false)
	EventFieldNameIncidentAggregation EventFieldName = "incident_aggregation"
	// Unique Cato ID that identifies this security incident
	EventFieldNameIncidentID EventFieldName = "incident_id"
	// Indication
	EventFieldNameIndication EventFieldName = "indication"
	// Indicator
	EventFieldNameIndicator EventFieldName = "indicator"
	// The initial status of the object, before any policy was applied
	EventFieldNameInitialObjectStatus EventFieldName = "initial_object_status"
	// Cato Internal-use only
	EventFieldNameInternalID EventFieldName = "internalId"
	// Network protocol for this event
	EventFieldNameIPProtocol EventFieldName = "ip_protocol"
	// Classifies users based on their permissions.
	EventFieldNameIsAdmin EventFieldName = "is_admin"
	// Indicates whether an activity requires administrative permissions.
	EventFieldNameIsAdminActivity EventFieldName = "is_admin_activity"
	// Is Compliant
	EventFieldNameIsCompliant EventFieldName = "is_compliant"
	// Is Managed
	EventFieldNameIsManaged EventFieldName = "is_managed"
	// Is the app for this event defined as a sanctioned app? (True/False)
	EventFieldNameIsSanctionedApp EventFieldName = "is_sanctioned_app"
	// If the events was part of the sinkhole flow
	EventFieldNameIsSinkhole EventFieldName = "is_sinkhole"
	// The ISP related to this event (when the IP address isn't provided by the ISP, then the event message is IP Addresses are assigned statically)
	EventFieldNameIspName EventFieldName = "ISP_name"
	// Name defined for the public API Key in the Cato Management Application
	EventFieldNameKeyName EventFieldName = "key_name"
	// A list of labels providing additional context for the event
	EventFieldNameLabels EventFieldName = "labels"
	// Data that measures the congestion for a specific link
	EventFieldNameLinkHealthIsCongested EventFieldName = "link_health_is_congested"
	// Data that measures the jitter for a specific link
	EventFieldNameLinkHealthJitter EventFieldName = "link_health_jitter"
	// Round Trip Delay in Milliseconds that it takes a packet to travel between the source and the PoP
	EventFieldNameLinkHealthLatency EventFieldName = "link_health_latency"
	// Data that measures the packet loss for a specific link
	EventFieldNameLinkHealthPktLoss EventFieldName = "link_health_pkt_loss"
	// Link type – Cato, Alt. WAN or LAG
	EventFieldNameLinkType EventFieldName = "link_type"
	// The user logged into this endpoint during this event
	EventFieldNameLoggedInUser EventFieldName = "logged_in_user"
	// Login action, values are: User portal (myvpn.catonetworks.com) or VPN client (Client or site traffic)
	EventFieldNameLoginType EventFieldName = "login_type"
	// Matched DLP data types related to the event
	EventFieldNameMatchedDataTypes EventFieldName = "matched_data_types"
	// Mitre attack subtechniques
	EventFieldNameMitreAttackSubtechniques EventFieldName = "mitre_attack_subtechniques"
	// Mitre attack tactics
	EventFieldNameMitreAttackTactics EventFieldName = "mitre_attack_tactics"
	// Mitre attack techniques
	EventFieldNameMitreAttackTechniques EventFieldName = "mitre_attack_techniques"
	// Network Access
	EventFieldNameNetworkAccess EventFieldName = "network_access"
	// Matched network rule
	EventFieldNameNetworkRule EventFieldName = "network_rule"
	// For SaaS Security API, API Error of Apps Security Notification
	EventFieldNameNotificationAPIError EventFieldName = "notification_api_error"
	// For SaaS Security API, description of Apps Security Notification
	EventFieldNameNotificationDescription EventFieldName = "notification_description"
	// Unique identifier by the 3rd party App of the object being referenced
	EventFieldNameObjectID EventFieldName = "object_id"
	// The name of the object for this event (for example: file name)
	EventFieldNameObjectName EventFieldName = "object_name"
	// Specifies the type of object being acted upon (e.g., file, folder)
	EventFieldNameObjectType EventFieldName = "object_type"
	// Office mode Enabled/Disabled
	EventFieldNameOfficeMode EventFieldName = "office_mode"
	// Host OS or tunnel device
	EventFieldNameOsType EventFieldName = "os_type"
	// OS version for the device (such as 14.3.0)
	EventFieldNameOsVersion EventFieldName = "os_version"
	// Indicate if the Access to the 3rd Party SaaS App occurs without passing through Cato Cloud (direct access to saas App)
	EventFieldNameOutOfBandAccess EventFieldName = "out_of_band_access"
	// For SaaS Security API, email address of the file owner
	EventFieldNameOwner EventFieldName = "owner"
	// Pac File Enabled/Disabled
	EventFieldNamePacFile EventFieldName = "pac_file"
	// For SaaS Security API, parent Microsoft 365 connector
	EventFieldNameParentConnectorName EventFieldName = "parent_connector_name"
	// Name of PoP location
	EventFieldNamePopName EventFieldName = "pop_name"
	// Precedence
	EventFieldNamePrecedence EventFieldName = "precedence"
	// Indicate how many processes are part of this event
	EventFieldNameProcessesCount EventFieldName = "processes_count"
	// Producer
	EventFieldNameProducer EventFieldName = "producer"
	// Related project name(s)
	EventFieldNameProjects EventFieldName = "projects"
	// Prompt Page Selected Action
	EventFieldNamePromptAction EventFieldName = "prompt_action"
	// The name of the provider, for example cloud provider - AWS
	EventFieldNameProviderName EventFieldName = "provider_name"
	// Public source IP
	EventFieldNamePublicIP EventFieldName = "public_ip"
	// QoS Priority value
	EventFieldNameQosPriority EventFieldName = "qos_priority"
	// For QoS, the time that this QoS event started. The event is generated when the QoS event finishes
	EventFieldNameQosReportedTime EventFieldName = "qos_reported_time"
	// Specifies the path to a quarantine folder for isolated files
	EventFieldNameQuarantineFolderPath EventFieldName = "quarantine_folder_path"
	// A Unique ID for the quarantined file
	EventFieldNameQuarantineUUID EventFieldName = "quarantine_uuid"
	// Raw Data
	EventFieldNameRawData EventFieldName = "raw_data"
	// Textual recommendation of the steps to take
	EventFieldNameRecommendedActions EventFieldName = "recommended_actions"
	// The URL that links directly to the object involved in the activity
	EventFieldNameReferenceURL EventFieldName = "reference_url"
	// Referer URL from the HTTP request header indicating the source of the request.
	EventFieldNameRefererURL EventFieldName = "referer_url"
	// The region of the object
	EventFieldNameRegionName EventFieldName = "region_name"
	// Registration code used the first time that a SDP user authenticates (the code is partially obfuscated)
	EventFieldNameRegistrationCode EventFieldName = "registration_code"
	// The ID of the resource in the cloud provider
	EventFieldNameResourceID EventFieldName = "resource_id"
	// The specific name or identifier of the resource.
	EventFieldNameResourceName EventFieldName = "resource_name"
	// The type of resource being referenced.
	EventFieldNameResourceType EventFieldName = "resource_type"
	// (IPS or SAM event) Indicates the overall impact of a threat for the host or network: Low – ie. adware Medium – ie. network scans High – ie. spyware or worms
	EventFieldNameRiskLevel EventFieldName = "risk_level"
	// Unique Cato ID for the security rule related to the event
	EventFieldNameRuleID EventFieldName = "rule_id"
	// Rule name
	EventFieldNameRuleName EventFieldName = "rule_name"
	// Indicates the internal vendor service or module that produced the data reported in this event
	EventFieldNameServiceName EventFieldName = "service_name"
	// Severity defined for the rule
	EventFieldNameSeverity EventFieldName = "severity"
	// Sharing Options for the file (such as SharePoint)
	EventFieldNameSharingScope EventFieldName = "sharing_scope"
	// Sign In Types
	EventFieldNameSignInEventTypes EventFieldName = "sign_in_event_types"
	// For IPS and SAM, ID of the IPS signature
	EventFieldNameSignatureID EventFieldName = "signature_id"
	// Name for Socket interface
	EventFieldNameSocketInterface EventFieldName = "socket_interface"
	// Socket interface ID
	EventFieldNameSocketInterfaceID EventFieldName = "socket_interface_id"
	// For Socket upgrades, new version number
	EventFieldNameSocketNewVersion EventFieldName = "socket_new_version"
	// For Socket upgrade, previous version number
	EventFieldNameSocketOldVersion EventFieldName = "socket_old_version"
	// Type of Socket reset (Hardware/Software)
	EventFieldNameSocketReset EventFieldName = "socket_reset"
	// For Socket HA events, indicates if the Socket is primary or secondary
	EventFieldNameSocketRole EventFieldName = "socket_role"
	// Socket serial number
	EventFieldNameSocketSerial EventFieldName = "socket_serial"
	// Socket version number
	EventFieldNameSocketVersion EventFieldName = "socket_version"
	// Split Tunnel Configuration
	EventFieldNameSplitTunnelConfiguration EventFieldName = "split_tunnel_configuration"
	// Country in which the source host is located (detected via public IP address)
	EventFieldNameSrcCountry EventFieldName = "src_country"
	// Country Code of country in which the source host is located (detected via public IP address)
	EventFieldNameSrcCountryCode EventFieldName = "src_country_code"
	// IP for host or Cato Client
	EventFieldNameSrcIP EventFieldName = "src_ip"
	// Source type: site or remote user
	EventFieldNameSrcIsSiteOrVpn EventFieldName = "src_is_site_or_vpn"
	// IP address provided by ISP to site or Client
	EventFieldNameSrcIspIP EventFieldName = "src_isp_ip"
	// Source process ID
	EventFieldNameSrcPid EventFieldName = "src_pid"
	// Internal port number
	EventFieldNameSrcPort EventFieldName = "src_port"
	// Source process command line
	EventFieldNameSrcProcessCmdline EventFieldName = "src_process_cmdline"
	// Source process parent file path
	EventFieldNameSrcProcessParentPath EventFieldName = "src_process_parent_path"
	// Source process parent process ID
	EventFieldNameSrcProcessParentPid EventFieldName = "src_process_parent_pid"
	// Source process file path
	EventFieldNameSrcProcessPath EventFieldName = "src_process_path"
	// Unique internal Cato ID for the site or remote user
	EventFieldNameSrcSiteID EventFieldName = "src_site_id"
	// Source site or remote user
	EventFieldNameSrcSiteName EventFieldName = "src_site_name"
	// Static host
	EventFieldNameStaticHost EventFieldName = "static_host"
	// The story status.
	// Possible values: Open, Pending Analysis, Pending more info, Closed, Reopened, Monitoring
	EventFieldNameStatus EventFieldName = "status"
	// Story Id
	EventFieldNameStoryID EventFieldName = "story_id"
	// Name of subnet as defined in Cato Management Application
	EventFieldNameSubnetName EventFieldName = "subnet_name"
	// The name of the subscription
	EventFieldNameSubscriptionName EventFieldName = "subscription_name"
	// Number of targets (servers) associated with this event
	EventFieldNameTargetsCardinality EventFieldName = "targets_cardinality"
	// Shows if traffic was TCP accelerated or not
	EventFieldNameTCPAcceleration EventFieldName = "tcp_acceleration"
	// Unique identifier for the tenant within a multi-tenant environment
	EventFieldNameTenantID EventFieldName = "tenant_id"
	// Tenant Name
	EventFieldNameTenantName EventFieldName = "tenant_name"
	// Tenant Restriction Rule Name
	EventFieldNameTenantRestrictionRuleName EventFieldName = "tenant_restriction_rule_name"
	// Contains the detection risk level. Could be one of the following:
	// • Info - this is information-only event, the activity is not malicious;
	// • Suspicious - the event is suspicious. It may be malicious, but there is not enough information
	// • Malware - the event is malicious activity
	EventFieldNameThreatConfidence EventFieldName = "threat_confidence"
	// For anti-malware events, malware name For IPS events, explains the reason why the traffic was blocked
	EventFieldNameThreatName EventFieldName = "threat_name"
	// Link to external malware reference
	EventFieldNameThreatReference EventFieldName = "threat_reference"
	// The higher the score, the more dangerous the event. In range between 1 - 100 inclusive
	EventFieldNameThreatScore EventFieldName = "threat_score"
	// Type of malware event
	EventFieldNameThreatType EventFieldName = "threat_type"
	// Result of malware event (clean indicates a safe file)
	EventFieldNameThreatVerdict EventFieldName = "threat_verdict"
	// Time stamp of the event (Linux epoch format)
	EventFieldNameTime EventFieldName = "time"
	// Time stamp of the event (Human-readable format)
	EventFieldNameTimeStr EventFieldName = "time_str"
	// A short summary of the activity
	EventFieldNameTitle EventFieldName = "title"
	// TLS Certificate Error
	EventFieldNameTLSCertificateError EventFieldName = "tls_certificate_error"
	// TLS Error Description
	EventFieldNameTLSErrorDescription EventFieldName = "tls_error_description"
	// TLS Error Type
	EventFieldNameTLSErrorType EventFieldName = "tls_error_type"
	// Shows if traffic was TLS inspected or not
	EventFieldNameTLSInspection EventFieldName = "tls_inspection"
	// TLS Inspection rule name
	EventFieldNameTLSRuleName EventFieldName = "tls_rule_name"
	// TLS Version
	EventFieldNameTLSVersion EventFieldName = "tls_version"
	// Direction of network traffic for this event, values are inbound or outbound
	EventFieldNameTrafficDirection EventFieldName = "traffic_direction"
	// Translated Client IP
	EventFieldNameTranslatedClientIP EventFieldName = "translated_client_ip"
	// Translated Server IP
	EventFieldNameTranslatedServerIP EventFieldName = "translated_server_ip"
	// Trigger
	EventFieldNameTrigger EventFieldName = "trigger"
	// Trust Type
	EventFieldNameTrustType EventFieldName = "trust_type"
	// Trusted networks Enabled/Disabled
	EventFieldNameTrustedNetworks EventFieldName = "trusted_networks"
	// Tunnel Protocol TCP/UDP
	EventFieldNameTunnelIPProtocol EventFieldName = "tunnel_ip_protocol"
	// Protocol for the tunnel
	EventFieldNameTunnelProtocol EventFieldName = "tunnel_protocol"
	// Socket upgrade end time (Linux epoch format):
	EventFieldNameUpgradeEndTime EventFieldName = "upgrade_end_time"
	// Indicates if the Socket upgrade occurred during the maintenance window or initiated by Support (Cato Admin)
	EventFieldNameUpgradeInitiatedBy EventFieldName = "upgrade_initiated_by"
	// Socket upgrade start time (Linux epoch format)
	EventFieldNameUpgradeStartTime EventFieldName = "upgrade_start_time"
	// URL associated with the event
	EventFieldNameURL EventFieldName = "url"
	// User Agent
	EventFieldNameUserAgent EventFieldName = "user_agent"
	// Method used to get identity with User Awareness (such as Identity Agent)
	EventFieldNameUserAwarenessMethod EventFieldName = "user_awareness_method"
	// User ID
	EventFieldNameUserID EventFieldName = "user_id"
	// User that generated the event
	EventFieldNameUserName EventFieldName = "user_name"
	// Identifies the origin of the user’s connection.
	EventFieldNameUserOrigin EventFieldName = "user_origin"
	// For Block/Prompt page, reference ID to report incorrect category
	EventFieldNameUserReferenceID EventFieldName = "user_reference_id"
	// User risk level category
	EventFieldNameUserRiskLevel EventFieldName = "user_risk_level"
	// The vendor that identified the incident, such as Cato or Microsoft
	EventFieldNameVendor EventFieldName = "vendor"
	// Shows the id of the target user involved in an activity
	EventFieldNameVendorCollaboratorID EventFieldName = "vendor_collaborator_id"
	// Vendor Device Id
	EventFieldNameVendorDeviceID EventFieldName = "vendor_device_id"
	// Vendor Device Name
	EventFieldNameVendorDeviceName EventFieldName = "vendor_device_name"
	// Vendor Event Id
	EventFieldNameVendorEventID EventFieldName = "vendor_event_id"
	// Third party vendor policy description
	EventFieldNameVendorPolicyDescription EventFieldName = "vendor_policy_description"
	// Third party vendor policy ID
	EventFieldNameVendorPolicyID EventFieldName = "vendor_policy_id"
	// Third party vendor policy name
	EventFieldNameVendorPolicyName EventFieldName = "vendor_policy_name"
	// Identifies the user in the vendor’s system
	EventFieldNameVendorUserID EventFieldName = "vendor_user_id"
	// Unique Cato Visible ID for devices
	EventFieldNameVisibleDeviceID EventFieldName = "visible_device_id"
	// Lan access Allowed / Blocked
	EventFieldNameVpnLanAccess EventFieldName = "vpn_lan_access"
	// User’s email address
	EventFieldNameVpnUserEmail EventFieldName = "vpn_user_email"
	// For LDAP sync events, name of the AD domain
	EventFieldNameWindowsDomainName EventFieldName = "windows_domain_name"
	// XFF HTTP header indicates the original IP address for the connections
	EventFieldNameXff EventFieldName = "xff"
)

var AllEventFieldName = []EventFieldName{
	EventFieldNameAccessMethod,
	EventFieldNameAccountID,
	EventFieldNameAction,
	EventFieldNameActionsTaken,
	EventFieldNameActivityResourceID,
	EventFieldNameActorType,
	EventFieldNameAdName,
	EventFieldNameAlertID,
	EventFieldNameAlwaysOnConfiguration,
	EventFieldNameAnalystVerdict,
	EventFieldNameAPIName,
	EventFieldNameAPIType,
	EventFieldNameAppActivity,
	EventFieldNameAppActivityCategory,
	EventFieldNameAppActivityType,
	EventFieldNameAppStack,
	EventFieldNameApplicationID,
	EventFieldNameApplicationName,
	EventFieldNameApplicationRisk,
	EventFieldNameAuthMethod,
	EventFieldNameAuthenticationType,
	EventFieldNameBgpCatoAsn,
	EventFieldNameBgpCatoIP,
	EventFieldNameBgpErrorCode,
	EventFieldNameBgpPeerAsn,
	EventFieldNameBgpPeerIP,
	EventFieldNameBgpRouteCidr,
	EventFieldNameBgpSuberrorCode,
	EventFieldNameBypassDurationSec,
	EventFieldNameBypassMethod,
	EventFieldNameBypassReason,
	EventFieldNameCategories,
	EventFieldNameCatoApp,
	EventFieldNameClassification,
	EventFieldNameClientCertExpires,
	EventFieldNameClientCertName,
	EventFieldNameClientClass,
	EventFieldNameClientConnectionMode,
	EventFieldNameClientVersion,
	EventFieldNameCollaboratorName,
	EventFieldNameCollaborators,
	EventFieldNameConfidenceLevel,
	EventFieldNameConfiguredHostName,
	EventFieldNameCongestionAlgorithm,
	EventFieldNameConnectOnBoot,
	EventFieldNameConnectionOrigin,
	EventFieldNameConnectorName,
	EventFieldNameConnectorStatus,
	EventFieldNameConnectorType,
	EventFieldNameContainerName,
	EventFieldNameCorrelationID,
	EventFieldNameCriticality,
	EventFieldNameCustomCategoryID,
	EventFieldNameCustomCategoryName,
	EventFieldNameDestCountry,
	EventFieldNameDestCountryCode,
	EventFieldNameDestGroupID,
	EventFieldNameDestGroupName,
	EventFieldNameDestIP,
	EventFieldNameDestIsSiteOrVpn,
	EventFieldNameDestPid,
	EventFieldNameDestPort,
	EventFieldNameDestProcessCmdline,
	EventFieldNameDestProcessParentPath,
	EventFieldNameDestProcessParentPid,
	EventFieldNameDestProcessPath,
	EventFieldNameDestSiteID,
	EventFieldNameDestSiteName,
	EventFieldNameDetectionName,
	EventFieldNameDetectionStage,
	EventFieldNameDeviceCategories,
	EventFieldNameDeviceCertificate,
	EventFieldNameDeviceID,
	EventFieldNameDeviceManufacturer,
	EventFieldNameDeviceModel,
	EventFieldNameDeviceName,
	EventFieldNameDeviceOsType,
	EventFieldNameDevicePostureProfile,
	EventFieldNameDeviceType,
	EventFieldNameDirectoryHostName,
	EventFieldNameDirectoryIP,
	EventFieldNameDirectorySyncResult,
	EventFieldNameDirectorySyncType,
	EventFieldNameDisinfectResult,
	EventFieldNameDlpFailMode,
	EventFieldNameDlpProfiles,
	EventFieldNameDlpScanTypes,
	EventFieldNameDNSProtectionCategory,
	EventFieldNameDNSQuery,
	EventFieldNameDomainName,
	EventFieldNameEgressPopName,
	EventFieldNameEgressSiteName,
	EventFieldNameEmailSubject,
	EventFieldNameEndpointID,
	EventFieldNameEngineType,
	EventFieldNameEppEngineType,
	EventFieldNameEppProfile,
	EventFieldNameEventCount,
	EventFieldNameEventID,
	EventFieldNameEventMessage,
	EventFieldNameEventSubType,
	EventFieldNameEventType,
	EventFieldNameFailureReason,
	EventFieldNameFileHash,
	EventFieldNameFileName,
	EventFieldNameFileOperation,
	EventFieldNameFileSize,
	EventFieldNameFileType,
	EventFieldNameFinalObjectStatus,
	EventFieldNameFlowsCardinality,
	EventFieldNameFullPathURL,
	EventFieldNameGuestUser,
	EventFieldNameHostIP,
	EventFieldNameHostMac,
	EventFieldNameHTTPRequestMethod,
	EventFieldNameIncidentAggregation,
	EventFieldNameIncidentID,
	EventFieldNameIndication,
	EventFieldNameIndicator,
	EventFieldNameInitialObjectStatus,
	EventFieldNameInternalID,
	EventFieldNameIPProtocol,
	EventFieldNameIsAdmin,
	EventFieldNameIsAdminActivity,
	EventFieldNameIsCompliant,
	EventFieldNameIsManaged,
	EventFieldNameIsSanctionedApp,
	EventFieldNameIsSinkhole,
	EventFieldNameIspName,
	EventFieldNameKeyName,
	EventFieldNameLabels,
	EventFieldNameLinkHealthIsCongested,
	EventFieldNameLinkHealthJitter,
	EventFieldNameLinkHealthLatency,
	EventFieldNameLinkHealthPktLoss,
	EventFieldNameLinkType,
	EventFieldNameLoggedInUser,
	EventFieldNameLoginType,
	EventFieldNameMatchedDataTypes,
	EventFieldNameMitreAttackSubtechniques,
	EventFieldNameMitreAttackTactics,
	EventFieldNameMitreAttackTechniques,
	EventFieldNameNetworkAccess,
	EventFieldNameNetworkRule,
	EventFieldNameNotificationAPIError,
	EventFieldNameNotificationDescription,
	EventFieldNameObjectID,
	EventFieldNameObjectName,
	EventFieldNameObjectType,
	EventFieldNameOfficeMode,
	EventFieldNameOsType,
	EventFieldNameOsVersion,
	EventFieldNameOutOfBandAccess,
	EventFieldNameOwner,
	EventFieldNamePacFile,
	EventFieldNameParentConnectorName,
	EventFieldNamePopName,
	EventFieldNamePrecedence,
	EventFieldNameProcessesCount,
	EventFieldNameProducer,
	EventFieldNameProjects,
	EventFieldNamePromptAction,
	EventFieldNameProviderName,
	EventFieldNamePublicIP,
	EventFieldNameQosPriority,
	EventFieldNameQosReportedTime,
	EventFieldNameQuarantineFolderPath,
	EventFieldNameQuarantineUUID,
	EventFieldNameRawData,
	EventFieldNameRecommendedActions,
	EventFieldNameReferenceURL,
	EventFieldNameRefererURL,
	EventFieldNameRegionName,
	EventFieldNameRegistrationCode,
	EventFieldNameResourceID,
	EventFieldNameResourceName,
	EventFieldNameResourceType,
	EventFieldNameRiskLevel,
	EventFieldNameRuleID,
	EventFieldNameRuleName,
	EventFieldNameServiceName,
	EventFieldNameSeverity,
	EventFieldNameSharingScope,
	EventFieldNameSignInEventTypes,
	EventFieldNameSignatureID,
	EventFieldNameSocketInterface,
	EventFieldNameSocketInterfaceID,
	EventFieldNameSocketNewVersion,
	EventFieldNameSocketOldVersion,
	EventFieldNameSocketReset,
	EventFieldNameSocketRole,
	EventFieldNameSocketSerial,
	EventFieldNameSocketVersion,
	EventFieldNameSplitTunnelConfiguration,
	EventFieldNameSrcCountry,
	EventFieldNameSrcCountryCode,
	EventFieldNameSrcIP,
	EventFieldNameSrcIsSiteOrVpn,
	EventFieldNameSrcIspIP,
	EventFieldNameSrcPid,
	EventFieldNameSrcPort,
	EventFieldNameSrcProcessCmdline,
	EventFieldNameSrcProcessParentPath,
	EventFieldNameSrcProcessParentPid,
	EventFieldNameSrcProcessPath,
	EventFieldNameSrcSiteID,
	EventFieldNameSrcSiteName,
	EventFieldNameStaticHost,
	EventFieldNameStatus,
	EventFieldNameStoryID,
	EventFieldNameSubnetName,
	EventFieldNameSubscriptionName,
	EventFieldNameTargetsCardinality,
	EventFieldNameTCPAcceleration,
	EventFieldNameTenantID,
	EventFieldNameTenantName,
	EventFieldNameTenantRestrictionRuleName,
	EventFieldNameThreatConfidence,
	EventFieldNameThreatName,
	EventFieldNameThreatReference,
	EventFieldNameThreatScore,
	EventFieldNameThreatType,
	EventFieldNameThreatVerdict,
	EventFieldNameTime,
	EventFieldNameTimeStr,
	EventFieldNameTitle,
	EventFieldNameTLSCertificateError,
	EventFieldNameTLSErrorDescription,
	EventFieldNameTLSErrorType,
	EventFieldNameTLSInspection,
	EventFieldNameTLSRuleName,
	EventFieldNameTLSVersion,
	EventFieldNameTrafficDirection,
	EventFieldNameTranslatedClientIP,
	EventFieldNameTranslatedServerIP,
	EventFieldNameTrigger,
	EventFieldNameTrustType,
	EventFieldNameTrustedNetworks,
	EventFieldNameTunnelIPProtocol,
	EventFieldNameTunnelProtocol,
	EventFieldNameUpgradeEndTime,
	EventFieldNameUpgradeInitiatedBy,
	EventFieldNameUpgradeStartTime,
	EventFieldNameURL,
	EventFieldNameUserAgent,
	EventFieldNameUserAwarenessMethod,
	EventFieldNameUserID,
	EventFieldNameUserName,
	EventFieldNameUserOrigin,
	EventFieldNameUserReferenceID,
	EventFieldNameUserRiskLevel,
	EventFieldNameVendor,
	EventFieldNameVendorCollaboratorID,
	EventFieldNameVendorDeviceID,
	EventFieldNameVendorDeviceName,
	EventFieldNameVendorEventID,
	EventFieldNameVendorPolicyDescription,
	EventFieldNameVendorPolicyID,
	EventFieldNameVendorPolicyName,
	EventFieldNameVendorUserID,
	EventFieldNameVisibleDeviceID,
	EventFieldNameVpnLanAccess,
	EventFieldNameVpnUserEmail,
	EventFieldNameWindowsDomainName,
	EventFieldNameXff,
}

func (e EventFieldName) IsValid() bool {
	switch e {
	case EventFieldNameAccessMethod, EventFieldNameAccountID, EventFieldNameAction, EventFieldNameActionsTaken, EventFieldNameActivityResourceID, EventFieldNameActorType, EventFieldNameAdName, EventFieldNameAlertID, EventFieldNameAlwaysOnConfiguration, EventFieldNameAnalystVerdict, EventFieldNameAPIName, EventFieldNameAPIType, EventFieldNameAppActivity, EventFieldNameAppActivityCategory, EventFieldNameAppActivityType, EventFieldNameAppStack, EventFieldNameApplicationID, EventFieldNameApplicationName, EventFieldNameApplicationRisk, EventFieldNameAuthMethod, EventFieldNameAuthenticationType, EventFieldNameBgpCatoAsn, EventFieldNameBgpCatoIP, EventFieldNameBgpErrorCode, EventFieldNameBgpPeerAsn, EventFieldNameBgpPeerIP, EventFieldNameBgpRouteCidr, EventFieldNameBgpSuberrorCode, EventFieldNameBypassDurationSec, EventFieldNameBypassMethod, EventFieldNameBypassReason, EventFieldNameCategories, EventFieldNameCatoApp, EventFieldNameClassification, EventFieldNameClientCertExpires, EventFieldNameClientCertName, EventFieldNameClientClass, EventFieldNameClientConnectionMode, EventFieldNameClientVersion, EventFieldNameCollaboratorName, EventFieldNameCollaborators, EventFieldNameConfidenceLevel, EventFieldNameConfiguredHostName, EventFieldNameCongestionAlgorithm, EventFieldNameConnectOnBoot, EventFieldNameConnectionOrigin, EventFieldNameConnectorName, EventFieldNameConnectorStatus, EventFieldNameConnectorType, EventFieldNameContainerName, EventFieldNameCorrelationID, EventFieldNameCriticality, EventFieldNameCustomCategoryID, EventFieldNameCustomCategoryName, EventFieldNameDestCountry, EventFieldNameDestCountryCode, EventFieldNameDestGroupID, EventFieldNameDestGroupName, EventFieldNameDestIP, EventFieldNameDestIsSiteOrVpn, EventFieldNameDestPid, EventFieldNameDestPort, EventFieldNameDestProcessCmdline, EventFieldNameDestProcessParentPath, EventFieldNameDestProcessParentPid, EventFieldNameDestProcessPath, EventFieldNameDestSiteID, EventFieldNameDestSiteName, EventFieldNameDetectionName, EventFieldNameDetectionStage, EventFieldNameDeviceCategories, EventFieldNameDeviceCertificate, EventFieldNameDeviceID, EventFieldNameDeviceManufacturer, EventFieldNameDeviceModel, EventFieldNameDeviceName, EventFieldNameDeviceOsType, EventFieldNameDevicePostureProfile, EventFieldNameDeviceType, EventFieldNameDirectoryHostName, EventFieldNameDirectoryIP, EventFieldNameDirectorySyncResult, EventFieldNameDirectorySyncType, EventFieldNameDisinfectResult, EventFieldNameDlpFailMode, EventFieldNameDlpProfiles, EventFieldNameDlpScanTypes, EventFieldNameDNSProtectionCategory, EventFieldNameDNSQuery, EventFieldNameDomainName, EventFieldNameEgressPopName, EventFieldNameEgressSiteName, EventFieldNameEmailSubject, EventFieldNameEndpointID, EventFieldNameEngineType, EventFieldNameEppEngineType, EventFieldNameEppProfile, EventFieldNameEventCount, EventFieldNameEventID, EventFieldNameEventMessage, EventFieldNameEventSubType, EventFieldNameEventType, EventFieldNameFailureReason, EventFieldNameFileHash, EventFieldNameFileName, EventFieldNameFileOperation, EventFieldNameFileSize, EventFieldNameFileType, EventFieldNameFinalObjectStatus, EventFieldNameFlowsCardinality, EventFieldNameFullPathURL, EventFieldNameGuestUser, EventFieldNameHostIP, EventFieldNameHostMac, EventFieldNameHTTPRequestMethod, EventFieldNameIncidentAggregation, EventFieldNameIncidentID, EventFieldNameIndication, EventFieldNameIndicator, EventFieldNameInitialObjectStatus, EventFieldNameInternalID, EventFieldNameIPProtocol, EventFieldNameIsAdmin, EventFieldNameIsAdminActivity, EventFieldNameIsCompliant, EventFieldNameIsManaged, EventFieldNameIsSanctionedApp, EventFieldNameIsSinkhole, EventFieldNameIspName, EventFieldNameKeyName, EventFieldNameLabels, EventFieldNameLinkHealthIsCongested, EventFieldNameLinkHealthJitter, EventFieldNameLinkHealthLatency, EventFieldNameLinkHealthPktLoss, EventFieldNameLinkType, EventFieldNameLoggedInUser, EventFieldNameLoginType, EventFieldNameMatchedDataTypes, EventFieldNameMitreAttackSubtechniques, EventFieldNameMitreAttackTactics, EventFieldNameMitreAttackTechniques, EventFieldNameNetworkAccess, EventFieldNameNetworkRule, EventFieldNameNotificationAPIError, EventFieldNameNotificationDescription, EventFieldNameObjectID, EventFieldNameObjectName, EventFieldNameObjectType, EventFieldNameOfficeMode, EventFieldNameOsType, EventFieldNameOsVersion, EventFieldNameOutOfBandAccess, EventFieldNameOwner, EventFieldNamePacFile, EventFieldNameParentConnectorName, EventFieldNamePopName, EventFieldNamePrecedence, EventFieldNameProcessesCount, EventFieldNameProducer, EventFieldNameProjects, EventFieldNamePromptAction, EventFieldNameProviderName, EventFieldNamePublicIP, EventFieldNameQosPriority, EventFieldNameQosReportedTime, EventFieldNameQuarantineFolderPath, EventFieldNameQuarantineUUID, EventFieldNameRawData, EventFieldNameRecommendedActions, EventFieldNameReferenceURL, EventFieldNameRefererURL, EventFieldNameRegionName, EventFieldNameRegistrationCode, EventFieldNameResourceID, EventFieldNameResourceName, EventFieldNameResourceType, EventFieldNameRiskLevel, EventFieldNameRuleID, EventFieldNameRuleName, EventFieldNameServiceName, EventFieldNameSeverity, EventFieldNameSharingScope, EventFieldNameSignInEventTypes, EventFieldNameSignatureID, EventFieldNameSocketInterface, EventFieldNameSocketInterfaceID, EventFieldNameSocketNewVersion, EventFieldNameSocketOldVersion, EventFieldNameSocketReset, EventFieldNameSocketRole, EventFieldNameSocketSerial, EventFieldNameSocketVersion, EventFieldNameSplitTunnelConfiguration, EventFieldNameSrcCountry, EventFieldNameSrcCountryCode, EventFieldNameSrcIP, EventFieldNameSrcIsSiteOrVpn, EventFieldNameSrcIspIP, EventFieldNameSrcPid, EventFieldNameSrcPort, EventFieldNameSrcProcessCmdline, EventFieldNameSrcProcessParentPath, EventFieldNameSrcProcessParentPid, EventFieldNameSrcProcessPath, EventFieldNameSrcSiteID, EventFieldNameSrcSiteName, EventFieldNameStaticHost, EventFieldNameStatus, EventFieldNameStoryID, EventFieldNameSubnetName, EventFieldNameSubscriptionName, EventFieldNameTargetsCardinality, EventFieldNameTCPAcceleration, EventFieldNameTenantID, EventFieldNameTenantName, EventFieldNameTenantRestrictionRuleName, EventFieldNameThreatConfidence, EventFieldNameThreatName, EventFieldNameThreatReference, EventFieldNameThreatScore, EventFieldNameThreatType, EventFieldNameThreatVerdict, EventFieldNameTime, EventFieldNameTimeStr, EventFieldNameTitle, EventFieldNameTLSCertificateError, EventFieldNameTLSErrorDescription, EventFieldNameTLSErrorType, EventFieldNameTLSInspection, EventFieldNameTLSRuleName, EventFieldNameTLSVersion, EventFieldNameTrafficDirection, EventFieldNameTranslatedClientIP, EventFieldNameTranslatedServerIP, EventFieldNameTrigger, EventFieldNameTrustType, EventFieldNameTrustedNetworks, EventFieldNameTunnelIPProtocol, EventFieldNameTunnelProtocol, EventFieldNameUpgradeEndTime, EventFieldNameUpgradeInitiatedBy, EventFieldNameUpgradeStartTime, EventFieldNameURL, EventFieldNameUserAgent, EventFieldNameUserAwarenessMethod, EventFieldNameUserID, EventFieldNameUserName, EventFieldNameUserOrigin, EventFieldNameUserReferenceID, EventFieldNameUserRiskLevel, EventFieldNameVendor, EventFieldNameVendorCollaboratorID, EventFieldNameVendorDeviceID, EventFieldNameVendorDeviceName, EventFieldNameVendorEventID, EventFieldNameVendorPolicyDescription, EventFieldNameVendorPolicyID, EventFieldNameVendorPolicyName, EventFieldNameVendorUserID, EventFieldNameVisibleDeviceID, EventFieldNameVpnLanAccess, EventFieldNameVpnUserEmail, EventFieldNameWindowsDomainName, EventFieldNameXff:
		return true
	}
	return false
}

func (e EventFieldName) String() string {
	return string(e)
}

func (e *EventFieldName) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EventFieldName(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EventFieldName", str)
	}
	return nil
}

func (e EventFieldName) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *EventFieldName) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e EventFieldName) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Status values for export job lifecycle
type ExportJobStatus string

const (
	// Export job finished successfully and file is ready for download
	ExportJobStatusCompleted ExportJobStatus = "COMPLETED"
	// Export job encountered an error and could not complete
	ExportJobStatusFailed ExportJobStatus = "FAILED"
	// Export job is currently being processed
	ExportJobStatusInProgress ExportJobStatus = "IN_PROGRESS"
	// Export job has been queued but not yet started
	ExportJobStatusPending ExportJobStatus = "PENDING"
)

var AllExportJobStatus = []ExportJobStatus{
	ExportJobStatusCompleted,
	ExportJobStatusFailed,
	ExportJobStatusInProgress,
	ExportJobStatusPending,
}

func (e ExportJobStatus) IsValid() bool {
	switch e {
	case ExportJobStatusCompleted, ExportJobStatusFailed, ExportJobStatusInProgress, ExportJobStatusPending:
		return true
	}
	return false
}

func (e ExportJobStatus) String() string {
	return string(e)
}

func (e *ExportJobStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ExportJobStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ExportJobStatus", str)
	}
	return nil
}

func (e ExportJobStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ExportJobStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ExportJobStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type FilterOperator string

const (
	FilterOperatorBetween    FilterOperator = "between"
	FilterOperatorExists     FilterOperator = "exists"
	FilterOperatorGt         FilterOperator = "gt"
	FilterOperatorGte        FilterOperator = "gte"
	FilterOperatorIn         FilterOperator = "in"
	FilterOperatorIs         FilterOperator = "is"
	FilterOperatorIsNot      FilterOperator = "is_not"
	FilterOperatorLt         FilterOperator = "lt"
	FilterOperatorLte        FilterOperator = "lte"
	FilterOperatorNotBetween FilterOperator = "not_between"
	FilterOperatorNotExists  FilterOperator = "not_exists"
	FilterOperatorNotIn      FilterOperator = "not_in"
)

var AllFilterOperator = []FilterOperator{
	FilterOperatorBetween,
	FilterOperatorExists,
	FilterOperatorGt,
	FilterOperatorGte,
	FilterOperatorIn,
	FilterOperatorIs,
	FilterOperatorIsNot,
	FilterOperatorLt,
	FilterOperatorLte,
	FilterOperatorNotBetween,
	FilterOperatorNotExists,
	FilterOperatorNotIn,
}

func (e FilterOperator) IsValid() bool {
	switch e {
	case FilterOperatorBetween, FilterOperatorExists, FilterOperatorGt, FilterOperatorGte, FilterOperatorIn, FilterOperatorIs, FilterOperatorIsNot, FilterOperatorLt, FilterOperatorLte, FilterOperatorNotBetween, FilterOperatorNotExists, FilterOperatorNotIn:
		return true
	}
	return false
}

func (e FilterOperator) String() string {
	return string(e)
}

func (e *FilterOperator) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FilterOperator(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FilterOperator", str)
	}
	return nil
}

func (e FilterOperator) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *FilterOperator) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e FilterOperator) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type GraphType string

const (
	GraphTypeAnalytics GraphType = "ANALYTICS"
)

var AllGraphType = []GraphType{
	GraphTypeAnalytics,
}

func (e GraphType) IsValid() bool {
	switch e {
	case GraphTypeAnalytics:
		return true
	}
	return false
}

func (e GraphType) String() string {
	return string(e)
}

func (e *GraphType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GraphType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GraphType", str)
	}
	return nil
}

func (e GraphType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *GraphType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e GraphType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Member types that can be referenced in a group.
type GroupMemberRefType string

const (
	GroupMemberRefTypeFloatingSubnet    GroupMemberRefType = "FLOATING_SUBNET"
	GroupMemberRefTypeGlobalIPRange     GroupMemberRefType = "GLOBAL_IP_RANGE"
	GroupMemberRefTypeHost              GroupMemberRefType = "HOST"
	GroupMemberRefTypeNetworkInterface  GroupMemberRefType = "NETWORK_INTERFACE"
	GroupMemberRefTypeSite              GroupMemberRefType = "SITE"
	GroupMemberRefTypeSiteNetworkSubnet GroupMemberRefType = "SITE_NETWORK_SUBNET"
)

var AllGroupMemberRefType = []GroupMemberRefType{
	GroupMemberRefTypeFloatingSubnet,
	GroupMemberRefTypeGlobalIPRange,
	GroupMemberRefTypeHost,
	GroupMemberRefTypeNetworkInterface,
	GroupMemberRefTypeSite,
	GroupMemberRefTypeSiteNetworkSubnet,
}

func (e GroupMemberRefType) IsValid() bool {
	switch e {
	case GroupMemberRefTypeFloatingSubnet, GroupMemberRefTypeGlobalIPRange, GroupMemberRefTypeHost, GroupMemberRefTypeNetworkInterface, GroupMemberRefTypeSite, GroupMemberRefTypeSiteNetworkSubnet:
		return true
	}
	return false
}

func (e GroupMemberRefType) String() string {
	return string(e)
}

func (e *GroupMemberRefType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GroupMemberRefType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GroupMemberRefType", str)
	}
	return nil
}

func (e GroupMemberRefType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *GroupMemberRefType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e GroupMemberRefType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type HaReadiness string

const (
	HaReadinessNotReady HaReadiness = "not_ready"
	HaReadinessReady    HaReadiness = "ready"
)

var AllHaReadiness = []HaReadiness{
	HaReadinessNotReady,
	HaReadinessReady,
}

func (e HaReadiness) IsValid() bool {
	switch e {
	case HaReadinessNotReady, HaReadinessReady:
		return true
	}
	return false
}

func (e HaReadiness) String() string {
	return string(e)
}

func (e *HaReadiness) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HaReadiness(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HaReadiness", str)
	}
	return nil
}

func (e HaReadiness) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *HaReadiness) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e HaReadiness) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type HaRole string

const (
	HaRolePrimary   HaRole = "PRIMARY"
	HaRoleSecondary HaRole = "SECONDARY"
)

var AllHaRole = []HaRole{
	HaRolePrimary,
	HaRoleSecondary,
}

func (e HaRole) IsValid() bool {
	switch e {
	case HaRolePrimary, HaRoleSecondary:
		return true
	}
	return false
}

func (e HaRole) String() string {
	return string(e)
}

func (e *HaRole) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HaRole(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HaRole", str)
	}
	return nil
}

func (e HaRole) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *HaRole) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e HaRole) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type HaSubStatus string

const (
	HaSubStatusFail HaSubStatus = "fail"
	HaSubStatusOk   HaSubStatus = "ok"
)

var AllHaSubStatus = []HaSubStatus{
	HaSubStatusFail,
	HaSubStatusOk,
}

func (e HaSubStatus) IsValid() bool {
	switch e {
	case HaSubStatusFail, HaSubStatusOk:
		return true
	}
	return false
}

func (e HaSubStatus) String() string {
	return string(e)
}

func (e *HaSubStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HaSubStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HaSubStatus", str)
	}
	return nil
}

func (e HaSubStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *HaSubStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e HaSubStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type IPSecV2InterfaceID string

const (
	IPSecV2InterfaceIDPrimary1   IPSecV2InterfaceID = "PRIMARY1"
	IPSecV2InterfaceIDPrimary2   IPSecV2InterfaceID = "PRIMARY2"
	IPSecV2InterfaceIDPrimary3   IPSecV2InterfaceID = "PRIMARY3"
	IPSecV2InterfaceIDSecondary1 IPSecV2InterfaceID = "SECONDARY1"
	IPSecV2InterfaceIDSecondary2 IPSecV2InterfaceID = "SECONDARY2"
	IPSecV2InterfaceIDSecondary3 IPSecV2InterfaceID = "SECONDARY3"
)

var AllIPSecV2InterfaceID = []IPSecV2InterfaceID{
	IPSecV2InterfaceIDPrimary1,
	IPSecV2InterfaceIDPrimary2,
	IPSecV2InterfaceIDPrimary3,
	IPSecV2InterfaceIDSecondary1,
	IPSecV2InterfaceIDSecondary2,
	IPSecV2InterfaceIDSecondary3,
}

func (e IPSecV2InterfaceID) IsValid() bool {
	switch e {
	case IPSecV2InterfaceIDPrimary1, IPSecV2InterfaceIDPrimary2, IPSecV2InterfaceIDPrimary3, IPSecV2InterfaceIDSecondary1, IPSecV2InterfaceIDSecondary2, IPSecV2InterfaceIDSecondary3:
		return true
	}
	return false
}

func (e IPSecV2InterfaceID) String() string {
	return string(e)
}

func (e *IPSecV2InterfaceID) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = IPSecV2InterfaceID(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid IPSecV2InterfaceId", str)
	}
	return nil
}

func (e IPSecV2InterfaceID) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *IPSecV2InterfaceID) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e IPSecV2InterfaceID) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type IPSecV2TunnelRole string

const (
	IPSecV2TunnelRoleWan1 IPSecV2TunnelRole = "WAN1"
	IPSecV2TunnelRoleWan2 IPSecV2TunnelRole = "WAN2"
	IPSecV2TunnelRoleWan3 IPSecV2TunnelRole = "WAN3"
)

var AllIPSecV2TunnelRole = []IPSecV2TunnelRole{
	IPSecV2TunnelRoleWan1,
	IPSecV2TunnelRoleWan2,
	IPSecV2TunnelRoleWan3,
}

func (e IPSecV2TunnelRole) IsValid() bool {
	switch e {
	case IPSecV2TunnelRoleWan1, IPSecV2TunnelRoleWan2, IPSecV2TunnelRoleWan3:
		return true
	}
	return false
}

func (e IPSecV2TunnelRole) String() string {
	return string(e)
}

func (e *IPSecV2TunnelRole) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = IPSecV2TunnelRole(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid IPSecV2TunnelRole", str)
	}
	return nil
}

func (e IPSecV2TunnelRole) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *IPSecV2TunnelRole) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e IPSecV2TunnelRole) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type IdentificationType string

const (
	IdentificationTypeEmail IdentificationType = "EMAIL"
	IdentificationTypeFqdn  IdentificationType = "FQDN"
	IdentificationTypeIPV4  IdentificationType = "IPV4"
	IdentificationTypeKeyID IdentificationType = "KEY_ID"
)

var AllIdentificationType = []IdentificationType{
	IdentificationTypeEmail,
	IdentificationTypeFqdn,
	IdentificationTypeIPV4,
	IdentificationTypeKeyID,
}

func (e IdentificationType) IsValid() bool {
	switch e {
	case IdentificationTypeEmail, IdentificationTypeFqdn, IdentificationTypeIPV4, IdentificationTypeKeyID:
		return true
	}
	return false
}

func (e IdentificationType) String() string {
	return string(e)
}

func (e *IdentificationType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = IdentificationType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid IdentificationType", str)
	}
	return nil
}

func (e IdentificationType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *IdentificationType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e IdentificationType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type IlmmOnboardingStatus string

const (
	IlmmOnboardingStatusComplete IlmmOnboardingStatus = "COMPLETE"
	IlmmOnboardingStatusFailed   IlmmOnboardingStatus = "FAILED"
	IlmmOnboardingStatusMissing  IlmmOnboardingStatus = "MISSING"
	IlmmOnboardingStatusPending  IlmmOnboardingStatus = "PENDING"
)

var AllIlmmOnboardingStatus = []IlmmOnboardingStatus{
	IlmmOnboardingStatusComplete,
	IlmmOnboardingStatusFailed,
	IlmmOnboardingStatusMissing,
	IlmmOnboardingStatusPending,
}

func (e IlmmOnboardingStatus) IsValid() bool {
	switch e {
	case IlmmOnboardingStatusComplete, IlmmOnboardingStatusFailed, IlmmOnboardingStatusMissing, IlmmOnboardingStatusPending:
		return true
	}
	return false
}

func (e IlmmOnboardingStatus) String() string {
	return string(e)
}

func (e *IlmmOnboardingStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = IlmmOnboardingStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid IlmmOnboardingStatus", str)
	}
	return nil
}

func (e IlmmOnboardingStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *IlmmOnboardingStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e IlmmOnboardingStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// The action applied by the Internet Firewall if the rule is matched
type InternetFirewallActionEnum string

const (
	// Allow the network traffic to pass through the firewall.
	InternetFirewallActionEnumAllow InternetFirewallActionEnum = "ALLOW"
	// Deny the network traffic from passing through the firewall.
	InternetFirewallActionEnumBlock InternetFirewallActionEnum = "BLOCK"
	// Requests user confirmation to allow or block network traffic.
	InternetFirewallActionEnumPrompt InternetFirewallActionEnum = "PROMPT"
	// Apply Remote Browser Isolation (RBI) to the network traffic
	InternetFirewallActionEnumRbi InternetFirewallActionEnum = "RBI"
)

var AllInternetFirewallActionEnum = []InternetFirewallActionEnum{
	InternetFirewallActionEnumAllow,
	InternetFirewallActionEnumBlock,
	InternetFirewallActionEnumPrompt,
	InternetFirewallActionEnumRbi,
}

func (e InternetFirewallActionEnum) IsValid() bool {
	switch e {
	case InternetFirewallActionEnumAllow, InternetFirewallActionEnumBlock, InternetFirewallActionEnumPrompt, InternetFirewallActionEnumRbi:
		return true
	}
	return false
}

func (e InternetFirewallActionEnum) String() string {
	return string(e)
}

func (e *InternetFirewallActionEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = InternetFirewallActionEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid InternetFirewallActionEnum", str)
	}
	return nil
}

func (e InternetFirewallActionEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *InternetFirewallActionEnum) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e InternetFirewallActionEnum) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type IPProtocol string

const (
	IPProtocolAny  IPProtocol = "ANY"
	IPProtocolICMP IPProtocol = "ICMP"
	IPProtocolTCP  IPProtocol = "TCP"
	// TCP or UDP
	IPProtocolTCPUDP IPProtocol = "TCP_UDP"
	IPProtocolUDP    IPProtocol = "UDP"
)

var AllIPProtocol = []IPProtocol{
	IPProtocolAny,
	IPProtocolICMP,
	IPProtocolTCP,
	IPProtocolTCPUDP,
	IPProtocolUDP,
}

func (e IPProtocol) IsValid() bool {
	switch e {
	case IPProtocolAny, IPProtocolICMP, IPProtocolTCP, IPProtocolTCPUDP, IPProtocolUDP:
		return true
	}
	return false
}

func (e IPProtocol) String() string {
	return string(e)
}

func (e *IPProtocol) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = IPProtocol(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid IpProtocol", str)
	}
	return nil
}

func (e IPProtocol) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *IPProtocol) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e IPProtocol) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type IPSecCipher string

const (
	IPSecCipherAesCbc128 IPSecCipher = "AES_CBC_128"
	IPSecCipherAesCbc256 IPSecCipher = "AES_CBC_256"
	IPSecCipherAesGcm128 IPSecCipher = "AES_GCM_128"
	IPSecCipherAesGcm256 IPSecCipher = "AES_GCM_256"
	IPSecCipherAutomatic IPSecCipher = "AUTOMATIC"
	IPSecCipherDes3Cbc   IPSecCipher = "DES3_CBC"
	IPSecCipherNone      IPSecCipher = "NONE"
)

var AllIPSecCipher = []IPSecCipher{
	IPSecCipherAesCbc128,
	IPSecCipherAesCbc256,
	IPSecCipherAesGcm128,
	IPSecCipherAesGcm256,
	IPSecCipherAutomatic,
	IPSecCipherDes3Cbc,
	IPSecCipherNone,
}

func (e IPSecCipher) IsValid() bool {
	switch e {
	case IPSecCipherAesCbc128, IPSecCipherAesCbc256, IPSecCipherAesGcm128, IPSecCipherAesGcm256, IPSecCipherAutomatic, IPSecCipherDes3Cbc, IPSecCipherNone:
		return true
	}
	return false
}

func (e IPSecCipher) String() string {
	return string(e)
}

func (e *IPSecCipher) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = IPSecCipher(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid IpSecCipher", str)
	}
	return nil
}

func (e IPSecCipher) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *IPSecCipher) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e IPSecCipher) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type IPSecDHGroup string

const (
	IPSecDHGroupAutomatic    IPSecDHGroup = "AUTOMATIC"
	IPSecDHGroupDh14Modp2048 IPSecDHGroup = "DH_14_MODP2048"
	IPSecDHGroupDh15Modp3072 IPSecDHGroup = "DH_15_MODP3072"
	IPSecDHGroupDh16Modp4096 IPSecDHGroup = "DH_16_MODP4096"
	IPSecDHGroupDh19Ecp256   IPSecDHGroup = "DH_19_ECP256"
	IPSecDHGroupDh2Modp1024  IPSecDHGroup = "DH_2_MODP1024"
	IPSecDHGroupDh20Ecp384   IPSecDHGroup = "DH_20_ECP384"
	IPSecDHGroupDh21Ecp521   IPSecDHGroup = "DH_21_ECP521"
	IPSecDHGroupDh5Modp1536  IPSecDHGroup = "DH_5_MODP1536"
	IPSecDHGroupNone         IPSecDHGroup = "NONE"
)

var AllIPSecDHGroup = []IPSecDHGroup{
	IPSecDHGroupAutomatic,
	IPSecDHGroupDh14Modp2048,
	IPSecDHGroupDh15Modp3072,
	IPSecDHGroupDh16Modp4096,
	IPSecDHGroupDh19Ecp256,
	IPSecDHGroupDh2Modp1024,
	IPSecDHGroupDh20Ecp384,
	IPSecDHGroupDh21Ecp521,
	IPSecDHGroupDh5Modp1536,
	IPSecDHGroupNone,
}

func (e IPSecDHGroup) IsValid() bool {
	switch e {
	case IPSecDHGroupAutomatic, IPSecDHGroupDh14Modp2048, IPSecDHGroupDh15Modp3072, IPSecDHGroupDh16Modp4096, IPSecDHGroupDh19Ecp256, IPSecDHGroupDh2Modp1024, IPSecDHGroupDh20Ecp384, IPSecDHGroupDh21Ecp521, IPSecDHGroupDh5Modp1536, IPSecDHGroupNone:
		return true
	}
	return false
}

func (e IPSecDHGroup) String() string {
	return string(e)
}

func (e *IPSecDHGroup) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = IPSecDHGroup(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid IpSecDHGroup", str)
	}
	return nil
}

func (e IPSecDHGroup) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *IPSecDHGroup) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e IPSecDHGroup) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type IPSecHash string

const (
	IPSecHashAutomatic IPSecHash = "AUTOMATIC"
	IPSecHashMd5       IPSecHash = "MD5"
	IPSecHashNone      IPSecHash = "NONE"
	IPSecHashSha1      IPSecHash = "SHA1"
	IPSecHashSha256    IPSecHash = "SHA256"
	IPSecHashSha384    IPSecHash = "SHA384"
	IPSecHashSha512    IPSecHash = "SHA512"
)

var AllIPSecHash = []IPSecHash{
	IPSecHashAutomatic,
	IPSecHashMd5,
	IPSecHashNone,
	IPSecHashSha1,
	IPSecHashSha256,
	IPSecHashSha384,
	IPSecHashSha512,
}

func (e IPSecHash) IsValid() bool {
	switch e {
	case IPSecHashAutomatic, IPSecHashMd5, IPSecHashNone, IPSecHashSha1, IPSecHashSha256, IPSecHashSha384, IPSecHashSha512:
		return true
	}
	return false
}

func (e IPSecHash) String() string {
	return string(e)
}

func (e *IPSecHash) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = IPSecHash(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid IpSecHash", str)
	}
	return nil
}

func (e IPSecHash) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *IPSecHash) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e IPSecHash) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// enum for license plan type (site license, service license, etc...)
type LicensePlan string

const (
	LicensePlanCommercial LicensePlan = "COMMERCIAL"
	LicensePlanTrial      LicensePlan = "TRIAL"
)

var AllLicensePlan = []LicensePlan{
	LicensePlanCommercial,
	LicensePlanTrial,
}

func (e LicensePlan) IsValid() bool {
	switch e {
	case LicensePlanCommercial, LicensePlanTrial:
		return true
	}
	return false
}

func (e LicensePlan) String() string {
	return string(e)
}

func (e *LicensePlan) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LicensePlan(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid LicensePlan", str)
	}
	return nil
}

func (e LicensePlan) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *LicensePlan) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e LicensePlan) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type LicenseSku string

const (
	// Cato Anti Malware (legacy) service SKU
	LicenseSkuCatoAntiMalware LicenseSku = "CATO_ANTI_MALWARE"
	// Cato Anti Malware Next Generation (legacy) service SKU
	LicenseSkuCatoAntiMalwareNg LicenseSku = "CATO_ANTI_MALWARE_NG"
	// Cato CASB service SKU
	LicenseSkuCatoCasb LicenseSku = "CATO_CASB"
	// Cato datalake Group SKU
	LicenseSkuCatoDatalake LicenseSku = "CATO_DATALAKE"
	// 12 months data retention SKU
	LicenseSkuCatoDatalake12m LicenseSku = "CATO_DATALAKE_12M"
	// 3 months data retention SKU
	LicenseSkuCatoDatalake3m LicenseSku = "CATO_DATALAKE_3M"
	// 6 months data retention SKU
	LicenseSkuCatoDatalake6m LicenseSku = "CATO_DATALAKE_6M"
	// Cato DEM service SKU
	LicenseSkuCatoDem LicenseSku = "CATO_DEM"
	// Cato DLP service SKU
	LicenseSkuCatoDlp LicenseSku = "CATO_DLP"
	// Cato EPP service SKU
	LicenseSkuCatoEpp LicenseSku = "CATO_EPP"
	// Cato ILMM service SKU
	LicenseSkuCatoIlmm LicenseSku = "CATO_ILMM"
	// Cato IoT/OT Security service SKU
	LicenseSkuCatoIotOt LicenseSku = "CATO_IOT_OT"
	// Public IPs SKU
	LicenseSkuCatoIPAdd LicenseSku = "CATO_IP_ADD"
	// Cato IPS (legacy) service SKU
	LicenseSkuCatoIPS LicenseSku = "CATO_IPS"
	// Cato Managed XDR service SKU
	LicenseSkuCatoManagedXdr LicenseSku = "CATO_MANAGED_XDR"
	// Cato MDR service SKU
	LicenseSkuCatoMdr LicenseSku = "CATO_MDR"
	// Cato NOCaaS service SKU
	LicenseSkuCatoNocaasHf LicenseSku = "CATO_NOCAAS_HF"
	// Site pooled bandwidth SASE SKU
	LicenseSkuCatoPb LicenseSku = "CATO_PB"
	// Site pooled bandwidth SSE SKU
	LicenseSkuCatoPbSse LicenseSku = "CATO_PB_SSE"
	// Cato Remote Browser Isolation (RBI) service SKU
	LicenseSkuCatoRbi LicenseSku = "CATO_RBI"
	// Cato SAAS Group SKU
	LicenseSkuCatoSaas            LicenseSku = "CATO_SAAS"
	LicenseSkuCatoSaasSecurityAPI LicenseSku = "CATO_SAAS_SECURITY_API"
	// Cato SAAS Security API with more than two Applications integration (legacy) service SKU
	LicenseSkuCatoSaasSecurityAPIAllApps LicenseSku = "CATO_SAAS_SECURITY_API_ALL_APPS"
	// Cato SAAS Security API with one application integration (legacy) service SKU
	LicenseSkuCatoSaasSecurityAPIOneApp LicenseSku = "CATO_SAAS_SECURITY_API_ONE_APP"
	// Cato SAAS Security API with two applications integration (legacy) service SKU
	LicenseSkuCatoSaasSecurityAPITwoApps LicenseSku = "CATO_SAAS_SECURITY_API_TWO_APPS"
	// Site bandwidth SASE SKU
	LicenseSkuCatoSite LicenseSku = "CATO_SITE"
	// Site bandwidth SSE SKU
	LicenseSkuCatoSseSite LicenseSku = "CATO_SSE_SITE"
	// Cato Threat Prevention (legacy) service SKU
	LicenseSkuCatoThreatPrevention LicenseSku = "CATO_THREAT_PREVENTION"
	// Cato Advanced Threat Prevention service SKU
	LicenseSkuCatoThreatPreventionAdv LicenseSku = "CATO_THREAT_PREVENTION_ADV"
	// Cato XDR service SKU
	LicenseSkuCatoXdrPro LicenseSku = "CATO_XDR_PRO"
	// Cato XOps service SKU
	LicenseSkuCatoXops LicenseSku = "CATO_XOPS"
	// ZTNA remote users SKU
	LicenseSkuCatoZtnaUsers LicenseSku = "CATO_ZTNA_USERS"
	// ZTNA remote users SKU
	LicenseSkuMobileUsers LicenseSku = "MOBILE_USERS"
)

var AllLicenseSku = []LicenseSku{
	LicenseSkuCatoAntiMalware,
	LicenseSkuCatoAntiMalwareNg,
	LicenseSkuCatoCasb,
	LicenseSkuCatoDatalake,
	LicenseSkuCatoDatalake12m,
	LicenseSkuCatoDatalake3m,
	LicenseSkuCatoDatalake6m,
	LicenseSkuCatoDem,
	LicenseSkuCatoDlp,
	LicenseSkuCatoEpp,
	LicenseSkuCatoIlmm,
	LicenseSkuCatoIotOt,
	LicenseSkuCatoIPAdd,
	LicenseSkuCatoIPS,
	LicenseSkuCatoManagedXdr,
	LicenseSkuCatoMdr,
	LicenseSkuCatoNocaasHf,
	LicenseSkuCatoPb,
	LicenseSkuCatoPbSse,
	LicenseSkuCatoRbi,
	LicenseSkuCatoSaas,
	LicenseSkuCatoSaasSecurityAPI,
	LicenseSkuCatoSaasSecurityAPIAllApps,
	LicenseSkuCatoSaasSecurityAPIOneApp,
	LicenseSkuCatoSaasSecurityAPITwoApps,
	LicenseSkuCatoSite,
	LicenseSkuCatoSseSite,
	LicenseSkuCatoThreatPrevention,
	LicenseSkuCatoThreatPreventionAdv,
	LicenseSkuCatoXdrPro,
	LicenseSkuCatoXops,
	LicenseSkuCatoZtnaUsers,
	LicenseSkuMobileUsers,
}

func (e LicenseSku) IsValid() bool {
	switch e {
	case LicenseSkuCatoAntiMalware, LicenseSkuCatoAntiMalwareNg, LicenseSkuCatoCasb, LicenseSkuCatoDatalake, LicenseSkuCatoDatalake12m, LicenseSkuCatoDatalake3m, LicenseSkuCatoDatalake6m, LicenseSkuCatoDem, LicenseSkuCatoDlp, LicenseSkuCatoEpp, LicenseSkuCatoIlmm, LicenseSkuCatoIotOt, LicenseSkuCatoIPAdd, LicenseSkuCatoIPS, LicenseSkuCatoManagedXdr, LicenseSkuCatoMdr, LicenseSkuCatoNocaasHf, LicenseSkuCatoPb, LicenseSkuCatoPbSse, LicenseSkuCatoRbi, LicenseSkuCatoSaas, LicenseSkuCatoSaasSecurityAPI, LicenseSkuCatoSaasSecurityAPIAllApps, LicenseSkuCatoSaasSecurityAPIOneApp, LicenseSkuCatoSaasSecurityAPITwoApps, LicenseSkuCatoSite, LicenseSkuCatoSseSite, LicenseSkuCatoThreatPrevention, LicenseSkuCatoThreatPreventionAdv, LicenseSkuCatoXdrPro, LicenseSkuCatoXops, LicenseSkuCatoZtnaUsers, LicenseSkuMobileUsers:
		return true
	}
	return false
}

func (e LicenseSku) String() string {
	return string(e)
}

func (e *LicenseSku) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LicenseSku(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid LicenseSku", str)
	}
	return nil
}

func (e LicenseSku) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *LicenseSku) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e LicenseSku) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// enum for account plan status – the current license status within the license lifecycle
type LicenseStatus string

const (
	// A license that is currently active
	LicenseStatusActive LicenseStatus = "ACTIVE"
	// An expired license is no longer active
	LicenseStatusDisabled LicenseStatus = "DISABLED"
	// A license in a grace period
	LicenseStatusLocked LicenseStatus = "LOCKED"
	// The license is pending customer activation by setting a start date
	LicenseStatusPending LicenseStatus = "PENDING"
	// An existing license with a future start date that is not currently active
	LicenseStatusScheduled LicenseStatus = "SCHEDULED"
	// A license that is active before its start date, for partners and customers to verify the relevant configurations
	LicenseStatusStaging LicenseStatus = "STAGING"
)

var AllLicenseStatus = []LicenseStatus{
	LicenseStatusActive,
	LicenseStatusDisabled,
	LicenseStatusLocked,
	LicenseStatusPending,
	LicenseStatusScheduled,
	LicenseStatusStaging,
}

func (e LicenseStatus) IsValid() bool {
	switch e {
	case LicenseStatusActive, LicenseStatusDisabled, LicenseStatusLocked, LicenseStatusPending, LicenseStatusScheduled, LicenseStatusStaging:
		return true
	}
	return false
}

func (e LicenseStatus) String() string {
	return string(e)
}

func (e *LicenseStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LicenseStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid LicenseStatus", str)
	}
	return nil
}

func (e LicenseStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *LicenseStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e LicenseStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type LinkConfigPrecedenceEnum string

const (
	LinkConfigPrecedenceEnumActive     LinkConfigPrecedenceEnum = "ACTIVE"
	LinkConfigPrecedenceEnumLastResort LinkConfigPrecedenceEnum = "LAST_RESORT"
	LinkConfigPrecedenceEnumPassive    LinkConfigPrecedenceEnum = "PASSIVE"
)

var AllLinkConfigPrecedenceEnum = []LinkConfigPrecedenceEnum{
	LinkConfigPrecedenceEnumActive,
	LinkConfigPrecedenceEnumLastResort,
	LinkConfigPrecedenceEnumPassive,
}

func (e LinkConfigPrecedenceEnum) IsValid() bool {
	switch e {
	case LinkConfigPrecedenceEnumActive, LinkConfigPrecedenceEnumLastResort, LinkConfigPrecedenceEnumPassive:
		return true
	}
	return false
}

func (e LinkConfigPrecedenceEnum) String() string {
	return string(e)
}

func (e *LinkConfigPrecedenceEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LinkConfigPrecedenceEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid LinkConfigPrecedenceEnum", str)
	}
	return nil
}

func (e LinkConfigPrecedenceEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *LinkConfigPrecedenceEnum) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e LinkConfigPrecedenceEnum) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type LinkQualityIssueTypeEnum string

const (
	LinkQualityIssueTypeEnumCongestion LinkQualityIssueTypeEnum = "CONGESTION"
	LinkQualityIssueTypeEnumDistance   LinkQualityIssueTypeEnum = "DISTANCE"
	LinkQualityIssueTypeEnumJitter     LinkQualityIssueTypeEnum = "JITTER"
	LinkQualityIssueTypeEnumPacketLoss LinkQualityIssueTypeEnum = "PACKET_LOSS"
)

var AllLinkQualityIssueTypeEnum = []LinkQualityIssueTypeEnum{
	LinkQualityIssueTypeEnumCongestion,
	LinkQualityIssueTypeEnumDistance,
	LinkQualityIssueTypeEnumJitter,
	LinkQualityIssueTypeEnumPacketLoss,
}

func (e LinkQualityIssueTypeEnum) IsValid() bool {
	switch e {
	case LinkQualityIssueTypeEnumCongestion, LinkQualityIssueTypeEnumDistance, LinkQualityIssueTypeEnumJitter, LinkQualityIssueTypeEnumPacketLoss:
		return true
	}
	return false
}

func (e LinkQualityIssueTypeEnum) String() string {
	return string(e)
}

func (e *LinkQualityIssueTypeEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LinkQualityIssueTypeEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid LinkQualityIssueTypeEnum", str)
	}
	return nil
}

func (e LinkQualityIssueTypeEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *LinkQualityIssueTypeEnum) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e LinkQualityIssueTypeEnum) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type LinkStatusEnum string

const (
	LinkStatusEnumActive  LinkStatusEnum = "ACTIVE"
	LinkStatusEnumPassive LinkStatusEnum = "PASSIVE"
)

var AllLinkStatusEnum = []LinkStatusEnum{
	LinkStatusEnumActive,
	LinkStatusEnumPassive,
}

func (e LinkStatusEnum) IsValid() bool {
	switch e {
	case LinkStatusEnumActive, LinkStatusEnumPassive:
		return true
	}
	return false
}

func (e LinkStatusEnum) String() string {
	return string(e)
}

func (e *LinkStatusEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LinkStatusEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid LinkStatusEnum", str)
	}
	return nil
}

func (e LinkStatusEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *LinkStatusEnum) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e LinkStatusEnum) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type LocationType string

const (
	LocationTypeBranch          LocationType = "BRANCH"
	LocationTypeCloudDataCenter LocationType = "CLOUD_DATA_CENTER"
	LocationTypeDataCenter      LocationType = "DATA_CENTER"
	LocationTypeHeadquarters    LocationType = "HEADQUARTERS"
	LocationTypeOther           LocationType = "OTHER"
	LocationTypeWarehouse       LocationType = "WAREHOUSE"
)

var AllLocationType = []LocationType{
	LocationTypeBranch,
	LocationTypeCloudDataCenter,
	LocationTypeDataCenter,
	LocationTypeHeadquarters,
	LocationTypeOther,
	LocationTypeWarehouse,
}

func (e LocationType) IsValid() bool {
	switch e {
	case LocationTypeBranch, LocationTypeCloudDataCenter, LocationTypeDataCenter, LocationTypeHeadquarters, LocationTypeOther, LocationTypeWarehouse:
		return true
	}
	return false
}

func (e LocationType) String() string {
	return string(e)
}

func (e *LocationType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LocationType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid LocationType", str)
	}
	return nil
}

func (e LocationType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *LocationType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e LocationType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type LookupFilterType string

const (
	// Custom filter for country, used by city and state entityLookup
	LookupFilterTypeCountry LookupFilterType = "country"
	// Custom filter to be used with Site entityLookup, to get only sites with Alt WAN, possible values:
	// "true",
	// "false",
	LookupFilterTypeFilterByAltWan LookupFilterType = "filterByAltWan"
	// Custom filter to be used with Site entityLookup, to get only sites that are configured as backhauling gateways, possible values:
	// "true",
	// "false",
	LookupFilterTypeFilterByBackhaulingGw LookupFilterType = "filterByBackhaulingGW"
	// Custom filter to be used with Site entityLookup, to get only sites with one connection type, possible values (there are more values that can supported):
	// "SOCKET_X1500",
	// "SOCKET_X1600",
	// "SOCKET_X1700",
	// "VSOCKET_VGX_ESX",
	// "VSOCKET_VGX_AWS"
	// "VSOCKET_VGX_AZURE"
	// "SOCKET_X1600_LTE",
	LookupFilterTypeFilterByConnectionType LookupFilterType = "filterByConnectionType"
	// Custom filter to be used with Site entityLookup, to get only sites with one connection type, possible values:
	// "SOCKET",
	// "IPSEC",
	// "vSOCKET",
	// "PHYSICAL_SOCKET"
	LookupFilterTypeFilterByConnectionTypeFamily LookupFilterType = "filterByConnectionTypeFamily"
	// Custom filter to be used with Site entityLookup, to get only sites that are configured as OffCloudTransportEnabled, possible values:
	// "true",
	// "false",
	LookupFilterTypeFilterByOffCloudTransportEnabled LookupFilterType = "filterByOffCloudTransportEnabled"
	// Custom filter for state used by city entityLookup
	LookupFilterTypeState LookupFilterType = "state"
)

var AllLookupFilterType = []LookupFilterType{
	LookupFilterTypeCountry,
	LookupFilterTypeFilterByAltWan,
	LookupFilterTypeFilterByBackhaulingGw,
	LookupFilterTypeFilterByConnectionType,
	LookupFilterTypeFilterByConnectionTypeFamily,
	LookupFilterTypeFilterByOffCloudTransportEnabled,
	LookupFilterTypeState,
}

func (e LookupFilterType) IsValid() bool {
	switch e {
	case LookupFilterTypeCountry, LookupFilterTypeFilterByAltWan, LookupFilterTypeFilterByBackhaulingGw, LookupFilterTypeFilterByConnectionType, LookupFilterTypeFilterByConnectionTypeFamily, LookupFilterTypeFilterByOffCloudTransportEnabled, LookupFilterTypeState:
		return true
	}
	return false
}

func (e LookupFilterType) String() string {
	return string(e)
}

func (e *LookupFilterType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LookupFilterType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid LookupFilterType", str)
	}
	return nil
}

func (e LookupFilterType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *LookupFilterType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e LookupFilterType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type MetadataType string

const (
	MetadataTypeTxt MetadataType = "TXT"
)

var AllMetadataType = []MetadataType{
	MetadataTypeTxt,
}

func (e MetadataType) IsValid() bool {
	switch e {
	case MetadataTypeTxt:
		return true
	}
	return false
}

func (e MetadataType) String() string {
	return string(e)
}

func (e *MetadataType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MetadataType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MetadataType", str)
	}
	return nil
}

func (e MetadataType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *MetadataType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e MetadataType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type MsAlertStatus string

const (
	MsAlertStatusInProgress MsAlertStatus = "IN_PROGRESS"
	MsAlertStatusNew        MsAlertStatus = "NEW"
	MsAlertStatusResolved   MsAlertStatus = "RESOLVED"
)

var AllMsAlertStatus = []MsAlertStatus{
	MsAlertStatusInProgress,
	MsAlertStatusNew,
	MsAlertStatusResolved,
}

func (e MsAlertStatus) IsValid() bool {
	switch e {
	case MsAlertStatusInProgress, MsAlertStatusNew, MsAlertStatusResolved:
		return true
	}
	return false
}

func (e MsAlertStatus) String() string {
	return string(e)
}

func (e *MsAlertStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MsAlertStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MsAlertStatus", str)
	}
	return nil
}

func (e MsAlertStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *MsAlertStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e MsAlertStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type MsResourceVerdictEnum string

const (
	MsResourceVerdictEnumBenign        MsResourceVerdictEnum = "Benign"
	MsResourceVerdictEnumInformational MsResourceVerdictEnum = "Informational"
	MsResourceVerdictEnumMalicious     MsResourceVerdictEnum = "Malicious"
	MsResourceVerdictEnumSuspicious    MsResourceVerdictEnum = "Suspicious"
)

var AllMsResourceVerdictEnum = []MsResourceVerdictEnum{
	MsResourceVerdictEnumBenign,
	MsResourceVerdictEnumInformational,
	MsResourceVerdictEnumMalicious,
	MsResourceVerdictEnumSuspicious,
}

func (e MsResourceVerdictEnum) IsValid() bool {
	switch e {
	case MsResourceVerdictEnumBenign, MsResourceVerdictEnumInformational, MsResourceVerdictEnumMalicious, MsResourceVerdictEnumSuspicious:
		return true
	}
	return false
}

func (e MsResourceVerdictEnum) String() string {
	return string(e)
}

func (e *MsResourceVerdictEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MsResourceVerdictEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MsResourceVerdictEnum", str)
	}
	return nil
}

func (e MsResourceVerdictEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *MsResourceVerdictEnum) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e MsResourceVerdictEnum) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type NetworkEventSourceEnum string

const (
	NetworkEventSourceEnumBgpSession NetworkEventSourceEnum = "BGP_SESSION"
	NetworkEventSourceEnumDevice     NetworkEventSourceEnum = "DEVICE"
	NetworkEventSourceEnumHost       NetworkEventSourceEnum = "HOST"
	NetworkEventSourceEnumIsp        NetworkEventSourceEnum = "ISP"
	NetworkEventSourceEnumLink       NetworkEventSourceEnum = "LINK"
	NetworkEventSourceEnumPop        NetworkEventSourceEnum = "POP"
	NetworkEventSourceEnumSite       NetworkEventSourceEnum = "SITE"
)

var AllNetworkEventSourceEnum = []NetworkEventSourceEnum{
	NetworkEventSourceEnumBgpSession,
	NetworkEventSourceEnumDevice,
	NetworkEventSourceEnumHost,
	NetworkEventSourceEnumIsp,
	NetworkEventSourceEnumLink,
	NetworkEventSourceEnumPop,
	NetworkEventSourceEnumSite,
}

func (e NetworkEventSourceEnum) IsValid() bool {
	switch e {
	case NetworkEventSourceEnumBgpSession, NetworkEventSourceEnumDevice, NetworkEventSourceEnumHost, NetworkEventSourceEnumIsp, NetworkEventSourceEnumLink, NetworkEventSourceEnumPop, NetworkEventSourceEnumSite:
		return true
	}
	return false
}

func (e NetworkEventSourceEnum) String() string {
	return string(e)
}

func (e *NetworkEventSourceEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NetworkEventSourceEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NetworkEventSourceEnum", str)
	}
	return nil
}

func (e NetworkEventSourceEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *NetworkEventSourceEnum) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e NetworkEventSourceEnum) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type NetworkXDREventTypeEnum string

const (
	NetworkXDREventTypeEnumDegraded NetworkXDREventTypeEnum = "DEGRADED"
	NetworkXDREventTypeEnumInsight  NetworkXDREventTypeEnum = "INSIGHT"
	NetworkXDREventTypeEnumResolved NetworkXDREventTypeEnum = "RESOLVED"
)

var AllNetworkXDREventTypeEnum = []NetworkXDREventTypeEnum{
	NetworkXDREventTypeEnumDegraded,
	NetworkXDREventTypeEnumInsight,
	NetworkXDREventTypeEnumResolved,
}

func (e NetworkXDREventTypeEnum) IsValid() bool {
	switch e {
	case NetworkXDREventTypeEnumDegraded, NetworkXDREventTypeEnumInsight, NetworkXDREventTypeEnumResolved:
		return true
	}
	return false
}

func (e NetworkXDREventTypeEnum) String() string {
	return string(e)
}

func (e *NetworkXDREventTypeEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NetworkXDREventTypeEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NetworkXDREventTypeEnum", str)
	}
	return nil
}

func (e NetworkXDREventTypeEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *NetworkXDREventTypeEnum) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e NetworkXDREventTypeEnum) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type ObjectRefBy string

const (
	ObjectRefByID   ObjectRefBy = "ID"
	ObjectRefByName ObjectRefBy = "NAME"
)

var AllObjectRefBy = []ObjectRefBy{
	ObjectRefByID,
	ObjectRefByName,
}

func (e ObjectRefBy) IsValid() bool {
	switch e {
	case ObjectRefByID, ObjectRefByName:
		return true
	}
	return false
}

func (e ObjectRefBy) String() string {
	return string(e)
}

func (e *ObjectRefBy) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ObjectRefBy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ObjectRefBy", str)
	}
	return nil
}

func (e ObjectRefBy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ObjectRefBy) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ObjectRefBy) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type OnboardingStatusEnum string

const (
	OnboardingStatusEnumCanBeOnboarded   OnboardingStatusEnum = "CAN_BE_ONBOARDED"
	OnboardingStatusEnumInsufficientInfo OnboardingStatusEnum = "INSUFFICIENT_INFO"
	OnboardingStatusEnumOnboarded        OnboardingStatusEnum = "ONBOARDED"
)

var AllOnboardingStatusEnum = []OnboardingStatusEnum{
	OnboardingStatusEnumCanBeOnboarded,
	OnboardingStatusEnumInsufficientInfo,
	OnboardingStatusEnumOnboarded,
}

func (e OnboardingStatusEnum) IsValid() bool {
	switch e {
	case OnboardingStatusEnumCanBeOnboarded, OnboardingStatusEnumInsufficientInfo, OnboardingStatusEnumOnboarded:
		return true
	}
	return false
}

func (e OnboardingStatusEnum) String() string {
	return string(e)
}

func (e *OnboardingStatusEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OnboardingStatusEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OnboardingStatusEnum", str)
	}
	return nil
}

func (e OnboardingStatusEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *OnboardingStatusEnum) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e OnboardingStatusEnum) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type OperatingSystem string

const (
	OperatingSystemAndroid  OperatingSystem = "ANDROID"
	OperatingSystemEmbedded OperatingSystem = "EMBEDDED"
	OperatingSystemIos      OperatingSystem = "IOS"
	OperatingSystemLinux    OperatingSystem = "LINUX"
	OperatingSystemMacos    OperatingSystem = "MACOS"
	OperatingSystemWindows  OperatingSystem = "WINDOWS"
)

var AllOperatingSystem = []OperatingSystem{
	OperatingSystemAndroid,
	OperatingSystemEmbedded,
	OperatingSystemIos,
	OperatingSystemLinux,
	OperatingSystemMacos,
	OperatingSystemWindows,
}

func (e OperatingSystem) IsValid() bool {
	switch e {
	case OperatingSystemAndroid, OperatingSystemEmbedded, OperatingSystemIos, OperatingSystemLinux, OperatingSystemMacos, OperatingSystemWindows:
		return true
	}
	return false
}

func (e OperatingSystem) String() string {
	return string(e)
}

func (e *OperatingSystem) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OperatingSystem(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OperatingSystem", str)
	}
	return nil
}

func (e OperatingSystem) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *OperatingSystem) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e OperatingSystem) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// The origins (e.g., integrations, data feeds) that detected the device
type OriginType string

const (
	// Device details reported by the Armis security platform
	OriginTypeArmis OriginType = "Armis"
	// Device information provided by the Cato Networks platform
	OriginTypeCatoNetworks OriginType = "CatoNetworks"
	// Device data gathered from Claroty's security platform
	OriginTypeClaroty OriginType = "Claroty"
	// Device details provided by CrowdStrike endpoint security
	OriginTypeCrowdstrike OriginType = "Crowdstrike"
	// Device data collected from Microsoft Intune MDM
	OriginTypeMicrosoftIntune OriginType = "MicrosoftIntune"
	// Device information from SentinelOne endpoint platform
	OriginTypeSentinelOne OriginType = "SentinelOne"
	// Origin of the device data could not be determined
	OriginTypeUnknown OriginType = "Unknown"
	// Device information identified through Zoom integration
	OriginTypeZoom OriginType = "Zoom"
)

var AllOriginType = []OriginType{
	OriginTypeArmis,
	OriginTypeCatoNetworks,
	OriginTypeClaroty,
	OriginTypeCrowdstrike,
	OriginTypeMicrosoftIntune,
	OriginTypeSentinelOne,
	OriginTypeUnknown,
	OriginTypeZoom,
}

func (e OriginType) IsValid() bool {
	switch e {
	case OriginTypeArmis, OriginTypeCatoNetworks, OriginTypeClaroty, OriginTypeCrowdstrike, OriginTypeMicrosoftIntune, OriginTypeSentinelOne, OriginTypeUnknown, OriginTypeZoom:
		return true
	}
	return false
}

func (e OriginType) String() string {
	return string(e)
}

func (e *OriginType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OriginType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OriginType", str)
	}
	return nil
}

func (e OriginType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *OriginType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e OriginType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type PeriodType string

const (
	// traffic was seen
	PeriodTypeActive PeriodType = "active"
	// some packets were discarded after queue timeout
	PeriodTypeCongested PeriodType = "congested"
	// unspecified period type
	PeriodTypeGeneric PeriodType = "generic"
	// multiple last mile destinations measured large latency (greater than 500ms)
	PeriodTypeLastmileLatency PeriodType = "lastmileLatency"
	// multiple last mile destinations measured packet loss
	PeriodTypeLastmilePacketLoss PeriodType = "lastmilePacketLoss"
	// missing data
	PeriodTypeMissingData PeriodType = "missingData"
	// some packets were queued
	PeriodTypeOverlowed PeriodType = "overlowed"
	// packet loss connectivity issue
	PeriodTypePacketLoss PeriodType = "packetLoss"
	// interface in standby mode
	PeriodTypePassiveLink PeriodType = "passiveLink"
	// period connected to specific pop instance
	PeriodTypePop PeriodType = "pop"
)

var AllPeriodType = []PeriodType{
	PeriodTypeActive,
	PeriodTypeCongested,
	PeriodTypeGeneric,
	PeriodTypeLastmileLatency,
	PeriodTypeLastmilePacketLoss,
	PeriodTypeMissingData,
	PeriodTypeOverlowed,
	PeriodTypePacketLoss,
	PeriodTypePassiveLink,
	PeriodTypePop,
}

func (e PeriodType) IsValid() bool {
	switch e {
	case PeriodTypeActive, PeriodTypeCongested, PeriodTypeGeneric, PeriodTypeLastmileLatency, PeriodTypeLastmilePacketLoss, PeriodTypeMissingData, PeriodTypeOverlowed, PeriodTypePacketLoss, PeriodTypePassiveLink, PeriodTypePop:
		return true
	}
	return false
}

func (e PeriodType) String() string {
	return string(e)
}

func (e *PeriodType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PeriodType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PeriodType", str)
	}
	return nil
}

func (e PeriodType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *PeriodType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e PeriodType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Enum for the type of time range a rule is active
type PolicyActiveOnEnum string

const (
	PolicyActiveOnEnumAlways          PolicyActiveOnEnum = "ALWAYS"
	PolicyActiveOnEnumCustomRecurring PolicyActiveOnEnum = "CUSTOM_RECURRING"
	PolicyActiveOnEnumCustomTimeframe PolicyActiveOnEnum = "CUSTOM_TIMEFRAME"
	PolicyActiveOnEnumWorkingHours    PolicyActiveOnEnum = "WORKING_HOURS"
)

var AllPolicyActiveOnEnum = []PolicyActiveOnEnum{
	PolicyActiveOnEnumAlways,
	PolicyActiveOnEnumCustomRecurring,
	PolicyActiveOnEnumCustomTimeframe,
	PolicyActiveOnEnumWorkingHours,
}

func (e PolicyActiveOnEnum) IsValid() bool {
	switch e {
	case PolicyActiveOnEnumAlways, PolicyActiveOnEnumCustomRecurring, PolicyActiveOnEnumCustomTimeframe, PolicyActiveOnEnumWorkingHours:
		return true
	}
	return false
}

func (e PolicyActiveOnEnum) String() string {
	return string(e)
}

func (e *PolicyActiveOnEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PolicyActiveOnEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PolicyActiveOnEnum", str)
	}
	return nil
}

func (e PolicyActiveOnEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *PolicyActiveOnEnum) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e PolicyActiveOnEnum) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Attributes describing the rule state or type
type PolicyElementPropertiesEnum string

const (
	// New (added) rule
	PolicyElementPropertiesEnumAdded PolicyElementPropertiesEnum = "ADDED"
	// An object can not be moved, or referenced when moving other objects.
	// However its properties and content can be modified.
	PolicyElementPropertiesEnumAnchored PolicyElementPropertiesEnum = "ANCHORED"
	// A rule locked for changes by other admins
	PolicyElementPropertiesEnumLocked PolicyElementPropertiesEnum = "LOCKED"
	// A rule moved to a different position
	PolicyElementPropertiesEnumMoved PolicyElementPropertiesEnum = "MOVED"
	// Removed (deleted) rule
	PolicyElementPropertiesEnumRemoved PolicyElementPropertiesEnum = "REMOVED"
	// A pre-defined (system) rule that cannot be modified or removed
	PolicyElementPropertiesEnumSystem PolicyElementPropertiesEnum = "SYSTEM"
	// Updated (modified) existing rule
	PolicyElementPropertiesEnumUpdated PolicyElementPropertiesEnum = "UPDATED"
)

var AllPolicyElementPropertiesEnum = []PolicyElementPropertiesEnum{
	PolicyElementPropertiesEnumAdded,
	PolicyElementPropertiesEnumAnchored,
	PolicyElementPropertiesEnumLocked,
	PolicyElementPropertiesEnumMoved,
	PolicyElementPropertiesEnumRemoved,
	PolicyElementPropertiesEnumSystem,
	PolicyElementPropertiesEnumUpdated,
}

func (e PolicyElementPropertiesEnum) IsValid() bool {
	switch e {
	case PolicyElementPropertiesEnumAdded, PolicyElementPropertiesEnumAnchored, PolicyElementPropertiesEnumLocked, PolicyElementPropertiesEnumMoved, PolicyElementPropertiesEnumRemoved, PolicyElementPropertiesEnumSystem, PolicyElementPropertiesEnumUpdated:
		return true
	}
	return false
}

func (e PolicyElementPropertiesEnum) String() string {
	return string(e)
}

func (e *PolicyElementPropertiesEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PolicyElementPropertiesEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PolicyElementPropertiesEnum", str)
	}
	return nil
}

func (e PolicyElementPropertiesEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *PolicyElementPropertiesEnum) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e PolicyElementPropertiesEnum) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Enum for the status of a policy mutation
type PolicyMutationStatus string

const (
	PolicyMutationStatusFailure PolicyMutationStatus = "FAILURE"
	PolicyMutationStatusSuccess PolicyMutationStatus = "SUCCESS"
)

var AllPolicyMutationStatus = []PolicyMutationStatus{
	PolicyMutationStatusFailure,
	PolicyMutationStatusSuccess,
}

func (e PolicyMutationStatus) IsValid() bool {
	switch e {
	case PolicyMutationStatusFailure, PolicyMutationStatusSuccess:
		return true
	}
	return false
}

func (e PolicyMutationStatus) String() string {
	return string(e)
}

func (e *PolicyMutationStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PolicyMutationStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PolicyMutationStatus", str)
	}
	return nil
}

func (e PolicyMutationStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *PolicyMutationStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e PolicyMutationStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Enum for the type of a policy revision
type PolicyRevisionType string

const (
	PolicyRevisionTypePrivate PolicyRevisionType = "PRIVATE"
	PolicyRevisionTypePublic  PolicyRevisionType = "PUBLIC"
)

var AllPolicyRevisionType = []PolicyRevisionType{
	PolicyRevisionTypePrivate,
	PolicyRevisionTypePublic,
}

func (e PolicyRevisionType) IsValid() bool {
	switch e {
	case PolicyRevisionTypePrivate, PolicyRevisionTypePublic:
		return true
	}
	return false
}

func (e PolicyRevisionType) String() string {
	return string(e)
}

func (e *PolicyRevisionType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PolicyRevisionType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PolicyRevisionType", str)
	}
	return nil
}

func (e PolicyRevisionType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *PolicyRevisionType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e PolicyRevisionType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Enum for the position of a rule within a policy
type PolicyRulePositionEnum string

const (
	// The rule position is after the pre-existing specified rule
	PolicyRulePositionEnumAfterRule PolicyRulePositionEnum = "AFTER_RULE"
	// The rule position is before the pre-existing specified rule
	PolicyRulePositionEnumBeforeRule PolicyRulePositionEnum = "BEFORE_RULE"
	// The rule position is immediately after the system rules (first non-system rule)
	PolicyRulePositionEnumFirstInPolicy PolicyRulePositionEnum = "FIRST_IN_POLICY"
	// The rule position is first in the specified section
	PolicyRulePositionEnumFirstInSection PolicyRulePositionEnum = "FIRST_IN_SECTION"
	// The rule position is last in the policy
	PolicyRulePositionEnumLastInPolicy PolicyRulePositionEnum = "LAST_IN_POLICY"
	// The rule position is last in the specified section
	PolicyRulePositionEnumLastInSection PolicyRulePositionEnum = "LAST_IN_SECTION"
)

var AllPolicyRulePositionEnum = []PolicyRulePositionEnum{
	PolicyRulePositionEnumAfterRule,
	PolicyRulePositionEnumBeforeRule,
	PolicyRulePositionEnumFirstInPolicy,
	PolicyRulePositionEnumFirstInSection,
	PolicyRulePositionEnumLastInPolicy,
	PolicyRulePositionEnumLastInSection,
}

func (e PolicyRulePositionEnum) IsValid() bool {
	switch e {
	case PolicyRulePositionEnumAfterRule, PolicyRulePositionEnumBeforeRule, PolicyRulePositionEnumFirstInPolicy, PolicyRulePositionEnumFirstInSection, PolicyRulePositionEnumLastInPolicy, PolicyRulePositionEnumLastInSection:
		return true
	}
	return false
}

func (e PolicyRulePositionEnum) String() string {
	return string(e)
}

func (e *PolicyRulePositionEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PolicyRulePositionEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PolicyRulePositionEnum", str)
	}
	return nil
}

func (e PolicyRulePositionEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *PolicyRulePositionEnum) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e PolicyRulePositionEnum) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Enum for the frequency of an alert event for a rule
type PolicyRuleTrackingFrequencyEnum string

const (
	PolicyRuleTrackingFrequencyEnumDaily     PolicyRuleTrackingFrequencyEnum = "DAILY"
	PolicyRuleTrackingFrequencyEnumHourly    PolicyRuleTrackingFrequencyEnum = "HOURLY"
	PolicyRuleTrackingFrequencyEnumImmediate PolicyRuleTrackingFrequencyEnum = "IMMEDIATE"
	PolicyRuleTrackingFrequencyEnumWeekly    PolicyRuleTrackingFrequencyEnum = "WEEKLY"
)

var AllPolicyRuleTrackingFrequencyEnum = []PolicyRuleTrackingFrequencyEnum{
	PolicyRuleTrackingFrequencyEnumDaily,
	PolicyRuleTrackingFrequencyEnumHourly,
	PolicyRuleTrackingFrequencyEnumImmediate,
	PolicyRuleTrackingFrequencyEnumWeekly,
}

func (e PolicyRuleTrackingFrequencyEnum) IsValid() bool {
	switch e {
	case PolicyRuleTrackingFrequencyEnumDaily, PolicyRuleTrackingFrequencyEnumHourly, PolicyRuleTrackingFrequencyEnumImmediate, PolicyRuleTrackingFrequencyEnumWeekly:
		return true
	}
	return false
}

func (e PolicyRuleTrackingFrequencyEnum) String() string {
	return string(e)
}

func (e *PolicyRuleTrackingFrequencyEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PolicyRuleTrackingFrequencyEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PolicyRuleTrackingFrequencyEnum", str)
	}
	return nil
}

func (e PolicyRuleTrackingFrequencyEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *PolicyRuleTrackingFrequencyEnum) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e PolicyRuleTrackingFrequencyEnum) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type PolicySectionPositionEnum string

const (
	PolicySectionPositionEnumAfterSection  PolicySectionPositionEnum = "AFTER_SECTION"
	PolicySectionPositionEnumBeforeSection PolicySectionPositionEnum = "BEFORE_SECTION"
	PolicySectionPositionEnumLastInPolicy  PolicySectionPositionEnum = "LAST_IN_POLICY"
)

var AllPolicySectionPositionEnum = []PolicySectionPositionEnum{
	PolicySectionPositionEnumAfterSection,
	PolicySectionPositionEnumBeforeSection,
	PolicySectionPositionEnumLastInPolicy,
}

func (e PolicySectionPositionEnum) IsValid() bool {
	switch e {
	case PolicySectionPositionEnumAfterSection, PolicySectionPositionEnumBeforeSection, PolicySectionPositionEnumLastInPolicy:
		return true
	}
	return false
}

func (e PolicySectionPositionEnum) String() string {
	return string(e)
}

func (e *PolicySectionPositionEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PolicySectionPositionEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PolicySectionPositionEnum", str)
	}
	return nil
}

func (e PolicySectionPositionEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *PolicySectionPositionEnum) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e PolicySectionPositionEnum) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Enum for the position of a rule within a policy
type PolicySubRulePositionEnum string

const (
	// The rule position is after the pre-existing specified rule
	PolicySubRulePositionEnumAfterSubRule PolicySubRulePositionEnum = "AFTER_SUB_RULE"
	// The rule position is before the pre-existing specified rule
	PolicySubRulePositionEnumBeforeSubRule PolicySubRulePositionEnum = "BEFORE_SUB_RULE"
	// The rule position is first in the specified rule
	PolicySubRulePositionEnumFirstInRule PolicySubRulePositionEnum = "FIRST_IN_RULE"
	// The rule position is last in the specified rule
	PolicySubRulePositionEnumLastInRule PolicySubRulePositionEnum = "LAST_IN_RULE"
)

var AllPolicySubRulePositionEnum = []PolicySubRulePositionEnum{
	PolicySubRulePositionEnumAfterSubRule,
	PolicySubRulePositionEnumBeforeSubRule,
	PolicySubRulePositionEnumFirstInRule,
	PolicySubRulePositionEnumLastInRule,
}

func (e PolicySubRulePositionEnum) IsValid() bool {
	switch e {
	case PolicySubRulePositionEnumAfterSubRule, PolicySubRulePositionEnumBeforeSubRule, PolicySubRulePositionEnumFirstInRule, PolicySubRulePositionEnumLastInRule:
		return true
	}
	return false
}

func (e PolicySubRulePositionEnum) String() string {
	return string(e)
}

func (e *PolicySubRulePositionEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PolicySubRulePositionEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PolicySubRulePositionEnum", str)
	}
	return nil
}

func (e PolicySubRulePositionEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *PolicySubRulePositionEnum) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e PolicySubRulePositionEnum) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Enum for the state of a policy
type PolicyToggleState string

const (
	PolicyToggleStateDisabled PolicyToggleState = "DISABLED"
	PolicyToggleStateEnabled  PolicyToggleState = "ENABLED"
)

var AllPolicyToggleState = []PolicyToggleState{
	PolicyToggleStateDisabled,
	PolicyToggleStateEnabled,
}

func (e PolicyToggleState) IsValid() bool {
	switch e {
	case PolicyToggleStateDisabled, PolicyToggleStateEnabled:
		return true
	}
	return false
}

func (e PolicyToggleState) String() string {
	return string(e)
}

func (e *PolicyToggleState) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PolicyToggleState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PolicyToggleState", str)
	}
	return nil
}

func (e PolicyToggleState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *PolicyToggleState) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e PolicyToggleState) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type ProtoType string

const (
	ProtoTypeCrossConnect    ProtoType = "CROSS_CONNECT"
	ProtoTypeIpsecClient     ProtoType = "IPSEC_CLIENT"
	ProtoTypeIpsecHost       ProtoType = "IPSEC_HOST"
	ProtoTypeIpsecV2         ProtoType = "IPSEC_V2"
	ProtoTypeSocketAWS1500   ProtoType = "SOCKET_AWS1500"
	ProtoTypeSocketAz1500    ProtoType = "SOCKET_AZ1500"
	ProtoTypeSocketEsx1500   ProtoType = "SOCKET_ESX1500"
	ProtoTypeSocketGCP1500   ProtoType = "SOCKET_GCP1500"
	ProtoTypeSocketX1500     ProtoType = "SOCKET_X1500"
	ProtoTypeSocketX1600     ProtoType = "SOCKET_X1600"
	ProtoTypeSocketX1600Lte  ProtoType = "SOCKET_X1600_LTE"
	ProtoTypeSocketX1700     ProtoType = "SOCKET_X1700"
	ProtoTypeVsocketVgx      ProtoType = "VSOCKET_VGX"
	ProtoTypeCrossConnectL2  ProtoType = "CROSS_CONNECT_L2"
	ProtoTypeCrossConnectVrf ProtoType = "CROSS_CONNECT_VRF"
	ProtoTypeGreTunnel       ProtoType = "GRE_TUNNEL"
	ProtoTypeNotDefined      ProtoType = "NOT_DEFINED"
	ProtoTypePortalListener  ProtoType = "PORTAL_LISTENER"
	ProtoTypeSocketRpi64     ProtoType = "SOCKET_RPI64"
	ProtoTypeSocketX1        ProtoType = "SOCKET_X1"
	ProtoTypeVsocketVgs      ProtoType = "VSOCKET_VGS"
	ProtoTypeVsocketVgxAWS   ProtoType = "VSOCKET_VGX_AWS"
	ProtoTypeVsocketVgxAzure ProtoType = "VSOCKET_VGX_AZURE"
	ProtoTypeVsocketVgxEsx   ProtoType = "VSOCKET_VGX_ESX"
	ProtoTypeVsocketVsh      ProtoType = "VSOCKET_VSH"
)

var AllProtoType = []ProtoType{
	ProtoTypeCrossConnect,
	ProtoTypeIpsecClient,
	ProtoTypeIpsecHost,
	ProtoTypeIpsecV2,
	ProtoTypeSocketAWS1500,
	ProtoTypeSocketAz1500,
	ProtoTypeSocketEsx1500,
	ProtoTypeSocketGCP1500,
	ProtoTypeSocketX1500,
	ProtoTypeSocketX1600,
	ProtoTypeSocketX1600Lte,
	ProtoTypeSocketX1700,
	ProtoTypeVsocketVgx,
	ProtoTypeCrossConnectL2,
	ProtoTypeCrossConnectVrf,
	ProtoTypeGreTunnel,
	ProtoTypeNotDefined,
	ProtoTypePortalListener,
	ProtoTypeSocketRpi64,
	ProtoTypeSocketX1,
	ProtoTypeVsocketVgs,
	ProtoTypeVsocketVgxAWS,
	ProtoTypeVsocketVgxAzure,
	ProtoTypeVsocketVgxEsx,
	ProtoTypeVsocketVsh,
}

func (e ProtoType) IsValid() bool {
	switch e {
	case ProtoTypeCrossConnect, ProtoTypeIpsecClient, ProtoTypeIpsecHost, ProtoTypeIpsecV2, ProtoTypeSocketAWS1500, ProtoTypeSocketAz1500, ProtoTypeSocketEsx1500, ProtoTypeSocketGCP1500, ProtoTypeSocketX1500, ProtoTypeSocketX1600, ProtoTypeSocketX1600Lte, ProtoTypeSocketX1700, ProtoTypeVsocketVgx, ProtoTypeCrossConnectL2, ProtoTypeCrossConnectVrf, ProtoTypeGreTunnel, ProtoTypeNotDefined, ProtoTypePortalListener, ProtoTypeSocketRpi64, ProtoTypeSocketX1, ProtoTypeVsocketVgs, ProtoTypeVsocketVgxAWS, ProtoTypeVsocketVgxAzure, ProtoTypeVsocketVgxEsx, ProtoTypeVsocketVsh:
		return true
	}
	return false
}

func (e ProtoType) String() string {
	return string(e)
}

func (e *ProtoType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProtoType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProtoType", str)
	}
	return nil
}

func (e ProtoType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ProtoType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ProtoType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// REGIONAL and GLOBAL licenses for MOROCCO, CHINA, and VIETNAM group values
type Regionality string

const (
	// Global traffic going outside of the region
	RegionalityGlobal Regionality = "GLOBAL"
	// Site traffic within the region
	RegionalityRegional Regionality = "REGIONAL"
)

var AllRegionality = []Regionality{
	RegionalityGlobal,
	RegionalityRegional,
}

func (e Regionality) IsValid() bool {
	switch e {
	case RegionalityGlobal, RegionalityRegional:
		return true
	}
	return false
}

func (e Regionality) String() string {
	return string(e)
}

func (e *Regionality) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Regionality(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Regionality", str)
	}
	return nil
}

func (e Regionality) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *Regionality) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e Regionality) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type RemediationStatusEnum string

const (
	RemediationStatusEnumBlocked           RemediationStatusEnum = "BLOCKED"
	RemediationStatusEnumClean             RemediationStatusEnum = "CLEAN"
	RemediationStatusEnumDeleted           RemediationStatusEnum = "DELETED"
	RemediationStatusEnumDeletedReboot     RemediationStatusEnum = "DELETED_REBOOT"
	RemediationStatusEnumDisabled          RemediationStatusEnum = "DISABLED"
	RemediationStatusEnumDisinfectFailed   RemediationStatusEnum = "DISINFECT_FAILED"
	RemediationStatusEnumDisinfected       RemediationStatusEnum = "DISINFECTED"
	RemediationStatusEnumInfected          RemediationStatusEnum = "INFECTED"
	RemediationStatusEnumMoved             RemediationStatusEnum = "MOVED"
	RemediationStatusEnumMovedReboot       RemediationStatusEnum = "MOVED_REBOOT"
	RemediationStatusEnumNotFound          RemediationStatusEnum = "NOT_FOUND"
	RemediationStatusEnumNotStarted        RemediationStatusEnum = "NOT_STARTED"
	RemediationStatusEnumPasswordProtected RemediationStatusEnum = "PASSWORD_PROTECTED"
	RemediationStatusEnumPrevented         RemediationStatusEnum = "PREVENTED"
	RemediationStatusEnumRebootRequired    RemediationStatusEnum = "REBOOT_REQUIRED"
	RemediationStatusEnumRemediated        RemediationStatusEnum = "REMEDIATED"
	RemediationStatusEnumScanFailed        RemediationStatusEnum = "SCAN_FAILED"
	RemediationStatusEnumSuccess           RemediationStatusEnum = "SUCCESS"
	RemediationStatusEnumSuspicious        RemediationStatusEnum = "SUSPICIOUS"
	RemediationStatusEnumUnknown           RemediationStatusEnum = "UNKNOWN"
)

var AllRemediationStatusEnum = []RemediationStatusEnum{
	RemediationStatusEnumBlocked,
	RemediationStatusEnumClean,
	RemediationStatusEnumDeleted,
	RemediationStatusEnumDeletedReboot,
	RemediationStatusEnumDisabled,
	RemediationStatusEnumDisinfectFailed,
	RemediationStatusEnumDisinfected,
	RemediationStatusEnumInfected,
	RemediationStatusEnumMoved,
	RemediationStatusEnumMovedReboot,
	RemediationStatusEnumNotFound,
	RemediationStatusEnumNotStarted,
	RemediationStatusEnumPasswordProtected,
	RemediationStatusEnumPrevented,
	RemediationStatusEnumRebootRequired,
	RemediationStatusEnumRemediated,
	RemediationStatusEnumScanFailed,
	RemediationStatusEnumSuccess,
	RemediationStatusEnumSuspicious,
	RemediationStatusEnumUnknown,
}

func (e RemediationStatusEnum) IsValid() bool {
	switch e {
	case RemediationStatusEnumBlocked, RemediationStatusEnumClean, RemediationStatusEnumDeleted, RemediationStatusEnumDeletedReboot, RemediationStatusEnumDisabled, RemediationStatusEnumDisinfectFailed, RemediationStatusEnumDisinfected, RemediationStatusEnumInfected, RemediationStatusEnumMoved, RemediationStatusEnumMovedReboot, RemediationStatusEnumNotFound, RemediationStatusEnumNotStarted, RemediationStatusEnumPasswordProtected, RemediationStatusEnumPrevented, RemediationStatusEnumRebootRequired, RemediationStatusEnumRemediated, RemediationStatusEnumScanFailed, RemediationStatusEnumSuccess, RemediationStatusEnumSuspicious, RemediationStatusEnumUnknown:
		return true
	}
	return false
}

func (e RemediationStatusEnum) String() string {
	return string(e)
}

func (e *RemediationStatusEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RemediationStatusEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RemediationStatusEnum", str)
	}
	return nil
}

func (e RemediationStatusEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *RemediationStatusEnum) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e RemediationStatusEnum) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type RemotePortFwdRestrictionType string

const (
	RemotePortFwdRestrictionTypeAllowList RemotePortFwdRestrictionType = "ALLOW_LIST"
	RemotePortFwdRestrictionTypeBlockList RemotePortFwdRestrictionType = "BLOCK_LIST"
)

var AllRemotePortFwdRestrictionType = []RemotePortFwdRestrictionType{
	RemotePortFwdRestrictionTypeAllowList,
	RemotePortFwdRestrictionTypeBlockList,
}

func (e RemotePortFwdRestrictionType) IsValid() bool {
	switch e {
	case RemotePortFwdRestrictionTypeAllowList, RemotePortFwdRestrictionTypeBlockList:
		return true
	}
	return false
}

func (e RemotePortFwdRestrictionType) String() string {
	return string(e)
}

func (e *RemotePortFwdRestrictionType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RemotePortFwdRestrictionType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RemotePortFwdRestrictionType", str)
	}
	return nil
}

func (e RemotePortFwdRestrictionType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *RemotePortFwdRestrictionType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e RemotePortFwdRestrictionType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type ResourceRoleEnum string

const (
	ResourceRoleEnumAdded             ResourceRoleEnum = "ADDED"
	ResourceRoleEnumAttacked          ResourceRoleEnum = "ATTACKED"
	ResourceRoleEnumAttacker          ResourceRoleEnum = "ATTACKER"
	ResourceRoleEnumCommandAndControl ResourceRoleEnum = "COMMAND_AND_CONTROL"
	ResourceRoleEnumCompromised       ResourceRoleEnum = "COMPROMISED"
	ResourceRoleEnumContextual        ResourceRoleEnum = "CONTEXTUAL"
	ResourceRoleEnumCreated           ResourceRoleEnum = "CREATED"
	ResourceRoleEnumDestination       ResourceRoleEnum = "DESTINATION"
	ResourceRoleEnumEdited            ResourceRoleEnum = "EDITED"
	ResourceRoleEnumLoaded            ResourceRoleEnum = "LOADED"
	ResourceRoleEnumPolicyViolator    ResourceRoleEnum = "POLICY_VIOLATOR"
	ResourceRoleEnumScanned           ResourceRoleEnum = "SCANNED"
	ResourceRoleEnumSource            ResourceRoleEnum = "SOURCE"
	ResourceRoleEnumSuspicious        ResourceRoleEnum = "SUSPICIOUS"
)

var AllResourceRoleEnum = []ResourceRoleEnum{
	ResourceRoleEnumAdded,
	ResourceRoleEnumAttacked,
	ResourceRoleEnumAttacker,
	ResourceRoleEnumCommandAndControl,
	ResourceRoleEnumCompromised,
	ResourceRoleEnumContextual,
	ResourceRoleEnumCreated,
	ResourceRoleEnumDestination,
	ResourceRoleEnumEdited,
	ResourceRoleEnumLoaded,
	ResourceRoleEnumPolicyViolator,
	ResourceRoleEnumScanned,
	ResourceRoleEnumSource,
	ResourceRoleEnumSuspicious,
}

func (e ResourceRoleEnum) IsValid() bool {
	switch e {
	case ResourceRoleEnumAdded, ResourceRoleEnumAttacked, ResourceRoleEnumAttacker, ResourceRoleEnumCommandAndControl, ResourceRoleEnumCompromised, ResourceRoleEnumContextual, ResourceRoleEnumCreated, ResourceRoleEnumDestination, ResourceRoleEnumEdited, ResourceRoleEnumLoaded, ResourceRoleEnumPolicyViolator, ResourceRoleEnumScanned, ResourceRoleEnumSource, ResourceRoleEnumSuspicious:
		return true
	}
	return false
}

func (e ResourceRoleEnum) String() string {
	return string(e)
}

func (e *ResourceRoleEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ResourceRoleEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ResourceRoleEnum", str)
	}
	return nil
}

func (e ResourceRoleEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ResourceRoleEnum) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ResourceRoleEnum) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type RiskLevelEnum string

const (
	RiskLevelEnumBenign       RiskLevelEnum = "Benign"
	RiskLevelEnumHigh         RiskLevelEnum = "High"
	RiskLevelEnumInconclusive RiskLevelEnum = "Inconclusive"
	RiskLevelEnumLow          RiskLevelEnum = "Low"
	RiskLevelEnumMalicious    RiskLevelEnum = "Malicious"
	RiskLevelEnumMedium       RiskLevelEnum = "Medium"
	RiskLevelEnumNan          RiskLevelEnum = "nan"
)

var AllRiskLevelEnum = []RiskLevelEnum{
	RiskLevelEnumBenign,
	RiskLevelEnumHigh,
	RiskLevelEnumInconclusive,
	RiskLevelEnumLow,
	RiskLevelEnumMalicious,
	RiskLevelEnumMedium,
	RiskLevelEnumNan,
}

func (e RiskLevelEnum) IsValid() bool {
	switch e {
	case RiskLevelEnumBenign, RiskLevelEnumHigh, RiskLevelEnumInconclusive, RiskLevelEnumLow, RiskLevelEnumMalicious, RiskLevelEnumMedium, RiskLevelEnumNan:
		return true
	}
	return false
}

func (e RiskLevelEnum) String() string {
	return string(e)
}

func (e *RiskLevelEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RiskLevelEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RiskLevelEnum", str)
	}
	return nil
}

func (e RiskLevelEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *RiskLevelEnum) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e RiskLevelEnum) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Sandbox analysis failure reason
type SandboxFailureReason string

const (
	//  Failed to fetch report from sandbox service after 10 minutes
	SandboxFailureReasonAnalysisTimeout SandboxFailureReason = "ANALYSIS_TIMEOUT"
	//  Reached configured queued limit for account
	SandboxFailureReasonExceedRateLimit SandboxFailureReason = "EXCEED_RATE_LIMIT"
	//  Internal server error
	SandboxFailureReasonInternalError SandboxFailureReason = "INTERNAL_ERROR"
	//  Invalid file size (0 or too large)
	SandboxFailureReasonInvalidFileSize SandboxFailureReason = "INVALID_FILE_SIZE"
	//  Failed to submit file for sandbox analysis
	SandboxFailureReasonSubmissionError SandboxFailureReason = "SUBMISSION_ERROR"
	//  Unsupported file type
	SandboxFailureReasonUnsupportedFileType SandboxFailureReason = "UNSUPPORTED_FILE_TYPE"
)

var AllSandboxFailureReason = []SandboxFailureReason{
	SandboxFailureReasonAnalysisTimeout,
	SandboxFailureReasonExceedRateLimit,
	SandboxFailureReasonInternalError,
	SandboxFailureReasonInvalidFileSize,
	SandboxFailureReasonSubmissionError,
	SandboxFailureReasonUnsupportedFileType,
}

func (e SandboxFailureReason) IsValid() bool {
	switch e {
	case SandboxFailureReasonAnalysisTimeout, SandboxFailureReasonExceedRateLimit, SandboxFailureReasonInternalError, SandboxFailureReasonInvalidFileSize, SandboxFailureReasonSubmissionError, SandboxFailureReasonUnsupportedFileType:
		return true
	}
	return false
}

func (e SandboxFailureReason) String() string {
	return string(e)
}

func (e *SandboxFailureReason) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SandboxFailureReason(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SandboxFailureReason", str)
	}
	return nil
}

func (e SandboxFailureReason) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *SandboxFailureReason) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e SandboxFailureReason) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Sandbox analysis status
type SandboxStatus string

const (
	//  Report has expired
	SandboxStatusExpired SandboxStatus = "EXPIRED"
	//  Analysis has failed
	SandboxStatusFailed SandboxStatus = "FAILED"
	//  File is being analyzed
	SandboxStatusInProgress SandboxStatus = "IN_PROGRESS"
	//  File is pending analysis
	SandboxStatusPending SandboxStatus = "PENDING"
	//  File is queued for retry after throttling
	SandboxStatusQueued SandboxStatus = "QUEUED"
	//  Analysis is complete - report is ready
	SandboxStatusReady SandboxStatus = "READY"
)

var AllSandboxStatus = []SandboxStatus{
	SandboxStatusExpired,
	SandboxStatusFailed,
	SandboxStatusInProgress,
	SandboxStatusPending,
	SandboxStatusQueued,
	SandboxStatusReady,
}

func (e SandboxStatus) IsValid() bool {
	switch e {
	case SandboxStatusExpired, SandboxStatusFailed, SandboxStatusInProgress, SandboxStatusPending, SandboxStatusQueued, SandboxStatusReady:
		return true
	}
	return false
}

func (e SandboxStatus) String() string {
	return string(e)
}

func (e *SandboxStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SandboxStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SandboxStatus", str)
	}
	return nil
}

func (e SandboxStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *SandboxStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e SandboxStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Sandbox analysis verdict
type SandboxVerdict string

const (
	//  File is clean
	SandboxVerdictBenign SandboxVerdict = "BENIGN"
	//  File is malicious
	SandboxVerdictMalicious SandboxVerdict = "MALICIOUS"
	//  File is suspicious
	SandboxVerdictSuspicious SandboxVerdict = "SUSPICIOUS"
)

var AllSandboxVerdict = []SandboxVerdict{
	SandboxVerdictBenign,
	SandboxVerdictMalicious,
	SandboxVerdictSuspicious,
}

func (e SandboxVerdict) IsValid() bool {
	switch e {
	case SandboxVerdictBenign, SandboxVerdictMalicious, SandboxVerdictSuspicious:
		return true
	}
	return false
}

func (e SandboxVerdict) String() string {
	return string(e)
}

func (e *SandboxVerdict) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SandboxVerdict(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SandboxVerdict", str)
	}
	return nil
}

func (e SandboxVerdict) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *SandboxVerdict) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e SandboxVerdict) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type ScanResult string

const (
	ScanResultBypassByContentRule ScanResult = "BYPASS_BY_CONTENT_RULE"
	ScanResultBypassByOther       ScanResult = "BYPASS_BY_OTHER"
	ScanResultBypassByType        ScanResult = "BYPASS_BY_TYPE"
	ScanResultCancelled           ScanResult = "CANCELLED"
	ScanResultClean               ScanResult = "CLEAN"
	ScanResultEncrypted           ScanResult = "ENCRYPTED"
	ScanResultVirusFound          ScanResult = "VIRUS_FOUND"
)

var AllScanResult = []ScanResult{
	ScanResultBypassByContentRule,
	ScanResultBypassByOther,
	ScanResultBypassByType,
	ScanResultCancelled,
	ScanResultClean,
	ScanResultEncrypted,
	ScanResultVirusFound,
}

func (e ScanResult) IsValid() bool {
	switch e {
	case ScanResultBypassByContentRule, ScanResultBypassByOther, ScanResultBypassByType, ScanResultCancelled, ScanResultClean, ScanResultEncrypted, ScanResultVirusFound:
		return true
	}
	return false
}

func (e ScanResult) String() string {
	return string(e)
}

func (e *ScanResult) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ScanResult(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ScanResult", str)
	}
	return nil
}

func (e ScanResult) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ScanResult) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ScanResult) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type SeverityEnum string

const (
	SeverityEnumHigh   SeverityEnum = "High"
	SeverityEnumLow    SeverityEnum = "Low"
	SeverityEnumMedium SeverityEnum = "Medium"
)

var AllSeverityEnum = []SeverityEnum{
	SeverityEnumHigh,
	SeverityEnumLow,
	SeverityEnumMedium,
}

func (e SeverityEnum) IsValid() bool {
	switch e {
	case SeverityEnumHigh, SeverityEnumLow, SeverityEnumMedium:
		return true
	}
	return false
}

func (e SeverityEnum) String() string {
	return string(e)
}

func (e *SeverityEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SeverityEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SeverityEnum", str)
	}
	return nil
}

func (e SeverityEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *SeverityEnum) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e SeverityEnum) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type ShippingStatus string

const (
	ShippingStatusConfirmShipping ShippingStatus = "CONFIRM_SHIPPING"
	ShippingStatusDelivered       ShippingStatus = "DELIVERED"
	ShippingStatusInTransit       ShippingStatus = "IN_TRANSIT"
	ShippingStatusPendingInfo     ShippingStatus = "PENDING_INFO"
)

var AllShippingStatus = []ShippingStatus{
	ShippingStatusConfirmShipping,
	ShippingStatusDelivered,
	ShippingStatusInTransit,
	ShippingStatusPendingInfo,
}

func (e ShippingStatus) IsValid() bool {
	switch e {
	case ShippingStatusConfirmShipping, ShippingStatusDelivered, ShippingStatusInTransit, ShippingStatusPendingInfo:
		return true
	}
	return false
}

func (e ShippingStatus) String() string {
	return string(e)
}

func (e *ShippingStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ShippingStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ShippingStatus", str)
	}
	return nil
}

func (e ShippingStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ShippingStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ShippingStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type SimpleServiceType string

const (
	SimpleServiceTypeDNSTCP SimpleServiceType = "DNS_TCP"
	SimpleServiceTypeDNSUDP SimpleServiceType = "DNS_UDP"
	SimpleServiceTypeFtp    SimpleServiceType = "FTP"
	SimpleServiceTypeHTTP   SimpleServiceType = "HTTP"
	SimpleServiceTypeHTTPS  SimpleServiceType = "HTTPS"
	SimpleServiceTypeMysql  SimpleServiceType = "MYSQL"
	SimpleServiceTypeRdp    SimpleServiceType = "RDP"
	SimpleServiceTypeSMTP   SimpleServiceType = "SMTP"
	SimpleServiceTypeSSH    SimpleServiceType = "SSH"
)

var AllSimpleServiceType = []SimpleServiceType{
	SimpleServiceTypeDNSTCP,
	SimpleServiceTypeDNSUDP,
	SimpleServiceTypeFtp,
	SimpleServiceTypeHTTP,
	SimpleServiceTypeHTTPS,
	SimpleServiceTypeMysql,
	SimpleServiceTypeRdp,
	SimpleServiceTypeSMTP,
	SimpleServiceTypeSSH,
}

func (e SimpleServiceType) IsValid() bool {
	switch e {
	case SimpleServiceTypeDNSTCP, SimpleServiceTypeDNSUDP, SimpleServiceTypeFtp, SimpleServiceTypeHTTP, SimpleServiceTypeHTTPS, SimpleServiceTypeMysql, SimpleServiceTypeRdp, SimpleServiceTypeSMTP, SimpleServiceTypeSSH:
		return true
	}
	return false
}

func (e SimpleServiceType) String() string {
	return string(e)
}

func (e *SimpleServiceType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SimpleServiceType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SimpleServiceType", str)
	}
	return nil
}

func (e SimpleServiceType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *SimpleServiceType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e SimpleServiceType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type SiteConnectionTypeEnum string

const (
	SiteConnectionTypeEnumSocketAWS1500  SiteConnectionTypeEnum = "SOCKET_AWS1500"
	SiteConnectionTypeEnumSocketAz1500   SiteConnectionTypeEnum = "SOCKET_AZ1500"
	SiteConnectionTypeEnumSocketEsx1500  SiteConnectionTypeEnum = "SOCKET_ESX1500"
	SiteConnectionTypeEnumSocketGCP1500  SiteConnectionTypeEnum = "SOCKET_GCP1500"
	SiteConnectionTypeEnumSocketX1500    SiteConnectionTypeEnum = "SOCKET_X1500"
	SiteConnectionTypeEnumSocketX1600    SiteConnectionTypeEnum = "SOCKET_X1600"
	SiteConnectionTypeEnumSocketX1600Lte SiteConnectionTypeEnum = "SOCKET_X1600_LTE"
	SiteConnectionTypeEnumSocketX1700    SiteConnectionTypeEnum = "SOCKET_X1700"
)

var AllSiteConnectionTypeEnum = []SiteConnectionTypeEnum{
	SiteConnectionTypeEnumSocketAWS1500,
	SiteConnectionTypeEnumSocketAz1500,
	SiteConnectionTypeEnumSocketEsx1500,
	SiteConnectionTypeEnumSocketGCP1500,
	SiteConnectionTypeEnumSocketX1500,
	SiteConnectionTypeEnumSocketX1600,
	SiteConnectionTypeEnumSocketX1600Lte,
	SiteConnectionTypeEnumSocketX1700,
}

func (e SiteConnectionTypeEnum) IsValid() bool {
	switch e {
	case SiteConnectionTypeEnumSocketAWS1500, SiteConnectionTypeEnumSocketAz1500, SiteConnectionTypeEnumSocketEsx1500, SiteConnectionTypeEnumSocketGCP1500, SiteConnectionTypeEnumSocketX1500, SiteConnectionTypeEnumSocketX1600, SiteConnectionTypeEnumSocketX1600Lte, SiteConnectionTypeEnumSocketX1700:
		return true
	}
	return false
}

func (e SiteConnectionTypeEnum) String() string {
	return string(e)
}

func (e *SiteConnectionTypeEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SiteConnectionTypeEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SiteConnectionTypeEnum", str)
	}
	return nil
}

func (e SiteConnectionTypeEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *SiteConnectionTypeEnum) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e SiteConnectionTypeEnum) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type SiteLicenseGroup string

const (
	// legacy license group
	SiteLicenseGroupAfrica SiteLicenseGroup = "AFRICA"
	// legacy license group
	SiteLicenseGroupAnz SiteLicenseGroup = "ANZ"
	// legacy license group
	SiteLicenseGroupApj SiteLicenseGroup = "APJ"
	// Country with stand-alone licenses (not part of a group)
	SiteLicenseGroupChina SiteLicenseGroup = "CHINA"
	// legacy license group
	SiteLicenseGroupDubai SiteLicenseGroup = "DUBAI"
	// legacy license group
	SiteLicenseGroupEurope SiteLicenseGroup = "EUROPE"
	SiteLicenseGroupGroup1 SiteLicenseGroup = "GROUP_1"
	SiteLicenseGroupGroup2 SiteLicenseGroup = "GROUP_2"
	// legacy license group
	SiteLicenseGroupLatam SiteLicenseGroup = "LATAM"
	// legacy license group
	SiteLicenseGroupMiddleEast SiteLicenseGroup = "MIDDLE_EAST"
	// Country with stand-alone licenses (not part of a group)
	SiteLicenseGroupMorocco SiteLicenseGroup = "MOROCCO"
	// legacy license group
	SiteLicenseGroupNam SiteLicenseGroup = "NAM"
	// Country with stand-alone licenses (not part of a group)
	SiteLicenseGroupVietnam SiteLicenseGroup = "VIETNAM"
)

var AllSiteLicenseGroup = []SiteLicenseGroup{
	SiteLicenseGroupAfrica,
	SiteLicenseGroupAnz,
	SiteLicenseGroupApj,
	SiteLicenseGroupChina,
	SiteLicenseGroupDubai,
	SiteLicenseGroupEurope,
	SiteLicenseGroupGroup1,
	SiteLicenseGroupGroup2,
	SiteLicenseGroupLatam,
	SiteLicenseGroupMiddleEast,
	SiteLicenseGroupMorocco,
	SiteLicenseGroupNam,
	SiteLicenseGroupVietnam,
}

func (e SiteLicenseGroup) IsValid() bool {
	switch e {
	case SiteLicenseGroupAfrica, SiteLicenseGroupAnz, SiteLicenseGroupApj, SiteLicenseGroupChina, SiteLicenseGroupDubai, SiteLicenseGroupEurope, SiteLicenseGroupGroup1, SiteLicenseGroupGroup2, SiteLicenseGroupLatam, SiteLicenseGroupMiddleEast, SiteLicenseGroupMorocco, SiteLicenseGroupNam, SiteLicenseGroupVietnam:
		return true
	}
	return false
}

func (e SiteLicenseGroup) String() string {
	return string(e)
}

func (e *SiteLicenseGroup) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SiteLicenseGroup(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SiteLicenseGroup", str)
	}
	return nil
}

func (e SiteLicenseGroup) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *SiteLicenseGroup) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e SiteLicenseGroup) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type SiteLicenseType string

const (
	SiteLicenseTypeSase SiteLicenseType = "SASE"
	SiteLicenseTypeSse  SiteLicenseType = "SSE"
)

var AllSiteLicenseType = []SiteLicenseType{
	SiteLicenseTypeSase,
	SiteLicenseTypeSse,
}

func (e SiteLicenseType) IsValid() bool {
	switch e {
	case SiteLicenseTypeSase, SiteLicenseTypeSse:
		return true
	}
	return false
}

func (e SiteLicenseType) String() string {
	return string(e)
}

func (e *SiteLicenseType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SiteLicenseType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SiteLicenseType", str)
	}
	return nil
}

func (e SiteLicenseType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *SiteLicenseType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e SiteLicenseType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type SiteType string

const (
	SiteTypeBranch       SiteType = "BRANCH"
	SiteTypeCloudDc      SiteType = "CLOUD_DC"
	SiteTypeDatacenter   SiteType = "DATACENTER"
	SiteTypeHeadquarters SiteType = "HEADQUARTERS"
)

var AllSiteType = []SiteType{
	SiteTypeBranch,
	SiteTypeCloudDc,
	SiteTypeDatacenter,
	SiteTypeHeadquarters,
}

func (e SiteType) IsValid() bool {
	switch e {
	case SiteTypeBranch, SiteTypeCloudDc, SiteTypeDatacenter, SiteTypeHeadquarters:
		return true
	}
	return false
}

func (e SiteType) String() string {
	return string(e)
}

func (e *SiteType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SiteType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SiteType", str)
	}
	return nil
}

func (e SiteType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *SiteType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e SiteType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type SocketAddOnExpansionSlotNumber string

const (
	SocketAddOnExpansionSlotNumberSlot1 SocketAddOnExpansionSlotNumber = "SLOT_1"
	SocketAddOnExpansionSlotNumberSlot2 SocketAddOnExpansionSlotNumber = "SLOT_2"
)

var AllSocketAddOnExpansionSlotNumber = []SocketAddOnExpansionSlotNumber{
	SocketAddOnExpansionSlotNumberSlot1,
	SocketAddOnExpansionSlotNumberSlot2,
}

func (e SocketAddOnExpansionSlotNumber) IsValid() bool {
	switch e {
	case SocketAddOnExpansionSlotNumberSlot1, SocketAddOnExpansionSlotNumberSlot2:
		return true
	}
	return false
}

func (e SocketAddOnExpansionSlotNumber) String() string {
	return string(e)
}

func (e *SocketAddOnExpansionSlotNumber) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SocketAddOnExpansionSlotNumber(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SocketAddOnExpansionSlotNumber", str)
	}
	return nil
}

func (e SocketAddOnExpansionSlotNumber) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *SocketAddOnExpansionSlotNumber) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e SocketAddOnExpansionSlotNumber) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type SocketAddOnType string

const (
	SocketAddOnTypeFour10gFiber SocketAddOnType = "FOUR_10G_FIBER"
	SocketAddOnTypeFour1gCopper SocketAddOnType = "FOUR_1G_COPPER"
	SocketAddOnTypeTwo10gFiber  SocketAddOnType = "TWO_10G_FIBER"
	SocketAddOnTypeTwo1gFiber   SocketAddOnType = "TWO_1G_FIBER"
)

var AllSocketAddOnType = []SocketAddOnType{
	SocketAddOnTypeFour10gFiber,
	SocketAddOnTypeFour1gCopper,
	SocketAddOnTypeTwo10gFiber,
	SocketAddOnTypeTwo1gFiber,
}

func (e SocketAddOnType) IsValid() bool {
	switch e {
	case SocketAddOnTypeFour10gFiber, SocketAddOnTypeFour1gCopper, SocketAddOnTypeTwo10gFiber, SocketAddOnTypeTwo1gFiber:
		return true
	}
	return false
}

func (e SocketAddOnType) String() string {
	return string(e)
}

func (e *SocketAddOnType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SocketAddOnType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SocketAddOnType", str)
	}
	return nil
}

func (e SocketAddOnType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *SocketAddOnType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e SocketAddOnType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type SocketInterfaceDestType string

const (
	SocketInterfaceDestTypeAlternative         SocketInterfaceDestType = "ALTERNATIVE"
	SocketInterfaceDestTypeCato                SocketInterfaceDestType = "CATO"
	SocketInterfaceDestTypeInterfaceDisabled   SocketInterfaceDestType = "INTERFACE_DISABLED"
	SocketInterfaceDestTypeLan                 SocketInterfaceDestType = "LAN"
	SocketInterfaceDestTypeLanAndHa            SocketInterfaceDestType = "LAN_AND_HA"
	SocketInterfaceDestTypeLanLagMaster        SocketInterfaceDestType = "LAN_LAG_MASTER"
	SocketInterfaceDestTypeLanLagMasterAndVrrp SocketInterfaceDestType = "LAN_LAG_MASTER_AND_VRRP"
	SocketInterfaceDestTypeLanLagMember        SocketInterfaceDestType = "LAN_LAG_MEMBER"
	SocketInterfaceDestTypeLayer2Wan           SocketInterfaceDestType = "LAYER_2_WAN"
	SocketInterfaceDestTypeVrrp                SocketInterfaceDestType = "VRRP"
	SocketInterfaceDestTypeVrrpAndLan          SocketInterfaceDestType = "VRRP_AND_LAN"
)

var AllSocketInterfaceDestType = []SocketInterfaceDestType{
	SocketInterfaceDestTypeAlternative,
	SocketInterfaceDestTypeCato,
	SocketInterfaceDestTypeInterfaceDisabled,
	SocketInterfaceDestTypeLan,
	SocketInterfaceDestTypeLanAndHa,
	SocketInterfaceDestTypeLanLagMaster,
	SocketInterfaceDestTypeLanLagMasterAndVrrp,
	SocketInterfaceDestTypeLanLagMember,
	SocketInterfaceDestTypeLayer2Wan,
	SocketInterfaceDestTypeVrrp,
	SocketInterfaceDestTypeVrrpAndLan,
}

func (e SocketInterfaceDestType) IsValid() bool {
	switch e {
	case SocketInterfaceDestTypeAlternative, SocketInterfaceDestTypeCato, SocketInterfaceDestTypeInterfaceDisabled, SocketInterfaceDestTypeLan, SocketInterfaceDestTypeLanAndHa, SocketInterfaceDestTypeLanLagMaster, SocketInterfaceDestTypeLanLagMasterAndVrrp, SocketInterfaceDestTypeLanLagMember, SocketInterfaceDestTypeLayer2Wan, SocketInterfaceDestTypeVrrp, SocketInterfaceDestTypeVrrpAndLan:
		return true
	}
	return false
}

func (e SocketInterfaceDestType) String() string {
	return string(e)
}

func (e *SocketInterfaceDestType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SocketInterfaceDestType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SocketInterfaceDestType", str)
	}
	return nil
}

func (e SocketInterfaceDestType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *SocketInterfaceDestType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e SocketInterfaceDestType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// SocketInterface available ids, INT_# stands for 1,2,3...12 supported ids
type SocketInterfaceIDEnum string

const (
	SocketInterfaceIDEnumInt1  SocketInterfaceIDEnum = "INT_1"
	SocketInterfaceIDEnumInt10 SocketInterfaceIDEnum = "INT_10"
	SocketInterfaceIDEnumInt11 SocketInterfaceIDEnum = "INT_11"
	SocketInterfaceIDEnumInt12 SocketInterfaceIDEnum = "INT_12"
	SocketInterfaceIDEnumInt2  SocketInterfaceIDEnum = "INT_2"
	SocketInterfaceIDEnumInt3  SocketInterfaceIDEnum = "INT_3"
	SocketInterfaceIDEnumInt4  SocketInterfaceIDEnum = "INT_4"
	SocketInterfaceIDEnumInt5  SocketInterfaceIDEnum = "INT_5"
	SocketInterfaceIDEnumInt6  SocketInterfaceIDEnum = "INT_6"
	SocketInterfaceIDEnumInt7  SocketInterfaceIDEnum = "INT_7"
	SocketInterfaceIDEnumInt8  SocketInterfaceIDEnum = "INT_8"
	SocketInterfaceIDEnumInt9  SocketInterfaceIDEnum = "INT_9"
	SocketInterfaceIDEnumLan1  SocketInterfaceIDEnum = "LAN1"
	SocketInterfaceIDEnumLan2  SocketInterfaceIDEnum = "LAN2"
	SocketInterfaceIDEnumLte   SocketInterfaceIDEnum = "LTE"
	SocketInterfaceIDEnumUsb1  SocketInterfaceIDEnum = "USB1"
	SocketInterfaceIDEnumUsb2  SocketInterfaceIDEnum = "USB2"
	SocketInterfaceIDEnumWan1  SocketInterfaceIDEnum = "WAN1"
	SocketInterfaceIDEnumWan2  SocketInterfaceIDEnum = "WAN2"
	SocketInterfaceIDEnumWlan  SocketInterfaceIDEnum = "WLAN"
)

var AllSocketInterfaceIDEnum = []SocketInterfaceIDEnum{
	SocketInterfaceIDEnumInt1,
	SocketInterfaceIDEnumInt10,
	SocketInterfaceIDEnumInt11,
	SocketInterfaceIDEnumInt12,
	SocketInterfaceIDEnumInt2,
	SocketInterfaceIDEnumInt3,
	SocketInterfaceIDEnumInt4,
	SocketInterfaceIDEnumInt5,
	SocketInterfaceIDEnumInt6,
	SocketInterfaceIDEnumInt7,
	SocketInterfaceIDEnumInt8,
	SocketInterfaceIDEnumInt9,
	SocketInterfaceIDEnumLan1,
	SocketInterfaceIDEnumLan2,
	SocketInterfaceIDEnumLte,
	SocketInterfaceIDEnumUsb1,
	SocketInterfaceIDEnumUsb2,
	SocketInterfaceIDEnumWan1,
	SocketInterfaceIDEnumWan2,
	SocketInterfaceIDEnumWlan,
}

func (e SocketInterfaceIDEnum) IsValid() bool {
	switch e {
	case SocketInterfaceIDEnumInt1, SocketInterfaceIDEnumInt10, SocketInterfaceIDEnumInt11, SocketInterfaceIDEnumInt12, SocketInterfaceIDEnumInt2, SocketInterfaceIDEnumInt3, SocketInterfaceIDEnumInt4, SocketInterfaceIDEnumInt5, SocketInterfaceIDEnumInt6, SocketInterfaceIDEnumInt7, SocketInterfaceIDEnumInt8, SocketInterfaceIDEnumInt9, SocketInterfaceIDEnumLan1, SocketInterfaceIDEnumLan2, SocketInterfaceIDEnumLte, SocketInterfaceIDEnumUsb1, SocketInterfaceIDEnumUsb2, SocketInterfaceIDEnumWan1, SocketInterfaceIDEnumWan2, SocketInterfaceIDEnumWlan:
		return true
	}
	return false
}

func (e SocketInterfaceIDEnum) String() string {
	return string(e)
}

func (e *SocketInterfaceIDEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SocketInterfaceIDEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SocketInterfaceIDEnum", str)
	}
	return nil
}

func (e SocketInterfaceIDEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *SocketInterfaceIDEnum) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e SocketInterfaceIDEnum) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type SocketInterfacePrecedenceEnum string

const (
	SocketInterfacePrecedenceEnumActive     SocketInterfacePrecedenceEnum = "ACTIVE"
	SocketInterfacePrecedenceEnumLastResort SocketInterfacePrecedenceEnum = "LAST_RESORT"
	SocketInterfacePrecedenceEnumPassive    SocketInterfacePrecedenceEnum = "PASSIVE"
)

var AllSocketInterfacePrecedenceEnum = []SocketInterfacePrecedenceEnum{
	SocketInterfacePrecedenceEnumActive,
	SocketInterfacePrecedenceEnumLastResort,
	SocketInterfacePrecedenceEnumPassive,
}

func (e SocketInterfacePrecedenceEnum) IsValid() bool {
	switch e {
	case SocketInterfacePrecedenceEnumActive, SocketInterfacePrecedenceEnumLastResort, SocketInterfacePrecedenceEnumPassive:
		return true
	}
	return false
}

func (e SocketInterfacePrecedenceEnum) String() string {
	return string(e)
}

func (e *SocketInterfacePrecedenceEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SocketInterfacePrecedenceEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SocketInterfacePrecedenceEnum", str)
	}
	return nil
}

func (e SocketInterfacePrecedenceEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *SocketInterfacePrecedenceEnum) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e SocketInterfacePrecedenceEnum) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type SocketInterfaceRole string

const (
	SocketInterfaceRoleWan1 SocketInterfaceRole = "wan_1"
	SocketInterfaceRoleWan2 SocketInterfaceRole = "wan_2"
	SocketInterfaceRoleWan3 SocketInterfaceRole = "wan_3"
	SocketInterfaceRoleWan4 SocketInterfaceRole = "wan_4"
)

var AllSocketInterfaceRole = []SocketInterfaceRole{
	SocketInterfaceRoleWan1,
	SocketInterfaceRoleWan2,
	SocketInterfaceRoleWan3,
	SocketInterfaceRoleWan4,
}

func (e SocketInterfaceRole) IsValid() bool {
	switch e {
	case SocketInterfaceRoleWan1, SocketInterfaceRoleWan2, SocketInterfaceRoleWan3, SocketInterfaceRoleWan4:
		return true
	}
	return false
}

func (e SocketInterfaceRole) String() string {
	return string(e)
}

func (e *SocketInterfaceRole) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SocketInterfaceRole(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SocketInterfaceRole", str)
	}
	return nil
}

func (e SocketInterfaceRole) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *SocketInterfaceRole) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e SocketInterfaceRole) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type SocketInterfaceWanRole string

const (
	SocketInterfaceWanRoleNone  SocketInterfaceWanRole = "NONE"
	SocketInterfaceWanRoleWan1  SocketInterfaceWanRole = "WAN_1"
	SocketInterfaceWanRoleWan2  SocketInterfaceWanRole = "WAN_2"
	SocketInterfaceWanRoleWan3  SocketInterfaceWanRole = "WAN_3"
	SocketInterfaceWanRoleWan4  SocketInterfaceWanRole = "WAN_4"
	SocketInterfaceWanRolenone  SocketInterfaceWanRole = "none"
	SocketInterfaceWanRolewan_1 SocketInterfaceWanRole = "wan_1"
	SocketInterfaceWanRolewan_2 SocketInterfaceWanRole = "wan_2"
	SocketInterfaceWanRolewan_3 SocketInterfaceWanRole = "wan_3"
	SocketInterfaceWanRolewan_4 SocketInterfaceWanRole = "wan_4"
)

var AllSocketInterfaceWanRole = []SocketInterfaceWanRole{
	SocketInterfaceWanRoleNone,
	SocketInterfaceWanRoleWan1,
	SocketInterfaceWanRoleWan2,
	SocketInterfaceWanRoleWan3,
	SocketInterfaceWanRoleWan4,
	SocketInterfaceWanRolenone,
	SocketInterfaceWanRolewan_1,
	SocketInterfaceWanRolewan_2,
	SocketInterfaceWanRolewan_3,
	SocketInterfaceWanRolewan_4,
}

func (e SocketInterfaceWanRole) IsValid() bool {
	switch e {
	case SocketInterfaceWanRoleNone, SocketInterfaceWanRoleWan1, SocketInterfaceWanRoleWan2, SocketInterfaceWanRoleWan3, SocketInterfaceWanRoleWan4, SocketInterfaceWanRolenone, SocketInterfaceWanRolewan_1, SocketInterfaceWanRolewan_2, SocketInterfaceWanRolewan_3, SocketInterfaceWanRolewan_4:
		return true
	}
	return false
}

func (e SocketInterfaceWanRole) String() string {
	return string(e)
}

func (e *SocketInterfaceWanRole) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SocketInterfaceWanRole(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SocketInterfaceWanRole", str)
	}
	return nil
}

func (e SocketInterfaceWanRole) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *SocketInterfaceWanRole) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e SocketInterfaceWanRole) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type SocketInventoryItemStatus string

const (
	SocketInventoryItemStatusConnected SocketInventoryItemStatus = "CONNECTED"
	SocketInventoryItemStatusDelivered SocketInventoryItemStatus = "DELIVERED"
	SocketInventoryItemStatusInstalled SocketInventoryItemStatus = "INSTALLED"
	SocketInventoryItemStatusOrdered   SocketInventoryItemStatus = "ORDERED"
	SocketInventoryItemStatusShipped   SocketInventoryItemStatus = "SHIPPED"
)

var AllSocketInventoryItemStatus = []SocketInventoryItemStatus{
	SocketInventoryItemStatusConnected,
	SocketInventoryItemStatusDelivered,
	SocketInventoryItemStatusInstalled,
	SocketInventoryItemStatusOrdered,
	SocketInventoryItemStatusShipped,
}

func (e SocketInventoryItemStatus) IsValid() bool {
	switch e {
	case SocketInventoryItemStatusConnected, SocketInventoryItemStatusDelivered, SocketInventoryItemStatusInstalled, SocketInventoryItemStatusOrdered, SocketInventoryItemStatusShipped:
		return true
	}
	return false
}

func (e SocketInventoryItemStatus) String() string {
	return string(e)
}

func (e *SocketInventoryItemStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SocketInventoryItemStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SocketInventoryItemStatus", str)
	}
	return nil
}

func (e SocketInventoryItemStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *SocketInventoryItemStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e SocketInventoryItemStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type SocketLanDirection string

const (
	// Specifies two-way direction.
	SocketLanDirectionBoth SocketLanDirection = "BOTH"
	// Specifies one-way direction.
	SocketLanDirectionTo SocketLanDirection = "TO"
)

var AllSocketLanDirection = []SocketLanDirection{
	SocketLanDirectionBoth,
	SocketLanDirectionTo,
}

func (e SocketLanDirection) IsValid() bool {
	switch e {
	case SocketLanDirectionBoth, SocketLanDirectionTo:
		return true
	}
	return false
}

func (e SocketLanDirection) String() string {
	return string(e)
}

func (e *SocketLanDirection) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SocketLanDirection(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SocketLanDirection", str)
	}
	return nil
}

func (e SocketLanDirection) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *SocketLanDirection) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e SocketLanDirection) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type SocketLanFirewallAction string

const (
	SocketLanFirewallActionAllow SocketLanFirewallAction = "ALLOW"
	SocketLanFirewallActionBlock SocketLanFirewallAction = "BLOCK"
)

var AllSocketLanFirewallAction = []SocketLanFirewallAction{
	SocketLanFirewallActionAllow,
	SocketLanFirewallActionBlock,
}

func (e SocketLanFirewallAction) IsValid() bool {
	switch e {
	case SocketLanFirewallActionAllow, SocketLanFirewallActionBlock:
		return true
	}
	return false
}

func (e SocketLanFirewallAction) String() string {
	return string(e)
}

func (e *SocketLanFirewallAction) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SocketLanFirewallAction(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SocketLanFirewallAction", str)
	}
	return nil
}

func (e SocketLanFirewallAction) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *SocketLanFirewallAction) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e SocketLanFirewallAction) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type SocketLanFirewallDirection string

const (
	// Specifies two-way direction.
	SocketLanFirewallDirectionBoth SocketLanFirewallDirection = "BOTH"
	// Specifies one-way direction.
	SocketLanFirewallDirectionTo SocketLanFirewallDirection = "TO"
)

var AllSocketLanFirewallDirection = []SocketLanFirewallDirection{
	SocketLanFirewallDirectionBoth,
	SocketLanFirewallDirectionTo,
}

func (e SocketLanFirewallDirection) IsValid() bool {
	switch e {
	case SocketLanFirewallDirectionBoth, SocketLanFirewallDirectionTo:
		return true
	}
	return false
}

func (e SocketLanFirewallDirection) String() string {
	return string(e)
}

func (e *SocketLanFirewallDirection) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SocketLanFirewallDirection(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SocketLanFirewallDirection", str)
	}
	return nil
}

func (e SocketLanFirewallDirection) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *SocketLanFirewallDirection) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e SocketLanFirewallDirection) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type SocketLanNatType string

const (
	SocketLanNatTypeDynamicPat SocketLanNatType = "DYNAMIC_PAT"
)

var AllSocketLanNatType = []SocketLanNatType{
	SocketLanNatTypeDynamicPat,
}

func (e SocketLanNatType) IsValid() bool {
	switch e {
	case SocketLanNatTypeDynamicPat:
		return true
	}
	return false
}

func (e SocketLanNatType) String() string {
	return string(e)
}

func (e *SocketLanNatType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SocketLanNatType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SocketLanNatType", str)
	}
	return nil
}

func (e SocketLanNatType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *SocketLanNatType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e SocketLanNatType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type SocketLanTransportType string

const (
	// Specifies LAN transport type, routed locally for  inspection of LAN Firewall.
	SocketLanTransportTypeLan SocketLanTransportType = "LAN"
	// Specifies WAN transport type, send to the PoP for inspection of WAN Firewall.
	SocketLanTransportTypeWan SocketLanTransportType = "WAN"
)

var AllSocketLanTransportType = []SocketLanTransportType{
	SocketLanTransportTypeLan,
	SocketLanTransportTypeWan,
}

func (e SocketLanTransportType) IsValid() bool {
	switch e {
	case SocketLanTransportTypeLan, SocketLanTransportTypeWan:
		return true
	}
	return false
}

func (e SocketLanTransportType) String() string {
	return string(e)
}

func (e *SocketLanTransportType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SocketLanTransportType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SocketLanTransportType", str)
	}
	return nil
}

func (e SocketLanTransportType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *SocketLanTransportType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e SocketLanTransportType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type SocketPlatform string

const (
	SocketPlatformAWS1500   SocketPlatform = "AWS1500"
	SocketPlatformAz1500    SocketPlatform = "AZ1500"
	SocketPlatformEsx1500   SocketPlatform = "ESX1500"
	SocketPlatformGCP1500   SocketPlatform = "GCP1500"
	SocketPlatformX1500     SocketPlatform = "X1500"
	SocketPlatformX1500Br2  SocketPlatform = "X1500_BR2"
	SocketPlatformX1500bBr2 SocketPlatform = "X1500B_BR2"
	SocketPlatformX1600     SocketPlatform = "X1600"
	SocketPlatformX1600Lte  SocketPlatform = "X1600_LTE"
	SocketPlatformX1700     SocketPlatform = "X1700"
	SocketPlatformX1700b    SocketPlatform = "X1700B"
)

var AllSocketPlatform = []SocketPlatform{
	SocketPlatformAWS1500,
	SocketPlatformAz1500,
	SocketPlatformEsx1500,
	SocketPlatformGCP1500,
	SocketPlatformX1500,
	SocketPlatformX1500Br2,
	SocketPlatformX1500bBr2,
	SocketPlatformX1600,
	SocketPlatformX1600Lte,
	SocketPlatformX1700,
	SocketPlatformX1700b,
}

func (e SocketPlatform) IsValid() bool {
	switch e {
	case SocketPlatformAWS1500, SocketPlatformAz1500, SocketPlatformEsx1500, SocketPlatformGCP1500, SocketPlatformX1500, SocketPlatformX1500Br2, SocketPlatformX1500bBr2, SocketPlatformX1600, SocketPlatformX1600Lte, SocketPlatformX1700, SocketPlatformX1700b:
		return true
	}
	return false
}

func (e SocketPlatform) String() string {
	return string(e)
}

func (e *SocketPlatform) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SocketPlatform(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SocketPlatform", str)
	}
	return nil
}

func (e SocketPlatform) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *SocketPlatform) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e SocketPlatform) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type SocketPortMetricsFieldName string

const (
	// Unique identifier of the account that owns the site.
	SocketPortMetricsFieldNameAccountID SocketPortMetricsFieldName = "account_id"
	// Total bytes received downstream (from the network to the device).
	SocketPortMetricsFieldNameBytesDownstream SocketPortMetricsFieldName = "bytes_downstream"
	// Combined total of upstream and downstream bytes.
	SocketPortMetricsFieldNameBytesTotal SocketPortMetricsFieldName = "bytes_total"
	// Total bytes sent upstream (from the device to the network).
	SocketPortMetricsFieldNameBytesUpstream SocketPortMetricsFieldName = "bytes_upstream"
	// Reference Signal Received Power – measures LTE/5G signal strength (dBm).
	SocketPortMetricsFieldNameCellularRsrp SocketPortMetricsFieldName = "cellular_rsrp"
	// Reference Signal Received Quality – a key LTE/5G metric for link quality (dB).
	SocketPortMetricsFieldNameCellularRsrq SocketPortMetricsFieldName = "cellular_rsrq"
	// Received Signal Strength Indicator – legacy strength metric (dBm).
	SocketPortMetricsFieldNameCellularRssi SocketPortMetricsFieldName = "cellular_rssi"
	// Generic signal strength indicator (often maps to bars or percentage).
	SocketPortMetricsFieldNameCellularSignalStrength SocketPortMetricsFieldName = "cellular_signal_strength"
	// Signal to Interference + Noise Ratio – LTE/5G metric for signal clarity (dB).
	SocketPortMetricsFieldNameCellularSinr SocketPortMetricsFieldName = "cellular_sinr"
	// Unique identifier of the Socket (Cato edge device).
	SocketPortMetricsFieldNameDeviceID SocketPortMetricsFieldName = "device_id"
	// Indicates the high-availability (HA) role of the device (e.g., active, standby).
	SocketPortMetricsFieldNameHaRole SocketPortMetricsFieldName = "ha_role"
	// Type of physical interface (e.g., ethernet, cellular).
	SocketPortMetricsFieldNamePhysicalInterfaceType SocketPortMetricsFieldName = "physical_interface_type"
	// SIM card number (for cellular interfaces).
	SocketPortMetricsFieldNameSimNum SocketPortMetricsFieldName = "sim_num"
	// Unique identifier of the site where the socket is deployed.
	SocketPortMetricsFieldNameSiteID SocketPortMetricsFieldName = "site_id"
	// Human-readable name of the site.
	SocketPortMetricsFieldNameSiteName SocketPortMetricsFieldName = "site_name"
	// The name or ID of the physical or logical interface on the Socket device (e.g., eth0, cell1).
	SocketPortMetricsFieldNameSocketInterface SocketPortMetricsFieldName = "socket_interface"
	// Describes the interface role such as primary, backup, cellular, or none.
	SocketPortMetricsFieldNameSocketInterfaceRole SocketPortMetricsFieldName = "socket_interface_role"
	// Current download throughput in Mbps.
	SocketPortMetricsFieldNameThroughputDownstream SocketPortMetricsFieldName = "throughput_downstream"
	// Current upload throughput in Mbps.
	SocketPortMetricsFieldNameThroughputUpstream SocketPortMetricsFieldName = "throughput_upstream"
	// Type of transport used by the interface (e.g., wired, lte, 5g, wifi).
	SocketPortMetricsFieldNameTransportType SocketPortMetricsFieldName = "transport_type"
)

var AllSocketPortMetricsFieldName = []SocketPortMetricsFieldName{
	SocketPortMetricsFieldNameAccountID,
	SocketPortMetricsFieldNameBytesDownstream,
	SocketPortMetricsFieldNameBytesTotal,
	SocketPortMetricsFieldNameBytesUpstream,
	SocketPortMetricsFieldNameCellularRsrp,
	SocketPortMetricsFieldNameCellularRsrq,
	SocketPortMetricsFieldNameCellularRssi,
	SocketPortMetricsFieldNameCellularSignalStrength,
	SocketPortMetricsFieldNameCellularSinr,
	SocketPortMetricsFieldNameDeviceID,
	SocketPortMetricsFieldNameHaRole,
	SocketPortMetricsFieldNamePhysicalInterfaceType,
	SocketPortMetricsFieldNameSimNum,
	SocketPortMetricsFieldNameSiteID,
	SocketPortMetricsFieldNameSiteName,
	SocketPortMetricsFieldNameSocketInterface,
	SocketPortMetricsFieldNameSocketInterfaceRole,
	SocketPortMetricsFieldNameThroughputDownstream,
	SocketPortMetricsFieldNameThroughputUpstream,
	SocketPortMetricsFieldNameTransportType,
}

func (e SocketPortMetricsFieldName) IsValid() bool {
	switch e {
	case SocketPortMetricsFieldNameAccountID, SocketPortMetricsFieldNameBytesDownstream, SocketPortMetricsFieldNameBytesTotal, SocketPortMetricsFieldNameBytesUpstream, SocketPortMetricsFieldNameCellularRsrp, SocketPortMetricsFieldNameCellularRsrq, SocketPortMetricsFieldNameCellularRssi, SocketPortMetricsFieldNameCellularSignalStrength, SocketPortMetricsFieldNameCellularSinr, SocketPortMetricsFieldNameDeviceID, SocketPortMetricsFieldNameHaRole, SocketPortMetricsFieldNamePhysicalInterfaceType, SocketPortMetricsFieldNameSimNum, SocketPortMetricsFieldNameSiteID, SocketPortMetricsFieldNameSiteName, SocketPortMetricsFieldNameSocketInterface, SocketPortMetricsFieldNameSocketInterfaceRole, SocketPortMetricsFieldNameThroughputDownstream, SocketPortMetricsFieldNameThroughputUpstream, SocketPortMetricsFieldNameTransportType:
		return true
	}
	return false
}

func (e SocketPortMetricsFieldName) String() string {
	return string(e)
}

func (e *SocketPortMetricsFieldName) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SocketPortMetricsFieldName(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SocketPortMetricsFieldName", str)
	}
	return nil
}

func (e SocketPortMetricsFieldName) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *SocketPortMetricsFieldName) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e SocketPortMetricsFieldName) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type SocketRegistrationStatus string

const (
	SocketRegistrationStatusAssignedSite                SocketRegistrationStatus = "ASSIGNED_SITE"
	SocketRegistrationStatusAssignedSitePendingRegister SocketRegistrationStatus = "ASSIGNED_SITE_PENDING_REGISTER"
	SocketRegistrationStatusNew                         SocketRegistrationStatus = "NEW"
	SocketRegistrationStatusPending                     SocketRegistrationStatus = "PENDING"
	SocketRegistrationStatusRegistered                  SocketRegistrationStatus = "REGISTERED"
	SocketRegistrationStatusRejected                    SocketRegistrationStatus = "REJECTED"
	SocketRegistrationStatusUnassigning                 SocketRegistrationStatus = "UNASSIGNING"
)

var AllSocketRegistrationStatus = []SocketRegistrationStatus{
	SocketRegistrationStatusAssignedSite,
	SocketRegistrationStatusAssignedSitePendingRegister,
	SocketRegistrationStatusNew,
	SocketRegistrationStatusPending,
	SocketRegistrationStatusRegistered,
	SocketRegistrationStatusRejected,
	SocketRegistrationStatusUnassigning,
}

func (e SocketRegistrationStatus) IsValid() bool {
	switch e {
	case SocketRegistrationStatusAssignedSite, SocketRegistrationStatusAssignedSitePendingRegister, SocketRegistrationStatusNew, SocketRegistrationStatusPending, SocketRegistrationStatusRegistered, SocketRegistrationStatusRejected, SocketRegistrationStatusUnassigning:
		return true
	}
	return false
}

func (e SocketRegistrationStatus) String() string {
	return string(e)
}

func (e *SocketRegistrationStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SocketRegistrationStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SocketRegistrationStatus", str)
	}
	return nil
}

func (e SocketRegistrationStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *SocketRegistrationStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e SocketRegistrationStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type SocketUpgradeStatus string

const (
	SocketUpgradeStatusCancel        SocketUpgradeStatus = "CANCEL"
	SocketUpgradeStatusFail          SocketUpgradeStatus = "FAIL"
	SocketUpgradeStatusFatal         SocketUpgradeStatus = "FATAL"
	SocketUpgradeStatusPending       SocketUpgradeStatus = "PENDING"
	SocketUpgradeStatusPendingReboot SocketUpgradeStatus = "PENDING_REBOOT"
	SocketUpgradeStatusRetry         SocketUpgradeStatus = "RETRY"
	SocketUpgradeStatusSkip          SocketUpgradeStatus = "SKIP"
	SocketUpgradeStatusStarted       SocketUpgradeStatus = "STARTED"
	SocketUpgradeStatusStarting      SocketUpgradeStatus = "STARTING"
	SocketUpgradeStatusSuccess       SocketUpgradeStatus = "SUCCESS"
)

var AllSocketUpgradeStatus = []SocketUpgradeStatus{
	SocketUpgradeStatusCancel,
	SocketUpgradeStatusFail,
	SocketUpgradeStatusFatal,
	SocketUpgradeStatusPending,
	SocketUpgradeStatusPendingReboot,
	SocketUpgradeStatusRetry,
	SocketUpgradeStatusSkip,
	SocketUpgradeStatusStarted,
	SocketUpgradeStatusStarting,
	SocketUpgradeStatusSuccess,
}

func (e SocketUpgradeStatus) IsValid() bool {
	switch e {
	case SocketUpgradeStatusCancel, SocketUpgradeStatusFail, SocketUpgradeStatusFatal, SocketUpgradeStatusPending, SocketUpgradeStatusPendingReboot, SocketUpgradeStatusRetry, SocketUpgradeStatusSkip, SocketUpgradeStatusStarted, SocketUpgradeStatusStarting, SocketUpgradeStatusSuccess:
		return true
	}
	return false
}

func (e SocketUpgradeStatus) String() string {
	return string(e)
}

func (e *SocketUpgradeStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SocketUpgradeStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SocketUpgradeStatus", str)
	}
	return nil
}

func (e SocketUpgradeStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *SocketUpgradeStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e SocketUpgradeStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type SortDirectionEnum string

const (
	SortDirectionEnumAsc  SortDirectionEnum = "asc"
	SortDirectionEnumDesc SortDirectionEnum = "desc"
)

var AllSortDirectionEnum = []SortDirectionEnum{
	SortDirectionEnumAsc,
	SortDirectionEnumDesc,
}

func (e SortDirectionEnum) IsValid() bool {
	switch e {
	case SortDirectionEnumAsc, SortDirectionEnumDesc:
		return true
	}
	return false
}

func (e SortDirectionEnum) String() string {
	return string(e)
}

func (e *SortDirectionEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SortDirectionEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SortDirectionEnum", str)
	}
	return nil
}

func (e SortDirectionEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *SortDirectionEnum) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e SortDirectionEnum) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type SortOrder string

const (
	SortOrderAsc  SortOrder = "ASC"
	SortOrderDesc SortOrder = "DESC"
)

var AllSortOrder = []SortOrder{
	SortOrderAsc,
	SortOrderDesc,
}

func (e SortOrder) IsValid() bool {
	switch e {
	case SortOrderAsc, SortOrderDesc:
		return true
	}
	return false
}

func (e SortOrder) String() string {
	return string(e)
}

func (e *SortOrder) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SortOrder(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SortOrder", str)
	}
	return nil
}

func (e SortOrder) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *SortOrder) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e SortOrder) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type StoryEngineTypeEnum string

const (
	StoryEngineTypeEnumAnomaly  StoryEngineTypeEnum = "ANOMALY"
	StoryEngineTypeEnumEndpoint StoryEngineTypeEnum = "ENDPOINT"
	StoryEngineTypeEnumIdentity StoryEngineTypeEnum = "IDENTITY"
	StoryEngineTypeEnumNetwork  StoryEngineTypeEnum = "NETWORK"
	StoryEngineTypeEnumThreat   StoryEngineTypeEnum = "THREAT"
)

var AllStoryEngineTypeEnum = []StoryEngineTypeEnum{
	StoryEngineTypeEnumAnomaly,
	StoryEngineTypeEnumEndpoint,
	StoryEngineTypeEnumIdentity,
	StoryEngineTypeEnumNetwork,
	StoryEngineTypeEnumThreat,
}

func (e StoryEngineTypeEnum) IsValid() bool {
	switch e {
	case StoryEngineTypeEnumAnomaly, StoryEngineTypeEnumEndpoint, StoryEngineTypeEnumIdentity, StoryEngineTypeEnumNetwork, StoryEngineTypeEnumThreat:
		return true
	}
	return false
}

func (e StoryEngineTypeEnum) String() string {
	return string(e)
}

func (e *StoryEngineTypeEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StoryEngineTypeEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StoryEngineTypeEnum", str)
	}
	return nil
}

func (e StoryEngineTypeEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *StoryEngineTypeEnum) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e StoryEngineTypeEnum) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type StoryProducerEnum string

const (
	StoryProducerEnumAnomalyEvents             StoryProducerEnum = "AnomalyEvents"
	StoryProducerEnumAnomalyExperience         StoryProducerEnum = "AnomalyExperience"
	StoryProducerEnumAnomalyStats              StoryProducerEnum = "AnomalyStats"
	StoryProducerEnumCatoEndpointAlert         StoryProducerEnum = "CatoEndpointAlert"
	StoryProducerEnumEntraIDAlert              StoryProducerEnum = "EntraIdAlert"
	StoryProducerEnumMicrosoftEndpointDefender StoryProducerEnum = "MicrosoftEndpointDefender"
	StoryProducerEnumNetworkMonitor            StoryProducerEnum = "NetworkMonitor"
	// The producer of the Site Operations stories
	StoryProducerEnumNetworkXdr       StoryProducerEnum = "NetworkXDR"
	StoryProducerEnumThreatHunt       StoryProducerEnum = "ThreatHunt"
	StoryProducerEnumThreatPrevention StoryProducerEnum = "ThreatPrevention"
)

var AllStoryProducerEnum = []StoryProducerEnum{
	StoryProducerEnumAnomalyEvents,
	StoryProducerEnumAnomalyExperience,
	StoryProducerEnumAnomalyStats,
	StoryProducerEnumCatoEndpointAlert,
	StoryProducerEnumEntraIDAlert,
	StoryProducerEnumMicrosoftEndpointDefender,
	StoryProducerEnumNetworkMonitor,
	StoryProducerEnumNetworkXdr,
	StoryProducerEnumThreatHunt,
	StoryProducerEnumThreatPrevention,
}

func (e StoryProducerEnum) IsValid() bool {
	switch e {
	case StoryProducerEnumAnomalyEvents, StoryProducerEnumAnomalyExperience, StoryProducerEnumAnomalyStats, StoryProducerEnumCatoEndpointAlert, StoryProducerEnumEntraIDAlert, StoryProducerEnumMicrosoftEndpointDefender, StoryProducerEnumNetworkMonitor, StoryProducerEnumNetworkXdr, StoryProducerEnumThreatHunt, StoryProducerEnumThreatPrevention:
		return true
	}
	return false
}

func (e StoryProducerEnum) String() string {
	return string(e)
}

func (e *StoryProducerEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StoryProducerEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StoryProducerEnum", str)
	}
	return nil
}

func (e StoryProducerEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *StoryProducerEnum) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e StoryProducerEnum) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type StorySortFieldName string

const (
	StorySortFieldNameAccountName StorySortFieldName = "accountName"
	StorySortFieldNameCreatedAt   StorySortFieldName = "createdAt"
	StorySortFieldNameCriticality StorySortFieldName = "criticality"
	StorySortFieldNameEngineType  StorySortFieldName = "engineType"
	StorySortFieldNameFirstSignal StorySortFieldName = "firstSignal"
	StorySortFieldNameProducer    StorySortFieldName = "producer"
	StorySortFieldNameQueryName   StorySortFieldName = "queryName"
	StorySortFieldNameRiskScore   StorySortFieldName = "riskScore"
	StorySortFieldNameSeverity    StorySortFieldName = "severity"
	StorySortFieldNameSource      StorySortFieldName = "source"
	StorySortFieldNameSourceIP    StorySortFieldName = "sourceIp"
	StorySortFieldNameStatus      StorySortFieldName = "status"
	StorySortFieldNameUpdatedAt   StorySortFieldName = "updatedAt"
)

var AllStorySortFieldName = []StorySortFieldName{
	StorySortFieldNameAccountName,
	StorySortFieldNameCreatedAt,
	StorySortFieldNameCriticality,
	StorySortFieldNameEngineType,
	StorySortFieldNameFirstSignal,
	StorySortFieldNameProducer,
	StorySortFieldNameQueryName,
	StorySortFieldNameRiskScore,
	StorySortFieldNameSeverity,
	StorySortFieldNameSource,
	StorySortFieldNameSourceIP,
	StorySortFieldNameStatus,
	StorySortFieldNameUpdatedAt,
}

func (e StorySortFieldName) IsValid() bool {
	switch e {
	case StorySortFieldNameAccountName, StorySortFieldNameCreatedAt, StorySortFieldNameCriticality, StorySortFieldNameEngineType, StorySortFieldNameFirstSignal, StorySortFieldNameProducer, StorySortFieldNameQueryName, StorySortFieldNameRiskScore, StorySortFieldNameSeverity, StorySortFieldNameSource, StorySortFieldNameSourceIP, StorySortFieldNameStatus, StorySortFieldNameUpdatedAt:
		return true
	}
	return false
}

func (e StorySortFieldName) String() string {
	return string(e)
}

func (e *StorySortFieldName) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StorySortFieldName(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StorySortFieldName", str)
	}
	return nil
}

func (e StorySortFieldName) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *StorySortFieldName) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e StorySortFieldName) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type StoryStatusEnum string

const (
	StoryStatusEnumClosed          StoryStatusEnum = "Closed"
	StoryStatusEnumMonitoring      StoryStatusEnum = "Monitoring"
	StoryStatusEnumOpen            StoryStatusEnum = "Open"
	StoryStatusEnumPendingAnalysis StoryStatusEnum = "PendingAnalysis"
	StoryStatusEnumPendingMoreInfo StoryStatusEnum = "PendingMoreInfo"
	StoryStatusEnumReopened        StoryStatusEnum = "Reopened"
)

var AllStoryStatusEnum = []StoryStatusEnum{
	StoryStatusEnumClosed,
	StoryStatusEnumMonitoring,
	StoryStatusEnumOpen,
	StoryStatusEnumPendingAnalysis,
	StoryStatusEnumPendingMoreInfo,
	StoryStatusEnumReopened,
}

func (e StoryStatusEnum) IsValid() bool {
	switch e {
	case StoryStatusEnumClosed, StoryStatusEnumMonitoring, StoryStatusEnumOpen, StoryStatusEnumPendingAnalysis, StoryStatusEnumPendingMoreInfo, StoryStatusEnumReopened:
		return true
	}
	return false
}

func (e StoryStatusEnum) String() string {
	return string(e)
}

func (e *StoryStatusEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StoryStatusEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StoryStatusEnum", str)
	}
	return nil
}

func (e StoryStatusEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *StoryStatusEnum) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e StoryStatusEnum) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type StoryVerdictEnum string

const (
	StoryVerdictEnumBenign        StoryVerdictEnum = "Benign"
	StoryVerdictEnumInformational StoryVerdictEnum = "Informational"
	StoryVerdictEnumMalicious     StoryVerdictEnum = "Malicious"
	StoryVerdictEnumSuspicious    StoryVerdictEnum = "Suspicious"
)

var AllStoryVerdictEnum = []StoryVerdictEnum{
	StoryVerdictEnumBenign,
	StoryVerdictEnumInformational,
	StoryVerdictEnumMalicious,
	StoryVerdictEnumSuspicious,
}

func (e StoryVerdictEnum) IsValid() bool {
	switch e {
	case StoryVerdictEnumBenign, StoryVerdictEnumInformational, StoryVerdictEnumMalicious, StoryVerdictEnumSuspicious:
		return true
	}
	return false
}

func (e StoryVerdictEnum) String() string {
	return string(e)
}

func (e *StoryVerdictEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StoryVerdictEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StoryVerdictEnum", str)
	}
	return nil
}

func (e StoryVerdictEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *StoryVerdictEnum) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e StoryVerdictEnum) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type SubnetType string

const (
	SubnetTypeDirect          SubnetType = "Direct"
	SubnetTypeNative          SubnetType = "Native"
	SubnetTypeRouted          SubnetType = "Routed"
	SubnetTypeSecondaryNative SubnetType = "SecondaryNative"
	SubnetTypeVlan            SubnetType = "VLAN"
)

var AllSubnetType = []SubnetType{
	SubnetTypeDirect,
	SubnetTypeNative,
	SubnetTypeRouted,
	SubnetTypeSecondaryNative,
	SubnetTypeVlan,
}

func (e SubnetType) IsValid() bool {
	switch e {
	case SubnetTypeDirect, SubnetTypeNative, SubnetTypeRouted, SubnetTypeSecondaryNative, SubnetTypeVlan:
		return true
	}
	return false
}

func (e SubnetType) String() string {
	return string(e)
}

func (e *SubnetType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SubnetType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SubnetType", str)
	}
	return nil
}

func (e SubnetType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *SubnetType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e SubnetType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type TaggingMethod string

const (
	TaggingMethodDot1q TaggingMethod = "DOT1Q"
	TaggingMethodQinq  TaggingMethod = "QINQ"
)

var AllTaggingMethod = []TaggingMethod{
	TaggingMethodDot1q,
	TaggingMethodQinq,
}

func (e TaggingMethod) IsValid() bool {
	switch e {
	case TaggingMethodDot1q, TaggingMethodQinq:
		return true
	}
	return false
}

func (e TaggingMethod) String() string {
	return string(e)
}

func (e *TaggingMethod) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TaggingMethod(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TaggingMethod", str)
	}
	return nil
}

func (e TaggingMethod) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *TaggingMethod) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e TaggingMethod) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type TargetType string

const (
	TargetTypeDomain TargetType = "domain"
	TargetTypeFqdn   TargetType = "fqdn"
	TargetTypeIP     TargetType = "ip"
	TargetTypeURL    TargetType = "url"
)

var AllTargetType = []TargetType{
	TargetTypeDomain,
	TargetTypeFqdn,
	TargetTypeIP,
	TargetTypeURL,
}

func (e TargetType) IsValid() bool {
	switch e {
	case TargetTypeDomain, TargetTypeFqdn, TargetTypeIP, TargetTypeURL:
		return true
	}
	return false
}

func (e TargetType) String() string {
	return string(e)
}

func (e *TargetType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TargetType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TargetType", str)
	}
	return nil
}

func (e TargetType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *TargetType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e TargetType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type TimeFrameModifier string

const (
	TimeFrameModifierAnalystUpdate TimeFrameModifier = "AnalystUpdate"
	TimeFrameModifierStoryCreate   TimeFrameModifier = "StoryCreate"
	TimeFrameModifierStoryUpdate   TimeFrameModifier = "StoryUpdate"
)

var AllTimeFrameModifier = []TimeFrameModifier{
	TimeFrameModifierAnalystUpdate,
	TimeFrameModifierStoryCreate,
	TimeFrameModifierStoryUpdate,
}

func (e TimeFrameModifier) IsValid() bool {
	switch e {
	case TimeFrameModifierAnalystUpdate, TimeFrameModifierStoryCreate, TimeFrameModifierStoryUpdate:
		return true
	}
	return false
}

func (e TimeFrameModifier) String() string {
	return string(e)
}

func (e *TimeFrameModifier) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TimeFrameModifier(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TimeFrameModifier", str)
	}
	return nil
}

func (e TimeFrameModifier) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *TimeFrameModifier) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e TimeFrameModifier) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type TimelineItemCategoryEnum string

const (
	TimelineItemCategoryEnumError       TimelineItemCategoryEnum = "Error"
	TimelineItemCategoryEnumInformation TimelineItemCategoryEnum = "Information"
	TimelineItemCategoryEnumWarning     TimelineItemCategoryEnum = "Warning"
)

var AllTimelineItemCategoryEnum = []TimelineItemCategoryEnum{
	TimelineItemCategoryEnumError,
	TimelineItemCategoryEnumInformation,
	TimelineItemCategoryEnumWarning,
}

func (e TimelineItemCategoryEnum) IsValid() bool {
	switch e {
	case TimelineItemCategoryEnumError, TimelineItemCategoryEnumInformation, TimelineItemCategoryEnumWarning:
		return true
	}
	return false
}

func (e TimelineItemCategoryEnum) String() string {
	return string(e)
}

func (e *TimelineItemCategoryEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TimelineItemCategoryEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TimelineItemCategoryEnum", str)
	}
	return nil
}

func (e TimelineItemCategoryEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *TimelineItemCategoryEnum) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e TimelineItemCategoryEnum) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type TimelineTypeEnum string

const (
	TimelineTypeEnumAction  TimelineTypeEnum = "Action"
	TimelineTypeEnumComment TimelineTypeEnum = "Comment"
	TimelineTypeEnumDiff    TimelineTypeEnum = "Diff"
)

var AllTimelineTypeEnum = []TimelineTypeEnum{
	TimelineTypeEnumAction,
	TimelineTypeEnumComment,
	TimelineTypeEnumDiff,
}

func (e TimelineTypeEnum) IsValid() bool {
	switch e {
	case TimelineTypeEnumAction, TimelineTypeEnumComment, TimelineTypeEnumDiff:
		return true
	}
	return false
}

func (e TimelineTypeEnum) String() string {
	return string(e)
}

func (e *TimelineTypeEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TimelineTypeEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TimelineTypeEnum", str)
	}
	return nil
}

func (e TimelineTypeEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *TimelineTypeEnum) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e TimelineTypeEnum) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type TimeseriesMetricType string

const (
	// Total avg downstream traffic (from the Cato Cloud to the site)
	TimeseriesMetricTypeBytesDownstream TimeseriesMetricType = "bytesDownstream"
	// Total max downstream traffic (from the site to the Cato Cloud)
	TimeseriesMetricTypeBytesDownstreamMax TimeseriesMetricType = "bytesDownstreamMax"
	// Total number of bytes of upstream and downstream traffic
	TimeseriesMetricTypeBytesTotal TimeseriesMetricType = "bytesTotal"
	// Total avg upstream traffic (from the site to the Cato Cloud)
	TimeseriesMetricTypeBytesUpstream TimeseriesMetricType = "bytesUpstream"
	// Total max upstream traffic (from the site to the Cato Cloud)
	TimeseriesMetricTypeBytesUpstreamMax TimeseriesMetricType = "bytesUpstreamMax"
	// Health analytics for the site
	TimeseriesMetricTypeHealth TimeseriesMetricType = "health"
	// Jitter for downstream traffic (difference in time delay in milliseconds (ms) between data packets)
	TimeseriesMetricTypeJitterDownstream TimeseriesMetricType = "jitterDownstream"
	// Jitter for upstream traffic (difference in time delay in milliseconds (ms) between data packets)
	TimeseriesMetricTypeJitterUpstream TimeseriesMetricType = "jitterUpstream"
	// Latency from socket directly to a well known global service, not through Cato. This is used to measure last
	// mile provider's performance, independent of the service.
	TimeseriesMetricTypeLastMileLatency TimeseriesMetricType = "lastMileLatency"
	// Packet loss from socket directly to a well known global services, not through Cato This is used to measure last
	// mile provider's performance, independent of the service.
	TimeseriesMetricTypeLastMilePacketLoss TimeseriesMetricType = "lastMilePacketLoss"
	// Number of packets lost for downstream traffic
	TimeseriesMetricTypeLostDownstream TimeseriesMetricType = "lostDownstream"
	// Percent of packet loss for downstream traffic
	TimeseriesMetricTypeLostDownstreamPcnt TimeseriesMetricType = "lostDownstreamPcnt"
	// Number of packets lost for upstream traffic
	TimeseriesMetricTypeLostUpstream TimeseriesMetricType = "lostUpstream"
	// Percent of packet loss for upstream traffic
	TimeseriesMetricTypeLostUpstreamPcnt TimeseriesMetricType = "lostUpstreamPcnt"
	// Total packets discarded for downstream traffic
	TimeseriesMetricTypePacketsDiscardedDownstream TimeseriesMetricType = "packetsDiscardedDownstream"
	// Percent packets discarded for downstream traffic
	TimeseriesMetricTypePacketsDiscardedDownstreamPcnt TimeseriesMetricType = "packetsDiscardedDownstreamPcnt"
	// Total packets discarded for upstream traffic
	TimeseriesMetricTypePacketsDiscardedUpstream TimeseriesMetricType = "packetsDiscardedUpstream"
	// Percent packets discarded for upstream traffic
	TimeseriesMetricTypePacketsDiscardedUpstreamPcnt TimeseriesMetricType = "packetsDiscardedUpstreamPcnt"
	// Total downstream packets
	TimeseriesMetricTypePacketsDownstream TimeseriesMetricType = "packetsDownstream"
	// Total upstream packets
	TimeseriesMetricTypePacketsUpstream TimeseriesMetricType = "packetsUpstream"
	// Round-trip time from the Socket to the Cato Cloud
	TimeseriesMetricTypeRtt TimeseriesMetricType = "rtt"
	// The age of the physical tunnel in milliseconds (It is zeroed even on transparent reconnect)
	TimeseriesMetricTypeTunnelAge TimeseriesMetricType = "tunnelAge"
)

var AllTimeseriesMetricType = []TimeseriesMetricType{
	TimeseriesMetricTypeBytesDownstream,
	TimeseriesMetricTypeBytesDownstreamMax,
	TimeseriesMetricTypeBytesTotal,
	TimeseriesMetricTypeBytesUpstream,
	TimeseriesMetricTypeBytesUpstreamMax,
	TimeseriesMetricTypeHealth,
	TimeseriesMetricTypeJitterDownstream,
	TimeseriesMetricTypeJitterUpstream,
	TimeseriesMetricTypeLastMileLatency,
	TimeseriesMetricTypeLastMilePacketLoss,
	TimeseriesMetricTypeLostDownstream,
	TimeseriesMetricTypeLostDownstreamPcnt,
	TimeseriesMetricTypeLostUpstream,
	TimeseriesMetricTypeLostUpstreamPcnt,
	TimeseriesMetricTypePacketsDiscardedDownstream,
	TimeseriesMetricTypePacketsDiscardedDownstreamPcnt,
	TimeseriesMetricTypePacketsDiscardedUpstream,
	TimeseriesMetricTypePacketsDiscardedUpstreamPcnt,
	TimeseriesMetricTypePacketsDownstream,
	TimeseriesMetricTypePacketsUpstream,
	TimeseriesMetricTypeRtt,
	TimeseriesMetricTypeTunnelAge,
}

func (e TimeseriesMetricType) IsValid() bool {
	switch e {
	case TimeseriesMetricTypeBytesDownstream, TimeseriesMetricTypeBytesDownstreamMax, TimeseriesMetricTypeBytesTotal, TimeseriesMetricTypeBytesUpstream, TimeseriesMetricTypeBytesUpstreamMax, TimeseriesMetricTypeHealth, TimeseriesMetricTypeJitterDownstream, TimeseriesMetricTypeJitterUpstream, TimeseriesMetricTypeLastMileLatency, TimeseriesMetricTypeLastMilePacketLoss, TimeseriesMetricTypeLostDownstream, TimeseriesMetricTypeLostDownstreamPcnt, TimeseriesMetricTypeLostUpstream, TimeseriesMetricTypeLostUpstreamPcnt, TimeseriesMetricTypePacketsDiscardedDownstream, TimeseriesMetricTypePacketsDiscardedDownstreamPcnt, TimeseriesMetricTypePacketsDiscardedUpstream, TimeseriesMetricTypePacketsDiscardedUpstreamPcnt, TimeseriesMetricTypePacketsDownstream, TimeseriesMetricTypePacketsUpstream, TimeseriesMetricTypeRtt, TimeseriesMetricTypeTunnelAge:
		return true
	}
	return false
}

func (e TimeseriesMetricType) String() string {
	return string(e)
}

func (e *TimeseriesMetricType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TimeseriesMetricType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TimeseriesMetricType", str)
	}
	return nil
}

func (e TimeseriesMetricType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *TimeseriesMetricType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e TimeseriesMetricType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type TLSInspectAction string

const (
	TLSInspectActionBypass  TLSInspectAction = "BYPASS"
	TLSInspectActionInspect TLSInspectAction = "INSPECT"
)

var AllTLSInspectAction = []TLSInspectAction{
	TLSInspectActionBypass,
	TLSInspectActionInspect,
}

func (e TLSInspectAction) IsValid() bool {
	switch e {
	case TLSInspectActionBypass, TLSInspectActionInspect:
		return true
	}
	return false
}

func (e TLSInspectAction) String() string {
	return string(e)
}

func (e *TLSInspectAction) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TLSInspectAction(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TlsInspectAction", str)
	}
	return nil
}

func (e TLSInspectAction) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *TLSInspectAction) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e TLSInspectAction) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// System categories for TLS inspection policy
type TLSInspectSystemCategory string

const (
	// High-popularity cloud apps that were analyzed by Cato's security team and confirmed to be safe for inspection.
	TLSInspectSystemCategoryPopularCloudApps TLSInspectSystemCategory = "POPULAR_CLOUD_APPS"
	// Top domains found to be broadly TLS-inspected across the Cato cloud. TLS-inspecting these domains is likely to be safe.
	TLSInspectSystemCategorySafeToInspectDomains TLSInspectSystemCategory = "SAFE_TO_INSPECT_DOMAINS"
)

var AllTLSInspectSystemCategory = []TLSInspectSystemCategory{
	TLSInspectSystemCategoryPopularCloudApps,
	TLSInspectSystemCategorySafeToInspectDomains,
}

func (e TLSInspectSystemCategory) IsValid() bool {
	switch e {
	case TLSInspectSystemCategoryPopularCloudApps, TLSInspectSystemCategorySafeToInspectDomains:
		return true
	}
	return false
}

func (e TLSInspectSystemCategory) String() string {
	return string(e)
}

func (e *TLSInspectSystemCategory) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TLSInspectSystemCategory(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TlsInspectSystemCategory", str)
	}
	return nil
}

func (e TLSInspectSystemCategory) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *TLSInspectSystemCategory) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e TLSInspectSystemCategory) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type TLSInspectUntrustedCertificateAction string

const (
	TLSInspectUntrustedCertificateActionAllow  TLSInspectUntrustedCertificateAction = "ALLOW"
	TLSInspectUntrustedCertificateActionBlock  TLSInspectUntrustedCertificateAction = "BLOCK"
	TLSInspectUntrustedCertificateActionPrompt TLSInspectUntrustedCertificateAction = "PROMPT"
)

var AllTLSInspectUntrustedCertificateAction = []TLSInspectUntrustedCertificateAction{
	TLSInspectUntrustedCertificateActionAllow,
	TLSInspectUntrustedCertificateActionBlock,
	TLSInspectUntrustedCertificateActionPrompt,
}

func (e TLSInspectUntrustedCertificateAction) IsValid() bool {
	switch e {
	case TLSInspectUntrustedCertificateActionAllow, TLSInspectUntrustedCertificateActionBlock, TLSInspectUntrustedCertificateActionPrompt:
		return true
	}
	return false
}

func (e TLSInspectUntrustedCertificateAction) String() string {
	return string(e)
}

func (e *TLSInspectUntrustedCertificateAction) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TLSInspectUntrustedCertificateAction(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TlsInspectUntrustedCertificateAction", str)
	}
	return nil
}

func (e TLSInspectUntrustedCertificateAction) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *TLSInspectUntrustedCertificateAction) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e TLSInspectUntrustedCertificateAction) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type TrafficDirectionEnum string

const (
	TrafficDirectionEnumDownstream TrafficDirectionEnum = "DOWNSTREAM"
	TrafficDirectionEnumUpstream   TrafficDirectionEnum = "UPSTREAM"
)

var AllTrafficDirectionEnum = []TrafficDirectionEnum{
	TrafficDirectionEnumDownstream,
	TrafficDirectionEnumUpstream,
}

func (e TrafficDirectionEnum) IsValid() bool {
	switch e {
	case TrafficDirectionEnumDownstream, TrafficDirectionEnumUpstream:
		return true
	}
	return false
}

func (e TrafficDirectionEnum) String() string {
	return string(e)
}

func (e *TrafficDirectionEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TrafficDirectionEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TrafficDirectionEnum", str)
	}
	return nil
}

func (e TrafficDirectionEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *TrafficDirectionEnum) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e TrafficDirectionEnum) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type UnitType string

const (
	UnitTypeBits UnitType = "bits"
	// Bits per second
	UnitTypeBps   UnitType = "bps"
	UnitTypeBytes UnitType = "bytes"
	// Bytes per second
	UnitTypeBytesPerSec UnitType = "bytesPerSec"
	// The number of occurrences for this unit
	UnitTypeCount   UnitType = "count"
	UnitTypeMs      UnitType = "ms"
	UnitTypeNone    UnitType = "none"
	UnitTypePackets UnitType = "packets"
	UnitTypePercent UnitType = "percent"
	// health analytics for the site
	UnitTypeScore UnitType = "score"
	// For metrics that are measured in seconds, such as tunnelAge, the number of seconds
	UnitTypeSeconds UnitType = "seconds"
)

var AllUnitType = []UnitType{
	UnitTypeBits,
	UnitTypeBps,
	UnitTypeBytes,
	UnitTypeBytesPerSec,
	UnitTypeCount,
	UnitTypeMs,
	UnitTypeNone,
	UnitTypePackets,
	UnitTypePercent,
	UnitTypeScore,
	UnitTypeSeconds,
}

func (e UnitType) IsValid() bool {
	switch e {
	case UnitTypeBits, UnitTypeBps, UnitTypeBytes, UnitTypeBytesPerSec, UnitTypeCount, UnitTypeMs, UnitTypeNone, UnitTypePackets, UnitTypePercent, UnitTypeScore, UnitTypeSeconds:
		return true
	}
	return false
}

func (e UnitType) String() string {
	return string(e)
}

func (e *UnitType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UnitType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UnitType", str)
	}
	return nil
}

func (e UnitType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *UnitType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e UnitType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type UserRole string

const (
	UserRoleEditor       UserRole = "EDITOR"
	UserRoleOwner        UserRole = "OWNER"
	UserRolePublicEditor UserRole = "PUBLIC_EDITOR"
	UserRolePublicViewer UserRole = "PUBLIC_VIEWER"
	UserRoleSitesViewer  UserRole = "SITES_VIEWER"
	UserRoleSuperUser    UserRole = "SUPER_USER"
	UserRoleViewer       UserRole = "VIEWER"
)

var AllUserRole = []UserRole{
	UserRoleEditor,
	UserRoleOwner,
	UserRolePublicEditor,
	UserRolePublicViewer,
	UserRoleSitesViewer,
	UserRoleSuperUser,
	UserRoleViewer,
}

func (e UserRole) IsValid() bool {
	switch e {
	case UserRoleEditor, UserRoleOwner, UserRolePublicEditor, UserRolePublicViewer, UserRoleSitesViewer, UserRoleSuperUser, UserRoleViewer:
		return true
	}
	return false
}

func (e UserRole) String() string {
	return string(e)
}

func (e *UserRole) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UserRole(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UserRole", str)
	}
	return nil
}

func (e UserRole) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *UserRole) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e UserRole) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type VendorEnum string

const (
	VendorEnumCato      VendorEnum = "CATO"
	VendorEnumMicrosoft VendorEnum = "MICROSOFT"
)

var AllVendorEnum = []VendorEnum{
	VendorEnumCato,
	VendorEnumMicrosoft,
}

func (e VendorEnum) IsValid() bool {
	switch e {
	case VendorEnumCato, VendorEnumMicrosoft:
		return true
	}
	return false
}

func (e VendorEnum) String() string {
	return string(e)
}

func (e *VendorEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = VendorEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid VendorEnum", str)
	}
	return nil
}

func (e VendorEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *VendorEnum) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e VendorEnum) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type VrrpType string

const (
	VrrpTypeDirectLink VrrpType = "DIRECT_LINK"
	VrrpTypeViaSwitch  VrrpType = "VIA_SWITCH"
)

var AllVrrpType = []VrrpType{
	VrrpTypeDirectLink,
	VrrpTypeViaSwitch,
}

func (e VrrpType) IsValid() bool {
	switch e {
	case VrrpTypeDirectLink, VrrpTypeViaSwitch:
		return true
	}
	return false
}

func (e VrrpType) String() string {
	return string(e)
}

func (e *VrrpType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = VrrpType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid VrrpType", str)
	}
	return nil
}

func (e VrrpType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *VrrpType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e VrrpType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type WanFirewallActionEnum string

const (
	// Allow the network traffic to pass through the firewall.
	WanFirewallActionEnumAllow WanFirewallActionEnum = "ALLOW"
	// Deny the network traffic from passing through the firewall.
	WanFirewallActionEnumBlock WanFirewallActionEnum = "BLOCK"
	// Requests user confirmation to allow or block network traffic.
	WanFirewallActionEnumPrompt WanFirewallActionEnum = "PROMPT"
)

var AllWanFirewallActionEnum = []WanFirewallActionEnum{
	WanFirewallActionEnumAllow,
	WanFirewallActionEnumBlock,
	WanFirewallActionEnumPrompt,
}

func (e WanFirewallActionEnum) IsValid() bool {
	switch e {
	case WanFirewallActionEnumAllow, WanFirewallActionEnumBlock, WanFirewallActionEnumPrompt:
		return true
	}
	return false
}

func (e WanFirewallActionEnum) String() string {
	return string(e)
}

func (e *WanFirewallActionEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WanFirewallActionEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WanFirewallActionEnum", str)
	}
	return nil
}

func (e WanFirewallActionEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *WanFirewallActionEnum) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e WanFirewallActionEnum) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type WanFirewallDirectionEnum string

const (
	WanFirewallDirectionEnumBoth WanFirewallDirectionEnum = "BOTH"
	WanFirewallDirectionEnumTo   WanFirewallDirectionEnum = "TO"
)

var AllWanFirewallDirectionEnum = []WanFirewallDirectionEnum{
	WanFirewallDirectionEnumBoth,
	WanFirewallDirectionEnumTo,
}

func (e WanFirewallDirectionEnum) IsValid() bool {
	switch e {
	case WanFirewallDirectionEnumBoth, WanFirewallDirectionEnumTo:
		return true
	}
	return false
}

func (e WanFirewallDirectionEnum) String() string {
	return string(e)
}

func (e *WanFirewallDirectionEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WanFirewallDirectionEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WanFirewallDirectionEnum", str)
	}
	return nil
}

func (e WanFirewallDirectionEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *WanFirewallDirectionEnum) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e WanFirewallDirectionEnum) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type WanNetworkRuleInterfaceRole string

const (
	// Automatic interface role.
	WanNetworkRuleInterfaceRoleAutomatic WanNetworkRuleInterfaceRole = "AUTOMATIC"
	// No interface role.
	WanNetworkRuleInterfaceRoleNone WanNetworkRuleInterfaceRole = "NONE"
	// WAN1 interface role.
	WanNetworkRuleInterfaceRoleWan1 WanNetworkRuleInterfaceRole = "WAN1"
	// WAN2 interface role.
	WanNetworkRuleInterfaceRoleWan2 WanNetworkRuleInterfaceRole = "WAN2"
	// WAN3 interface role.
	WanNetworkRuleInterfaceRoleWan3 WanNetworkRuleInterfaceRole = "WAN3"
	// WAN4 interface role.
	WanNetworkRuleInterfaceRoleWan4 WanNetworkRuleInterfaceRole = "WAN4"
	// WAN5 interface role.
	WanNetworkRuleInterfaceRoleWan5 WanNetworkRuleInterfaceRole = "WAN5"
	// WAN6 interface role.
	WanNetworkRuleInterfaceRoleWan6 WanNetworkRuleInterfaceRole = "WAN6"
)

var AllWanNetworkRuleInterfaceRole = []WanNetworkRuleInterfaceRole{
	WanNetworkRuleInterfaceRoleAutomatic,
	WanNetworkRuleInterfaceRoleNone,
	WanNetworkRuleInterfaceRoleWan1,
	WanNetworkRuleInterfaceRoleWan2,
	WanNetworkRuleInterfaceRoleWan3,
	WanNetworkRuleInterfaceRoleWan4,
	WanNetworkRuleInterfaceRoleWan5,
	WanNetworkRuleInterfaceRoleWan6,
}

func (e WanNetworkRuleInterfaceRole) IsValid() bool {
	switch e {
	case WanNetworkRuleInterfaceRoleAutomatic, WanNetworkRuleInterfaceRoleNone, WanNetworkRuleInterfaceRoleWan1, WanNetworkRuleInterfaceRoleWan2, WanNetworkRuleInterfaceRoleWan3, WanNetworkRuleInterfaceRoleWan4, WanNetworkRuleInterfaceRoleWan5, WanNetworkRuleInterfaceRoleWan6:
		return true
	}
	return false
}

func (e WanNetworkRuleInterfaceRole) String() string {
	return string(e)
}

func (e *WanNetworkRuleInterfaceRole) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WanNetworkRuleInterfaceRole(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WanNetworkRuleInterfaceRole", str)
	}
	return nil
}

func (e WanNetworkRuleInterfaceRole) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *WanNetworkRuleInterfaceRole) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e WanNetworkRuleInterfaceRole) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type WanNetworkRuleRouteType string

const (
	// Backhaul routing.
	WanNetworkRuleRouteTypeBackhaul WanNetworkRuleRouteType = "BACKHAUL"
	// Backhaul hairpinning routing.
	WanNetworkRuleRouteTypeBackhaulHairpinning WanNetworkRuleRouteType = "BACKHAUL_HAIRPINNING"
	// NAT routing.
	WanNetworkRuleRouteTypeNat WanNetworkRuleRouteType = "NAT"
	// No routing.
	WanNetworkRuleRouteTypeNone WanNetworkRuleRouteType = "NONE"
	// Optimized routing. Smart Egress using closest destination
	WanNetworkRuleRouteTypeOptimized WanNetworkRuleRouteType = "OPTIMIZED"
	// Route via a specific path.
	WanNetworkRuleRouteTypeVia WanNetworkRuleRouteType = "VIA"
)

var AllWanNetworkRuleRouteType = []WanNetworkRuleRouteType{
	WanNetworkRuleRouteTypeBackhaul,
	WanNetworkRuleRouteTypeBackhaulHairpinning,
	WanNetworkRuleRouteTypeNat,
	WanNetworkRuleRouteTypeNone,
	WanNetworkRuleRouteTypeOptimized,
	WanNetworkRuleRouteTypeVia,
}

func (e WanNetworkRuleRouteType) IsValid() bool {
	switch e {
	case WanNetworkRuleRouteTypeBackhaul, WanNetworkRuleRouteTypeBackhaulHairpinning, WanNetworkRuleRouteTypeNat, WanNetworkRuleRouteTypeNone, WanNetworkRuleRouteTypeOptimized, WanNetworkRuleRouteTypeVia:
		return true
	}
	return false
}

func (e WanNetworkRuleRouteType) String() string {
	return string(e)
}

func (e *WanNetworkRuleRouteType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WanNetworkRuleRouteType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WanNetworkRuleRouteType", str)
	}
	return nil
}

func (e WanNetworkRuleRouteType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *WanNetworkRuleRouteType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e WanNetworkRuleRouteType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type WanNetworkRuleTransportType string

const (
	// Alternative WAN transport type.
	WanNetworkRuleTransportTypeAlternativeWan WanNetworkRuleTransportType = "ALTERNATIVE_WAN"
	// Automatic transport type.
	WanNetworkRuleTransportTypeAutomatic WanNetworkRuleTransportType = "AUTOMATIC"
	// No transport type.
	WanNetworkRuleTransportTypeNone WanNetworkRuleTransportType = "NONE"
	// Off-cloud transport type.
	WanNetworkRuleTransportTypeOffCloud WanNetworkRuleTransportType = "OFF_CLOUD"
	// WAN transport type.
	WanNetworkRuleTransportTypeWan WanNetworkRuleTransportType = "WAN"
)

var AllWanNetworkRuleTransportType = []WanNetworkRuleTransportType{
	WanNetworkRuleTransportTypeAlternativeWan,
	WanNetworkRuleTransportTypeAutomatic,
	WanNetworkRuleTransportTypeNone,
	WanNetworkRuleTransportTypeOffCloud,
	WanNetworkRuleTransportTypeWan,
}

func (e WanNetworkRuleTransportType) IsValid() bool {
	switch e {
	case WanNetworkRuleTransportTypeAlternativeWan, WanNetworkRuleTransportTypeAutomatic, WanNetworkRuleTransportTypeNone, WanNetworkRuleTransportTypeOffCloud, WanNetworkRuleTransportTypeWan:
		return true
	}
	return false
}

func (e WanNetworkRuleTransportType) String() string {
	return string(e)
}

func (e *WanNetworkRuleTransportType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WanNetworkRuleTransportType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WanNetworkRuleTransportType", str)
	}
	return nil
}

func (e WanNetworkRuleTransportType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *WanNetworkRuleTransportType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e WanNetworkRuleTransportType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type WanNetworkRuleType string

const (
	// Inbound Internet transport type.
	WanNetworkRuleTypeInboundInternet WanNetworkRuleType = "INBOUND_INTERNET"
	// Internet transport type.
	WanNetworkRuleTypeInternet WanNetworkRuleType = "INTERNET"
	// WAN transport type.
	WanNetworkRuleTypeWan WanNetworkRuleType = "WAN"
)

var AllWanNetworkRuleType = []WanNetworkRuleType{
	WanNetworkRuleTypeInboundInternet,
	WanNetworkRuleTypeInternet,
	WanNetworkRuleTypeWan,
}

func (e WanNetworkRuleType) IsValid() bool {
	switch e {
	case WanNetworkRuleTypeInboundInternet, WanNetworkRuleTypeInternet, WanNetworkRuleTypeWan:
		return true
	}
	return false
}

func (e WanNetworkRuleType) String() string {
	return string(e)
}

func (e *WanNetworkRuleType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WanNetworkRuleType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WanNetworkRuleType", str)
	}
	return nil
}

func (e WanNetworkRuleType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *WanNetworkRuleType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e WanNetworkRuleType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Geographical regions that can be associated with a remote user license
type ZtnaUsersLicenseGroup string

const (
	// Country with stand-alone licenses (not part of a group)
	ZtnaUsersLicenseGroupChina ZtnaUsersLicenseGroup = "CHINA"
	// Legacy group
	ZtnaUsersLicenseGroupDubai   ZtnaUsersLicenseGroup = "DUBAI"
	ZtnaUsersLicenseGroupGeneral ZtnaUsersLicenseGroup = "GENERAL"
	// Legacy group
	ZtnaUsersLicenseGroupLatam ZtnaUsersLicenseGroup = "LATAM"
	// Country with stand-alone licenses (not part of a group)
	ZtnaUsersLicenseGroupMorocco ZtnaUsersLicenseGroup = "MOROCCO"
	// Country with stand-alone licenses (not part of a group)
	ZtnaUsersLicenseGroupVietnam ZtnaUsersLicenseGroup = "VIETNAM"
)

var AllZtnaUsersLicenseGroup = []ZtnaUsersLicenseGroup{
	ZtnaUsersLicenseGroupChina,
	ZtnaUsersLicenseGroupDubai,
	ZtnaUsersLicenseGroupGeneral,
	ZtnaUsersLicenseGroupLatam,
	ZtnaUsersLicenseGroupMorocco,
	ZtnaUsersLicenseGroupVietnam,
}

func (e ZtnaUsersLicenseGroup) IsValid() bool {
	switch e {
	case ZtnaUsersLicenseGroupChina, ZtnaUsersLicenseGroupDubai, ZtnaUsersLicenseGroupGeneral, ZtnaUsersLicenseGroupLatam, ZtnaUsersLicenseGroupMorocco, ZtnaUsersLicenseGroupVietnam:
		return true
	}
	return false
}

func (e ZtnaUsersLicenseGroup) String() string {
	return string(e)
}

func (e *ZtnaUsersLicenseGroup) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ZtnaUsersLicenseGroup(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ZtnaUsersLicenseGroup", str)
	}
	return nil
}

func (e ZtnaUsersLicenseGroup) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ZtnaUsersLicenseGroup) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ZtnaUsersLicenseGroup) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}
